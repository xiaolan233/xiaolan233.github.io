<!-- build time:Tue Nov 13 2018 23:09:56 GMT+0800 (中国标准时间) --><!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="true"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=6.4.0" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple.png?v=6.4.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32.png?v=6.4.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16.png?v=6.4.0"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"6.4.0",sidebar:{position:"right",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="description" content="引言网络程序所做的很大一部分工作都是简单的输入和数据:将数据字节从一个系统移动到另一个系统。字节就是字节。很短程度上讲，读取服务器发送给你的数据与读取文件并没有什么不同。向客户端发送文本和写文件也没有什么不同。但是,Java中输入和输出(I/O)的组织与其他大多数语言如(Fortran,C和C++)都不一样。因此，这里要用几页来总结一下Java独特的I/O方法。"><meta name="keywords" content="没有关键字"><meta property="og:type" content="article"><meta property="og:title" content="java网络编程第4版 第2章 流"><meta property="og:url" content="https://www.lansheng.net.cn/blog/d3f6b577/index.html"><meta property="og:site_name" content="蓝生的博客"><meta property="og:description" content="引言网络程序所做的很大一部分工作都是简单的输入和数据:将数据字节从一个系统移动到另一个系统。字节就是字节。很短程度上讲，读取服务器发送给你的数据与读取文件并没有什么不同。向客户端发送文本和写文件也没有什么不同。但是,Java中输入和输出(I/O)的组织与其他大多数语言如(Fortran,C和C++)都不一样。因此，这里要用几页来总结一下Java独特的I/O方法。"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://i.imgur.com/SvzwLF8.png"><meta property="og:image" content="https://i.imgur.com/685kwhH.png"><meta property="og:updated_time" content="2018-11-05T09:17:11.033Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="java网络编程第4版 第2章 流"><meta name="twitter:description" content="引言网络程序所做的很大一部分工作都是简单的输入和数据:将数据字节从一个系统移动到另一个系统。字节就是字节。很短程度上讲，读取服务器发送给你的数据与读取文件并没有什么不同。向客户端发送文本和写文件也没有什么不同。但是,Java中输入和输出(I/O)的组织与其他大多数语言如(Fortran,C和C++)都不一样。因此，这里要用几页来总结一下Java独特的I/O方法。"><meta name="twitter:image" content="https://i.imgur.com/SvzwLF8.png"><link rel="alternate" href="/atom.xml" title="蓝生的博客" type="application/atom+xml"><link rel="canonical" href="https://www.lansheng.net.cn/blog/d3f6b577/"><script type="text/javascript" id="page.configurations">CONFIG.page={sidebar:""}</script><title>java网络编程第4版 第2章 流 | 蓝生的博客</title><noscript><style type="text/css">.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-right page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">蓝生的博客</span> <span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.lansheng.net.cn/blog/d3f6b577/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="蓝生"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="蓝生的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">java网络编程第4版 第2章 流</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-08-22 22:45:17" itemprop="dateCreated datePublished" datetime="2018-08-22T22:45:17+08:00">2018-08-22</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2018-11-05 17:17:11" itemprop="dateModified" datetime="2018-11-05T17:17:11+08:00">2018-11-05</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/读书笔记/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/读书笔记/java网络编程第四版/" itemprop="url" rel="index"><span itemprop="name">java网络编程第四版</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/blog/d3f6b577/#comments" itemprop="discussionUrl"><span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/blog/d3f6b577/" itemprop="commentCount"></span> </a></span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> 阅读次数： <span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>网络程序所做的很大一部分工作都是简单的输入和数据:<br>将数据字节从一个系统移动到另一个系统。字节就是字节。很短程度上讲，读取服务器发送给你的数据与读取文件并没有什么不同。向客户端发送文本和写文件也没有什么不同。但是,<code>Java</code>中输入和输出(<code>I/O)</code>的组织与其他大多数语言如(<code>Fortran</code>,<code>C</code>和<code>C</code>++)都不一样。因此，这里要用几页来总结一下<code>Java</code>独特的<code>I/O</code>方法。<br><a id="more"></a><br><code>Java</code>的<code>I/O</code>流建立与流(<code>stream)</code>之上。输入流用于读取数据，输出流用于写入数据。不同的流类，如<code>java.io.FileInputStream</code>和<code>sun.net.TelnetOutputStream</code>会读/写某个特定的数据源。但是，所有输出流都有相同的基本方法来写入数据，所有输入也使用相同的方法来读取数据。创建一个流之后，读/写时通常可以忽略读/写的具体细节。</p><p>过滤器(filter)流可以串联到输入流或输出流上。读写数据时，过滤器可以修改数据(例如,通过加密或压缩)，或者只是提供额外的方法，将读写的数据转换为其他格式。例如，java.io.DataOutputStream类就提供了一个方法，可以将int转换为4字节，并把这些字节写入低层的输出流。<br>阅读器(reader)和书写器(writer)可以串联到输入流和输出流上，允许程序读写文本(即字符)而不是字节。只要正确的使用，阅读器和书写器可以处理很多字符编码，包括多字节字符集，如SJIS和UTF-8</p><p>流是同步的。也就是说，当程序(确切的讲是线程)请求一个流读写一段数据时，在做任何其他操作前，它要等待所读写的数据。<br>Java还支持使用通道和缓冲区的非阻塞I/O。非阻塞I/O稍微有些复杂，但是在某些高吞吐量的应用程序中(如Web服务器)，非阻塞I/O要快的多。通常情况下，基本流模型就是实现客户端所需要和应当使用的全部内容。由于通道和缓冲依赖于流，下面将介绍流和客户端。</p><blockquote><h2 id="输出流"><a href="#输出流" class="headerlink" title="输出流"></a>输出流</h2><p><code>Java</code> 的基本输出流式<code>java.io.OutputStream</code>:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; public abstract class OutputStreamextends Objectimplements Closeable, Flushable</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>这个类提供了写入数据所需的基本方法，这些方法包括：</p></blockquote><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>public abstract void write(int b) throws IOException</code></td><td style="text-align:left">将指定的字节写入此输出流。</td></tr><tr><td style="text-align:left"><code>public void write(byte[] b) throws IOException</code></td><td style="text-align:left">将 b.length 个字节从指定的 byte 数组写入此输出流。</td></tr><tr><td style="text-align:left"><code>public void write(byte[] b,int off,int len) throws IOException</code></td><td style="text-align:left">将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流。</td></tr><tr><td style="text-align:left"><code>public void close() throws IOException</code></td><td style="text-align:left">关闭此输出流并释放与此流有关的所有系统资源。</td></tr><tr><td style="text-align:left"><code>public void flush() throws IOException</code></td><td style="text-align:left">刷新此输出流并强制写出所有缓冲的输出字节。</td></tr></tbody></table><blockquote><p><code>OutputStream</code>的子类使用这些方法向某种特定介质写入数据。例如，<code>FileOutputStream</code>使用这些方法写入文件，<code>TelnetOutputStream</code>使用这些方法写入网络连接。<code>ByteArraryOutputStream</code>使用这些方法将数据写入可扩展的字节数组。但不管写那种介质，大多都会使用同样的这5个方法。有时候甚至可能不知道所写入的流具体是何种类型。例如，在<code>Java</code>类库文档中找不到<code>TelnetOutputStream</code>。它被有意的隐藏在<code>sun</code>包<br>中。<code>java.net</code>中很多方法都会返回<code>TelnetOutputStream</code>，如<code>Java.net.Socket</code>的<code>getOutputStream()</code>方法。但是，这些方法声明为只返回<code>OutputStream</code>,而不是更特定的子类<code>TelnetOutputStream</code>。这正是多态的威力。如果你知道如何使用这些超类，那也就知道如何使用所有这些子类。</p><h3 id="write-int-b-方法"><a href="#write-int-b-方法" class="headerlink" title="write(int b)方法"></a>write(int b)方法</h3><p><code>OutputStream</code>的基本方法是<code>write(int b)</code>。这个方法接收一个<code>0-255</code>之间的整数作为参数，将对应的字节写入输出流中。这个方法声明为抽象方法，因为各个子类需要修改这个方法来处理特定的介质。例如，ByteArrayOutputStream可以<code>用纯Java代码</code>实现这个方法，将字节复制到数组中。与此不同，FileOutputStream则需要使用<code>原生代码</code>，这些代码了解如何将数据写入到主机平台的文件中。</p><p>注意，虽然这个方法接受一个int作为参数，但它实际上会写入一个无符号字节。Java没有无符号字节数据类型，所以这里要使用int来代替。无符号字节和有符号字节之间唯一真正的区别在于解释。它们都是由8个二进制位组成，当使用write(int b)将int协议一个网络连接时，线缆上只会放入8个二进制位。如果将一个超出0~255的int传入write(int b),将写入这个数的最低字节，其他3字节将被忽略(这正是将int强制转换为byte的结果)。<br>提示: 不过在极少数情况下，你可能会看到一些有问题的第三方类，在写超出0~255的值时，它们的做法有所不同，比如会抛出<code>IllegalArgumentException</code>异常或者总是写入255，所以尽可能要避免写入超出0~255的int</p><h3 id="write-int-b-方法实例"><a href="#write-int-b-方法实例" class="headerlink" title="write(int b)方法实例"></a>write(int b)方法实例</h3><p>例如，字符生成器协议定义了一个发出ASCII文本的服务器。这个协议最流行的变体是发送72个字符的文本行，其中包含可显示的ASCII字符。(可显示的ASCII字符是33~126之间的字符，不包括各种空白行和控制字符)。第一行按顺序包含字符33到字符104.第二行包含字符33+1到104+1,也就是字符34到字符105。第三行宝行字符35到字符106。一直到第29行宝行字符55到字符126。到这里，字符将回绕，第30行包含字符56到字符126加上字符33。各行用回车(ASCII 13)和换行(ASCII 10)结束。输出结果如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">!&quot;#$%&amp;&apos;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefgh</span><br><span class="line">&quot;#$%&amp;&apos;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghi</span><br><span class="line">#$%&amp;&apos;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghij</span><br><span class="line">$%&amp;&apos;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijk</span><br><span class="line">%&amp;&apos;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijkl</span><br><span class="line">&amp;&apos;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklm</span><br><span class="line">&apos;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmn</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>可以看到第一行第第一个字符是<code>!</code>到了第二行它将变为最后一个字符<code>!</code><br>由于ASCII是一个7位字符集，所以每个字符都作为单字节发送。因此，这个协议可以直接使用基本write()方法实现。实现代码如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generatecharacters</span><span class="params">(OutputStream out)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">&gt; </span>&#123;</span><br><span class="line">&gt; 	<span class="keyword">int</span> firstPrintableCharacter = <span class="number">33</span>;</span><br><span class="line">&gt; 	<span class="keyword">int</span> numberOfPrintableCharacters = <span class="number">94</span>;</span><br><span class="line">&gt; 	<span class="keyword">int</span> numberOfCharactersPerLine = <span class="number">72</span>;</span><br><span class="line">&gt; 	<span class="keyword">int</span> start = firstPrintableCharacter;</span><br><span class="line">&gt; 	<span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">&gt; 	&#123;<span class="comment">/* 无限循环 */</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; 		<span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; start + numberOfCharactersPerLine; i++)</span><br><span class="line">&gt; 		&#123;</span><br><span class="line">&gt; 			out.write((i - firstPrintableCharacter)</span><br><span class="line">&gt; 					% numberOfCharactersPerLine + firstPrintableCharacter);</span><br><span class="line">&gt; 		&#125;</span><br><span class="line">&gt; 		out.write(<span class="string">'\r'</span>);<span class="comment">// 回车</span></span><br><span class="line">&gt; 		out.write(<span class="string">'\n'</span>);<span class="comment">// 换行</span></span><br><span class="line">&gt; 		start = ((start + <span class="number">1</span>) - firstPrintableCharacter)</span><br><span class="line">&gt; 				% numberOfPrintableCharacters + firstPrintableCharacter;</span><br><span class="line">&gt; 	&#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>这里将一个OutputStream通过out参数传入到generatecharacters()方法中。一次项out写入1字节。这些字节作为33到126之间循环列出中的整数给出。这里的大部分运算都是让循环在这个范围内回绕。并写入每个72字符块之后，就想输出流写入一个回车和一个换行。<br>然后计算下一个起始字符,重复这个循环。整个方法声明为抛出IOException异常。这一点很重要，因为字符生成器服务器只又在客户端关闭连接时才会终止。Java代码会把它看做是一个IOException异常。</p></blockquote><p>看到这里可以能回迷惑，其实，作者这里是在介绍write(int b)这个方法的用法。不用去理解这个什么字符生成器的原理和作用。<br>main()方法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException</span><br><span class="line">&#123;</span><br><span class="line">	generatecharacters(System.out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>一次写入1字节通常效率不高。例如，流出以太网卡的每个TCP分片包含至少40字节的开销用于路由和纠错。如果每字节都单独发送，那么与你预想的数据量相比，使用write(int b)方法实际填入到网络中的数据可能是41个字节,也就是说比实际写入一个字节高了41倍。如果增加主机网络层协议的开销，情况可能更糟糕。因此，大多数TCP/IP实现都会在某种程度上缓存数据。也就是说，它们在内存中积累数据字节，只有积累到一定的数量后，或经过一定的时间后，才将积累的数据发送到最终目的地。不过，如果有多字节要发送。则一次全部发送，不失为一个好主意。使用write(byte[] data)或write(byte[] data,int offset,int length)一次写入一个数组，或数组中的一部分，通常比write(int b)一次写入一个字节要快的多。例如，下面是generatecharacters()方法的另一个实现，它将整行打包字节数组中，一次发送一行:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static void generateCharacters(OutputStream out) throws IOException</span><br><span class="line">&#123;</span><br><span class="line">	int firstPrintableCharacter = 33;</span><br><span class="line">	int numberOfPrintableCharacters = 94;</span><br><span class="line">	int numberOfCharactersPerLine = 72;</span><br><span class="line">	int start = firstPrintableCharacter;</span><br><span class="line">	//+2对应回车和换行</span><br><span class="line">	byte[] line=new byte[numberOfCharactersPerLine+2];</span><br><span class="line">	int count=0;</span><br><span class="line">	while (true)</span><br><span class="line">	&#123;/* 无限循环 */</span><br><span class="line">		for (int i = start; i &lt; start + numberOfCharactersPerLine; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			line[i-start]=(byte)((i-firstPrintableCharacter)%numberOfPrintableCharacters+firstPrintableCharacter);</span><br><span class="line">		&#125;</span><br><span class="line">		line[72]=(byte)&apos;\r&apos;;</span><br><span class="line">		line[73]=(byte)&apos;\n&apos;;</span><br><span class="line">		out.write(line);</span><br><span class="line">		start = ((start + 1) - firstPrintableCharacter)</span><br><span class="line">				% numberOfPrintableCharacters + firstPrintableCharacter;</span><br><span class="line">		if((count++)&gt;=72)</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>计算何时写那些字节的算法与前面的实现中是一样的。重要的区别在于这些字节在写入网络之前先打包到字节数组中。<br>还要注意计算的结果是int类型的，在存储到字节数组是要强制类型转换。这在前面的实现中是不需要强制类型转换的，因为write(int b )方法声明为接收一个int作为参数。</p><h3 id="flush-方法"><a href="#flush-方法" class="headerlink" title="flush()方法"></a>flush()方法</h3><p>与网络硬件中缓存一样，流还是可以在软件中得到缓冲，即直接使用Java代码缓存。一般来说，这可以通过把BufferedOutputStream或BufferedWriter串链到低层流上来实现，因此，在写入数据完成后，刷新(flush)输出流非常重要。例如假设已经向使用HTTP Keep-Alive的HTTP1.1服务器写入了300字节的请求到输出流中，然后服务器会等待客户端的响应。然后再发送更过的数据。不过，如果输出流有一个1024字节的缓冲区，那么这个流在发送缓冲区中的数据之前会等待等过的数据到达，以填满这个1024字节的缓冲区。不过在客户端的响应到达之前，服务器不会向流写入更多的数据，但是请求现在其实还在缓冲区中，没有发给客户端，所以客户端的响应是永远不会到来的。客户端等待服务器的消息，而服务端等待客户端的响应，两个相互等待，造成死锁，如下图所示。<br><img src="https://i.imgur.com/SvzwLF8.png" alt=""><br>这种情况，应该使用flush()方法，flush()方法可以强迫缓冲的流发送数据，即使缓冲区还没填满，以此来打破这种死锁状态。<br>不管你是否认为有必要，刷新输出流都很重要，取决于以如何控制流的引用，你可能知道流是否有缓冲，也可能不知道(例如，不论你是否希望如此，System.out都会使用缓冲)。<br>如果有必要刷新输出,不刷新，那么可能导致不可预知，不可重现的程序挂起。相应的，应当在关闭流之前立即刷新输出所有流，否则，关闭流时留在缓冲区中的数据可能会丢失。</p><h3 id="close-方法"><a href="#close-方法" class="headerlink" title="close()方法"></a>close()方法</h3><p>最后，当结束一个流的操作时,要通过调用他的close()方法将其关闭。这会释放与这个流相关联的所有资源，如文件句柄或端口。如果流来自一个网络连接，那么关闭这个流也会终止这个连接。一旦输出流关闭，继续写入时就会抛出IOException异常。不过，有些流仍允许对这个对象做一些处理。例如，关闭的ByteArrayOutputStream仍然可以转换为实际的字节数组，关闭的DigesOutputStream仍然可以返回其摘要。</p><h3 id="close-方法正确的写法"><a href="#close-方法正确的写法" class="headerlink" title="close()方法正确的写法"></a>close()方法正确的写法</h3><p>在一个长时间运行的程序中，如果未能关闭一个流，则可能会泄露文件句柄，网络端口和其他资源。因此在Java6和更早的版本中，明智的做法是在finally块中关闭流。而为了正确的变量作用域，必须在try块之前声明流变量，但必须在try块内完成初始化。另外为了避免NullPointerException异常，在关闭流之前需要检查流变量是否为null.最后通常都希望忽略关闭流时出现的异常，或者最多只是把这些异常记入日志中。例如：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出流引用定义在try块外面，以提高作用域</span></span><br><span class="line">OutputStream out =<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化输出流</span></span><br><span class="line">    out=<span class="keyword">new</span> FileOutputStream(<span class="string">"data.txt"</span>);</span><br><span class="line">    <span class="comment">//处理输出流...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(IOEXception ex)</span><br><span class="line">&#123;</span><br><span class="line">    System.err.println(ex.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(out!=<span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            out.colse();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException ex)&#123;</span><br><span class="line">            <span class="comment">//忽略</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这个技术有时称为释放模式(dispose pattern),这对于需要在垃圾回收前先进行清理的对象时很常见的。你会看到，这个技术不仅用于流，还可以用于socket,通道，JDBC连接和语句等。</p><p>Java 7引入了<code>带资源的try</code>构造(try with resources),可以更简洁地完成这个清理。<br>不需要再try块之外声明流变量，完全可以在try块的一个参数表中声明。例如，前面的代码段现在就变得简单多了：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try(OutputStream out=new FileOutputStream(&quot;data.txt&quot;))</span><br><span class="line">&#123;</span><br><span class="line">    //处理输出流</span><br><span class="line">&#125;</span><br><span class="line">catch(IOException ex)</span><br><span class="line">&#123;</span><br><span class="line">    System.err.println(ex.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>现在不需要Finally子句，Java会对try块参数表中声明的所有AutoCloseable对象自动调用close()。<br>提示：只要对象事项了Closeable接口，都可以使用<code>带资源的try</code>构造。这包括几乎所有需要释放的对象。到到目前为止，JavaMail Transport对象是我见过的唯一的例外，这些对象还需要显式的释放。</p><h2 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h2><p><code>Java</code>的基本输入流类是<code>java.io.InputStream</code>:<br><code>public abstract class InputStreamextends Objectimplements Closeable</code><br>这个类提供两个将数据读取为原始字节所需要的基本方法。这些方法包括：</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>public abstract int read() throws IOException</code></td><td style="text-align:left">从输入流中读取数据的下一个字节。</td></tr><tr><td style="text-align:left"><code>public int read(byte[] b) throws IOException</code></td><td style="text-align:left">从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。</td></tr><tr><td style="text-align:left"><code>public int read(byte[] b, int off, int len) throws IOException</code></td><td style="text-align:left">将输入流中最多 len 个数据字节读入 byte 数组。</td></tr><tr><td style="text-align:left"><code>public long skip(long n) throws IOException</code></td><td style="text-align:left">跳过和丢弃此输入流中数据的 n 个字节。</td></tr><tr><td style="text-align:left"><code>public int available() throws IOException</code></td><td style="text-align:left">返回此输入流下一个方法调用可以不受阻塞地从此输入流读取（或跳过）的估计字节数。</td></tr><tr><td style="text-align:left"><code>public void close() throws IOException</code></td><td style="text-align:left">关闭此输入流并释放与该流关联的所有系统资源。</td></tr><tr><td style="text-align:left"><code>public void mark(int readlimit)</code></td><td style="text-align:left">在此输入流中标记当前的位置。</td></tr><tr><td style="text-align:left"><code>public boolean markSupported()</code></td><td style="text-align:left">测试此输入流是否支持 mark 和 reset 方法。</td></tr><tr><td style="text-align:left"><code>public void reset() throws IOException</code></td><td style="text-align:left">将此流重新定位到最后一次对此输入流调用 mark 方法时的位置。</td></tr></tbody></table><p>InputStream的具体子类使用这些方法从某种特定介质中读取数据。例如，FileInputStream从文件中读取数据。TelnetInputStream从网络中读取数据。ByteArrayInputStream从字节数组中读取数据。但无论读完哪种数据源，主要使用以上这六个方法。<br>有时你不知道正在读取的流具体是何种类型。例如，TelnetInputStream类隐藏在sun.net包中，没有提供相关文档。java.net包中的很多方法都会返回这个类的实例(例如java.net.URL的openStream()方法)。不过，这些方法声明为只返回InputStream，而不是特定的子类TelnetInputStream。这又是多态在起作用。子类的实例可以透明的作为其超类的实例来使用。而不需要子类更特定的知识。</p><p>InputStream的基本方法是没有参数的read()方法。这个方法从输入流的源中读取1个字节数据，作为一个0~255的int返回。流的结束通过放回-1来表示。read()方法会等待并阻塞其后任何代码的执行，知道有1字节的数据可供读取。输入和输出可能很慢，所以如果程序在做其他重要的工作，要尽量将I/O放在单独的线程中。</p><h3 id="read-方法"><a href="#read-方法" class="headerlink" title="read()方法"></a>read()方法</h3><p>read()方法声明为抽象方法，因为各个子类需要修改这个方法来处理特定的介质。例如，ByteArraryInputStream会用纯Java代码实现这个方法，从数组复制字节。不过，TelnetInputStream需要使用一个原生库，它知道如何从主机平台的网络接口读取数据。</p><p>下面的代码段从InputStream in中读取10个字节，存储在byte数组input中。不过，如果检测到流结束,循环就会提前终止。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">byte[] input =new byte[10];</span><br><span class="line">for(int i=0;i&lt;input.length,i++)</span><br><span class="line">&#123;</span><br><span class="line">    int b=in.read();</span><br><span class="line">    if(b==-1) break;</span><br><span class="line">    input[i]=(byte)b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="有符号字节转换为无符号字节"><a href="#有符号字节转换为无符号字节" class="headerlink" title="有符号字节转换为无符号字节"></a>有符号字节转换为无符号字节</h4><p>虽然read()只读取一个字节，但它会返回一个int.这样把结果存储到字节数组之前就必须进行强制类型转换。当然，这会产生一个-128到127之间的有符号字节，而不是read()方法返回的0到255之间的一个无符号字节。不过，只要你清楚在做什么，这就不是大问题。<br>你可以如下将一个有符号字节转换为无符号字节：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int i=b&gt;=0 ? b :256+b;</span><br></pre></td></tr></table></figure><p></p><p>与一次写入1字节的数据一样，一次读取1字节的效率也不高。因此，有两个重载的read()方法，可以用流中读取多个字节的数据来填充一个指定的数组：read(byte[] input)和read(byte[] input,int offset,int length)。第一个犯法尝试填充指定的数组input,第二个方法尝试填充指定的input从offset开始连续length字节的子数组。</p><p>注意我说着这些方法是在尝试填充数组，也就是说不是一定会成功。尝试可能会以很多不同的方式失败。例如，你可能听说说，当你的程序正在通过DSL从远程Web服务器读取数据时，由于电话公式中心办公室的交换机存在bug，这会断开你与其他地方数百个邻居的连接。这会导致一个IOException异常。但更常见的是，读尝试可能不会完全失败，但也不会完全成功。可能读取到一些请求的字节，但未能全部读取到。例如，你可能尝试从一个网络连接中读取1024字节，限制实际上只有512字节到达，其他的仍在传输中。尽管它们最终会到达，但此时却不可用。考虑这一点，读取多字节的方法会返回实际读取的字节数。例如，考虑下面的代码段：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte[] input =new byte[1024];</span><br><span class="line">int bytesRead=in.read(input);</span><br></pre></td></tr></table></figure><p></p><p>它尝试从InputStream in向数组input读入1024字节。不过，如果只有512字节可用，那就只会读取这么多，bytesRead将会设置为512。为了保证你希望的所有数据都真正读取到，要把读取方法放在循环中，这样会重复读取，知道数组填满为止。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int bytesRead=0；</span><br><span class="line">int bytesToRead=1024;</span><br><span class="line">byte[] input= new byte[bytesToRead];</span><br><span class="line">while(bytesRead&lt;bytesToRead)</span><br><span class="line">&#123;</span><br><span class="line">    bytesRead+=in.read(intput,bytesRead,bytesToRead-bytesRead);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这项技术对于网络流尤为重要,一般来讲如果一个文件完全可用，那么文件的所有字节也都可用。不过由于网络要不CPU慢很多，所以郑旭很容易在所有数据到达前清空网络缓冲区。事实上，如果这两个方法读取展示为空但打开的网络缓冲区，它通常会返回0，表示没有数据可用，但是流还没有关闭。这往往要比单个字节的read()方法要好，因为在这种情况下单字节方法会阻塞正在运行的线程。</p><p>所有3个read()方法都用返回-1表示流的结束。如果流已经结束，而又没有读取的数据，多字节read()方法会返回这些数据，直到缓冲区清空。其后任何一个read()方法调用会返回-1，-1永远不会放进数组中，数组中只包含实际的数据。前面的代码段中存在一个bug,因为它没有考虑所有1024字节永远不可能到达的情况(这与前面所说的情况不同，那只是当时不可用,但以后所有字节总会到达)。要修复这个bug,需要先测试read()的返回值，然后在增加到哦bytesRead中。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int bytesRead=0；</span><br><span class="line">int bytesToRead=1024;</span><br><span class="line">byte[] input=new byte[bytesToRead];</span><br><span class="line">while(bytesRead&lt;bytesToRead)</span><br><span class="line">&#123;</span><br><span class="line">    int result=in.read(input,bytesRead,bytesToRead-bytesRead);</span><br><span class="line">    if(result==-1) break;//流结束</span><br><span class="line">    bytesRead+=result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="available-方法"><a href="#available-方法" class="headerlink" title="available()方法"></a>available()方法</h3><p>如果不想等待所需的全部字节都立即可用，可以使用available()方法来确定不阻塞的情况下有多少字节可用读取。它会返回可以读取的最少字节数。事实上还能读取更多字节，但至少可以读取available()建立的字节数。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int byteAvailable = in.available();</span><br><span class="line">byte[] input=new byte[bytesAvailable];</span><br><span class="line">int bytesRead=in.read(input,0,bytesAvailable);</span><br><span class="line">//立即继续执行程序的其他部分...</span><br></pre></td></tr></table></figure><p></p><p>在这种情况下，可以人文bytesRead与bytesAvailable相等。不过，不能期望bytesRead大于0。有可能没有可用的字节，在流的最后，available()会返回0。一般来说，read(byte[] input,int offset,int length)在流结束时返回-1;但如果length是0,那么他不会注意流的结束，而是返回0。</p><h3 id="skip-方法"><a href="#skip-方法" class="headerlink" title="skip()方法"></a>skip()方法</h3><p>在少数情况下，你可能希望跳过数据不进行读取。skip()方法会完全完成这项任务。与读取文件相比，在网络连接中它的用处不大。网络连接是顺序的，一般情况下很慢，所以与跳过数据(不读取)相比，读取数据并不会耗费太长时间。文件是随机访问的，所以要跳过数据，可以简单的实现为重新指定文件指针位置，而不需要跳过的各字节。</p><h3 id="close-方法-1"><a href="#close-方法-1" class="headerlink" title="close()方法"></a>close()方法</h3><p>与输出流一样，一旦结束对输入流的操作，应当调用他的close()方法将其关闭。这会释放与这个流关联的所有资源如句柄或端口。一旦输入流已关闭,进一步读取这个流会抛出IOException异常。不过，有些流可能仍然允许处理这个对象。例如，你通常会在读取了数据并关闭之后才会从java.security.DigestInputStream获取消息摘要。</p><h3 id="标记和重置"><a href="#标记和重置" class="headerlink" title="标记和重置"></a>标记和重置</h3><p>InputStream类还有3个不太用的方法，允许程序备份和重新读取已经读取的数据。这些方法是：</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>public void mark(int readAheadLimit)</code></td><td style="text-align:left">在此输入流中标记当前的位置。</td></tr><tr><td style="text-align:left"><code>public void reset() throws IOException</code></td><td style="text-align:left">将此流重新定位到最后一次对此输入流调用 mark 方法时的位置。</td></tr><tr><td style="text-align:left"><code>public boolean markSupported()</code></td><td style="text-align:left">测试此输入流是否支持 mark 和 reset 方法。</td></tr></tbody></table><p>为了重新读取数据，用mark()方法标记流的当前位置。在以后某个时刻，可以用reset()方法把流重置到之前标记的位置。接下来的读取操作会返回从标记位置开始的数据。不过，不能随心所欲的向前重置任意远的位置。从标记处读取和重置的字节数有mark()的readAheadLimit参数确定。如果试图重置的太远，就会抛出IOException异常。此外，一个流在任何时刻都只能有一个标记，标记第二个位置会清除第一个标记。</p><p>标记和重置通常通过将标记位置之后的所有字节存储在一个内部缓冲区来事项。不过，不是所有输入流都支持这一点。在尝试使用标记和重置之前，要检查markSupported()方法是否返回true。如果返回true,那么这个流确实支持标记和重置。否则，mark()方法会什么都不做，而调用reset()方法将抛出一个IOException异常。</p><hr><p>提示：在我看来，这是一个非常差的设计，实际上，不支持标记和重置的流比支持的更过。如果向抽象的超类附加一个功能，但这个功能对很多(甚至可能是大多数)子类都不可用，这就是一个很不好的想法。把这三个方法放在一个单独的接口中，由提供这个功能的类实现这个接口，这样做可能会更好。这个方法的缺点是不能在外置类型的任意输入流上调用这些方法，但实际上也不会这么做，因为并不是所有流都支持标记和重置。可以提供一个方法(如markSupport())在运行时进行检查，这是针对该问题的一个更传统的非面向对象的解决方案。面向对象的方法是通过接口和类将其嵌入在类型系统中，这样就可以在编译时进行检查。</p><hr><p>java.io中仅有连个的使用支持标记的输入流时BufferedInputStream和ByteArrayInputStream。而其他输入流(如TelnetInputStream)如果先串链到缓冲的输入流才支持标记，这里的串链，应该是这种类型的写法：<br>BufferedInputStream in=new BufferedInputStrem(new TelnetInputStream);<br>其实这样不就是直接使用了BufferedInputStream的标记功能了吗</p><h2 id="过滤器流"><a href="#过滤器流" class="headerlink" title="过滤器流"></a>过滤器流</h2><p>InputStream和OutputStream是相当原始的类。他们可以单个或成组的读写字节，但仅此而已。要确定这些字节的含义(比如，他们是整数还是IEEE 754浮点数，或者是Unicode文本)，这就完全由程序员和代码来完成。不过，有一些极为常见的数据格式，如果在类库中提供这些数据格式的固定实现，会有很多好处。例如，许多作为网络协议一部分传递的整数是32位的big-endain整数。许多通过Web发送的文本是7位ASCII,8位Latin-1或多字节UTF-8。许多由FTP传输的文件存储为zip格式。Java提供了很多过滤器类，可以附加到原始流中，在原始字节和个中格式之间来回转换。</p><hr><p>这里有必要说一下过滤器流<br>BufferedInputStream, CheckedInputStream, CipherInputStream, DataInputStream, DeflaterInputStream, DigestInputStream, InflaterInputStream, LineNumberInputStream, ProgressMonitorInputStream, PushbackInputStream</p><hr><p>过滤器有两个版本:过滤器流以及阅读器和书写器。过滤器流仍然主要讲原始数据作为字节处理，例如通过压缩数据或解释为二进制数字。阅读器和书写器处理多种编码文本的特殊情况，如UTF-8和ISO 8859-1。</p><p>过滤器流以链的形式进行组织，如下图所示。链中的每个环节都接收一个过滤器或流的数据，并把数据传递给链中的下一个环节。在这个示例中，从本地网络结构结构到一个压缩的加密文本文件，在这里本地代码将这个文件表示为TelnetInputStream(TelnetInputStream没有相关文档提供说明)。通过一个BufferedInputStream缓冲这个数据来加速整个过程。由一个CipherInputStream将数据解密。再由一个GZIPInputStream解压解密后的数据。一个InputStreamReader将解压后的数据转换为Unicode文本。最后，文本由应用程序读取并处理。<br><img src="https://i.imgur.com/685kwhH.png" alt=""><br>每个过滤器输出流都有与java.io.OutputStream相同的write(),close()和flush()方法。每个过滤器输入流都有与java.io.InputStream相同的read(),close()和available()方法。有些情况下，如BufferedInputStream和BufferedOutputStream,过滤器可能只有这些方法。过滤纯粹是内部操作，不提供任何新的公共接口。不过，在大多数情况下，过滤器流还增加一些公共方法提供额外的作用。有时除了平常的read()和write()方法之外，还需要使用这些方法，如PushbackInputStream的unread()方法。另外一些情况下，它们几乎完全代替了最初的接口。例如PrintStream的write()方法就很少使用，而会使用它的print()和println()方法。</p><h2 id="将过滤器串链在一起"><a href="#将过滤器串链在一起" class="headerlink" title="将过滤器串链在一起"></a>将过滤器串链在一起</h2><p>过滤器通过其构造函数与流连接。例如，下面的代码段将缓冲文件data.txt的输入。首先，创建一个FileInputStream对象fin，为此将文件名作为参数传递给FileInputStram构造函数。然后，通过将fin作为参数传递给BufferedInputStream构造函数来创建一个BufferendInputStream对象bin:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fin=new FileInputStream(&quot;data.txt&quot;);</span><br><span class="line">BufferedInputStream bin=new BufferedInputStream(fin);</span><br></pre></td></tr></table></figure><p></p><p>在此之后，从文件data.txt中读取文件可能会同时使用fin和bin的read()方法。不过，如果很合调用连接到同一和源的不同流，这可能睡违反过滤流的一些隐含的约定。大多数情况下，应当只使用链中最后一个过滤器进行实际的读写。想要在编写代码时尽量不带入这个中bug,可以有意的重写低层输入流的引用。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStream in =new FileInputStream(&quot;data.txt&quot;);</span><br><span class="line">in=new BufferedInputStream(in);</span><br></pre></td></tr></table></figure><p></p><p>执行这两行代码后，再没有任何方法能够访问低层文件输入流了，所以也就不会不小心读取这个流而破坏缓冲区。这个实例之所以可运行，原因是既然BufferedInputStream可以多态的用作InputStream的实例，所以没有必要区分InputStream和BufferedInputStream的方法。如果必须使用超类中没有声明的过滤器流的其他方法，可以直接在一个流中构建另一个流，例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DateOutputStream dout=new DataOutputStream(new BufferesOutputStream(new FileOutputStream(&quot;data.txt&quot;)));</span><br></pre></td></tr></table></figure><p></p><p>虽然这些语句有些长，不过很容易将这条语句分成多行，像这样：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DataOutputStream dout =new DataOutputStream（</span><br><span class="line">                                        new BufferedOutputStream(</span><br><span class="line">                                        new FileOutputStream(&quot;data.txt&quot;)</span><br><span class="line">                                        ));</span><br></pre></td></tr></table></figure><p></p><p>这种连接时永久的，过滤器无法与流断开连接。</p><p>有时可能会需要使用链找那个多个过滤器的方法。例如，在读取Unicode文本文件时，可能希望读取前3个字节的字节顺序标记，来判断文件时用big-endian UCS-2,little-endian USC-2，还是UTF-8编码的。然后选择读取服务器发送的首部，找到Content-encoding(内容编码)，然后用这个内容编码方式选取正确的Reader(阅读器)过滤器来读取响应主体。或者可能希望通过网络连接使用DataOutputStream发送浮点数，然后从DataOutputStream所连接的DigestOutputStream中获取一个MessageDigest。在所有这些情况下，都小保存和使用各低层流的引用。不过，除了链中最后一个过滤器之外，无论如何你都不应该从其他过滤器读取数据，或想其写入任何内容。</p><h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><p>BufferedOutputStream类将写入的数据存储在缓冲区中(一个名为buff的保护字节数组字段)，直到缓冲区满或刷新输出流。然后它将数据一次全部写入低层输出流。如果一次写入多字节，这与多次写入少量字节(但字节加起来是一样的)相比，前者往往要快得多。对于网络连接尤其是这样，因为每个TCP片或UDP包都有一定的开销，一般大约为40字节。这里就假设为40字节，这意味着，如果一次发送1字节，则实际发送40+1=41字节。那么发送1K数据，要发送1K次，则实际上需要通过线缆发送41K，而一次全部发送只需要发送1K+40字节。不过大多数网卡和TCP实现自身都是提供了一定程度的缓冲，所以实际的数量不会那么夸张。尽管如此，缓冲网络输出通常会带来巨大的性能提升。</p><p>BufferedInputStream类也有一个缓冲区的保护字节数组，名为buf。当调用某个流的read()方法时，它会首先尝试从缓冲区获得请求的数据。只有当缓冲区没有数据时，流才从底层的源中读取数据。这时，它会从源中读取尽可能多的数据存入缓冲区，而不管是否马上需要所有这些数据。不会立即用到的数据可以在以后调用read()时读取。当文本从本地磁盘中读取文件时，从底层流中读取几百字节的数据与读取1字节数据几乎一样快。因此，缓冲和显著提高性能。对于网络连接，这种效果则不甚明显，在这里瓶颈往往是网络传送数据的速度，而不是网络结构向程序传送数据的速度或程序运行的速度。尽管如此，缓冲输入没有什么坏处，随着网络的速度加快会变得更为重要。<br>BufferedInputStream有两个构造函数，BufferedOutputStream也一样：</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>BufferedInputStream(InputStream in)</code></td><td style="text-align:left">创建一个 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。</td></tr><tr><td style="text-align:left"><code>BufferedInputStream(InputStream in, int size)</code></td><td style="text-align:left">创建具有指定缓冲区大小的 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。</td></tr></tbody></table><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>BufferedOutputStream(OutputStream out)</code></td><td style="text-align:left">创建一个新的缓冲输出流，以将数据写入指定的底层输出流。</td></tr><tr><td style="text-align:left"><code>BufferedOutputStream(OutputStream out, int size)</code></td><td style="text-align:left">创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流。</td></tr></tbody></table><p>第一个参数是底层流，可以从中读取未缓冲的数据，或向其写入缓冲的数据。如果给出第二个参数，它会指定缓冲区的字节数。否则，输入流的缓冲区大小设置为8192字节。输入流的缓冲区大小也设置为8192字节。缓冲区的理想大小取决于所缓冲的流时何种类型。对于网络连接，你希望比一般的包大小更大一些。不过，这很难预测，根据本地网络连接和协议不同也有所区别。更快，更大带宽的网络倾向于使用更大的包，不过TCP片通常不会大于1K字节。</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>int read()</code></td><td style="text-align:left">参见 InputStream 的 read 方法的常规协定。</td></tr><tr><td style="text-align:left"><code>int read(byte[] b, int off, int len)</code></td><td style="text-align:left">从此字节输入流中给定偏移量处开始将各字节读取到指定的 byte 数组中。</td></tr><tr><td style="text-align:left"><code>int available()</code></td><td style="text-align:left">返回可以从此输入流读取（或跳过）、且不受此输入流接下来的方法调用阻塞的估计字节数。</td></tr><tr><td style="text-align:left"><code>void close()</code></td><td style="text-align:left">关闭此输入流并释放与该流关联的所有系统资源。</td></tr><tr><td style="text-align:left"><code>long skip(long n)</code></td><td style="text-align:left">参见 InputStream 的 skip 方法的常规协定。</td></tr><tr><td style="text-align:left"><code>boolean markSupported()</code></td><td style="text-align:left">测试此输入流是否支持 mark 和 reset 方法。</td></tr><tr><td style="text-align:left"><code>void mark(int readlimit)</code></td><td style="text-align:left">参见 InputStream 的 mark 方法的常规协定。</td></tr><tr><td style="text-align:left"><code>void reset()</code></td><td style="text-align:left">参见 InputStream 的 reset 方法的常规协定。</td></tr></tbody></table><p>从类 java.io.FilterInputStream 继承的方法 (没有覆盖)<br><code>public int read(byte[] b) throws IOException</code></p><blockquote><p><strong>BufferedInputStream没有声明自己的任何新方法,它只覆盖了InputStream的方法。</strong>它折尺标记和重置。两个多字节read(byte[] b)和read(byte[] b, int off, int len)方法<strong>尝试根据需要多次从底层输入流中读取数据，从而完全填充指定的数组或子数组。只有当数组或子数组完全填满，到达流的结尾或低层流阻塞而无法进一步读取时，这两个read()方法才返回</strong>。而大多数输入流(如FileInputStream等)都不这样做。它们在返回前只从低层流或数据源中读取一次。</p></blockquote><blockquote><p><strong>BufferedOutputStream也没有声明自己的任何新方法。</strong>调用它的方法与任何输出流的方法是一样的。区别在于，每次写入会把数据放在缓冲区中，而不是直接放入底层的输出流。因此，<strong>需要发送数据时应当刷新输出流，这一点非常重要。</strong></p></blockquote><h2 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a>PrintStream</h2><p>PrintStream类是大多数程序员都会遇到的第一个过滤器输出流，因为System.out就是一个PrintStream。不过还可以使用下面两个构造函数将其他输出流串链到打印流:</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>PrintStream(OutputStream out)</code></td><td style="text-align:left">创建新的打印流。</td></tr><tr><td style="text-align:left"><code>PrintStream(OutputStream out, boolean autoFlush)</code></td><td style="text-align:left">创建新的打印流。</td></tr></tbody></table><p>默认情况下，打印流应当显示刷新输出。不过，如果autoFlush参数为true,那么每次写入1字节数组或换行，或者调用println()方法时，都会刷新输出流。<br>除了平常的write()，flsuh()和close()方法，PrintStream还有9个重载的print()方法和10个重载的println()方法。每个print()方法都当参数以可预见的方式转换为一个字符串，再用默认的编码方式把每个字符串写入低层输出流。println()方法也完成相同的操作，但会在所写的行尾追加一个与平台有关的行分隔符。在UNIX(包括Mac OS)下是换行符(<code>\n</code>)。在Windows下是回车/换行符(<code>\r\n</code>)。</p><hr><p><strong>警告:</strong> PrintStream是有害的，网络程序员应当向躲避瘟疫一样避开它!</p><hr><p>第一个问题是println()的输出是与平台相关的，取决于运行代码的机器各行有时用换行符分割，有时则用回车符或者回车/换行符来分割。写入控制台时不会产生问题，但对于编写必须遵循明确协议的网络客户端和服务而言，这却是个灾难。大多数网络协议(如HTTP和Gnutela)明确指定行应当以回车/换行符结束。而使用println()写出的程序可能在Windows上正常工作，但在UNIX和Mac上无法工作。虽然许多服务和客户端能够”宽容”地接收而器能处理不正确的行结束符，但偶尔也有例外。</p><p>第二个问题是Printstream假定使用所在平台的默认编码方式。不过,这种编码方式可能不是服务器或客户端所期望的。例如，以接收XML文件的Web浏览器希望文件已UTF-8或UTF16方式编码，除非服务器另行要求。不过，一个使用PrintStream的Web服务器可能会从一个没做本地化环境的Windows胸发送CP1252编码的文件，或者从日本本地化环境的系统发送SJIS编码的文件，而不管客户端是否期望或理解这些编码方式。PrintStream不提供任何改变默认编码的机制。这个问题可以通过使用相关的PrintWriter类来修补。但是其他问题依旧。</p><p>第三个问题是PrintStream吞掉了所有的异常。这使得PrintSteam很适合作为教科书程序，比如HelloWrold,因为你要讲授简单的控制台输出，不用让学生先去学习异常处理的所有闲逛的知识。不过，网络连接不如控制台那么可靠。连接经常会由于网络拥塞，电话公司的错误，远程系统崩溃，以及很多其他原因而断开。网络程序必须准备处理数据流中意外的中断。要做到这一点，就需要使用异常处理。不过，PrintStream捕获了低层输出流抛出的所有异常。注意PrintStream中重写过的标准的OutputStream方法的声明没有平常的throws IOExceprion:</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>public void write(int b)</code></td><td style="text-align:left">将指定的字节写入此流。</td></tr><tr><td style="text-align:left"><code>public void write(byte[] buf, int off, int len)</code></td><td style="text-align:left">将 len 字节从指定的初始偏移量为 off 的 byte 数组写入此流。</td></tr><tr><td style="text-align:left"><code>public void close()</code></td><td style="text-align:left">关闭流。</td></tr><tr><td style="text-align:left"><code>public void flush()</code></td><td style="text-align:left">刷新该流的缓冲。</td></tr></tbody></table><p>实际上，PrintStream要依靠一个过时的不充分的错误标志。如果低层流抛出一个异常，就是设置这个内部错误标志。要由程序员使用checkError()方法来检查这个标志的值：<br>public boolean checkError()</p><p>要对PrintStream完成任何错误检查，代码必须显示的检查每一个调用。此外，异动单出现错误，就没有办法重置这个标志再进行进一步的错误检测，也就没有关于这个错误的更多信息。简而言之，PrintStream提供的错误通知对于不可靠的网络连接来说还远远不够。</p><h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p>DataInputStream和DataOutputStream类提供了一些方法，可用二进制格式读写Java的基本数据类型和字符串。所用的二进制格式主要<strong>用于在两个不同的Java程序之间交换数据</strong>(可能通过网络连接，数据文件，管道或者其他中间介质)。输出流写入什么数据，输入流就能读取什么数据。不过，这碰巧与大多数交换二进制的Internet协议所用的格式相同。例如，事件协议使用32位的IEEE 754浮点数，类似于Java的float数据类型(这是有关联的，而不只是巧合。Java和大多数网络协议都是由UNIX程序员设计的，因此都倾向于使用大多数UNIX系统中的常见格式)。然而，这并不适用与所有网络协议，所以请检查你使用的协议的具体细节。例如,网络时间协议(NTP)会把时间表示为64位无符号定点数，前32位是整数部分，后32位是小数部分。这与所有常见编程语言中的基本类型都不相同，不过处理起来相当简单，至少对NTP必须使用这种格式。<br>DataOutputStream类提供了下面11中方法，可以写入特定的Java数据类型:</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>void writeBoolean(boolean v)</code></td><td style="text-align:left">将一个 boolean 值以 1-byte 值形式写入基础输出流。</td></tr><tr><td style="text-align:left"><code>void writeByte(int v)</code></td><td style="text-align:left">将一个 byte 值以 1-byte 值形式写出到基础输出流中。</td></tr><tr><td style="text-align:left"><code>void writeBytes(String s)</code></td><td style="text-align:left">将字符串按字节顺序写出到基础输出流中。</td></tr><tr><td style="text-align:left"><code>void writeShort(int v)</code></td><td style="text-align:left">将一个 short 值以 2-byte 值形式写入基础输出流中，先写入高字节。</td></tr><tr><td style="text-align:left"><code>void writeInt(int v)</code></td><td style="text-align:left">将一个 int 值以 4-byte 值形式写入基础输出流中，先写入高字节。</td></tr><tr><td style="text-align:left"><code>void writeLong(long v)</code></td><td style="text-align:left">将一个 long 值以 8-byte 值形式写入基础输出流中，先写入高字节。</td></tr><tr><td style="text-align:left"><code>void writeFloat(float v)</code></td><td style="text-align:left">使用 Float 类中的 floatToIntBits 方法将 float 参数转换为一个 int 值，然后将该 int 值以 4-byte 值形式写入基础输出流中，先写入高字节。</td></tr><tr><td style="text-align:left"><code>void writeDouble(double v)</code></td><td style="text-align:left">使用 Double 类中的 doubleToLongBits 方法将 double 参数转换为一个 long 值，然后将该 long 值以 8-byte 值形式写入基础输出流中，先写入高字节。</td></tr><tr><td style="text-align:left"><code>void writeChar(int v)</code></td><td style="text-align:left">将一个 char 值以 2-byte 值形式写入基础输出流中，先写入高字节。</td></tr><tr><td style="text-align:left"><code>void writeChars(String s)</code></td><td style="text-align:left">将字符串按字符顺序写入基础输出流。</td></tr><tr><td style="text-align:left"><code>void writeUTF(String str)</code></td><td style="text-align:left">以与机器无关方式使用 UTF-8 修改版编码将一个字符串写入基础输出流。</td></tr></tbody></table><hr><h3 id="网络字节顺序"><a href="#网络字节顺序" class="headerlink" title="网络字节顺序"></a>网络字节顺序</h3><p><strong>字节序</strong>，顾名思义<strong>字节的顺序</strong>，就是<strong>大于一个字节类型的数据在内存中的存放顺序</strong>(一个字节的数据当然就无需谈顺序的问题了)。其实大部分人在实际的开发中都很少会直接和字节序打交道。<strong>唯有在跨平台以及网络程序中字节序才是一个应该被考虑的问题。</strong></p><p>在所有的介绍字节序的文章中都会提到字节序分为两类：Big-Endian和Little-Endian，引用标准的Big-Endian和Little-Endian的定义如下：<br>a) <code>Little-Endian</code>就是<strong>低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。</strong><br>b)<code>Big-Endian</code>就是<strong>高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。</strong><br>c<strong>) 网络字节序</strong>：<code>TCP/IP</code>各层协议将字节序定义为<code>Big-Endian</code>，因此<code>TCP/IP</code>协议中使用的字节序通常称之为网络字节序。</p><p>little-endian是x86系列CPU的数据存储方式，即将低序的部分存储在前面。<br>而big-endian是将高序部分存储在前面。</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>例如，要存储0xF432，little-endian将以32F4存储，而使用big-endian与此相反，将存储为F432</p><hr><p>所有数据都以big-endian格式写入。整数用尽可能少的字节写为2进制的补码。因此，byte会写为1字节，short写为2字节，int写为4字节，long写为8字节。浮点数和双精度分别写为4字节和8字节的IEEE 754格式。布尔数写为1字节。0表示false,1表示true。字符写为两个无符号字节。</p><p>最后三个方法有些棘手，writeChars()方法只是对String参数迭代(循环)处理,将各个字符安顺序写为一个2字节的big-endain Unicode字符(确切的讲是UTF-16码点),writeBytes()犯法迭代处理String参数，但只写入每个字符的低字节。因此，如果字符串中包换有<code>Latin-1</code>字符集以外的字符，其中的信息将会丢失。对于一些指定了ASCII编码的网络协议来说，这个方法或许有用，但多数情况下都应当避免使用。</p><p>writeChars和writeBytes都不会对输出流的字符串的长度编码。因此，你无法真正区分原始字符和作为字符串一部分的字符。writeUTF()方法则包含了字符串的长度。它将字符串本社用Unicode UTF-8编码的一个变体进行编码，由于这个变体的编码与大多数非Java软件有点不兼容，所以应当只用于与其他使用DataInputStream读取字符串的Java程序进行数据交换。<br>为了与所有其他软件交换UTF-8文本,应当使用有适当编码的InputStreamReader(如果Sun当初把这个方法的以及相应的读取方法命名为writeString()和readString(),而不是writeUTF()和readUTF(),那就不会产生任何混淆了)。</p><p>除了这些写入二进制数字和字符串的方法，DataOutputStream当然还有OutputStream类平常的write(),flush()和close()方法。</p><p><strong>重写或继承与父类的方法：</strong></p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>void write(int b)</code></td><td style="text-align:left">将指定字节（参数 b 的八个低位）写入基础输出流。</td></tr><tr><td style="text-align:left"><code>void write(byte[] b, int off, int len)</code></td><td style="text-align:left">将指定 byte 数组中从偏移量 off 开始的 len 个字节写入基础输出流。</td></tr><tr><td style="text-align:left"><code>void write(byte[] b)</code></td><td style="text-align:left">写一个数组，继承于父类</td></tr><tr><td style="text-align:left"><code>void flush()</code></td><td style="text-align:left">清空此数据输出流。</td></tr><tr><td style="text-align:left"><code>public void close() throws IOException</code></td><td style="text-align:left">关闭此输出流并释放与此流有关的所有系统资源。</td></tr></tbody></table><p>DataInputStream和DataOutputStream是互补的。DataOutputStream协议一种格式，DataInputStream都可以读取。此外DateInputSteam还有通常的read()，available(),skip()和close()方法，以及读取整个字节数组和文本行的方法。</p><p>有9个读取而二进制数据的方法，这些方法对应于DataOutputStream的11个方法(writeBytes()或writeChars()没有相应的读取方法，这要通过一次读取1字节和字符来处理):</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>boolean readBoolean()</code></td><td style="text-align:left">参见 DataInput 的 readBoolean 方法的常规协定。</td></tr><tr><td style="text-align:left"><code>byte readByte()</code></td><td style="text-align:left">参见 DataInput 的 readByte 方法的常规协定。</td></tr><tr><td style="text-align:left"><code>short readShort()</code></td><td style="text-align:left">参见 DataInput 的 readShort 方法的常规协定。</td></tr><tr><td style="text-align:left"><code>int readInt()</code></td><td style="text-align:left">参见 DataInput 的 readInt 方法的常规协定。</td></tr><tr><td style="text-align:left"><code>long readLong()</code></td><td style="text-align:left">参见 DataInput 的 readLong 方法的常规协定。</td></tr><tr><td style="text-align:left"><code>float readFloat()</code></td><td style="text-align:left">参见 DataInput 的 readFloat 方法的常规协定。</td></tr><tr><td style="text-align:left"><code>double readDouble()</code></td><td style="text-align:left">参见 DataInput 的 readDouble 方法的常规协定。</td></tr><tr><td style="text-align:left"><code>char readChar()</code></td><td style="text-align:left">参见 DataInput 的 readChar 方法的常规协定。</td></tr><tr><td style="text-align:left"><code>String readUTF()</code></td><td style="text-align:left">参见 DataInput 的 readUTF 方法的常规协定。</td></tr></tbody></table><p>此外，DataInputStream提供了两个方法，可以读取无符号字节和无法好短整数，并返回等价的int。Java没有这些数据类型，但在读完C程序写入的二进制数据时会遇到：</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>int readUnsignedByte()</code></td><td style="text-align:left">参见 DataInput 的 readUnsignedByte 方法的常规协定。</td></tr><tr><td style="text-align:left"><code>int readUnsignedShort()</code></td><td style="text-align:left">参见 DataInput 的 readUnsignedShort 方法的常规协定。</td></tr></tbody></table><p>DataInputStream有两个通常的多字节read()方法，可以把数据读入一个数组或子数组，并返回读取的字节数。它还有两个readFully()方法，会重复的从底层输入流像一个数组读取数据，知道读取了所有请求的字节数为止。如果不能读取到足够的数据，就会抛出IOException异常。如果你能提前知道要读取多少字节，使用这些方法尤其有用。例如如果你已经从HTTP首部读取了Content-lenght(内容长度)字段，就能知道有多少字节的数据，这种情况下就可以很好的利用这些方法：</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>int read(byte[] b)</code></td><td style="text-align:left">从包含的输入流中读取一定数量的字节，并将它们存储到缓冲区数组 b 中。</td></tr><tr><td style="text-align:left"><code>int read(byte[] b, int off, int len)</code></td><td style="text-align:left">从包含的输入流中将最多 len 个字节读入一个 byte 数组中。</td></tr><tr><td style="text-align:left"><code>void readFully(byte[] b)</code></td><td style="text-align:left">参见 DataInput 的 readFully 方法的常规协定。</td></tr><tr><td style="text-align:left"><code>void readFully(byte[] b, int off, int len)</code></td><td style="text-align:left">参见 DataInput 的 readFully 方法的常规协定。</td></tr></tbody></table><p>最后,DataInputStream还提供了流行的readLine()方法,它读取用行结束符分隔的一行，文本，并返回一个字符串:</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>String readLine()</code></td><td style="text-align:left">已过时。 该方法无法将字节正确转换为字符。从 JDK 1.1 开始，读取文本行的首选方法是使用 BufferedReader.readLine() 方法。</td></tr></tbody></table><p>不过，任何情况下都不要使用这个方法，不仅是因为它已经被废弃，而且它还有bug。之所以将这个方法废弃，是因为你在大多数情况下它不能正确地将非ASCII字符转换为字节。这个任务现在有BufferedReader类的readLine()方法来处理。不过，这两个方法都存在一个隐含的bug:它们并不总能把一个回车识别为行结束。实际上，readLine()只能识别换行或回车/换行对。如果是换行，则抛出这个回车和换行。把这一行作为String返回。如果不是换行，就抛掉这个回车，把这一行作为String返回，刚读取的这个额外的字符会成为下一行的一部分。不过，如果回车是流的最后一个字符，那么readLine()会挂起，等待最后一个字符的出现，但这个字符永远也不会出现。</p><p>这个问题在读取文件时，不太明显，因为几乎可以肯定会有下一个字符:如果没有别的字符，那么会由-1表示流结束。不过，在持久的网络连接中(如用于FTP和新型HTTP的连接),服务器或客户端可能只是在最后一个字符之后停止发送数据，并等待响应，二不会真正关闭连接。如果幸运，最终可能某一端的连接超时，你将得到一个IOEception异常，不过这可能至少要花费几分钟，而且会使你丢失流的最后一行数据，如果不够幸运，程序将永远挂起。</p><h2 id="阅读器和书写器"><a href="#阅读器和书写器" class="headerlink" title="阅读器和书写器"></a>阅读器和书写器</h2><p>许多程序员在编码时有一个坏习惯，好像所有文本都是ASCII,或者至少是该平台的内置编码方式。虽然有些比较老，较简单的网络协议(如daytime,quete of the day和chargen)确定指定文本采用ASCII编码方式,如<code>K0I8-R</code>西里尔文，Big-5中文和土耳其语使用的是ISO8859-9。Java的内置字符集是Unicode的UTF-16编码。当编码不再是ASCII时，如果假定字节和字符实质上是一样的，这也会出现问题。因此，对应输入和输出流类层次体系，Java提供了一个基本上完整的镜像，用来处理字符而不是字节。</p><p>这个镜像体系中，两个抽象超类定义了读/写字符的基本API，java.io.Reader类指定读取字符的API。java.io.Writer指定写字符的API。对应输入和输出流使用字节的地方，阅读器和书写器会使用Unicode字符。Reader和Writer的具体子类允许读取特定的源和写入特定的目标。过滤器阅读器和书写器可以附加在其他阅读器或书写器上，以提供额外的服务或接口。</p><p>Reader和Writer最重要的具体子类是InputStreamReader和OutputStreamWriter类。InputStreamReader类包含一个底层输入流，可以从中读取原始字节。它根据指定的编码方式，将这些字节转换为Unicode字符。OutputStreamWriter从运行的程序中接收Unicode字符。然后使用指定的编码方式将这些字符转换为字节，再将这些字节写入低层输出流中。</p><p>除了这两个类，java.io包还提供了几个原始阅读器和书写器类,它们可以读取字符而不需要一个地城输入流，这些类包括：</p><ul><li>FileReader</li><li>FileWriter</li><li>StringReader</li><li>StringWriter</li><li>CharArrayReader</li><li>CharArrayWriter</li></ul><p>以上所列的两个类可以处理文件，后四个由Java内部使用，所以在网络编程中不太常用。不过，除了构造函数不同，这些类与其他阅读器和书写器类一样，都有相同的公共接口。</p><h2 id="书写器"><a href="#书写器" class="headerlink" title="书写器"></a>书写器</h2><p>Writer类是java.io.OutputStream类的映射。它是一个抽象类，有两个保护类型的构造函数，与OutputStream类似，Writer类从不直接使用;相反，会通过它的某个子类以多态方式使用。它有5个write()方法，另外还有flush()和close()方法：</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>protected Writer()</code></td><td style="text-align:left">创建一个新的字符流 writer，其关键部分将同步 writer 自身。</td></tr><tr><td style="text-align:left"><code>protected Writer(Object lock)</code></td><td style="text-align:left">创建一个新的字符流 writer，其关键部分将同步给定的对象。</td></tr></tbody></table><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>void write(int c)</code></td><td style="text-align:left">写入单个字符。</td></tr><tr><td style="text-align:left"><code>void write(char[] cbuf)</code></td><td style="text-align:left">写入字符数组。</td></tr><tr><td style="text-align:left"><code>abstract void write(char[] cbuf, int off, int len)</code></td><td style="text-align:left">写入字符数组的某一部分。</td></tr><tr><td style="text-align:left"><code>void write(String str)</code></td><td style="text-align:left">写入字符串。</td></tr><tr><td style="text-align:left"><code>void write(String str, int off, int len)</code></td><td style="text-align:left">写入字符串的某一部分。</td></tr><tr><td style="text-align:left"><code>Writer append(char c)</code></td><td style="text-align:left">将指定字符添加到此 writer。</td></tr><tr><td style="text-align:left"><code>Writer append(CharSequence csq)</code></td><td style="text-align:left">将指定字符序列添加到此 writer。</td></tr><tr><td style="text-align:left"><code>Writer append(CharSequence csq, int start, int end)</code></td><td style="text-align:left">将指定字符序列的子序列添加到此 writer.Appendable。</td></tr><tr><td style="text-align:left"><code>abstract void close()</code></td><td style="text-align:left">关闭此流，但要先刷新它。</td></tr><tr><td style="text-align:left"><code>abstract void flush()</code></td><td style="text-align:left">刷新该流的缓冲。</td></tr></tbody></table><p>write(char[] text,int offset,int length)方法是基础方法，其他四个write()都是根据它实现的。子类至少要覆盖这个方法以及flush()和close()，但是为了提供更搞笑的实现方法，大多数子类还覆盖了其他一些write()方法。例如，给定一个Writer对象w,可以这样写入字符串“Network”<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char[] network=&#123;&apos;N&apos;,&apos;e&apos;,&apos;t&apos;,&apos;w&apos;,&apos;o&apos;,&apos;r&apos;,&apos;k&apos;&#125;;</span><br><span class="line">w.write(network,0,network.length);</span><br></pre></td></tr></table></figure><p></p><p>也可以用其他write()方法完成同样的任务:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">w.write(network);</span><br><span class="line">for(int i=0;i&lt;network.length;i++)</span><br><span class="line">    w.write(network[i]);</span><br></pre></td></tr></table></figure><p></p><p>或者：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.write(&quot;Network&quot;);</span><br></pre></td></tr></table></figure><p></p><p>或者：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.write(&quot;Network&quot;,0,7);</span><br></pre></td></tr></table></figure><p></p><p>所有这些例子表述都是同样的事情，只不过方式有所不同。在任何给定情况下，选择使用哪个方法主要考虑是否方便，以及你有什么偏好。不过，这些代码写入多字节以及写入哪些字节，则取决于w使用的编码方式。如果使用big-endian UTF-16编码，那么它将依次写入下面14字节(以16进制显示):<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00 4E 00 65 00 74 00 77 00 6F 00 72 00 8B</span><br></pre></td></tr></table></figure><p></p><p>另一方面，如果w使用little-endain UTF-16，则写入下面14字节序列：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4E 00 65 00 74 00 77 00 6f 00 72 00 8B 00</span><br></pre></td></tr></table></figure><p></p><p>如果w使用<code>Latin-1</code>,UTF-8或MacRoman,则写入下面7字节的序列:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4E 65 74 77 6F 72 6B</span><br></pre></td></tr></table></figure><p></p><p>其他编码方式可能写入不同的字节序列。具体的输出取决于编码方式。<br>书写器可以缓冲，有可能直接串链到BufferedWriter,也有可能间接链入(因为其低层输出流时缓冲的)。为了强制将一个写入提前交给输出介质，要调用flush()方法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.flush();</span><br></pre></td></tr></table></figure><p></p><p>close()方法的行为与OutputStream的close()方法类似。close()刷新输出书写器，然后关闭低层输出流，并释放与之关联的所有资源:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public absctract void close() throws IOException</span><br></pre></td></tr></table></figure><p></p><p>在书写器关闭之后，进一步的写入会抛出IOException异常。</p><h2 id="OutputStreamWrter"><a href="#OutputStreamWrter" class="headerlink" title="OutputStreamWrter"></a>OutputStreamWrter</h2><p>OutputStreamWriter是Writer的最重要的具体子类。OutputStreamWriter会从Java程序接收字符。它根据指定的编码方式将这些字符转换为字节，并写入低层输出流。它的构造函数指定了要写入的输出流和使用的编码方式：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public OutputStreamWriter(OutputStream out,String encoding) throws UnsupportedEncodingException</span><br></pre></td></tr></table></figure><p></p><p>JDK中包括一个Sun的native2ascii工具，其相关文档中列出了所有合法的编码方式，如果没有指定编码方式，就使用平台的默认编码方式。2013年，Mac上默认编码方式是UTF-8,Linux上也大多如此。不过，在Linux上，如果本地操作系统配置为默认使用另外某个字符集，Linux上的默认编码方式可能有变化。在Windows上，默认编码方式会根据国家和配置而改变，但是在美国，Windows上默认的编码方式往往是<code>Windows-1252</code>，又叫做<code>CP1252</code>。默认字符集可能会在出乎意料的时候导致意外的问题。<strong>如果能明确地指定字符集，这往往比让Java为你选择一个字符集要好。</strong></p><p>除了构造函数，OutputStramWriter只有通常的Writer方法(这些方法与所有Writer类中的用法相同)，还有一个返回对象编码方式的方法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public String getEncoding()</span><br></pre></td></tr></table></figure><p></p><h2 id="阅读器"><a href="#阅读器" class="headerlink" title="阅读器"></a>阅读器</h2><p>Reader类是java.io.InputStream类的镜像。它是以抽象类，有两个保护的构造函数。与InputStream和Writer类似，Reader类从不直接使用，只通过其子类来使用。他有三个read()方法，另外还有skip()，close()，ready()，mark()，reset()和markSupported()方法</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>protected Reader()</code></td><td style="text-align:left">创建一个新的字符流 reader，其重要部分将同步其自身的 reader。</td></tr><tr><td style="text-align:left"><code>protected Reader(Object lock)</code></td><td style="text-align:left">创建一个新的字符流 reader，其重要部分将同步给定的对象。</td></tr></tbody></table><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>void reset()</code></td><td style="text-align:left">重置该流。</td></tr><tr><td style="text-align:left"><code>int read()</code></td><td style="text-align:left">读取单个字符。</td></tr><tr><td style="text-align:left"><code>int read(char[] cbuf)</code></td><td style="text-align:left">将字符读入数组。</td></tr><tr><td style="text-align:left"><code>abstract int read(char[] cbuf, int offset, int len)</code></td><td style="text-align:left">将字符读入数组的某一部分。</td></tr><tr><td style="text-align:left"><code>int read(CharBuffer target)</code></td><td style="text-align:left">试图将字符读入指定的字符缓冲区。</td></tr><tr><td style="text-align:left"><code>boolean markSupported()</code></td><td style="text-align:left">判断此流是否支持 mark() 操作。</td></tr><tr><td style="text-align:left"><code>void mark(int readAheadLimit)</code></td><td style="text-align:left">标记流中的当前位置。</td></tr><tr><td style="text-align:left"><code>long skip(long n)</code></td><td style="text-align:left">跳过字符。</td></tr><tr><td style="text-align:left"><code>boolean ready()</code></td><td style="text-align:left">判断是否准备读取此流。</td></tr><tr><td style="text-align:left"><code>abstract void close()</code></td><td style="text-align:left">关闭该流并释放与之关联的所有资源。</td></tr></tbody></table><p><code>read(char[] cbuf, int off, int len)</code>方法是基本方法，其他两个read()方法都是根据它实现的。子类必须至少覆盖这个方法以及close()方法，但是为了提供更搞笑的实现，大多数子类还会覆盖其他一些read()方法。</p><p>由于与对应的InputStream类似，大多数方法都很容易理解。read()方法将一个Unicode字符作为一个int返回。可以是0到65535之间的一个值,或者在流结束时返回-1(理论上讲，它会返回一个UTF-16码点,不过这基于等同于Unicode字符)。<code>read(char[] cbuf)</code>方法尝试使用字符填充<code>cbuf</code>,并返回实际读取的字节数，或者在流结束时返回-1。<code>read(char[] cbuf, int offset, int length)</code>方法尝试将length个字符读入text的子数组中(从offset开始持续读入length个字符)。它也会返回实际读取的字符数，或者在流结束时返回-1。</p><ul><li>skip(long n)方法跳过n个字符。</li><li>mark()和reset()方法允许一些阅读器重置到字符序列中做标记的位置。</li><li>markSupported()方法会告知阅读器是否支持标记和重置。</li><li>close()方法会关闭阅读器和所有底层输入流，如果试图进一步读取则会抛出IOException异常。</li></ul><p>尽管与InputStream非常相似，但也有所例外: Reader类有一个ready()方法，它与InputStream的available()的用途相同，但语义却不尽相同，尽管都涉及字节到字符转换。available()返回一个int,指定可无阻赛的最少读取多少字节。但ready()犯法只返回一个boolean,指示阅读器是否可以无阻赛的读取。问题在于，有些字符编码仿方式(如UTF-8)对于不同的字符会使用不同数量的字节。因此在实际从缓冲区读取之前，很难说有多好个字符正在网络或文件系统的缓冲区中等待。</p><p>InputStreamReader是Reader的最重要的具体子类。InputStreamReader从底层输入流(FileInputStream或TelnetInputStream)中读取字节。它根据指定的编码方式将这些字节转换为字符。并返回这些字符。构造函数指定要读取的输入流所用的编码方式:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public InputStreamReader(InputStream in)</span><br><span class="line">public InputStreamReader(InputStream in,String encoding) </span><br><span class="line">    throws UnsupportedEncodingException</span><br></pre></td></tr></table></figure><p></p><p>如果没有指定编码方式，就使用平台的默认编码方式。如果指定了一个未知的编码方式，会抛出<code>UnsupportEncodingException</code>异常。<br>例如，下面的方法将读取一个输入流，使用MacCyrillic编码方式将其全部转换为一个Unicode字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static String getMacCyrillicString(InputStream in)</span><br><span class="line">    throws IOExceptionn </span><br><span class="line">&#123;</span><br><span class="line">    InputStreamReader r=new InputStreamReader(in,&quot;MacCyrillic&quot;);</span><br><span class="line">    StringBuilder sb=new StringBuilder();</span><br><span class="line">    int c;</span><br><span class="line">    while( (c=r.read()!=-1) )</span><br><span class="line">        sb.append((char) c);</span><br><span class="line"></span><br><span class="line">    return sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="过滤器阅读器和书写器"><a href="#过滤器阅读器和书写器" class="headerlink" title="过滤器阅读器和书写器"></a>过滤器阅读器和书写器</h2><p>InputStreamReader和OutputStreamWriter类就相当于输入和输出流的装饰器，把面向字节的接口改为面向字符的接口。完场之后，就可以将其他面向字符的过滤器放在用java.io.FilterReader和java.io.FilterWriter类的阅读器或书写器上面。与过滤器流一样，有很多子类可以完成特定的过滤工作，包括:</p><ul><li>BufferedReader</li><li>BufferedWriter</li><li>LineNumberReder</li><li>PushbackReader</li><li>PrintWriter<br>BufferedReader和BufferedWriter类是基于字符的，而BufferedInputStream和BufferedOutputStream类是面向<code>字节</code>的<br>BufferedInputStream和BufferedOutputStream使用一个内部字节数组作为缓冲区，响应的，BufferedReader和BufferedWriter使用一个内部字符数组作为缓冲区。</li></ul><p><strong>当程序从BufferedReader读取时，文本会从缓冲区得到，而不是直接同低层输入流或其他文本源读取</strong>。当缓冲区清空时，BufferedReader将用尽可能多的文本再次填充，尽管这些文本不是全部都立即需要，这样可以使以后的读取速度更快。当程序写入一个BufferedWriter时，文本被放置在缓冲区中。只有当缓冲区填满或者当书写器显示刷新输出时，文本才会被一道低层输出流或其他目标，这样使得写入也要快得多。</p><p>如果没有设置大小，则默认使用的大小为8192字符：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public BufferedReader(Reader in,int bufferSize)</span><br><span class="line">public BufferedReader(Reader in)</span><br><span class="line">public BufferedWriter(Writer out)</span><br><span class="line">public BufferedWriter(Writer out,int bufferSize)</span><br></pre></td></tr></table></figure><p></p><p>例如，前面的getMacCyrillicString()示例效率不太高，因为它每次只读取一个字符。由于MacCyrillic是一个单字节的字符集，所以也是每次读取1字节。不过,通常将一个BufferedReader串链到InputStreamReader，会是它运行得更快，如下所示:<br>public static String getMacCyrillicString(InputStream in)<br>throws IOException<br>{<br>Reader r=new InputStreamReader(in,”MacCyrillic”);<br>r=new BufferedReader(r,1024);<br>StringBuider sb=new StringBuilder();<br>int c;<br>while((c=r.read())!=-1)<br>sb.append((char)c);</p><pre><code>return sb.toString();
</code></pre><p>}</p><p>要让这个方法进行缓冲，只需要增加另外一行代码。算法的其他部分都不用改变，因为要用到的InputStreamReader方法只是Reader超类中声明的read()和close()方法，所有的Reader子类都有着两个方法，BufferedReader也不例外。<br>BufferedReader类还有一个readeLine()方法，它读取一行文本，并作为一个字符串返回:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public String readLine() throws IOException</span><br></pre></td></tr></table></figure><p></p><p>这个方法可以替代DataInputStream中已废弃的readerLine()方法，它与该方法的行为基本相同。主要区别在于，通过将BufferedReader串链到InputStreamReader,你可以采用正确的字符集进读取行，而不是采用平台的默认编码方式。</p><p>这个BufferedWriter()类增加了一个其超类所没有的新的方法，名为newLine()，也用于写入一行:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void newLine() throws IOException</span><br></pre></td></tr></table></figure><p></p><p>这个方法向输出插入一个与平台有关的行分隔符字符串。line.separator系统属性会确定这个字符串是什么:在UNIX和Mac OS X可能是换行”<code>\n</code>“,在Windows下是回车/换行对。由于网络协议一般会指定所需的行结束符，所以网络编程中不要使用这个方法。而是应当显示的下如协议所需的行结束符。大多数情况下，所需的结束符都是回车/换行对(“\r\n”)</p><h2 id="PrintWriter"><a href="#PrintWriter" class="headerlink" title="PrintWriter"></a>PrintWriter</h2><p>PrintWriter类用于取代Java 1.0的PrintStream类，它能正确的处理多字节字符集和国际化文本。Sun最初计划废弃PrintStream而支持PrintWriter，但是当它意识到这样做会使太多现有的代码失效(尤其是依赖于System.out的代码)，就放弃了这种想法。尽管如此，新编写的代码还是应当使用PrintWriter而不是PrintStream。</p><p>除了构造函数，PrintWriter类也有与PrintStream几乎相同的方法集。包括:</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>PrintWriter(File file)</code></td><td style="text-align:left">使用指定文件创建不具有自动行刷新的新 PrintWriter。</td></tr><tr><td style="text-align:left"><code>PrintWriter(File file, String csn)</code></td><td style="text-align:left">创建具有指定文件和字符集且不带自动刷行新的新 PrintWriter。</td></tr><tr><td style="text-align:left"><code>PrintWriter(OutputStream out)</code></td><td style="text-align:left">根据现有的 OutputStream 创建不带自动行刷新的新 PrintWriter。</td></tr><tr><td style="text-align:left"><code>PrintWriter(OutputStream out, boolean autoFlush)</code></td><td style="text-align:left">通过现有的 OutputStream 创建新的 PrintWriter。</td></tr><tr><td style="text-align:left"><code>PrintWriter(String fileName)</code></td><td style="text-align:left">创建具有指定文件名称且不带自动行刷新的新 PrintWriter。</td></tr><tr><td style="text-align:left"><code>PrintWriter(String fileName, String csn)</code></td><td style="text-align:left">创建具有指定文件名称和字符集且不带自动行刷新的新 PrintWriter。</td></tr><tr><td style="text-align:left"><code>PrintWriter(Writer out)</code></td><td style="text-align:left">创建不带自动行刷新的新 PrintWriter。</td></tr><tr><td style="text-align:left"><code>PrintWriter(Writer out, boolean autoFlush)</code></td><td style="text-align:left">创建新 PrintWriter。</td></tr></tbody></table><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>PrintWriter append(char c)</code></td><td style="text-align:left">将指定字符添加到此 writer。</td></tr><tr><td style="text-align:left"><code>PrintWriter append(CharSequence csq)</code></td><td style="text-align:left">将指定的字符序列添加到此 writer。</td></tr><tr><td style="text-align:left"><code>PrintWriter append(CharSequence csq, int start, int end)</code></td><td style="text-align:left">将指定字符序列的子序列添加到此 writer。</td></tr><tr><td style="text-align:left"><code>void close()</code></td><td style="text-align:left">关闭该流并释放与之关联的所有系统资源。</td></tr><tr><td style="text-align:left"><code>void flush()</code></td><td style="text-align:left">刷新该流的缓冲。</td></tr><tr><td style="text-align:left"><code>boolean checkError()</code></td><td style="text-align:left">如果流没有关闭，则刷新流且检查其错误状态。</td></tr><tr><td style="text-align:left"><code>protected void clearError()</code></td><td style="text-align:left">清除此流的错误状态。</td></tr><tr><td style="text-align:left"><code>protected void setError()</code></td><td style="text-align:left">指示已发生错误。</td></tr><tr><td style="text-align:left"><code>void write(char[] buf)</code></td><td style="text-align:left">写入字符数组。</td></tr><tr><td style="text-align:left"><code>void write(char[] buf, int off, int len)</code></td><td style="text-align:left">写入字符数组的某一部分。</td></tr><tr><td style="text-align:left"><code>void write(int c)</code></td><td style="text-align:left">写入单个字符。</td></tr><tr><td style="text-align:left"><code>void write(String s)</code></td><td style="text-align:left">写入字符串。</td></tr><tr><td style="text-align:left"><code>void write(String s, int off, int len)</code></td><td style="text-align:left">写入字符串的某一部分。</td></tr><tr><td style="text-align:left"><code>PrintWriter format(Locale l, String format, Object... args)</code></td><td style="text-align:left">使用指定格式字符串和参数将一个格式化字符串写入此 writer 中。</td></tr><tr><td style="text-align:left"><code>PrintWriter format(String format, Object... args)</code></td><td style="text-align:left">使用指定格式字符串和参数将一个格式化字符串写入此 writer 中。</td></tr><tr><td style="text-align:left"><code>void print(boolean b)</code></td><td style="text-align:left">打印 boolean 值。</td></tr><tr><td style="text-align:left"><code>void print(char c)</code></td><td style="text-align:left">打印字符。</td></tr><tr><td style="text-align:left"><code>void print(char[] s)</code></td><td style="text-align:left">打印字符数组。</td></tr><tr><td style="text-align:left"><code>void print(double d)</code></td><td style="text-align:left">打印 double 精度浮点数。</td></tr><tr><td style="text-align:left"><code>void print(float f)</code></td><td style="text-align:left">打印一个浮点数。</td></tr><tr><td style="text-align:left"><code>void print(int i)</code></td><td style="text-align:left">打印整数。</td></tr><tr><td style="text-align:left"><code>void print(long l)</code></td><td style="text-align:left">打印 long 整数。</td></tr><tr><td style="text-align:left"><code>void print(Object obj)</code></td><td style="text-align:left">打印对象。</td></tr><tr><td style="text-align:left"><code>void print(String s)</code></td><td style="text-align:left">打印字符串。</td></tr><tr><td style="text-align:left"><code>PrintWriter printf(Locale l, String format, Object... args)</code></td><td style="text-align:left">使用指定格式字符串和参数将格式化的字符串写入此 writer 的便捷方法。</td></tr><tr><td style="text-align:left"><code>PrintWriter printf(String format, Object... args)</code></td><td style="text-align:left">使用指定格式字符串和参数将格式化的字符串写入此 writer 的便捷方法。</td></tr><tr><td style="text-align:left"><code>void println()</code></td><td style="text-align:left">通过写入行分隔符字符串终止当前行。</td></tr><tr><td style="text-align:left"><code>void println(boolean x)</code></td><td style="text-align:left">打印 boolean 值，然后终止该行。</td></tr><tr><td style="text-align:left"><code>void println(char x)</code></td><td style="text-align:left">打印字符，然后终止该行。</td></tr><tr><td style="text-align:left"><code>void println(char[] x)</code></td><td style="text-align:left">打印字符数组，然后终止该行。</td></tr><tr><td style="text-align:left"><code>void println(double x)</code></td><td style="text-align:left">打印双精度浮点数，然后终止该行。</td></tr><tr><td style="text-align:left"><code>void println(float x)</code></td><td style="text-align:left">打印浮点数，然后终止该行。</td></tr><tr><td style="text-align:left"><code>void println(int x)</code></td><td style="text-align:left">打印整数，然后终止该行。</td></tr><tr><td style="text-align:left"><code>void println(long x)</code></td><td style="text-align:left">打印 long 整数，然后终止该行。</td></tr><tr><td style="text-align:left"><code>void println(Object x)</code></td><td style="text-align:left">打印 Object，然后终止该行。</td></tr><tr><td style="text-align:left"><code>void println(String x)</code></td><td style="text-align:left">打印 String，然后终止该行。</td></tr></tbody></table><p>这些方法的行为大多与PrintStream中相同。只有4个write()方法有所例外，他们写入字符而不是字节。此外，如果低层的书写器能够正确地处理字符集转换，那么PrintWriter的所有方法也能处理这种转换。这是对非国际化的PrintStream类的改进，但对弈网络编程来说，仍然不太合适。很遗憾，PrintWriter也存在困扰PrintStream类的平台依赖性和错误检查报告信息量小的问题。</p><hr><p>提示:本章快速的浏览了java.io包，涵盖了编写网络程序所需要的最起码的知识。更详细的介绍及更多的实例请查阅这个系列中我的另一本数《Java I/O》(O’Reilly出版)。</p><hr><p>好的，一定看看。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/d3f6b577/">java网络编程第4版 第2章 流</a></p></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div></div><button id="rewardButton" disable="enable" onclick='var e=document.getElementById("QR");"none"===e.style.display?e.style.display="block":e.style.display="none"'><span>打赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"><img id="wechat_qr" src="/images/wechatpay.png" alt="蓝生 微信支付"><p>微信支付</p></div><div id="alipay" style="display:inline-block"><img id="alipay_qr" src="/images/alipay.png" alt="蓝生 支付宝"><p>支付宝</p></div></div></div></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/blog/d4b540e/" rel="next" title="BufferedInputStream读数组方法和FileInputStream读数组方法的区别："><i class="fa fa-chevron-left"></i> BufferedInputStream读数组方法和FileInputStream读数组方法的区别：</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/blog/ad610aad/" rel="prev" title="挖掉图片中间一部分">挖掉图片中间一部分 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="蓝生"><p class="site-author-name" itemprop="name">蓝生</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">241</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">78</span> <span class="site-state-item-name">分类</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://blog.csdn.net/qq_21808961" target="_blank" title="CSDN"><i class="fa fa-fw fa-arrow-right"></i>CSDN</a> </span><span class="links-of-author-item"><a href="https://www.shixiseng.com/" target="_blank" title="实习僧"><i class="fa fa-fw fa-arrow-right"></i>实习僧</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://ziyuan.baidu.com/xzh/home/index" title="百度熊掌号" target="_blank">百度熊掌号</a></li><li class="links-of-blogroll-item"><a href="https://ziyuan.baidu.com/linksubmit/index" title="百度链接提交" target="_blank">百度链接提交</a></li><li class="links-of-blogroll-item"><a href="https://reuixiy.github.io/" title="超好看的Hexo+NexT博客" target="_blank">超好看的Hexo+NexT博客</a></li><li class="links-of-blogroll-item"><a href="https://www.face2ai.com/" title="谭升" target="_blank">谭升</a></li></ul></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#引言"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#输出流"><span class="nav-number">2.</span> <span class="nav-text">输出流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#write-int-b-方法"><span class="nav-number">2.1.</span> <span class="nav-text">write(int b)方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#write-int-b-方法实例"><span class="nav-number">2.2.</span> <span class="nav-text">write(int b)方法实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#flush-方法"><span class="nav-number">2.3.</span> <span class="nav-text">flush()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#close-方法"><span class="nav-number">2.4.</span> <span class="nav-text">close()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#close-方法正确的写法"><span class="nav-number">2.5.</span> <span class="nav-text">close()方法正确的写法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#输入流"><span class="nav-number">3.</span> <span class="nav-text">输入流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#read-方法"><span class="nav-number">3.1.</span> <span class="nav-text">read()方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#有符号字节转换为无符号字节"><span class="nav-number">3.1.1.</span> <span class="nav-text">有符号字节转换为无符号字节</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#available-方法"><span class="nav-number">3.2.</span> <span class="nav-text">available()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#skip-方法"><span class="nav-number">3.3.</span> <span class="nav-text">skip()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#close-方法-1"><span class="nav-number">3.4.</span> <span class="nav-text">close()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标记和重置"><span class="nav-number">3.5.</span> <span class="nav-text">标记和重置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#过滤器流"><span class="nav-number">4.</span> <span class="nav-text">过滤器流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#将过滤器串链在一起"><span class="nav-number">5.</span> <span class="nav-text">将过滤器串链在一起</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缓冲流"><span class="nav-number">6.</span> <span class="nav-text">缓冲流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PrintStream"><span class="nav-number">7.</span> <span class="nav-text">PrintStream</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据流"><span class="nav-number">8.</span> <span class="nav-text">数据流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#网络字节顺序"><span class="nav-number">8.1.</span> <span class="nav-text">网络字节顺序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#例子"><span class="nav-number">8.1.1.</span> <span class="nav-text">例子</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#阅读器和书写器"><span class="nav-number">9.</span> <span class="nav-text">阅读器和书写器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#书写器"><span class="nav-number">10.</span> <span class="nav-text">书写器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OutputStreamWrter"><span class="nav-number">11.</span> <span class="nav-text">OutputStreamWrter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#阅读器"><span class="nav-number">12.</span> <span class="nav-text">阅读器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#过滤器阅读器和书写器"><span class="nav-number">13.</span> <span class="nav-text">过滤器阅读器和书写器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PrintWriter"><span class="nav-number">14.</span> <span class="nav-text">PrintWriter</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">蓝生</span></div><div class="theme-info"><div class="powered-by"></div><span class="post-count">博客全站共342.8k字</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv" title="总访客量"><i class="fa fa-user"></i> 总访客量:<span class="busuanzi-value" id="busuanzi_value_site_uv"></span> </span><span class="site-pv" title="总访问量"><i class="fa fa-eye"></i> 总访问量:<span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/js/src/utils.js?v=6.4.0"></script><script type="text/javascript" src="/js/src/motion.js?v=6.4.0"></script><script type="text/javascript" src="/js/src/affix.js?v=6.4.0"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.0"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=6.4.0"></script><script type="text/javascript" src="/js/src/post-details.js?v=6.4.0"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.0"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script type="text/javascript">var GUEST=["nick","mail","link"],guest="nick,mail,link";guest=guest.split(",").filter(function(e){return GUEST.indexOf(e)>-1}),new Valine({el:"#comments",verify:!0,notify:!1,appId:"8uEACQMqUrxjo1Hqof21pkCV-gzGzoHsz",appKey:"DgRm99ypfVS7Mm9YLchO1RGG",placeholder:"填写昵称,邮箱,网址即可评论.昵称可随意写,邮箱用于接收回复提醒,网址也设置为你个人网站或者博客的地址.",avatar:"mm",meta:guest,pageSize:"10",visitor:!1})</script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(t,e,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,r=document.getElementById(e),s=document.getElementById(o),a=function(){var t=r.value.trim().toLowerCase(),e=t.split(/[\s\-]+/);e.length>1&&e.push(t);var o=[];if(t.length>0&&n.forEach(function(n){function r(e,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===t&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(t,e){var o="",n=e.start;return e.hits.forEach(function(e){o+=t.substring(n,e.position);var r=e.position+e.length;o+='<b class="search-keyword">'+t.substring(e.position,r)+"</b>",n=r}),o+=t.substring(n,e.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url),d=[],g=[];if(""!=l&&(e.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());(s=e.indexOf(t,r))>-1;)a.push({position:s,word:t}),r=s+n;return a}d=d.concat(e(t,h,!1)),g=g.concat(e(t,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(t){b+="<a href='"+f+'\'><p class="search-result">'+s(p,t)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===e.length&&""===e[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>';else{o.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id});var a='<ul class="search-result-list">';o.forEach(function(t){a+=t.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){var e=27===t.which&&$(".search-popup").is(":visible");e&&onPopupClose()})</script><script>!function(){var t=document.createElement("script"),s=window.location.protocol.split(":")[0];"https"===s?t.src="https://zz.bdstatic.com/linksubmit/push.js":t.src="http://push.zhanzhang.baidu.com/push.js";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script></body></html><script type="text/javascript" src="/js/src/love.js"></script><!-- rebuild by neat -->