<!-- build time:Sat Nov 10 2018 23:10:58 GMT+0800 (中国标准时间) --><!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="true"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=6.4.0" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple.png?v=6.4.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32.png?v=6.4.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16.png?v=6.4.0"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"6.4.0",sidebar:{position:"right",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="description" content="正则表达式定义了字符串的模式。正则表达式可以用来搜索、编辑或处理文本。正则表达式并不仅限于某一种语言，但是在每种语言中有细微的差别。一些正则表达式的实例及描述Java 正则表达式和 Perl 的是最为相似的。一个字符串其实就是一个简单的正则表达式，例如 Hello World 正则表达式匹配 “Hello World“ 字符串。.（点号）也是一个正则表达式，它匹配任何一个字符如：”a“ 或 “1“"><meta name="keywords" content="没有关键字"><meta property="og:type" content="article"><meta property="og:title" content="Java正则表达式"><meta property="og:url" content="https://www.lansheng.net.cn/blog/4ea1809c/index.html"><meta property="og:site_name" content="蓝生的博客"><meta property="og:description" content="正则表达式定义了字符串的模式。正则表达式可以用来搜索、编辑或处理文本。正则表达式并不仅限于某一种语言，但是在每种语言中有细微的差别。一些正则表达式的实例及描述Java 正则表达式和 Perl 的是最为相似的。一个字符串其实就是一个简单的正则表达式，例如 Hello World 正则表达式匹配 “Hello World“ 字符串。.（点号）也是一个正则表达式，它匹配任何一个字符如：”a“ 或 “1“"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2018-11-05T09:17:07.235Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Java正则表达式"><meta name="twitter:description" content="正则表达式定义了字符串的模式。正则表达式可以用来搜索、编辑或处理文本。正则表达式并不仅限于某一种语言，但是在每种语言中有细微的差别。一些正则表达式的实例及描述Java 正则表达式和 Perl 的是最为相似的。一个字符串其实就是一个简单的正则表达式，例如 Hello World 正则表达式匹配 “Hello World“ 字符串。.（点号）也是一个正则表达式，它匹配任何一个字符如：”a“ 或 “1“"><link rel="alternate" href="/atom.xml" title="蓝生的博客" type="application/atom+xml"><link rel="canonical" href="https://www.lansheng.net.cn/blog/4ea1809c/"><script type="text/javascript" id="page.configurations">CONFIG.page={sidebar:""}</script><title>Java正则表达式 | 蓝生的博客</title><noscript><style type="text/css">.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-right page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">蓝生的博客</span> <span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.lansheng.net.cn/blog/4ea1809c/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="蓝生"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="蓝生的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Java正则表达式</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-08-06 19:10:52" itemprop="dateCreated datePublished" datetime="2018-08-06T19:10:52+08:00">2018-08-06</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2018-11-05 17:17:07" itemprop="dateModified" datetime="2018-11-05T17:17:07+08:00">2018-11-05</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/Java-正则表达式/" itemprop="url" rel="index"><span itemprop="name">Java 正则表达式</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/blog/4ea1809c/#comments" itemprop="discussionUrl"><span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/blog/4ea1809c/" itemprop="commentCount"></span> </a></span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> 阅读次数： <span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><p>正则表达式<strong>定义了字符串的模式。</strong><br>正则表达式<strong>可以用来搜索、编辑或处理文本。</strong><br>正则表达式<strong>并不仅限于某一种语言，但是在每种语言中有细微的差别。</strong></p><h2 id="一些正则表达式的实例及描述"><a href="#一些正则表达式的实例及描述" class="headerlink" title="一些正则表达式的实例及描述"></a>一些正则表达式的实例及描述</h2><p><code>Java</code> 正则表达式和 <code>Perl</code> 的是最为相似的。<br><strong>一个字符串其实就是一个简单的正则表达式</strong>，例如 <code>Hello World</code> 正则表达式匹配 “<code>Hello World</code>“ 字符串。</p><p><code>.</code>（点号）也是一个正则表达式，它匹配任何一个字符如：”<code>a</code>“ 或 “<code>1</code>“。<br>下表列出了一些正则表达式的实例及描述：</p><table><thead><tr><th>序号</th><th>正则表达式</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td><code>this is text</code></td><td>匹配字符串 “<code>this is text</code>“，字符串只能匹配它自己，如果有任何一个字符不匹配都会失败，例如不能匹配这个中间有多个空白符的情况字符串”this&emsp;&emsp;&emsp;&emsp;is&emsp;&emsp;&emsp;&emsp; text”</td></tr><tr><td>2</td><td><code>this\s+is\s+text</code></td><td>注意字符串中的 <code>\s+</code>。<br>匹配单词 “<code>this</code>“ 之后，然后后面的 \s+ 可以匹配多个空格，之后匹配 <code>is</code>字符串，再之后 <code>\s+</code> 匹配多个空格然后再跟上 <code>text</code> 字符串。<br>可以匹配这个实例：<code>this is text</code>，也可以匹配字符串”this&emsp;&emsp;&emsp;&emsp;is&emsp;&emsp;&emsp;&emsp; text”</td></tr><tr><td>3</td><td><code>^\d+(\.\d+)?</code></td><td><code>^</code> 定义了该字符串以什么开始<br><code>\d+</code>匹配一个或多个数字<br><code>?</code> 设置括号内的选项是可选的(可以匹配一次或者多次)<br><code>\.</code>匹配 “<code>.</code>“<br>可以匹配的实例：”<code>5</code>“, “<code>1.5</code>“ 和 “<code>2.21</code>“。<br></td></tr></tbody></table><h1 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h1><p><strong>在其他语言中</strong>，<code>\\</code> 表示：我想要在正则表达式中<strong>插入一个普通的</strong>（字面上的）<strong>反斜杠</strong>，请不要给它任何特殊的意义。</p><p>在 Java 中，<code>\\</code>表示：我要<strong>插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。</strong></p><p>所以，<strong>在其他的语言中（如Perl），一个反斜杠 <code>\</code>就足以具有转义的作用，<code>而在 Java 中正则表达式中则需要有两个反斜杠才能被解析为其他语言中的转义作用。</code></strong>也可以简单的理解在 Java 的正则表达式中，两个<code>\\</code>代表其他语言中的一个 <code>\</code>，这也就是为什么表示一位数字的正则表达式是<code>\\d</code>，而表示一个普通的反斜杠是<code>\\\\</code>。<br><strong>正则表达式的特殊字符字符序列如下</strong></p><h2 id="匹配位置"><a href="#匹配位置" class="headerlink" title="匹配位置"></a>匹配位置</h2><table><thead><tr><th>序号</th><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td><code>^</code></td><td>匹配输入字符串开始的位置。如果设置了 <code>RegExp</code> 对象的 <code>Multiline</code> 属性，<code>^</code> 还会与”<code>\n</code>“或”<code>\r</code>“之后的位置匹配。</td></tr><tr><td>2</td><td><code>$</code></td><td>匹配输入字符串结尾的位置。如果设置了 <code>RegExp</code> 对象的 <code>Multiline</code> 属性，$ 还会与”<code>\n</code>“或”<code>\r</code>“之前的位置匹配。</td></tr><tr><td>3</td><td><code>\b</code></td><td>匹配一个字边界，即字与空格间的位置。例如，”<code>er\b</code>“匹配”<code>never</code>“中的”<code>er</code>“，但不匹配”<code>verb</code>“中的”<code>er</code>“。</td></tr></tbody></table><h2 id="匹配单个字符"><a href="#匹配单个字符" class="headerlink" title="匹配单个字符"></a>匹配单个字符</h2><table><thead><tr><th>序号</th><th>匹配单个字符</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td><code>.</code></td><td><strong>匹配除”<code>\r\n</code>“之外的任何单个字符</strong>。若要匹配包括”<code>\r\n</code>“在内的任意字符，请使用诸如”[<code>\s\S</code>]”之类的模式。</td></tr><tr><td>2</td><td><code>[xyz]</code></td><td><strong>字符集</strong>。<strong>匹配括号里包含的任意<code>一个</code>字符</strong>。例如，”[<code>abc</code>]”匹配”<code>plain</code>“中的”<code>a</code>“。</td></tr><tr><td>3</td><td><code>[^xyz]</code></td><td><strong>反向字符集</strong>。<strong>匹配括号里未包含的任何<code>一个</code>字符</strong>。例如，”<code>[^abc]</code>“匹配”<code>plain</code>“中”<code>p</code>“，”<code>l</code>“，”<code>i</code>“，”<code>n</code>“，但不会匹配<code>a</code></td></tr><tr><td>4</td><td><code>[a-z]</code></td><td><strong>范围字符集</strong>。<strong>匹配指定范围内的任何<code>一个</code>字符</strong>。例如，”<code>[a-z]</code>“匹配”<code>a</code>“到”<code>z</code>“范围内的任何<code>一个</code>小写字母。</td></tr><tr><td>5</td><td><code>[^a-z]</code></td><td><strong>反向范围字符集</strong>。<strong>匹配不在指定的范围内的任何一个字符</strong>。例如，”<code>[^a-z]</code>“匹配任何不在”<code>a</code>“到”<code>z</code>“范围内的任何字符。</td></tr></tbody></table><h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><table><thead><tr><th>序号</th><th>量词</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td><code>?</code></td><td>匹配前面的子符或子表达<strong><code>1次</code>或者<code>0次</code></strong>，例如 <code>zo?</code>匹配<code>z</code>或者<code>zo</code>。<code>?</code> 等效于 <code>{0,1}</code>。</td></tr><tr><td>2</td><td><code>*</code></td><td>匹配前面的字符或子表达式<strong><code>0次</code>或者<code>多次</code></strong>。例如，<code>zo*</code> 匹配”<code>z</code>“,”<code>zoo</code>“,”<code>zooo</code>“,<code>...</code>。<code>*</code> 等效于 <code>{0,}</code>。</td></tr><tr><td>3</td><td><code>+</code></td><td>匹配前面的字符或子表达式<strong><code>1次</code>或<code>多次</code></strong>。例如，”<code>zo+</code>“与”<code>zo</code>“和”<code>zoo</code>“匹配，但与”<code>z</code>“不匹配。<code>+</code>等效于 <code>{1,}</code>。</td></tr><tr><td>4</td><td><code>{n}</code></td><td><code>n</code> 是非负整数。<strong>正好匹配 <code>n</code> 次</strong>。例如，”<code>o{2}</code>“与”<code>Bob</code>“中的”<code>o</code>“不匹配，但与”<code>food</code>“中的两个”<code>o</code>“匹配。</td></tr><tr><td>5</td><td><code>{n,}</code></td><td><code>n</code> 是非负整数。<strong>至少匹配 <code>n</code> 次</strong>。例如，”<code>o{2,}</code>“不匹配”<code>Bob</code>“中的”<code>o</code>“，而匹配”<code>foooood</code>“中的所有 <code>o</code>。”<code>o</code>{1,}”等效于”<code>o+</code>“。”<code>o{0,}</code>“等效于”<code>o*</code>“。</td></tr><tr><td>6</td><td><code>{n,m}</code></td><td><code>m</code> 和 <code>n</code> 是非负整数，其中 <code>n &lt;= m</code>。<strong>匹配至少 <code>n</code> 次，至多 <code>m</code> 次</strong>。例如，”<code>o{1,3}</code>“匹配”<code>fooooood</code>“中的头三个 <code>o</code>。’<code>o{0,1}</code>‘ 等效于 ‘<code>o?</code>‘。注意：您不能将空格插入逗号和数字之间。</td></tr><tr><td>7</td><td><code>?</code></td><td>当此字符紧随任何其他限定符（<code>*</code>、<code>+</code>、<code>?</code>、<code>{n}</code>、<code>{n,}</code>、<code>{n,m}</code>）之后时，匹配模式是”非贪心的”。<strong>“非贪心的”模式匹配搜索到的、尽可能短的字符串</strong>，<strong>而默认的”贪心的”模式匹配搜索到的、尽可能长的字符串。</strong>例如，在字符串”<code>oooo</code>“中，”<code>o+?</code>“只匹配单个”<code>o</code>“，而”<code>o</code>+”匹配所有”<code>o</code>“。</td></tr></tbody></table><h2 id="懒惰匹配"><a href="#懒惰匹配" class="headerlink" title="懒惰匹配"></a>懒惰匹配</h2><p>参考：<a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="noopener">http://deerchao.net/tutorials/regex/regex.htm</a><br>解释一下上表的最后一个<code>?</code>的作用，这个<code>?</code>在上面其他量词后面，让原来的量词从尽可能匹配更多的字符，编程尽可能匹配更少的字符。也就是从贪婪的编程懒惰的。</p><p>当正则表达式中包含能接受重复的限定符时，<strong>通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符</strong>。以这个表达式为例：<code>a.*b</code>，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索<code>aabab</code>的话，它会匹配整个字符串<code>aabab</code>。这被称为贪婪匹配。</p><p>有时，我们更需要<strong>懒惰匹配，也就是匹配尽可能少的字符</strong>。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号<code>?</code>。这样<code>.*?</code>就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：</p><p><code>a.*?b</code>匹配最短的，以<code>a</code>开始，以<code>b</code>结束的字符串。如果把它应用于<code>aabab</code>的话，它会匹配<code>aab</code>（第一到第三个字符）和<code>ab</code>（第四到第五个字符）。</p><p>所以，在上面的量词后面都加上问号<code>?</code>，就可以懒惰匹配量词表，如下所示。</p><table><thead><tr><th>懒惰匹配量词</th><th>说明</th></tr></thead><tbody><tr><td><code>*?</code></td><td>重复任意次，但尽可能少重复</td></tr><tr><td><code>+?</code></td><td>重复1次或更多次，但尽可能少重复</td></tr><tr><td><code>??</code></td><td>重复0次或1次，但尽可能少重复</td></tr><tr><td><code>{n,m}?</code></td><td>重复n到m次，但尽可能少重复</td></tr><tr><td><code>{n,}?</code></td><td>重复n次以上，但尽可能少重复</td></tr></tbody></table><h2 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h2><table><thead><tr><th>序号</th><th>反向引用</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td><code>\num</code></td><td>匹配 num，此处的 <code>num 是一个正整数</code>。<strong>到捕获匹配的反向引用</strong>。例如，”<code>(.)\1</code>“匹配两个连续的相同字符。”<code>(a).+\1</code>“匹配<code>axa</code>,<code>abbba</code>等等</td></tr><tr><td>2</td><td><code>\n</code></td><td>标识一个八进制转义码或反向引用。如果 <code>\n</code> 前面至少有 <code>n</code> 个捕获子表达式，那么 <code>n</code> 是反向引用。否则，如果 <code>n</code> 是八进制数 (<code>0-7</code>)，那么 <code>n</code>是八进制转义码。</td></tr></tbody></table><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><h3 id="字符组简写形式"><a href="#字符组简写形式" class="headerlink" title="字符组简写形式"></a>字符组简写形式</h3><table><thead><tr><th>序号</th><th>字符组简写形式</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td><code>\d</code></td><td>数字字符匹配。等效于 <code>[0-9]</code>。</td></tr><tr><td>2</td><td><code>\D</code></td><td>非数字字符匹配。等效于 <code>[^0-9]</code>。</td></tr><tr><td>3</td><td><code>\s</code></td><td>匹配任何空白字符，包括空格、制表符、换页符等。与<code>[ \f\n\r\t\v]</code> 等效。</td></tr><tr><td>4</td><td><code>\S</code></td><td>匹配任何非空白字符。与 <code>[^ \f\n\r\t\v]</code> 等效。</td></tr><tr><td>5</td><td><code>\w</code></td><td>匹配任何字类字符，包括下划线。与”<code>[A-Za-z0-9_]</code>“等效。</td></tr><tr><td>6</td><td><code>\W</code></td><td>与任何非单词字符匹配。与”<code>[^A-Za-z0-9_]</code>“等效。</td></tr></tbody></table><h3 id="不可见字符"><a href="#不可见字符" class="headerlink" title="不可见字符"></a>不可见字符</h3><table><thead><tr><th>序号</th><th>转义字符</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td><code>\</code></td><td>将下一字符标记为特殊字符、文本、向引用或反八进制转义符。例如，”<code>n</code>“匹配字符”<code>n</code>“,而”<code>\n</code>“匹配换行符。序列”<code>\\\\</code>“匹配”<code>\\</code>“，”<code>\\(</code>“匹配”<code>(</code>“。</td></tr><tr><td>2</td><td><code>\b</code></td><td>匹配一个字边界，即字与空格间的位置。例如，”<code>er\b</code>“匹配”<code>never</code>“中的”<code>er</code>“，但不匹配”<code>verb</code>“中的”<code>er</code>“。</td></tr><tr><td>3</td><td><code>\B</code></td><td>非字边界匹配。”<code>er\B</code>“匹配”<code>verb</code>“中的”<code>er</code>“，但不匹配”<code>never</code>“中的”<code>er</code>“。</td></tr><tr><td>10</td><td><code>\t</code></td><td>制表符匹配。与 \x09 和 \cI 等效。</td></tr><tr><td>11</td><td><code>\v</code></td><td>垂直制表符匹配。与 \x0b 和 \cK 等效。</td></tr><tr><td>12</td><td><code>\r</code></td><td>匹配一个回车符。等效于 \x0d 和 \cM。</td></tr><tr><td>13</td><td><code>\n</code></td><td>换行符匹配。等效于 \x0a 和 \cJ。</td></tr><tr><td>14</td><td><code>\f</code></td><td>换页符匹配。等效于 \x0c 和 \cL。</td></tr><tr><td>15</td><td><code>\cx</code></td><td>匹配 x 指示的控制字符。例如，<code>\cM</code> 匹配<code>Control-M</code> 或回车符。<code>x</code> 的值必须在 <code>A-Z</code> 或 <code>a-z</code> 之间。如果不是这样，则假定 <code>c</code> 就是”<code>c</code>“字符本身。</td></tr></tbody></table><h3 id="进制相关"><a href="#进制相关" class="headerlink" title="进制相关"></a>进制相关</h3><table><thead><tr><th>序号</th><th>带进制的转义符</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td><code>\xn</code></td><td>匹配 <code>n</code>，此处的 <code>n</code> 是一<strong>个十六进制转义码</strong>。十六进制转义码必须正好是两位数长。例如，”<code>\x41</code>“匹配”<code>A</code>“。”<code>\x041</code>“与”<code>\x04</code>“<code>&amp;</code>“<code>1</code>“等效。允许在正则表达式中使用 <code>ASCII</code> 代码。</td></tr><tr><td>2</td><td><code>\n</code></td><td>标识一个<strong>八进制转义码或反向引用</strong>。如果 <code>\n</code> 前面至少有 <code>n</code> 个捕获子表达式，那么 <code>n</code> 是反向引用。否则，如果 <code>n</code> 是八进制数 (<code>0-7</code>)，那么 <code>n</code> 是八进制转义码。</td></tr><tr><td>3</td><td><code>\un</code></td><td>匹配 <code>n</code>，其中 <code>n</code> 是以四位十六进制数表示的 <code>Unicode</code> 字符。例如，<code>\u00A9</code> 匹配版权符号 (<code>©</code>)。</td></tr></tbody></table><h1 id="java-使用正则表达式步骤"><a href="#java-使用正则表达式步骤" class="headerlink" title="java 使用正则表达式步骤"></a>java 使用正则表达式步骤</h1><p>参考:<a href="https://www.cnblogs.com/haodawang/p/5967219.html" target="_blank" rel="noopener">https://www.cnblogs.com/haodawang/p/5967219.html</a></p><h2 id="java的regex库常用类"><a href="#java的regex库常用类" class="headerlink" title="java的regex库常用类"></a>java的regex库常用类</h2><p><code>java</code>里提供了一个<code>java.util.regex</code>库，方便于我们在<code>java</code>里操作正则表达式，或者用它来匹配字符串。</p><h3 id="常用类：Pattern和Matcher"><a href="#常用类：Pattern和Matcher" class="headerlink" title="常用类：Pattern和Matcher"></a>常用类：Pattern和Matcher</h3><p>其中比较常用的类有 <code>Pattern</code> 和 <code>Matcher</code> ,<code>Pattern</code>是一个编译好的正则表达式，而<code>Mather</code>是一个正则表达式适配器，<code>Mather</code>的功能很强大，所以我们一般用<code>pattern</code> 来获取一个<code>Matcher</code>对象，然后用<code>Matcher</code>来操作正则表达式。</p><h3 id="Pattern-类和Matcher-类的关系"><a href="#Pattern-类和Matcher-类的关系" class="headerlink" title="Pattern 类和Matcher 类的关系"></a><code>Pattern</code> 类和<code>Matcher</code> 类的关系</h3><p>首先一个<code>Pattern</code>实例订制了一个所用语法与<code>PERL</code>的类似的正则表达式经编译后的模式，然后一个<code>Matcher</code>实例在这个给定的<code>Pattern</code>实例的模式控制下进行字符串的匹配工作。</p><h3 id="PatternSyntaxException-类"><a href="#PatternSyntaxException-类" class="headerlink" title="PatternSyntaxException 类"></a><code>PatternSyntaxException</code> 类</h3><p><code>PatternSyntaxException</code> 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</p><h2 id="通常使用步骤"><a href="#通常使用步骤" class="headerlink" title="通常使用步骤"></a>通常使用步骤</h2><h3 id="创建Pattern对象"><a href="#创建Pattern对象" class="headerlink" title="创建Pattern对象"></a>创建Pattern对象</h3><p>创建<code>pattern</code>的对象是很简单的，但是由于<code>pattern</code>的构造方法是用<code>private</code>声明的，所以我们仅能通过工厂模式的<code>compile()</code>方法来返回一个<code>Pattern</code>的对象,<code>compile</code>可以接收一个正则表达式作为参数。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pattern pattern = Pattern.compile(&quot;[abc]&quot;);</span><br></pre></td></tr></table></figure><p></p><h3 id="创建Matcher对象"><a href="#创建Matcher对象" class="headerlink" title="创建Matcher对象"></a>创建<code>Matcher</code>对象</h3><p>接下来我们创建一个<code>Matcher</code>对象。<code>Matcher</code>的构造方法也是一个<code>private</code>方法，但是我们可以通过<code>Pattern</code>的<code>Matcher</code>方法来返回一个<code>Matcher</code>对象。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Matcher matcher = pattern.matcher(&quot;hello abc&quot;);</span><br></pre></td></tr></table></figure><p></p><p>这里<code>matcher</code>可以接收一个字符串作为参数，<strong>准确的说这里所接收的参数类型是<code>CharSequences</code>接口类型的参数</strong>，<code>String</code>、<code>StringBuffer</code>、<code>StringBuilder</code>还有<code>CharBuffer</code>都实现了<code>CharSequence</code>接口，因此这四种类型的对象都可以传入。</p><h3 id="简便用法"><a href="#简便用法" class="headerlink" title="简便用法"></a>简便用法</h3><p>与此同时<code>Pattern</code>还提供了一个<code>matches</code> 静态方法(<code>Pattern.matches(regex, input)</code>)，它允许我们传入一个<code>String</code>类型的正则表达式和一个<code>String</code>类型的需要匹配的字符串，并返回一个<code>boolean</code>类型的值，这个方法的好处在于我们可以不用创建<code>pattern</code>对象和<code>matcher</code>对象就可以知道所传入的正则表达式能不能匹配所传入的字符串。</p><p>####实例####<br>使用了正则表达式 <code>.*groot.*</code>判断字符串中是否包了 groot 这个子串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegexExample1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String content = <span class="string">"I am groot"</span>;</span><br><span class="line">        String pattern = <span class="string">".*groot.*"</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isMatch = Pattern.matches(pattern, content);</span><br><span class="line">        System.out.println(<span class="string">"字符串中是否包含了 'groot' 子字符串? "</span> + isMatch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例输出结果为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串中是否包含了 &apos;groot&apos; 子字符串? true</span><br></pre></td></tr></table></figure><p></p><p>创建Matcher类对象后就可使用Matcher类许多强大的方法了。</p><h1 id="Matcher-类的主要方法介绍"><a href="#Matcher-类的主要方法介绍" class="headerlink" title="Matcher 类的主要方法介绍"></a>Matcher 类的主要方法介绍</h1><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>说到<code>Matcher</code>,这个东西就很强大了，我们比较常用的方法有:</p><ul><li><code>find();</code></li><li><code>group();</code></li></ul><p>(1)先来说一下<code>find()</code>和<code>group</code>这两个方法。<br><code>find</code>有点像一个迭代器，它能通过正则表达式向前迭代。而<code>group()</code>方法返回0号分组，也就是整个正则表达式匹配的文本。<br>下来看一个例子<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testFindGroup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Pattern pattern = Pattern.compile(<span class="string">"\\d+"</span>);</span><br><span class="line">    Matcher matcher = pattern.matcher(<span class="string">"aaa 111 bbbb 222 333 ccc"</span>);</span><br><span class="line">    <span class="comment">//find向前迭代,查找匹配的字符串</span></span><br><span class="line">    <span class="keyword">while</span>(matcher.find())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取匹配正则表达式的子串</span></span><br><span class="line">        System.out.println(matcher.group());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">111</span><br><span class="line">222</span><br><span class="line">333</span><br></pre></td></tr></table></figure><p></p><p>可以看到这和<code>Matcher.find()</code>和<code>Scanner.hasnext()</code>方法类似，而<code>Matcher.group()</code>和<code>Scanner.next()</code>方法类似。</p><h2 id="捕获组"><a href="#捕获组" class="headerlink" title="捕获组"></a>捕获组</h2><p>捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。</p><p>例如，正则表达式 (dog) 创建了单一分组，组里包含”d”，”o”，和”g”。</p><p><strong>捕获组是通过从左至右计算其开括号来编号</strong>。例如，在表达式<code>((A)(B(C))）</code>，有四个这样的组：</p><ul><li><code>((A)(B(C)))</code></li><li><code>(A)</code></li><li><code>(B(C))</code></li><li><code>(C)</code></li></ul><p>可以通过调用 <code>matcher</code> 对象的 <code>groupCount()</code>方法来查看表达式有多少个分组。<code>groupCount()</code> 方法返回一个 <code>int</code> 值，表示<code>matcher</code>对象当前有多个捕获组。</p><p>还有一个特殊的组（<code>group(0)</code>），它总是代表整个表达式。该组不包括在 <code>groupCount</code> 的返回值中。</p><table><thead><tr><th>序号</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td><code>public int groupCount()</code></td><td>返回此匹配器模式中的捕获组数。根据惯例，零组表示整个模式。它不包括在此计数中。</td></tr><tr><td>2</td><td><code>String group()</code></td><td>返回0号捕获组，也就是整个表达式匹配的字符串</td></tr><tr><td>3</td><td><code>String group(int group)</code></td><td>返回指定捕获组捕获到的子串</td></tr></tbody></table><h3 id="捕获组实例"><a href="#捕获组实例" class="headerlink" title="捕获组实例"></a>捕获组实例</h3><h4 id="查看正则表达式中有多到个捕获组"><a href="#查看正则表达式中有多到个捕获组" class="headerlink" title="查看正则表达式中有多到个捕获组"></a>查看正则表达式中有多到个捕获组</h4><p><code>int groupCount()</code>方法：返回此匹配器模式中的捕获组数.不包括0捕获组<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGroupCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Pattern pattern = Pattern.compile(<span class="string">"(\\w+)(\\s+)([0-9]+)"</span>);</span><br><span class="line">       Matcher matcher = pattern.matcher(<span class="string">"aaa 111 bbbb 222 333 ccc"</span>);</span><br><span class="line">       System.out.println(pattern.toString()+<span class="string">"这个正则表达式捕获组数目:"</span>+matcher.groupCount());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(\w+)(\s+)([0-9]+)这个正则表达式捕获组数目:3</span><br></pre></td></tr></table></figure><p></p><h4 id="捕获方法group-和group-int-group-实例"><a href="#捕获方法group-和group-int-group-实例" class="headerlink" title="捕获方法group()和group(int group)实例"></a>捕获方法group()和group(int group)实例</h4><p><strong>下面的例子说明如何从一个给定的字符串中捕获数字串：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package java1.regex.test;</span><br><span class="line"></span><br><span class="line">import java.util.regex.Matcher;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line">public class RegexMatches</span><br><span class="line">&#123;</span><br><span class="line">	public static void main(String args[])</span><br><span class="line">	&#123;</span><br><span class="line">		// 按指定模式在字符串查找</span><br><span class="line">		String line = &quot;I hope that 2018 is also a year full of hope.&quot;;</span><br><span class="line">		String pattern = &quot;(\\D*)(\\d+)(.*)&quot;;</span><br><span class="line">		// 创建 Pattern 对象</span><br><span class="line">		Pattern r = Pattern.compile(pattern);</span><br><span class="line">		// 现在创建 matcher 对象</span><br><span class="line">		Matcher m = r.matcher(line);</span><br><span class="line">		if (m.find())</span><br><span class="line">		&#123;</span><br><span class="line">			//默认匹配捕获整个表达式-调用m.group(0);</span><br><span class="line">			System.out.println(m.group());</span><br><span class="line">			System.out.println(&quot;第0个分组: &quot; + m.group(0));</span><br><span class="line">			System.out.println(&quot;第1个分组: &quot; + m.group(1));</span><br><span class="line">			System.out.println(&quot;第2个分组: &quot; + m.group(2));</span><br><span class="line">			System.out.println(&quot;第3个分组: &quot; + m.group(3));</span><br><span class="line">		&#125; else</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(&quot;NO MATCH&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实例编译运行结果如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第0个分组: I hope that 2018 is also a year full of hope.</span><br><span class="line">第1个分组: I hope that </span><br><span class="line">第2个分组: 2018</span><br><span class="line">第3个分组:  is also a year full of hope.</span><br></pre></td></tr></table></figure><p></p><p>这里要注意的是<strong>第0个分组捕获的是整个正则表达式匹配到的字符串</strong>，而子字符串的捕获是从第1个分组开始的。<strong>使用无参的捕获函数group()默认捕获0号分组</strong>，看源码就知道了：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public String group() &#123;</span><br><span class="line">    return group(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="索引方法"><a href="#索引方法" class="headerlink" title="索引方法"></a>索引方法</h2><p>索引方法提供了有用的索引值，精确表明输入字符串中在哪能找到匹配：</p><table><thead><tr><th>序号</th><th>索引方法</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td><code>public int start()</code></td><td>返回匹配子序列在原序列的起始下标</td></tr><tr><td>2</td><td><code>public int start(int group)</code></td><td>返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引</td></tr><tr><td>3</td><td><code>public int end()</code></td><td>返回匹配子序列在原序列的结束下标</td></tr><tr><td>4</td><td><code>public int end(int group)</code></td><td>返回在以前的匹配操作期间，由给定组所捕获子序列的最后字符之后的偏移量。</td></tr></tbody></table><h3 id="start-和-end-方法"><a href="#start-和-end-方法" class="headerlink" title="start 和 end 方法"></a>start 和 end 方法</h3><ul><li><code>start()</code>是返回匹配成功的子串的第一个字母的索引</li><li>而<code>end()</code>是返回子串最后一个索引的位置+1。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStartEnd1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    String input = <span class="string">"hello_World"</span>;</span><br><span class="line">    Matcher matcher = Pattern.compile(<span class="string">"\\w+_"</span>).matcher(input);</span><br><span class="line">    matcher.find();</span><br><span class="line">    System.out.println(input.charAt(matcher.start()));</span><br><span class="line">    System.out.println(input.charAt(matcher.end()));</span><br><span class="line">    System.out.println(input.charAt(matcher.end()-<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h</span><br><span class="line">W</span><br><span class="line">_</span><br></pre></td></tr></table></figure><p></p><p>从运行中可以看到，end方法返回的是最后匹配的字符<code>_</code>后面的字符<code>W</code>，而不是该字符<code>_</code>本身。</p><h3 id="实例：统计一个单词出现的次数"><a href="#实例：统计一个单词出现的次数" class="headerlink" title="实例：统计一个单词出现的次数"></a>实例：统计一个单词出现的次数</h3><p>下面统计单词 “<code>groot</code>“ 在输入字符串中出现的次数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStartEnd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String regex = <span class="string">"\\bgroot\\b"</span>;</span><br><span class="line">    <span class="keyword">final</span> String text = <span class="string">"I am groot!I am groot!I am groot!I am groot!!!"</span>;</span><br><span class="line"><span class="comment">//  编译表示的正则表达式</span></span><br><span class="line">    Pattern p = Pattern.compile(regex);</span><br><span class="line"><span class="comment">//  获取  matcher  对象</span></span><br><span class="line">    Matcher m = p.matcher(text);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//  boolean  find()</span></span><br><span class="line"><span class="comment">//  尝试查找与该模式匹配的输入序列的下一个子序列。</span></span><br><span class="line"><span class="comment">//  尝试查找与正则表达式匹配的下一个字序列</span></span><br><span class="line">    <span class="keyword">while</span> (m.find())</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(<span class="string">"子序列起始下标:--&gt;"</span> + m.start());</span><br><span class="line">        System.out.println(<span class="string">"成功匹配子序列:"</span> + m.group());</span><br><span class="line">        System.out.println(<span class="string">"子序列结束下标:&lt;--"</span> + m.end());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"总共匹配次数:"</span> + count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实例编译运行结果如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">子序列起始下标:--&gt;5</span><br><span class="line">成功匹配子序列:groot</span><br><span class="line">子序列结束下标:&lt;--10</span><br><span class="line">子序列起始下标:--&gt;16</span><br><span class="line">成功匹配子序列:groot</span><br><span class="line">子序列结束下标:&lt;--21</span><br><span class="line">子序列起始下标:--&gt;27</span><br><span class="line">成功匹配子序列:groot</span><br><span class="line">子序列结束下标:&lt;--32</span><br><span class="line">子序列起始下标:--&gt;38</span><br><span class="line">成功匹配子序列:groot</span><br><span class="line">子序列结束下标:&lt;--43</span><br><span class="line">总共匹配次数:4</span><br></pre></td></tr></table></figure><p></p><p>这个例子中使用单词边界，以确保匹配的字符序列是 “<code>g</code>“ ,”<code>r</code>“,”<code>o</code>“,”<code>o</code>“,”<code>t</code>“ 而不会匹配到一个较长的字符串的子串(如 gg<code>groot</code>tttt)。而统计功能是我们通过计数器<code>count</code>实现的。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>出处：<a href="https://zhidao.baidu.com/question/443782938.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/443782938.html</a><br><code>Mathcer.start()/ Matcher.end()/ Matcher.group()</code> <strong>这三个方法必须是在有字符匹配到的条件下才能够调用，否则会报错。</strong></p><ul><li><code>start()</code>返回匹配到的子串在字符串中的索引位置</li><li><code>end()</code>返回匹配到的子串的最后一个字符在字符串中的索引位置+1</li><li><code>group()</code>返回匹配到的子字符串。</li></ul><p><code>start()</code>,<code>end()</code>,<code>group()</code>均有一个重载方法它们是<code>start(int i)</code>,<code>end(int i)</code>,<code>group(int i)</code>专用于分组操作,<code>Mathcer</code>类还有一个<code>groupCount()</code>用于返回有多少组。</p><h2 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h2><p>判断方法用来检查字符串并返回一个布尔值，表示是否匹配该正则表达式：</p><table><thead><tr><th>序号</th><th>判断方法</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td><code>public boolean matches()</code></td><td>只有整个字符序列完全匹配成功才返回<code>true</code></td></tr><tr><td>2</td><td><code>public boolean lookingAt()</code></td><td>总是从第一个字符进行匹配,匹配成功了不再继续匹配，匹配失败了,也不继续匹配。</td></tr><tr><td>3</td><td><code>public boolean find()</code></td><td>尝试查找与该模式匹配的输入序列的下一个子序列。</td></tr><tr><td>4</td><td><code>public boolean find(int start）</code></td><td>重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。</td></tr></tbody></table><h3 id="java-matcher-中find-matches-lookingAt三个方法的区别"><a href="#java-matcher-中find-matches-lookingAt三个方法的区别" class="headerlink" title="java matcher 中find,matches,lookingAt三个方法的区别"></a>java matcher 中find,matches,lookingAt三个方法的区别</h3><p>出处：<a href="https://www.cnblogs.com/wangjunxiao/p/7115559.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangjunxiao/p/7115559.html</a></p><p>在Matcher类中有find都是匹配目标的方法，但容易混淆，整理它们的区别如下：</p><ul><li><strong><code>matches()</code>:整个匹配</strong>，matches 要求整个序列，只有整个字符序列完全匹配成功，才返回<code>True</code>，否则返回<code>False</code>。但如果前部分匹配成功，将移动下次匹配的位置。</li><li><strong><code>lookingAt()</code>:部分匹配</strong>，总是从第一个字符进行匹配,匹配成功了不再继续匹配，匹配失败了,也不继续匹配。</li><li><strong><code>find()</code>:部分匹配</strong>，从当前位置开始匹配，找到一个匹配的子串，将移动下次匹配的位置。</li><li><strong><code>reset()</code>:给当前的<code>Matcher</code>对象设置新的位置</strong>，位置是就该方法的参数；如果不给参数，<code>reset</code>会把<code>Matcher</code>设到当前字符串的开始处。</li></ul><p>验证代码如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testFindLookingAtMatcher</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Pattern pattern = Pattern.compile(<span class="string">"\\d&#123;3,5&#125;"</span>);</span><br><span class="line">    String charSequence = <span class="string">"123-34345-234-00"</span>;</span><br><span class="line">    Matcher matcher = pattern.matcher(charSequence);</span><br><span class="line">    System.out.println(<span class="string">"待匹配字符序列:"</span>+charSequence);</span><br><span class="line">    System.out.println(<span class="string">"正则表达式:"</span>+pattern.toString());</span><br><span class="line">    <span class="comment">//虽然匹配失败，但由于charSequence里面的"123"和pattern是匹配的,所以下次的匹配从位置4开始</span></span><br><span class="line">    System.out.println(<span class="string">"matcher.matches()返回:"</span>+matcher.matches());</span><br><span class="line">    <span class="comment">//查找匹配位置</span></span><br><span class="line">    matcher.find();</span><br><span class="line">    System.out.println(<span class="string">"当前位置:"</span>+matcher.start());</span><br><span class="line">    <span class="comment">//使用reset方法重置匹配位置</span></span><br><span class="line">    matcher.reset();</span><br><span class="line">    <span class="comment">//第一次find匹配以及匹配的目标和匹配的起始位置</span></span><br><span class="line">    System.out.println(<span class="string">"matcher.find()返回:"</span>+matcher.find());</span><br><span class="line">    System.out.println(<span class="string">"捕获所有匹配的到子串:"</span>+matcher.group()+<span class="string">",位置:"</span>+matcher.start());</span><br><span class="line">    <span class="comment">//第二次find匹配以及匹配的目标和匹配的起始位置</span></span><br><span class="line">    System.out.println(<span class="string">"matcher.find()返回:"</span>+matcher.find());</span><br><span class="line">    System.out.println(<span class="string">"捕获到子串:"</span>+matcher.group()+<span class="string">",位置:"</span>+matcher.start());</span><br><span class="line">    System.out.println(<span class="string">"#####################################################"</span>);</span><br><span class="line">    <span class="comment">//第一次lookingAt匹配以及匹配的目标和匹配的起始位置</span></span><br><span class="line">    System.out.println(<span class="string">"matcher.lookingAt()返回:"</span>+matcher.lookingAt());</span><br><span class="line">    System.out.println(<span class="string">"捕获所有匹配的子串:"</span>+matcher.group()+<span class="string">",位置:"</span>+matcher.start());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第二次lookingAt匹配以及匹配的目标和匹配的起始位置</span></span><br><span class="line">    System.out.println(<span class="string">"matcher.lookingAt()返回:"</span>+matcher.lookingAt());</span><br><span class="line">    System.out.println(<span class="string">"捕获所有匹配的子串:"</span>+matcher.group()+<span class="string">",位置:"</span>+matcher.start());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">待匹配字符序列:123-34345-234-00</span><br><span class="line">正则表达式:\d&#123;3,5&#125;</span><br><span class="line">matcher.matches()返回:false</span><br><span class="line">当前位置:4</span><br><span class="line">matcher.find()返回:true</span><br><span class="line">捕获所有匹配的到子串:123,位置:0</span><br><span class="line">matcher.find()返回:true</span><br><span class="line">捕获到子串:34345,位置:4</span><br><span class="line">#####################################################</span><br><span class="line">matcher.lookingAt()返回:true</span><br><span class="line">捕获所有匹配的子串:123,位置:0</span><br><span class="line">matcher.lookingAt()返回:true</span><br><span class="line">捕获所有匹配的子串:123,位置:0</span><br></pre></td></tr></table></figure><h2 id="替换方法"><a href="#替换方法" class="headerlink" title="替换方法"></a>替换方法</h2><p>api看的我有点晕头转向，个人总结如下。<br>|序号|方法|描述|<br>|-|-|-|<br>|1|<code>public String replaceAll(String replacement)</code>|用<code>replacement</code>替换正则表达式匹配到的所有子串|<br>|2|<code>public String replaceFirst(String replacement)</code>|用<code>replacement</code>替换正则表达式匹配到的第一个子串|<br>|3|<code>public Matcher appendReplacement(StringBuffer sb, String replacement)</code>|实现非终端添加和替换步骤。|<br>|4|<code>public StringBuffer appendTail(StringBuffer sb)</code>|实现终端添加和替换步骤。|<br>|5|<code>public static String quoteReplacement(String s)</code>|返回指定字符串的字面替换字符串。这个方法返回一个字符串，就像传递给Matcher类的appendReplacement 方法一个字面字符串一样工作。|</p><h3 id="replaceFirst-和-replaceAll-方法"><a href="#replaceFirst-和-replaceAll-方法" class="headerlink" title="replaceFirst 和 replaceAll 方法"></a>replaceFirst 和 replaceAll 方法</h3><p><code>replaceFirst</code> 和 <code>replaceAll</code> 方法用来替换匹配正则表达式的文本。不同的是，<code>replaceFirst</code> 替换首次匹配的子串，<code>replaceAll</code> 替换所有匹配的子串。<br>看下面的例子：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testReplaceAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    String regex = <span class="string">"dog"</span>;</span><br><span class="line">    String input = <span class="string">"The dog says meow. "</span> + <span class="string">"All dogs say meow."</span>;</span><br><span class="line">    String replace = <span class="string">"cat"</span>;</span><br><span class="line">    Pattern p = Pattern.compile(regex);</span><br><span class="line"><span class="comment">//  get  a  matcher  object</span></span><br><span class="line">    Matcher m = p.matcher(input);</span><br><span class="line">    input = m.replaceAll(replace);</span><br><span class="line">    System.out.println(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The cat says meow. All cats say meow.</span><br></pre></td></tr></table></figure><p></p><h3 id="appendReplacement-和-appendTail-方法"><a href="#appendReplacement-和-appendTail-方法" class="headerlink" title="appendReplacement 和 appendTail 方法"></a>appendReplacement 和 appendTail 方法</h3><p>参考：<a href="https://blog.csdn.net/key_xyes/article/details/78705181" target="_blank" rel="noopener">https://blog.csdn.net/key_xyes/article/details/78705181</a></p><ul><li><code>appendReplacement(sb,replacement)</code>方法中：<code>sb</code>是一个<code>StringBuffer</code>，<code>replacement</code>用于替换的字符串，这个方法会把匹配到的子串替换为<code>replacement</code>，并且把从上次替换的位置到这次替换位置之间的字符串也拿到，然后，加上这次替换后的结果一起追加到<code>StringBuffer</code>里（假如这次替换是第一次替换，那就是只追加替换后的字符串啦）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Matcher <span class="title">appendReplacement</span><span class="params">(StringBuffer sb,String replacement)</span></span></span><br></pre></td></tr></table></figure><p><code>appendTail(StringBuffer sb)</code>方法:这个方法是把原来文本中最后一次匹配到的内容之后的字符串追加到<code>StringBuffer</code>中。</p><p>两个方法一起使用就可以达到所有替换或者替换第一个：</p><p>全部替换：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//find()方法向前查找匹配的子串</span></span><br><span class="line"><span class="keyword">while</span>(m.find())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取位置在匹配子串之前的文本strbefore，获取匹配的子串strmacther，然后把匹配的子串strmacther替换为replacement，</span></span><br><span class="line">    <span class="comment">//然后(strbefore+replacement)追加到StringBuffer中</span></span><br><span class="line">    m.appendReplacement(sb,replacement);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把文本中没有匹配的剩下的文本也加入到StringBuffer中</span></span><br><span class="line">m.appendTail(sb);</span><br></pre></td></tr></table></figure><p></p><p>替换第一个：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (matcher.find())</span><br><span class="line">&#123;</span><br><span class="line">    matcher.appendReplacement(sb, replacement);</span><br><span class="line">&#125;</span><br><span class="line">matcher.appendTail(sb);</span><br></pre></td></tr></table></figure><p></p><p><strong>实例1：全部替换</strong><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAppendReplace_Tail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Pattern p = Pattern.compile(<span class="string">"a"</span>);</span><br><span class="line">    String text=<span class="string">"before_ONEa_TWOa_THREEa_End"</span>;</span><br><span class="line">    Matcher m = p.matcher(text);</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">while</span> (m.find())</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//      获取位置在匹配子串之前的文本strbefore，获取匹配的子串strmacther，然后把匹配的子串strmacther替换为replacement，</span></span><br><span class="line"><span class="comment">//      然后之前的文本和替换文本一起(strbefore+replacement)追加到StringBuffer中</span></span><br><span class="line">        System.out.println(<span class="string">"替换之前StringBuffer中的内容--&gt;"</span> + sb);</span><br><span class="line">        m.appendReplacement(sb, <span class="string">"A"</span>);</span><br><span class="line">        System.out.println(<span class="string">"替换之后StringBuffer中的内容--&gt;"</span> + sb);</span><br><span class="line">        System.out.println(<span class="string">"---------------------------------------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//原来文本中把上次匹配结束位置之后剩下的字符串也写到StringBuffer中</span></span><br><span class="line">    System.out.println(<span class="string">"#######################################"</span>);</span><br><span class="line">    System.out.println(<span class="string">"替换之前StringBuffer中的内容--&gt;"</span> + sb);</span><br><span class="line">    m.appendTail(sb);</span><br><span class="line">    System.out.println(<span class="string">"替换之后StringBuffer中的内容--&gt;"</span> + sb);</span><br><span class="line">    System.out.println(<span class="string">"替换之前的文本:"</span>+text);</span><br><span class="line">    System.out.println(<span class="string">"全部替换之后的:"</span> + sb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">替换之前StringBuffer中的内容--&gt;</span><br><span class="line">替换之后StringBuffer中的内容--&gt;before_ONEA</span><br><span class="line">---------------------------------------------</span><br><span class="line">替换之前StringBuffer中的内容--&gt;before_ONEA</span><br><span class="line">替换之后StringBuffer中的内容--&gt;before_ONEA_TWOA</span><br><span class="line">---------------------------------------------</span><br><span class="line">替换之前StringBuffer中的内容--&gt;before_ONEA_TWOA</span><br><span class="line">替换之后StringBuffer中的内容--&gt;before_ONEA_TWOA_THREEA</span><br><span class="line">---------------------------------------------</span><br><span class="line">#######################################</span><br><span class="line">替换之前StringBuffer中的内容--&gt;before_ONEA_TWOA_THREEA</span><br><span class="line">替换之后StringBuffer中的内容--&gt;before_ONEA_TWOA_THREEA_End</span><br><span class="line">替换之前的文本:before_ONEa_TWOa_THREEa_End</span><br><span class="line">全部替换之后的:before_ONEA_TWOA_THREEA_End</span><br></pre></td></tr></table></figure><p></p><p><strong>分析：</strong><br><strong>while语句：</strong></p><ul><li><p>第一次替换:sb中是没有内容的，find()方法匹配到before_ONE<code>a</code>_TWOa_THREEa_End,这个时候，获取匹配文本前面的字符串<code>before_NO</code>，然后把匹配文本<code>a</code>替换成<code>A</code>,前面的字符串<code>before_NO</code>和替换文本<code>A</code>组成<code>before_NOA</code>追加到StringBuffer中。</p></li><li><p>第二次替换:sb中的内容为<code>before_NOA</code>,find()方法匹配到before_ONEa_TWO<code>a</code>_THREEa_End，同样获取前面没有匹配的文本<code>_TWO</code>(做法是获取从find()方法上次结束的位置,到这次find()方法开始位置之间的字符串：before_ONEa<code>_TWO</code>a_THREEa_End),然后把<code>a</code>替换成<code>A</code>,这样组成新的文本呢<code>_TWOA</code>,追加到StringBuffer中，这样就形成<code>before_NOA_TWOA</code></p></li><li><p>find()方法会一直向前匹配子串，然后替换,如此类推，直到所有的替换完成</p></li></ul><p>因为原来文本中还有剩下的没有匹配的内容，before_ONEa_TWOa_THREEa<code>_End</code>，<br>使用m.appendTail(sb);把这剩下的内容<code>_End</code>也追加到StringBuffer中，这样就实现全部替换了。</p><p><strong>实例2：替换第一次</strong><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAppendReplace_TailFrist</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Pattern p = Pattern.compile(<span class="string">"a"</span>);</span><br><span class="line">    String text=<span class="string">"before_ONEa_TWOa_THREEa_End"</span>;</span><br><span class="line">    Matcher m = p.matcher(text);</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">if</span>(m.find())</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//      获取匹配子串之前的文本strbefore，获取匹配的子串strmacther，然后把匹配的子串strmacther替换为replacement，</span></span><br><span class="line"><span class="comment">//      然后(strbefore+replacement)追加到StringBuffer中</span></span><br><span class="line">        System.out.println(<span class="string">"替换之前StringBuffer中的内容--&gt;"</span> + sb);</span><br><span class="line">        m.appendReplacement(sb, <span class="string">"A"</span>);</span><br><span class="line">        System.out.println(<span class="string">"替换之后StringBuffer中的内容--&gt;"</span> + sb);</span><br><span class="line">        System.out.println(<span class="string">"---------------------------------------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//原来文本中把上次匹配结束位置之后剩下的字符串也写到StringBuffer中</span></span><br><span class="line">    System.out.println(<span class="string">"#######################################"</span>);</span><br><span class="line">    System.out.println(<span class="string">"上述替换完成后StringBuffer中的内容------&gt;"</span> + sb);</span><br><span class="line">    m.appendTail(sb);</span><br><span class="line">    System.out.println(<span class="string">"加上文本中剩余子串后StringBuffer中的内容--&gt;"</span> + sb);</span><br><span class="line">    System.out.println(<span class="string">"替换之前的文本:"</span>+text);</span><br><span class="line">    System.out.println(<span class="string">"全部替换之后的:"</span> + sb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">替换之前StringBuffer中的内容--&gt;</span><br><span class="line">替换之后StringBuffer中的内容--&gt;before_ONEA</span><br><span class="line">---------------------------------------------</span><br><span class="line">#######################################</span><br><span class="line">上述替换完成后StringBuffer中的内容------&gt;before_ONEA</span><br><span class="line">加上文本中剩余子串后StringBuffer中的内容--&gt;before_ONEA_TWOa_THREEa_End</span><br><span class="line">替换之前的文本:before_ONEa_TWOa_THREEa_End</span><br><span class="line">全部替换之后的:before_ONEA_TWOa_THREEa_End</span><br></pre></td></tr></table></figure><p></p><p>这里我们只替换了第一次，before_ONE<code>a</code>_TWOa_THREEa_End,然后StringBuffer中处理完毕的文本为<code>before_ONEA</code>，未处理的文本为<code>_TWOa_THREEa_End</code>，最后调用m.appendTail(sb);把未处理的文本也追加入到StringBuffer中，处理完毕的文本为:<code>before_ONEA_TWOa_THREEa_End</code></p><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><ul><li><code>find()</code>方法匹配子串的时候都会<strong>记下</strong>本次成功<strong>匹配子串的<code>开始位置</code>和<code>结束位置</code></strong></li><li><code>appendReplacement(sb</code>,<code>replacement)</code>方法先获取所有<code>从上次结束位置，到本次结束位置的所有字符串</code>，然后<code>替换其中匹配的部分</code>，最后追加到<code>sb</code>中。</li><li><code>appendReplacement(sb)</code>方法把结束位置到文本结尾的所有字符追加到<code>sb</code>中。</li><li>使用appendReplace()和appendTail()方法可以更加灵活的进行替换操作，注意要结合find()方法使用。</li></ul><p>本文链接: <a href="https://www.lansheng.net.cn/blog/4ea1809c/">Java正则表达式</a></p></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div></div><button id="rewardButton" disable="enable" onclick='var e=document.getElementById("QR");"none"===e.style.display?e.style.display="block":e.style.display="none"'><span>打赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"><img id="wechat_qr" src="/images/wechatpay.png" alt="蓝生 微信支付"><p>微信支付</p></div><div id="alipay" style="display:inline-block"><img id="alipay_qr" src="/images/alipay.png" alt="蓝生 支付宝"><p>支付宝</p></div></div></div></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/blog/aa025735/" rel="next" title="Java正则表达式应用"><i class="fa fa-chevron-left"></i> Java正则表达式应用</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/blog/12fb64fe/" rel="prev" title="String类中的正则表达式">String类中的正则表达式 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="蓝生"><p class="site-author-name" itemprop="name">蓝生</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">235</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">79</span> <span class="site-state-item-name">分类</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://blog.csdn.net/qq_21808961" target="_blank" title="CSDN"><i class="fa fa-fw fa-arrow-right"></i>CSDN</a> </span><span class="links-of-author-item"><a href="https://www.shixiseng.com/" target="_blank" title="实习僧"><i class="fa fa-fw fa-arrow-right"></i>实习僧</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://ziyuan.baidu.com/xzh/home/index" title="百度熊掌号" target="_blank">百度熊掌号</a></li><li class="links-of-blogroll-item"><a href="https://ziyuan.baidu.com/linksubmit/index" title="百度链接提交" target="_blank">百度链接提交</a></li><li class="links-of-blogroll-item"><a href="https://reuixiy.github.io/" title="超好看的Hexo+NexT博客" target="_blank">超好看的Hexo+NexT博客</a></li><li class="links-of-blogroll-item"><a href="https://www.face2ai.com/" title="谭升" target="_blank">谭升</a></li></ul></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一些正则表达式的实例及描述"><span class="nav-number">1.</span> <span class="nav-text">一些正则表达式的实例及描述</span></a></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#正则表达式语法"><span class="nav-number"></span> <span class="nav-text">正则表达式语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#匹配位置"><span class="nav-number">1.</span> <span class="nav-text">匹配位置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#匹配单个字符"><span class="nav-number">2.</span> <span class="nav-text">匹配单个字符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#量词"><span class="nav-number">3.</span> <span class="nav-text">量词</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#懒惰匹配"><span class="nav-number">4.</span> <span class="nav-text">懒惰匹配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#反向引用"><span class="nav-number">5.</span> <span class="nav-text">反向引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#转义字符"><span class="nav-number">6.</span> <span class="nav-text">转义字符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字符组简写形式"><span class="nav-number">6.1.</span> <span class="nav-text">字符组简写形式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不可见字符"><span class="nav-number">6.2.</span> <span class="nav-text">不可见字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进制相关"><span class="nav-number">6.3.</span> <span class="nav-text">进制相关</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#java-使用正则表达式步骤"><span class="nav-number"></span> <span class="nav-text">java 使用正则表达式步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#java的regex库常用类"><span class="nav-number">1.</span> <span class="nav-text">java的regex库常用类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#常用类：Pattern和Matcher"><span class="nav-number">1.1.</span> <span class="nav-text">常用类：Pattern和Matcher</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pattern-类和Matcher-类的关系"><span class="nav-number">1.2.</span> <span class="nav-text">Pattern 类和Matcher 类的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PatternSyntaxException-类"><span class="nav-number">1.3.</span> <span class="nav-text">PatternSyntaxException 类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通常使用步骤"><span class="nav-number">2.</span> <span class="nav-text">通常使用步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建Pattern对象"><span class="nav-number">2.1.</span> <span class="nav-text">创建Pattern对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建Matcher对象"><span class="nav-number">2.2.</span> <span class="nav-text">创建Matcher对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简便用法"><span class="nav-number">2.3.</span> <span class="nav-text">简便用法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Matcher-类的主要方法介绍"><span class="nav-number"></span> <span class="nav-text">Matcher 类的主要方法介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#常用方法"><span class="nav-number">1.</span> <span class="nav-text">常用方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#捕获组"><span class="nav-number">2.</span> <span class="nav-text">捕获组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#捕获组实例"><span class="nav-number">2.1.</span> <span class="nav-text">捕获组实例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#查看正则表达式中有多到个捕获组"><span class="nav-number">2.1.1.</span> <span class="nav-text">查看正则表达式中有多到个捕获组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#捕获方法group-和group-int-group-实例"><span class="nav-number">2.1.2.</span> <span class="nav-text">捕获方法group()和group(int group)实例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#索引方法"><span class="nav-number">3.</span> <span class="nav-text">索引方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#start-和-end-方法"><span class="nav-number">3.1.</span> <span class="nav-text">start 和 end 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例：统计一个单词出现的次数"><span class="nav-number">3.2.</span> <span class="nav-text">实例：统计一个单词出现的次数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#小结"><span class="nav-number">3.2.1.</span> <span class="nav-text">小结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#判断方法"><span class="nav-number">4.</span> <span class="nav-text">判断方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#java-matcher-中find-matches-lookingAt三个方法的区别"><span class="nav-number">4.1.</span> <span class="nav-text">java matcher 中find,matches,lookingAt三个方法的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#替换方法"><span class="nav-number">5.</span> <span class="nav-text">替换方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#replaceFirst-和-replaceAll-方法"><span class="nav-number">5.1.</span> <span class="nav-text">replaceFirst 和 replaceAll 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#appendReplacement-和-appendTail-方法"><span class="nav-number">5.2.</span> <span class="nav-text">appendReplacement 和 appendTail 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结："><span class="nav-number">5.3.</span> <span class="nav-text">小结：</span></a></li></ol></li></ol></li></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">蓝生</span></div><div class="theme-info"><div class="powered-by"></div><span class="post-count">博客全站共336.3k字</span></div><div class="busuanzi-count"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv" title="总访客量"><i class="fa fa-user"></i> <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> </span><span class="site-pv" title="总访问量"><i class="fa fa-eye"></i> <span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/js/src/utils.js?v=6.4.0"></script><script type="text/javascript" src="/js/src/motion.js?v=6.4.0"></script><script type="text/javascript" src="/js/src/affix.js?v=6.4.0"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.0"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=6.4.0"></script><script type="text/javascript" src="/js/src/post-details.js?v=6.4.0"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.0"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script type="text/javascript">var GUEST=["nick","mail","link"],guest="nick,mail,link";guest=guest.split(",").filter(function(e){return GUEST.indexOf(e)>-1}),new Valine({el:"#comments",verify:!0,notify:!0,appId:"8uEACQMqUrxjo1Hqof21pkCV-gzGzoHsz",appKey:"DgRm99ypfVS7Mm9YLchO1RGG",placeholder:"在上方填入昵称，邮箱，个人博客地址即可评论",avatar:"mm",meta:guest,pageSize:"10",visitor:!1})</script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(t,e,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,r=document.getElementById(e),s=document.getElementById(o),a=function(){var t=r.value.trim().toLowerCase(),e=t.split(/[\s\-]+/);e.length>1&&e.push(t);var o=[];if(t.length>0&&n.forEach(function(n){function r(e,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===t&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(t,e){var o="",n=e.start;return e.hits.forEach(function(e){o+=t.substring(n,e.position);var r=e.position+e.length;o+='<b class="search-keyword">'+t.substring(e.position,r)+"</b>",n=r}),o+=t.substring(n,e.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url),d=[],g=[];if(""!=l&&(e.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());(s=e.indexOf(t,r))>-1;)a.push({position:s,word:t}),r=s+n;return a}d=d.concat(e(t,h,!1)),g=g.concat(e(t,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(t){b+="<a href='"+f+'\'><p class="search-result">'+s(p,t)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===e.length&&""===e[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>';else{o.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id});var a='<ul class="search-result-list">';o.forEach(function(t){a+=t.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){var e=27===t.which&&$(".search-popup").is(":visible");e&&onPopupClose()})</script><script>!function(){var t=document.createElement("script"),s=window.location.protocol.split(":")[0];"https"===s?t.src="https://zz.bdstatic.com/linksubmit/push.js":t.src="http://push.zhanzhang.baidu.com/push.js";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script></body></html><script type="text/javascript" src="/js/src/love.js"></script><!-- rebuild by neat -->