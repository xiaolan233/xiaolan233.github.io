<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Linux 常用指令</title>
      <link href="/blog/e44da/"/>
      <url>/blog/e44da/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:16 GMT+0800 (中国标准时间) --><p><strong>目录</strong></p><ul><li><a href="null#文件目录相关命令">文件目录相关命令</a><ul><li><a href="null#创建一个空白文件命令touch">创建一个空白文件命令touch</a></li><li><a href="null#文件复制命令cp">文件复制命令cp</a></li><li><a href="null#文件移动命令mv">文件移动命令mv</a><ul><li><a href="null#实例-移动文件到其他目录">实例 移动文件到其他目录</a></li><li><a href="null#使用移动命令重命名文件">使用移动命令重命名文件</a></li></ul></li><li><a href="null#文件删除命令rm">文件删除命令rm</a></li><li><a href="null#参考链接">参考链接</a></li></ul></li></ul><a id="more"></a><p>我这里是在git-bash中运行的，因为懒得打开虚拟机了，在Linux终端上运行效果也一样。</p><h1 id="文件目录相关命令"><a href="#文件目录相关命令" class="headerlink" title="文件目录相关命令"></a>文件目录相关命令</h1><h2 id="创建一个空白文件命令touch"><a href="#创建一个空白文件命令touch" class="headerlink" title="创建一个空白文件命令touch"></a>创建一个空白文件命令touch</h2><p>命令格式<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch 新文件名</span><br></pre></td></tr></table></figure><p></p><p>例如，在当前目录下创建一个test.txt的空白文件：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lan@DESKTOP-8ISAT6B MINGW64 /e/Blog/bolg5/source/_posts/Linux</span><br><span class="line">$ ls -l</span><br><span class="line">total 8</span><br><span class="line">-rw-r--r-- 1 lan 197609 3622 11月 11 17:06 &apos;Linux 常用指令.md&apos;</span><br><span class="line">-rw-r--r-- 1 lan 197609 1537 11月  5 17:17  linux下删除目录及其子目录下某种类型文件.md</span><br><span class="line">lan@DESKTOP-8ISAT6B MINGW64 /e/Blog/bolg5/source/_posts/Linux</span><br><span class="line">$ touch text.txt</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lan@DESKTOP-8ISAT6B MINGW64 /e/Blog/bolg5/source/_posts/Linux</span><br><span class="line">$ ls -l</span><br><span class="line">total 8</span><br><span class="line">-rw-r--r-- 1 lan 197609 3622 11月 11 17:06 &apos;Linux 常用指令.md&apos;</span><br><span class="line">-rw-r--r-- 1 lan 197609 1537 11月  5 17:17  linux下删除目录及其子目录下某种类型文件.md</span><br><span class="line">-rw-r--r-- 1 lan 197609    0 11月 11 17:06  text.txt</span><br></pre></td></tr></table></figure><p></p><h2 id="文件复制命令cp"><a href="#文件复制命令cp" class="headerlink" title="文件复制命令cp"></a>文件复制命令cp</h2><p><strong>命令格式</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp [option] source1 source2 source3 ... directory</span><br></pre></td></tr></table></figure><p></p><p><strong>参数说明</strong></p><ul><li><code>-a</code>:是指archive的意思，也说是指复制所有的目录</li><li><code>-d</code>:若源文件为连接文件(link file)，则复制连接文件属性而非文件本身</li><li><code>-f</code>:强制(force)，若有重复或其它疑问时，不会询问用户，而强制复制</li><li><code>-i</code>:若目标文件(destination)已存在，在覆盖时会先询问是否真的操作</li><li><code>-l</code>:建立硬连接(hard link)的连接文件，而非复制文件本身</li><li><code>-p</code>:与文件的属性一起复制，而非使用默认属性</li><li><code>-r</code>:递归复制，用于目录的复制操作</li><li><code>-s</code>:复制成符号连接文件(symbolic link)，即“快捷方式”文件</li><li><code>-u</code>:若目标文件比源文件旧，更新目标文件</li></ul><p>例如将当前博客站点目录bolg5复制一份到到同级目录blog5copy:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lan@DESKTOP-8ISAT6B MINGW64 /e/Blog/bolg5</span><br><span class="line">$ cd ..</span><br><span class="line">lan@DESKTOP-8ISAT6B MINGW64 /e/Blog</span><br><span class="line">$ cp -r bolg5 blog5copy</span><br></pre></td></tr></table></figure><p></p><p>运行结束后，就复制了一份站点目录文件到同级目录(Blog)下的blog5copy目录了。这个blog5copy相当于一个博客站点目录的备份。</p><h2 id="文件移动命令mv"><a href="#文件移动命令mv" class="headerlink" title="文件移动命令mv"></a>文件移动命令mv</h2><p><strong>命令格式</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv [-fiv] source destination</span><br></pre></td></tr></table></figure><p></p><p><strong>参数说明</strong></p><ul><li><code>-f</code>:force，强制直接移动而不询问</li><li><code>-i</code>:若目标文件(destination)已经存在，就会询问是否覆盖</li><li><code>-u</code>:若目标文件已经存在，且源文件比较新，才会更新<h3 id="实例-移动文件到其他目录"><a href="#实例-移动文件到其他目录" class="headerlink" title="实例 移动文件到其他目录"></a>实例 移动文件到其他目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lan@DESKTOP-8ISAT6B MINGW64 /e/Blog/bolg5dug/source/_posts/Linux</span><br><span class="line">$ mv &apos;Linux 常用指令.md&apos; ../../../../*5/source/_posts/Linux</span><br></pre></td></tr></table></figure></li></ul><p>这个命令会把<code>/e/Blog/bolg5dug/source/_posts/Linux</code>目录下的<code>&#39;Linux 常用指令.md&#39;</code>文件移动到，<code>/e/Blog/bolg5/source/_posts/Linux</code>目录下。</p><h3 id="使用移动命令重命名文件"><a href="#使用移动命令重命名文件" class="headerlink" title="使用移动命令重命名文件"></a>使用移动命令重命名文件</h3><p>在当前目录下使用移动命令可以达到给文件重命名的效果：<br>为了不误删我之前写的文章，先来创建一个测试文件：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lan@DESKTOP-8ISAT6B MINGW64 /e/Blog/bolg5/source/_posts/Linux</span><br><span class="line">$ touch test.txt</span><br><span class="line">lan@DESKTOP-8ISAT6B MINGW64 /e/Blog/bolg5/source/_posts/Linux</span><br><span class="line">$ ls -l</span><br><span class="line">total 8</span><br><span class="line">-rw-r--r-- 1 lan 197609 2447 11月 11 16:58 &apos;Linux 常用指令.md&apos;</span><br><span class="line">-rw-r--r-- 1 lan 197609 1537 11月  5 17:17  linux下删除目录及其子目录下某种类型文件.md</span><br><span class="line">-rw-r--r-- 1 lan 197609    0 11月 11 16:59  test.txt</span><br></pre></td></tr></table></figure><p></p><p>使用mv命令重命名：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mv test.txt rename.txt</span><br><span class="line">lan@DESKTOP-8ISAT6B MINGW64 /e/Blog/bolg5/source/_posts/Linux</span><br></pre></td></tr></table></figure><p></p><p>重命名结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">total 8</span><br><span class="line">-rw-r--r-- 1 lan 197609 2447 11月 11 16:58 &apos;Linux 常用指令.md&apos;</span><br><span class="line">-rw-r--r-- 1 lan 197609 1537 11月  5 17:17  linux下删除目录及其子目录下某种类型文件.md</span><br><span class="line">-rw-r--r-- 1 lan 197609    0 11月 11 16:59  rename.txt</span><br><span class="line">lan@DESKTOP-8ISAT6B MINGW64 /e/Blog/bolg5/source/_posts/Linux</span><br></pre></td></tr></table></figure><p></p><h2 id="文件删除命令rm"><a href="#文件删除命令rm" class="headerlink" title="文件删除命令rm"></a>文件删除命令rm</h2><p><strong>命令格式</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm [fir] 文件或目录</span><br></pre></td></tr></table></figure><p></p><p><strong>参数说明</strong></p><ul><li><code>-f</code>:强制删除</li><li><code>-i</code>:交互模式，在删除前询问用户是否操作</li><li><code>-r</code>:递归删除，常用在目录的删除</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/liaojie970/p/6746230.html" target="_blank" rel="noopener">https://www.cnblogs.com/liaojie970/p/6746230.html</a></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/e44da/">Linux 常用指令</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hexo next主题 valine评论系统 使用第三方邮件提醒</title>
      <link href="/blog/f1fdd2cf/"/>
      <url>/blog/f1fdd2cf/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><ul><li><a href="https://www.lansheng.net.cn/blog/f1fdd2cf/#valine自带的邮件提醒设置">valine自带的邮件提醒设置</a></li><li><a href="https://www.lansheng.net.cn/blog/f1fdd2cf/#使用第三方邮件提醒">使用第三方邮件提醒</a><ul><li><a href="https://www.lansheng.net.cn/blog/f1fdd2cf/#关闭valine自带的邮件提醒">关闭valine自带的邮件提醒</a></li><li><a href="https://www.lansheng.net.cn/blog/f1fdd2cf/#怎么获取SMTP授权码">怎么获取SMTP授权码</a></li><li><a href="https://www.lansheng.net.cn/blog/f1fdd2cf/#重新部署使环境变量生效">重新部署使环境变量生效</a></li><li><a href="https://www.lansheng.net.cn/blog/f1fdd2cf/#提示邮件中文章链接错误加载不到评论">提示邮件中文章链接错误加载不到评论</a></li></ul></li></ul><a id="more"></a><h2 id="valine自带的邮件提醒设置"><a href="#valine自带的邮件提醒设置" class="headerlink" title="valine自带的邮件提醒设置"></a>valine自带的邮件提醒设置</h2><p>参见：<a href="https://valine.js.org/notify.html" target="_blank" rel="noopener">Valine 评论系统中的邮件提醒设置</a></p><h2 id="使用第三方邮件提醒"><a href="#使用第三方邮件提醒" class="headerlink" title="使用第三方邮件提醒"></a>使用第三方邮件提醒</h2><p>参见：<a href="https://github.com/zhaojun1998/Valine-Admin" target="_blank" rel="noopener">https://github.com/zhaojun1998/Valine-Admin</a></p><h3 id="关闭valine自带的邮件提醒"><a href="#关闭valine自带的邮件提醒" class="headerlink" title="关闭valine自带的邮件提醒"></a>关闭valine自带的邮件提醒</h3><p>使用第三方评论插件的话，就不要使用valine自带的邮件提醒插件，在主题配置文件<code>E:\Blog\bolg5\themes\next\_config.yml</code>中把notify设置为false。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">valine:</span><br><span class="line">  ......</span><br><span class="line">  notify: false # mail notifier , https://github.com/xCss/Valine/wiki #是否开启邮箱提醒</span><br><span class="line">  .......</span><br></pre></td></tr></table></figure><p></p><h3 id="怎么获取SMTP授权码"><a href="#怎么获取SMTP授权码" class="headerlink" title="怎么获取SMTP授权码"></a>怎么获取SMTP授权码</h3><p>上面的文档没有介绍怎么获取SMTP授权码，我这里来说明一下，我使用的是163的邮箱：<br>参见：<a href="http://blog.51cto.com/13284080/2065376" target="_blank" rel="noopener">163邮箱设置smtp密码步骤</a></p><h3 id="重新部署使环境变量生效"><a href="#重新部署使环境变量生效" class="headerlink" title="重新部署使环境变量生效"></a>重新部署使环境变量生效</h3><p>设置好上述的环境变量后，需要重新部署一下让环境变量生效。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexoSettings/NextSettings/Valine/chongxinbushuranghuangjiangbiangliangshengxiao.png" alt=""></p><h3 id="提示邮件中文章链接错误加载不到评论"><a href="#提示邮件中文章链接错误加载不到评论" class="headerlink" title="提示邮件中文章链接错误加载不到评论"></a>提示邮件中文章链接错误加载不到评论</h3><p>可以正常收到邮件提醒后,点击<code>前往参看</code>链接：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexoSettings/NextSettings/Valine/youxiang/wenzhangdizhicuowu.png" alt=""><br>打开的链接为：<code>https://www.lansheng.net.cn//blog/4f1b06ea/#comments</code><br>这样地址是不对的，也就加载不到评论信息，这是因为上面设置的环境变量错了：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexoSettings/NextSettings/Valine/youxiang/errorSITE_URL.png" alt=""><br>这样也就加载不到评论了：</p><p>解决方案：把错误的SITE_URL<code>https://www.lansheng.net.cn/</code>最后的斜杆删除掉，改成<code>https://www.lansheng.net.cn</code>,然后点击保存，然后点击<code>部署标签</code>，点击<code>部署按钮</code>，重新部署，让设置生效即可。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexoSettings/NextSettings/Valine/chongxinbushuranghuangjiangbiangliangshengxiao.png" alt=""></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/f1fdd2cf/">hexo next主题 valine评论系统 使用第三方邮件提醒</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> 给博客添加功能 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hexo next主题 如何自定义CSS样式</title>
      <link href="/blog/cd4775fc/"/>
      <url>/blog/cd4775fc/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:16 GMT+0800 (中国标准时间) --><p>本文介绍修改next主题默认样式的详细步骤！<br><strong>目录</strong></p><ul><li><a href="https://www.lansheng.net.cn/blog/cd4775fc/#用到的工具">用到的工具</a></li><li><a href="https://www.lansheng.net.cn/blog/cd4775fc/#1-获取标签的css选择器">1 获取标签的css选择器</a></li><li><a href="https://www.lansheng.net.cn/blog/cd4775fc/#2-编写css">2 编写css</a></li><li><a href="https://www.lansheng.net.cn/blog/cd4775fc/#3-使用新的css样式">3 使用新的css样式</a></li><li><a href="https://www.lansheng.net.cn/blog/cd4775fc/#4-刷新浏览器看效果">4 刷新浏览器看效果</a></li><li><a href="https://www.lansheng.net.cn/blog/cd4775fc/#5-部署">5 部署</a></li></ul><a id="more"></a><h2 id="用到的工具"><a href="#用到的工具" class="headerlink" title="用到的工具"></a>用到的工具</h2><ul><li>火狐浏览器—参看效果，获取css选择器</li><li>vscode编辑器—自动补全，便于编写css<h2 id="1-获取标签的css选择器"><a href="#1-获取标签的css选择器" class="headerlink" title="1 获取标签的css选择器"></a>1 获取标签的css选择器</h2>站点目录下，输入<code>hexo s</code>命令启动本地服务器，然后在<code>火狐浏览器</code>打开你的博文，选中你要调整的内容，如无须列表，点击鼠标右键，选中查看元素：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexoSettings/NextSettings/myCSS/cankanwuxuliebiao.png" alt=""><br>在火狐浏览器的查看器中，选中你想要调整的html标签,我这里是&lt;ul&gt;标签，然后点击右键，选中复制，然后选择复制css选择器：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexoSettings/NextSettings/myCSS/copycssselecter.png" alt=""><br>这样就得到了该html标签(ul)的css选择器如下：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span><span class="selector-class">.post</span><span class="selector-pseudo">:nth-child(1)</span> &gt; <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(1)</span> &gt; <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(5)</span> &gt; <span class="selector-tag">ul</span><span class="selector-pseudo">:nth-child(2)</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="2-编写css"><a href="#2-编写css" class="headerlink" title="2 编写css"></a>2 编写css</h2><p>打开vscode,创建一个html文件，写下如下的html基本骨架：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>然后在style标签之间编写css样式代码，这样vscode会自动补全，这对我这种小白来说很好，毕竟全部记住那么多css属性和值比较难。把上面的选择器粘贴到vscode中,：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">article</span><span class="selector-class">.post</span><span class="selector-pseudo">:nth-child(1)</span> &gt; <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(1)</span> &gt; <span class="selector-tag">div</span><span class="selector-pseudo">:nth-child(5)</span> &gt; <span class="selector-tag">ul</span><span class="selector-pseudo">:nth-child(2)</span></span></span><br><span class="line"><span class="undefined">        &#123;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>因为我需要选中所有的无序列表，所以这里需要稍微修改一下css选择器，如下：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">article</span><span class="selector-class">.post</span> <span class="selector-tag">div</span> <span class="selector-tag">div</span> <span class="selector-tag">ul</span> &#123;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>next主题默认的无须列表的内左边距太大了，如果无须列表下有太多的子孙无须列表，在手机端显示的时候，会很难看，所以我这里修改无须列表的内左边距为20px：<br></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span><span class="selector-class">.post</span> <span class="selector-tag">div</span> <span class="selector-tag">div</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="3-使用新的css样式"><a href="#3-使用新的css样式" class="headerlink" title="3 使用新的css样式"></a>3 使用新的css样式</h2><p>修改后css样式后，接下来就是应用到next主题中，打开<code>站点目录\themes\next\source\css\_custom\custom.styl</code>，我这里是<code>E:\Blog\bolg5\themes\next\source\css\_custom\custom.styl</code>，把上面的css代码，粘贴到文本末尾即可：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexoSettings/NextSettings/myCSS/paseIncustomstyl.png" alt=""></p><h2 id="4-刷新浏览器看效果"><a href="#4-刷新浏览器看效果" class="headerlink" title="4 刷新浏览器看效果"></a>4 刷新浏览器看效果</h2><p>然后刷新浏览器即可看到效果,打开<code>开发者工具</code>，然后点<code>查看器</code>，点击刚才的ul标签，在右侧的<code>布局窗口</code>，可看到<code>盒模型</code>，可以看到左内边距已经变成20px了。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexoSettings/NextSettings/myCSS/layoutInfirefoxdevTool.png" alt=""></p><h2 id="5-部署"><a href="#5-部署" class="headerlink" title="5 部署"></a>5 部署</h2><p>在本地调试无误后，就可以部署了。<br>本文链接: <a href="https://www.lansheng.net.cn/blog/0/">hexo next主题 如何自定义CSS样式</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> Next主题配置 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hexo博客中 使用javascript和jqurey播放audio</title>
      <link href="/blog/4f1b06ea/"/>
      <url>/blog/4f1b06ea/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:16 GMT+0800 (中国标准时间) --><p><strong>目录</strong></p><ul><li><a href="https://www.lansheng.net.cn/blog/4f1b06ea/#方式0-使用原生的audio播放音频">方式0 使用原生的audio播放音频</a></li><li><a href="https://www.lansheng.net.cn/blog/4f1b06ea/#方式1-使用javascript播放音频">方式1 使用javascript播放音频</a></li><li><a href="https://www.lansheng.net.cn/blog/4f1b06ea/#方式2-使用javascript播放音频-简写">方式2 使用javascript播放音频 简写</a></li><li><a href="https://www.lansheng.net.cn/blog/4f1b06ea/#方式2-使用jquery播放音频">方式2 使用jquery播放音频</a></li><li><a href="https://www.lansheng.net.cn/blog/4f1b06ea/#总结">总结</a></li></ul><a id="more"></a><p>markdown中可以插入html标签，所以可以插入audio标签来播放音频。</p><h2 id="方式0-使用原生的audio播放音频"><a href="#方式0-使用原生的audio播放音频" class="headerlink" title="方式0 使用原生的audio播放音频"></a>方式0 使用原生的audio播放音频</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">"http://fanyi.baidu.com/gettts?lan=en&amp;text=focus&amp;spd=5&amp;source=web"</span> <span class="attr">controls</span>=<span class="string">"controls"</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><p>显示效果：</p><audio src="http://fanyi.baidu.com/gettts?lan=en&text=focus&spd=5&source=web" controls></audio><p>但是原生的audio标签控件太大了，占用文章太多空间,在电脑端，看起来还勉强凑合，但是在手机端的原生的audio控件会超出屏幕之外很不美观。所以我想着不用原生的audio,而是使用其他方式来打开音频。</p><h2 id="方式1-使用javascript播放音频"><a href="#方式1-使用javascript播放音频" class="headerlink" title="方式1 使用javascript播放音频"></a>方式1 使用javascript播放音频</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">"http://fanyi.baidu.com/gettts?lan=en&amp;text=document&amp;spd=3&amp;source=web"</span> <span class="attr">id</span>=<span class="string">"audio0"</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"paly_audio0();"</span> <span class="attr">value</span>=<span class="string">"使用JS播放"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    function paly_audio0() &#123;</span></span><br><span class="line"><span class="undefined">        //找到音频</span></span><br><span class="line"><span class="undefined">        var audio0 = document.getElementById("audio0");</span></span><br><span class="line"><span class="undefined">        if (audio0 != null) &#123;</span></span><br><span class="line"><span class="undefined">            audio0.play();</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>显示效果：</p><p><audio src="http://fanyi.baidu.com/gettts?lan=en&text=document&spd=3&source=web" id="audio0"></audio></p><p><input type="button" onclick="paly_audio0()" value="使用JS播放"></p><script>function paly_audio0(){var a=document.getElementById("audio0");null!=a&&a.play()}</script><h2 id="方式2-使用javascript播放音频-简写"><a href="#方式2-使用javascript播放音频-简写" class="headerlink" title="方式2 使用javascript播放音频 简写"></a>方式2 使用javascript播放音频 简写</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">"http://fanyi.baidu.com/gettts?lan=en&amp;text=hello world&amp;spd=3&amp;source=web"</span>  <span class="attr">id</span>=<span class="string">"audio1"</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"document.getElementById('audio1').play();"</span> <span class="attr">value</span>=<span class="string">"播放"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这种方式，直接写在html中是可以播放的，但是写到在这里hexo 无法渲染。我用的是next主题，也不知道是hexo的原因，还是next主题的原因 。总之不要在文章中使用这种简写的方式就行了。</p><h2 id="方式2-使用jquery播放音频"><a href="#方式2-使用jquery播放音频" class="headerlink" title="方式2 使用jquery播放音频"></a>方式2 使用jquery播放音频</h2><p>跟使用javascript方式，也可以使用jquery来播放：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">"http://fanyi.baidu.com/gettts?lan=en&amp;text=document&amp;spd=3&amp;source=web"</span> <span class="attr">id</span>=<span class="string">"documentAudio"</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"documentPlay"</span> <span class="attr">value</span>=<span class="string">"播放document"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://code.jquery.com/jquery-2.1.1.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    $('#documentPlay').click(function () &#123;</span></span><br><span class="line"><span class="undefined">        //找到音频</span></span><br><span class="line"><span class="undefined">        var documentAudio = document.getElementById('documentAudio');</span></span><br><span class="line"><span class="undefined">        if (documentAudio != null) &#123;</span></span><br><span class="line"><span class="undefined">            documentAudio.play();</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>效果如下：</p><p><audio src="http://fanyi.baidu.com/gettts?lan=en&text=document&spd=3&source=web" id="documentAudio"></audio></p><p><input type="button" id="documentPlay" value="播放document"><br></p><script>$("#documentPlay").click(function(){var n=document.getElementById("documentAudio");null!=n&&n.play()})</script><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>还是直接使用javascript来播放音频的好，这样还少几行代码，也不用引入jqurey库。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/0/">hexo next主题 使用jquery播放audio</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
          <category> 音视频 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hexo next主题博客中 文章中使用javascript和jquery</title>
      <link href="/blog/7a1ad816/"/>
      <url>/blog/7a1ad816/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:16 GMT+0800 (中国标准时间) --><p><strong>目录</strong></p><ul><li><a href="https://www.lansheng.net.cn/blog/7a1ad816/#描述">描述</a><ul><li><a href="https://www.lansheng.net.cn/blog/7a1ad816/#演示效果">演示效果</a></li></ul></li><li><a href="https://www.lansheng.net.cn/blog/7a1ad816/#实现">实现</a></li><li><a href="https://www.lansheng.net.cn/blog/7a1ad816/#使用javascript播放音频">使用javascript播放音频</a></li><li><a href="https://www.lansheng.net.cn/blog/7a1ad816/#使用Jquery在代码块中显示当前时间">使用Jquery在代码块中显示当前时间</a></li><li><a href="https://www.lansheng.net.cn/blog/7a1ad816/#使用jqurey播放audio">使用jqurey播放audio</a></li></ul><a id="more"></a><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>之前知道可以在markdown文档中插入html标签,今天我发现其实也可以插入javascript脚本的。</p><h3 id="演示效果"><a href="#演示效果" class="headerlink" title="演示效果"></a>演示效果</h3><p>注意查看下面的代码框，记下当前的分钟，然后刷新当前页面后再查看。</p><p><pre><code><span id="span1"></span></code></pre></p><script type="text/javascript">var d=new Date,span1=document.getElementById("span1");span1.innerText="当前分钟数->"+d.getMinutes()</script><p>不出意料的话，上面代码框中的分钟数，与现在的分钟数是一致的。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><!--more--><p>这个实现起来也很简单。把下面的JavaScript代码添加到markdown中即可：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"span1"</span>&gt;</span><span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    var d = new Date();</span></span><br><span class="line"><span class="undefined">    var span1 = document.getElementById("span1");</span></span><br><span class="line"><span class="undefined">    span1.innerText = "当前分钟数-&gt;"+d.getMinutes();</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>需要注意的是需要用空行把上述代码和正文中的其他文字分割开，不然hexo渲染成html文件的时候会出错。</p><h2 id="使用javascript播放音频"><a href="#使用javascript播放音频" class="headerlink" title="使用javascript播放音频"></a>使用javascript播放音频</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">"http://fanyi.baidu.com/gettts?lan=en&amp;text=document&amp;spd=3&amp;source=web"</span> <span class="attr">id</span>=<span class="string">"audio0"</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"paly_audio0();"</span> <span class="attr">value</span>=<span class="string">"使用JS播放"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    function paly_audio0() &#123;</span></span><br><span class="line"><span class="undefined">        //找到音频</span></span><br><span class="line"><span class="undefined">        var audio0 = document.getElementById("audio0");</span></span><br><span class="line"><span class="undefined">        if (audio0 != null) &#123;</span></span><br><span class="line"><span class="undefined">            audio0.play();</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>显示效果：</p><p><audio src="http://fanyi.baidu.com/gettts?lan=en&text=document&spd=3&source=web" id="audio0"></audio></p><p><input type="button" onclick="paly_audio0()" value="使用JS播放"></p><script>function paly_audio0(){var a=document.getElementById("audio0");null!=a&&a.play()}</script><h2 id="使用Jquery在代码块中显示当前时间"><a href="#使用Jquery在代码块中显示当前时间" class="headerlink" title="使用Jquery在代码块中显示当前时间"></a>使用Jquery在代码块中显示当前时间</h2><p>测试代码：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://code.jquery.com/jquery-2.1.1.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span> <span class="attr">calss</span>=<span class="string">"run"</span>&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"jqueryTestId"</span>&gt;</span>点击查看运行结果<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    $('#jqueryTestId').click(function () &#123;</span></span><br><span class="line"><span class="undefined">        var jqueryTestId = document.getElementById('jqueryTestId');</span></span><br><span class="line"><span class="undefined">        var date = new Date();</span></span><br><span class="line"><span class="undefined">        jqueryTestId.innerHTML = "当前时间：" + date.getHours() + ":" + date.getMinutes() + ":" + date.getSeconds();</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>效果：</p><script src="http://code.jquery.com/jquery-2.1.1.min.js"></script><pre calss="run"><code><span id="jqueryTestId">点击查看运行结果</span></code></pre><script>$("#jqueryTestId").click(function(){var e=document.getElementById("jqueryTestId"),t=new Date;e.innerHTML="当前时间："+t.getHours()+":"+t.getMinutes()+":"+t.getSeconds()})</script><p>点击上面可以运行，这说明hexo next主题的文章中是可以使用jqurey的,可以通过这样来实现点击事件。</p><h2 id="使用jqurey播放audio"><a href="#使用jqurey播放audio" class="headerlink" title="使用jqurey播放audio"></a>使用jqurey播放audio</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">原生audio控件：<span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">"http://fanyi.baidu.com/gettts?lan=en&amp;text=document&amp;spd=3&amp;source=web"</span> <span class="attr">id</span>=<span class="string">"documentAudio"</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">"http://fanyi.baidu.com/gettts?lan=en&amp;text=document&amp;spd=3&amp;source=web"</span> <span class="attr">controls</span>=<span class="string">"controls"</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line">jquery播放：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"documentPlay"</span> <span class="attr">value</span>=<span class="string">"点击播放document"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    $('#documentPlay').click(function () &#123;</span></span><br><span class="line"><span class="undefined">        //找到音频</span></span><br><span class="line"><span class="undefined">        var documentAudio=document.getElementById('documentAudio');</span></span><br><span class="line"><span class="undefined">        if(documentAudio!=null)</span></span><br><span class="line"><span class="undefined">        &#123;</span></span><br><span class="line"><span class="undefined">            documentAudio.play();</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>显示效果：</p><p>原生audio控件：<audio src="http://fanyi.baidu.com/gettts?lan=en&text=document&spd=3&source=web" id="documentAudio"></audio></p><p><audio src="http://fanyi.baidu.com/gettts?lan=en&text=document&spd=3&source=web" controls></audio><br>jquery播放：<input type="button" id="documentPlay" value="点击播放document"></p><script>$("#documentPlay").click(function(){var n=document.getElementById("documentAudio");null!=n&&n.play()})</script><p>本文链接: <a href="https://www.lansheng.net.cn/blog/7a1ad816/">hexo next 主题 文章中插入使用JavaScript脚本</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> Next主题配置 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JavaScript常用对象3 Date对象</title>
      <link href="/blog/39300b18/"/>
      <url>/blog/39300b18/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><p><strong>目录</strong></p><ul><li><a href="https://www.lansheng.net.cn/blog/39300b18/#创建Date对象">创建Date对象</a></li><li><a href="https://www.lansheng.net.cn/blog/39300b18/#Date对象的方法">Date对象的方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/39300b18/#Date-方法">Date() 方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/39300b18/#实例-将输出今天的日期和时间">实例 将输出今天的日期和时间</a></li></ul></li><li><a href="https://www.lansheng.net.cn/blog/39300b18/#获取年份-getFullYear-方法">获取年份 getFullYear() 方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/39300b18/#实例-获取当前的年份">实例 获取当前的年份</a></li><li><a href="https://www.lansheng.net.cn/blog/39300b18/#实例-从具体到日期提取年份">实例 从具体到日期提取年份</a></li></ul></li><li><a href="https://www.lansheng.net.cn/blog/39300b18/#获取月份-getMonth-方法">获取月份 getMonth() 方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/39300b18/#实例">实例</a></li></ul></li><li><a href="https://www.lansheng.net.cn/blog/39300b18/#获取天数-getDate-方法">获取天数 getDate() 方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/39300b18/#实例-输出当前月份的日期">实例 输出当前月份的日期</a></li><li><a href="https://www.lansheng.net.cn/blog/39300b18/#实例-输出具体日期变量中的天数">实例 输出具体日期变量中的天数</a></li></ul></li><li><a href="https://www.lansheng.net.cn/blog/39300b18/#获取星期数-getDay-方法">获取星期数 getDay() 方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/39300b18/#实例-查看今天星期几">实例 查看今天星期几</a></li><li><a href="https://www.lansheng.net.cn/blog/39300b18/#实例-使用数字查看今天星期几">实例 使用数字查看今天星期几</a></li><li><a href="https://www.lansheng.net.cn/blog/39300b18/#实例-获取当前的小时数">实例 获取当前的小时数</a></li></ul></li></ul></li><li><a href="https://www.lansheng.net.cn/blog/39300b18/#参考链接">参考链接</a></li></ul><a id="more"></a><p>在Web程序开发的过程中,可以使用 JavaScript的Date对象来对日期和时间进行操作。例如,如果想在网页中显示计时的时钟,就可以使用Date对象来获取当前系统的时间并按照指定的格式进行显示。下面将对Date对象进行详细介绍。</p><h2 id="创建Date对象"><a href="#创建Date对象" class="headerlink" title="创建Date对象"></a>创建Date对象</h2><p>Date对象是一个有关日期和时间的对象。它具有动态性,即必须使用new运算符创建一个实例创建Date对象的语法格式如下:<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dateObject=<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">dateobject=<span class="keyword">new</span> <span class="built_in">Date</span>(dateValue);</span><br><span class="line">dateobject=<span class="keyword">new</span> <span class="built_in">Date</span>(year, month, date[,hours[,minutes[,seconds[,ms]]]]);</span><br></pre></td></tr></table></figure><p></p><p>参数说明:</p><ul><li>dateValue:如果是数值,则表示指定日期与1970年1月1日午夜间全球标准时间相差的毫秒数;如果是字符串,则 dateValue按照 parse()方法中的规则进行解析。</li><li>year:一个4位数的年份。如果输入的是0~99之间的值,则给它加上1900</li><li>month:表示月份,值为0~11之间的整数,即0代表1月份。</li><li>date:表示日,值为1~31之间的整数。</li><li>hours:表示小时,值为0~23之间的整数</li><li>minutes:表示分钟,值为0~59之间的整数。</li><li>seconds:表示秒钟,值为0~59之间的整数。</li><li>ms:表示毫秒,值为0~999之间的整数</li></ul><p>创建一个代表当前系统日期的Date对象的代码如下:<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> now=<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br></pre></td></tr></table></figure><p></p><h2 id="Date对象的方法"><a href="#Date对象的方法" class="headerlink" title="Date对象的方法"></a>Date对象的方法</h2><p><strong>Date对象没有提供直接访问的属性</strong>,只具有获取、设置日期和时间的方法。Date对象的常用方法如下所示</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Date()</td><td>返回当日的日期和时间。</td></tr><tr><td>getDate()</td><td>从 Date 对象返回一个月中的某一天 (1 ~ 31)。</td></tr><tr><td>getDay()</td><td>从 Date 对象返回一周中的某一天 (0 ~ 6)。</td></tr><tr><td>getMonth()</td><td>从 Date 对象返回月份 (0 ~ 11)。</td></tr><tr><td>getFullYear()</td><td>从 Date 对象以四位数字返回年份。</td></tr><tr><td>getYear()</td><td>请使用 getFullYear() 方法代替。</td></tr><tr><td>getHours()</td><td>返回 Date 对象的小时 (0 ~ 23)。</td></tr><tr><td>getMinutes()</td><td>返回 Date 对象的分钟 (0 ~ 59)。</td></tr><tr><td>getSeconds()</td><td>返回 Date 对象的秒数 (0 ~ 59)。</td></tr><tr><td>getMilliseconds()</td><td>返回 Date 对象的毫秒(0 ~ 999)。</td></tr><tr><td>getTime()</td><td>返回 1970 年 1 月 1 日至今的毫秒数。</td></tr><tr><td>getTimezoneOffset()</td><td>返回本地时间与格林威治标准时间 (GMT) 的分钟差。</td></tr><tr><td>getUTCDate()</td><td>根据世界时从 Date 对象返回月中的一天 (1 ~ 31)。</td></tr><tr><td>getUTCDay()</td><td>根据世界时从 Date 对象返回周中的一天 (0 ~ 6)。</td></tr><tr><td>getUTCMonth()</td><td>根据世界时从 Date 对象返回月份 (0 ~ 11)。</td></tr><tr><td>getUTCFullYear()</td><td>根据世界时从 Date 对象返回四位数的年份。</td></tr><tr><td>getUTCHours()</td><td>根据世界时返回 Date 对象的小时 (0 ~ 23)。</td></tr><tr><td>getUTCMinutes()</td><td>根据世界时返回 Date 对象的分钟 (0 ~ 59)。</td></tr><tr><td>getUTCSeconds()</td><td>根据世界时返回 Date 对象的秒钟 (0 ~ 59)。</td></tr><tr><td>getUTCMilliseconds()</td><td>根据世界时返回 Date 对象的毫秒(0 ~ 999)。</td></tr><tr><td>parse()</td><td>返回1970年1月1日午夜到指定日期（字符串）的毫秒数。</td></tr><tr><td>setDate()</td><td>设置 Date 对象中月的某一天 (1 ~ 31)。</td></tr><tr><td>setMonth()</td><td>设置 Date 对象中月份 (0 ~ 11)。</td></tr><tr><td>setFullYear()</td><td>设置 Date 对象中的年份（四位数字）。</td></tr><tr><td>setYear()</td><td>请使用 setFullYear() 方法代替。</td></tr><tr><td>setHours()</td><td>设置 Date 对象中的小时 (0 ~ 23)。</td></tr><tr><td>setMinutes()</td><td>设置 Date 对象中的分钟 (0 ~ 59)。</td></tr><tr><td>setSeconds()</td><td>设置 Date 对象中的秒钟 (0 ~ 59)。</td></tr><tr><td>setMilliseconds()</td><td>设置 Date 对象中的毫秒 (0 ~ 999)。</td></tr><tr><td>setTime()</td><td>以毫秒设置 Date 对象。</td></tr><tr><td>setUTCDate()</td><td>根据世界时设置 Date 对象中月份的一天 (1 ~ 31)。</td></tr><tr><td>setUTCMonth()</td><td>根据世界时设置 Date 对象中的月份 (0 ~ 11)。</td></tr><tr><td>setUTCFullYear()</td><td>根据世界时设置 Date 对象中的年份（四位数字）。</td></tr><tr><td>setUTCHours()</td><td>根据世界时设置 Date 对象中的小时 (0 ~ 23)。</td></tr><tr><td>setUTCMinutes()</td><td>根据世界时设置 Date 对象中的分钟 (0 ~ 59)。</td></tr><tr><td>setUTCSeconds()</td><td>根据世界时设置 Date 对象中的秒钟 (0 ~ 59)。</td></tr><tr><td>setUTCMilliseconds()</td><td>根据世界时设置 Date 对象中的毫秒 (0 ~ 999)。</td></tr><tr><td>toSource()</td><td>返回该对象的源代码。</td></tr><tr><td>toString()</td><td>把 Date 对象转换为字符串。</td></tr><tr><td>toTimeString()</td><td>把 Date 对象的时间部分转换为字符串。</td></tr><tr><td>toDateString()</td><td>把 Date 对象的日期部分转换为字符串。</td></tr><tr><td>toGMTString()</td><td>请使用 toUTCString() 方法代替。</td></tr><tr><td>toUTCString()</td><td>根据世界时，把 Date 对象转换为字符串。</td></tr><tr><td>toLocaleString()</td><td>根据本地时间格式，把 Date 对象转换为字符串。</td></tr><tr><td>toLocaleTimeString()</td><td>根据本地时间格式，把 Date 对象的时间部分转换为字符串。</td></tr><tr><td>toLocaleDateString()</td><td>根据本地时间格式，把 Date 对象的日期部分转换为字符串。</td></tr><tr><td>UTC()</td><td>根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数。</td></tr><tr><td>valueOf()</td><td>返回 Date 对象的原始值。</td></tr></tbody></table><h3 id="Date-方法"><a href="#Date-方法" class="headerlink" title="Date() 方法"></a>Date() 方法</h3><p><strong>定义和用法</strong><br>Date() 方法可返回当天的日期和时间。<br><strong>语法</strong><br>Date()</p><h4 id="实例-将输出今天的日期和时间"><a href="#实例-将输出今天的日期和时间" class="headerlink" title="实例 将输出今天的日期和时间"></a>实例 将输出今天的日期和时间</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(<span class="built_in">Date</span>())</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><p><pre><code><span id="newDate" style="font-size:14px"></span></code></pre></p><script type="text/javascript">var newDate=document.getElementById("newDate");newDate.innerText=new Date</script><h3 id="获取年份-getFullYear-方法"><a href="#获取年份-getFullYear-方法" class="headerlink" title="获取年份 getFullYear() 方法"></a>获取年份 getFullYear() 方法</h3><blockquote><p><strong>定义和用法</strong><br>getFullYear() 方法可返回一个<strong>表示年份的 4 位数字</strong>。<br><strong>语法</strong><br><code>dateObject.getFullYear()</code><br><strong>返回值</strong><br>当 dateObject 用本地时间表示时返回的年份。返回值是一个四位数，表示包括世纪值在内的完整年份，而不是两位数的缩写形式。</p></blockquote><h4 id="实例-获取当前的年份"><a href="#实例-获取当前的年份" class="headerlink" title="实例 获取当前的年份"></a>实例 获取当前的年份</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>()</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(d.getFullYear())</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><p><pre><code><span id="getFullYear" style="font-size:14px"></span></code></pre></p><script type="text/javascript">var d=new Date,getFullYear=document.getElementById("getFullYear");getFullYear.innerText=d.getFullYear()</script><h4 id="实例-从具体到日期提取年份"><a href="#实例-从具体到日期提取年份" class="headerlink" title="实例 从具体到日期提取年份"></a>实例 从具体到日期提取年份</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> born = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"July 21, 1983 01:15:00"</span>)</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(<span class="string">"I was born in "</span> + born.getFullYear())</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I was born in 1983</span><br></pre></td></tr></table></figure><p></p><h3 id="getYear-方法"><a href="#getYear-方法" class="headerlink" title="getYear() 方法"></a>getYear() 方法</h3><blockquote><p><strong>定义和用法</strong><br><del>getYear()</del>方法可返回表示年份的两位或四位的数字。<br><strong>语法</strong><br>dateObject.getYear()<br><strong>返回值</strong><br>返回 Date 对象的年份字段。<br><strong>提示和注释</strong> ：<br>注释：由 getYear() 返回的值不总是 4 位的数字！对于介于 1900 与 1999 之间的年份，getYear() 方法仅返回两位数字。对于 1900 之前或 1999 之后的年份，则返回 4 位数字！<br>注释：该方法总是结合一个 Date 对象来使用。<br>重要事项： <strong>从 ECMAScript v3 开始，JavaScript 的实现就不再使用该方法，而使用 getFullYear() 方法取而代之</strong> ！</p></blockquote><h3 id="获取月份-getMonth-方法"><a href="#获取月份-getMonth-方法" class="headerlink" title="获取月份 getMonth() 方法"></a>获取月份 getMonth() 方法</h3><blockquote><p><strong>定义和用法</strong><br>getMonth() 方法可返回表示月份的数字。<br><strong>语法</strong><br><code>dateObject.getMonth()</code><br><strong>返回值</strong><br>dateObject 的月份字段，使用本地时间。<strong>返回值是 0（一月） 到 11（十二月） 之间的一个整数</strong>。</p></blockquote><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> d=<span class="keyword">new</span> <span class="built_in">Date</span>();</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> month=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">12</span>);</span></span><br><span class="line"><span class="javascript">month[<span class="number">0</span>]=<span class="string">"January"</span>;</span></span><br><span class="line"><span class="javascript">month[<span class="number">1</span>]=<span class="string">"February"</span>;</span></span><br><span class="line"><span class="javascript">month[<span class="number">2</span>]=<span class="string">"March"</span>;</span></span><br><span class="line"><span class="javascript">month[<span class="number">3</span>]=<span class="string">"April"</span>;</span></span><br><span class="line"><span class="javascript">month[<span class="number">4</span>]=<span class="string">"May"</span>;</span></span><br><span class="line"><span class="javascript">month[<span class="number">5</span>]=<span class="string">"June"</span>;</span></span><br><span class="line"><span class="javascript">month[<span class="number">6</span>]=<span class="string">"July"</span>;</span></span><br><span class="line"><span class="javascript">month[<span class="number">7</span>]=<span class="string">"August"</span>;</span></span><br><span class="line"><span class="javascript">month[<span class="number">8</span>]=<span class="string">"September"</span>;</span></span><br><span class="line"><span class="javascript">month[<span class="number">9</span>]=<span class="string">"October"</span>;</span></span><br><span class="line"><span class="javascript">month[<span class="number">10</span>]=<span class="string">"November"</span>;</span></span><br><span class="line"><span class="javascript">month[<span class="number">11</span>]=<span class="string">"December"</span>;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(<span class="string">"The month is "</span> + month[d.getMonth()]);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><p><pre><code><span id="getMonth" style="font-size:14px"></span></code></pre></p><script type="text/javascript">var d=new Date,month=new Array(12);month[0]="January",month[1]="February",month[2]="March",month[3]="April",month[4]="May",month[5]="June",month[6]="July",month[7]="August",month[8]="September",month[9]="October",month[10]="November",month[11]="December";var getMonth=document.getElementById("getMonth");getMonth.innerText="The month is "+month[d.getMonth()]</script><h3 id="获取天数-getDate-方法"><a href="#获取天数-getDate-方法" class="headerlink" title="获取天数 getDate() 方法"></a>获取天数 getDate() 方法</h3><blockquote><p><strong>定义和用法</strong><br>getDate() 方法可返回月份的某一天。<br><strong>语法</strong><br>dateObject.getDate()<br><strong>返回值</strong><br>dateObject所指的月份中的某一天，使用本地时间。<strong>返回值是 1 ~ 31 之间的一个整数</strong>。</p></blockquote><h4 id="实例-输出当前月份的日期"><a href="#实例-输出当前月份的日期" class="headerlink" title="实例 输出当前月份的日期"></a>实例 输出当前月份的日期</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>()</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(d.getDate())</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><p><pre><code><span id="getDate0" style="font-size:14px"></span></code></pre></p><script type="text/javascript">var d=new Date,getHours1=document.getElementById("getDate0");getDate0.innerText=d.getDate()</script><h4 id="实例-输出具体日期变量中的天数"><a href="#实例-输出具体日期变量中的天数" class="headerlink" title="实例 输出具体日期变量中的天数"></a>实例 输出具体日期变量中的天数</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> birthday = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"July 21, 1983 01:15:00"</span>)</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(birthday.getDate())</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><p><pre><code><span id="getDate1" style="font-size:14px"></span></code></pre></p><script type="text/javascript">var birthday=new Date("July 21, 1983 01:15:00"),getHours1=document.getElementById("getHours1");getDate1.innerText=birthday.getDate()</script><h3 id="获取星期数-getDay-方法"><a href="#获取星期数-getDay-方法" class="headerlink" title="获取星期数 getDay() 方法"></a>获取星期数 getDay() 方法</h3><blockquote><p><strong>定义和用法</strong><br>getDay() 方法可返回表示星期的某一天的数字。<br><strong>语法</strong><br><code>dateObject.getDay()</code><br><strong>返回值</strong><br>dateObject 所指的星期中的某一天，使用本地时间。<strong>返回值是 0（周日） 到 6（周六） 之间的一个整数</strong>。</p></blockquote><h4 id="实例-查看今天星期几"><a href="#实例-查看今天星期几" class="headerlink" title="实例 查看今天星期几"></a>实例 查看今天星期几</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JavaScript Date对象获取星期getDay方法.html<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> day = <span class="keyword">new</span> <span class="built_in">Date</span>().getDay();</span></span><br><span class="line"><span class="javascript">        <span class="keyword">switch</span> (day) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">case</span> <span class="number">0</span>:</span></span><br><span class="line"><span class="javascript">                week = <span class="string">"Today it's Sunday"</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">case</span> <span class="number">1</span>:</span></span><br><span class="line"><span class="javascript">                week = <span class="string">"Today it's Monday"</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">case</span> <span class="number">2</span>:</span></span><br><span class="line"><span class="javascript">                week = <span class="string">"Today it's Tuesday"</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">case</span> <span class="number">3</span>:</span></span><br><span class="line"><span class="javascript">                week = <span class="string">"Today it's Wednesday"</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">case</span> <span class="number">4</span>:</span></span><br><span class="line"><span class="javascript">                week = <span class="string">"Today it's Thursday"</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">case</span> <span class="number">5</span>:</span></span><br><span class="line"><span class="javascript">                week = <span class="string">"Today it's Friday"</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">case</span> <span class="number">6</span>:</span></span><br><span class="line"><span class="javascript">                week = <span class="string">"Today it's Saturday"</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">break</span>;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.write(week);</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><p><pre><code><span id="getDay1" style="font-size:14px"></span></code></pre></p><script type="text/javascript">var day=(new Date).getDay();switch(day){case 0:week="Today it's Sunday";break;case 1:week="Today it's Monday";break;case 2:week="Today it's Tuesday";break;case 3:week="Today it's Wednesday";break;case 4:week="Today it's Thursday";break;case 5:week="Today it's Friday";break;case 6:week="Today it's Saturday"}var getDay1=document.getElementById("getDay1");getDay1.innerText=week</script><h4 id="实例-使用数字查看今天星期几"><a href="#实例-使用数字查看今天星期几" class="headerlink" title="实例 使用数字查看今天星期几"></a>实例 使用数字查看今天星期几</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>()</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> weekday = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">7</span>)</span></span><br><span class="line"><span class="javascript">    weekday[<span class="number">0</span>] = <span class="string">"Sunday"</span></span></span><br><span class="line"><span class="javascript">    weekday[<span class="number">1</span>] = <span class="string">"Monday"</span></span></span><br><span class="line"><span class="javascript">    weekday[<span class="number">2</span>] = <span class="string">"Tuesday"</span></span></span><br><span class="line"><span class="javascript">    weekday[<span class="number">3</span>] = <span class="string">"Wednesday"</span></span></span><br><span class="line"><span class="javascript">    weekday[<span class="number">4</span>] = <span class="string">"Thursday"</span></span></span><br><span class="line"><span class="javascript">    weekday[<span class="number">5</span>] = <span class="string">"Friday"</span></span></span><br><span class="line"><span class="javascript">    weekday[<span class="number">6</span>] = <span class="string">"Saturday"</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(<span class="string">"Today it is "</span> + weekday[d.getDay()])</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><p><pre><code><span id="getDay2" style="font-size:14px"></span></code></pre></p><script type="text/javascript">var d=new Date,weekday=new Array(7);weekday[0]="Sunday",weekday[1]="Monday",weekday[2]="Tuesday",weekday[3]="Wednesday",weekday[4]="Thursday",weekday[5]="Friday",weekday[6]="Saturday";var getDay2=document.getElementById("getDay2");getDay2.innerText="Today it is "+weekday[d.getDay()]</script><h3 id="返回小时的方法-getHours-方法"><a href="#返回小时的方法-getHours-方法" class="headerlink" title="返回小时的方法 getHours() 方法"></a>返回小时的方法 getHours() 方法</h3><blockquote><p><strong>定义和用法</strong><br>getHours() 方法可返回时间的小时字段。<br><strong>语法</strong><br><code>dateObject.getHours()</code><br><strong>返回值</strong><br>dateObject 的小时字段，以本地时间显示。<strong>返回值是 0 （午夜） 到 23 （晚上 11 点）之间的一个整数</strong>。<br><strong>提示和注释</strong><br>注释：由 getHours() 返回的值是一个两位的数字。不过返回值不总是两位的，如果该值小于 10，则仅返回一位数字。</p></blockquote><h4 id="实例-获取当前的小时数"><a href="#实例-获取当前的小时数" class="headerlink" title="实例 获取当前的小时数"></a>实例 获取当前的小时数</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>()</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(d.getHours())</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><p><pre><code><span id="getHours1" style="font-size:14px"></span></code></pre></p><script type="text/javascript">var d=new Date,getHours1=document.getElementById("getHours1");getHours1.innerText=d.getHours()</script><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.w3school.com.cn/jsref/jsref_obj_date.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/jsref/jsref_obj_date.asp</a></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/39300b18/">JavaScript常用对象3 Date对象</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Java Web从入门到精通 </category>
          
          <category> 第3章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>下载百度翻译英文读音</title>
      <link href="/blog/9022bbc4/"/>
      <url>/blog/9022bbc4/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:16 GMT+0800 (中国标准时间) --><p><strong>目录</strong></p><ul><li><a href="https://www.lansheng.net.cn/blog/9022bbc4/#下载百度翻译英文读音">下载百度翻译英文读音</a></li><li><a href="https://www.lansheng.net.cn/blog/9022bbc4/#使用html5-audio控件播放">使用html5 audio控件播放</a></li><li><a href="https://www.lansheng.net.cn/blog/9022bbc4/#百度翻译读音链接说明">百度翻译读音链接说明</a><ul><li><a href="https://www.lansheng.net.cn/blog/9022bbc4/#实例-中文和朗读">实例 中文和朗读</a></li></ul></li><li><a href="https://www.lansheng.net.cn/blog/9022bbc4/#参考链接">参考链接</a></li></ul><a id="more"></a><h2 id="下载百度翻译英文读音"><a href="#下载百度翻译英文读音" class="headerlink" title="下载百度翻译英文读音"></a>下载百度翻译英文读音</h2><p>链接如下，把<code>你要查的单词</code>替换成你要查找的单词，然后用浏览器打开,即可下载该该单词的读音。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://fanyi.baidu.com/gettts?lan=en&amp;text=YouWord&amp;spd=5&amp;source=web</span><br></pre></td></tr></table></figure><p></p><h2 id="使用html5-audio控件播放"><a href="#使用html5-audio控件播放" class="headerlink" title="使用html5 audio控件播放"></a>使用html5 audio控件播放</h2><p>当然也可以添加audio标签，这样就可以放在网页中，点击即可播放：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;audio src=&quot;http://fanyi.baidu.com/gettts?lan=en&amp;text=focus&amp;spd=5&amp;source=web&quot;&gt;&lt;/audio&gt;</span><br></pre></td></tr></table></figure><p></p><p>显示效果：</p><p><audio src="http://fanyi.baidu.com/gettts?lan=en&text=focus&spd=5&source=web" controls>buzhici</audio></p><h2 id="单词和读音放在一行"><a href="#单词和读音放在一行" class="headerlink" title="单词和读音放在一行"></a>单词和读音放在一行</h2><p>为了把单词和读音放在一行，我又套了一个表格在外面，这样比较美观。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;table style=&quot;width: 30%;&quot;&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;focus&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;</span><br><span class="line">            &lt;audio src=&quot;http://fanyi.baidu.com/gettts?lan=en&amp;text=focus&amp;spd=5&amp;source=web&quot; controls=&quot;controls&quot;&gt;focus&lt;/audio&gt;</span><br><span class="line">        &lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><p></p><p>不过在Markdown中插入表格的话，要把所有的html代码写在一行。不然表格和表格上的文本会出现很多空白行，所以最终的代码为：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">style</span>=<span class="string">"width: 30%;"</span>&gt;</span><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> &gt;</span>focus<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">"http://fanyi.baidu.com/gettts?lan=en&amp;text=focus&amp;spd=5&amp;source=web"</span> <span class="attr">controls</span>=<span class="string">"controls"</span>&gt;</span>focus<span class="tag">&lt;/<span class="name">audio</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>显示效果：</p><table style="width:30%"><tr><td>focus</td><td><audio src="http://fanyi.baidu.com/gettts?lan=en&text=focus&spd=5&source=web" controls>focus</audio></td></tr></table><h2 id="百度翻译读音链接说明"><a href="#百度翻译读音链接说明" class="headerlink" title="百度翻译读音链接说明"></a>百度翻译读音链接说明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://fanyi.baidu.com/gettts?lan=en&amp;text=focus&amp;spd=5&amp;source=web</span><br><span class="line">http://fanyi.baidu.com/gettts?lan=zh&amp;text=focus&amp;spd=5&amp;source=web</span><br></pre></td></tr></table></figure><ul><li>lan 表示读音的方法<ul><li>en 表示英式读音</li><li>zh 表示中式读音</li></ul></li><li>text 表示需要朗读的文本</li><li>spd 表示朗读的速度</li><li>source 这一项我不知道是什么意思</li></ul><h3 id="实例-中文和朗读"><a href="#实例-中文和朗读" class="headerlink" title="实例 中文和朗读"></a>实例 中文和朗读</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">style</span>=<span class="string">"width: 30%;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>focus(en)<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">"http://fanyi.baidu.com/gettts?lan=en&amp;text=focus&amp;spd=5&amp;source=web"</span> <span class="attr">controls</span>=<span class="string">"controls"</span>&gt;</span>focus<span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>小明(zh)<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">"http://fanyi.baidu.com/gettts?lan=zh&amp;text=小明&amp;spd=5&amp;source=web"</span> <span class="attr">controls</span>=<span class="string">"controls"</span>&gt;</span>小明<span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span></span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p><table style="width:30%"><tr><td>focus(en)</td><td><audio src="http://fanyi.baidu.com/gettts?lan=en&text=focus&spd=5&source=web" controls>focus</audio></td></tr><tr><td>小明(zh)</td><td><audio src="http://fanyi.baidu.com/gettts?lan=zh&text=小明&spd=5&source=web" controls>focus</audio></td></tr></table></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.v2ex.com/amp/t/393846" title="请问百度翻译里的语音可以下载下来嘛？" target="_blank" rel="noopener">https://www.v2ex.com/amp/t/393846</a><br><a href="http://www.w3school.com.cn/tags/tag_audio.asp" title="HTML &lt;audio&gt;标签" target="_blank" rel="noopener">http://www.w3school.com.cn/tags/tag_audio.asp</a><br>本文链接: <a href="https://www.lansheng.net.cn/blog/9022bbc4/">下载百度翻译英文读音</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
          <category> 音视频 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hexo next 设置表格的宽度</title>
      <link href="/blog/51caa039/"/>
      <url>/blog/51caa039/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:16 GMT+0800 (中国标准时间) --><p>使用html表格标签即可,这样可以自定义样式。<br><strong>正确写法</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">style</span>=<span class="string">"width: 50%;"</span>&gt;</span><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>标题1<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>标题2<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格1<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格2<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>显示效果:<table style="width:50%"><tr><th>标题1</th><th>标题2</th></tr><tr><td>单元格1</td><td>单元格2</td></tr></table><br><a id="more"></a><br><strong>错误写法</strong></p><table width="50%"><tr><th>标题1</th><th>标题2</th></tr><tr><td>单元格1</td><td>单元格2</td></tr></table><p>本文链接: <a href="https://www.lansheng.net.cn/blog/0/">hexo next 设置表格的宽度</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
          <category> 表格 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hexo Coding无法部署：Coding 提示 Repo size exceeded quota 512M 仓库容量超限 512M</title>
      <link href="/blog/39481c48/"/>
      <url>/blog/39481c48/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p><strong>目录</strong></p><ul><li><a href="https://www.lansheng.net.cn/blog/39481c48/#问题描述">问题描述</a></li><li><a href="https://www.lansheng.net.cn/blog/39481c48/#解决方案">解决方案</a><ul><li><a href="https://www.lansheng.net.cn/blog/39481c48/#登录coding-清空仓库">登录coding 清空仓库</a></li><li><a href="https://www.lansheng.net.cn/blog/39481c48/#重新部署">重新部署</a></li><li><a href="https://www.lansheng.net.cn/blog/39481c48/#重新开启pages服务">重新开启pages服务</a></li><li><a href="https://www.lansheng.net.cn/blog/39481c48/#重新绑定域名">重新绑定域名</a></li></ul></li></ul><a id="more"></a><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>今天部署到coding的时候，我又无法部署了，说我超出了容量(512M),我不可能写了那么多东西,我很奇怪。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Coding 提示: Repo size exceeded quota: 512M (100.02%).</span><br><span class="line">仓库容量超限: 512M (100.02%)， 查看您的会员计划: https://coding.net/vip</span><br><span class="line">......</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br><span class="line">FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br><span class="line">Error: Coding 提示: Repo size exceeded quota: 512M (100.02%).</span><br><span class="line">仓库容量超限: 512M (100.02%)， 查看您的会员计划: https://coding.net/vip</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="登录coding-清空仓库"><a href="#登录coding-清空仓库" class="headerlink" title="登录coding 清空仓库"></a>登录coding 清空仓库</h3><p>登录到coding.net,打开你的仓库，点击<code>设置-&gt;仓库设置-&gt;清空仓库</code>。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/wenti/codingcangkubuzu/qingkongcangku.png" alt=""></p><h3 id="重新部署"><a href="#重新部署" class="headerlink" title="重新部署"></a>重新部署</h3><p>站点目录下，打开git-bash 输入命令<code>hexo clean&amp;&amp;hexo g&amp;&amp;hexo d</code>重新部署，部署后,点开<code>设置-&gt;项目预览</code>，可以看到我这次推送占用的容量为：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/wenti/codingcangkubuzu/qingkongzhihou.png" alt=""><br><strong>这个Git仓库你每部署(推送)一次,就会占用一些容量。推送多了就会超出容量限制(512M)了，所以还是不要频繁部署</strong>。</p><h3 id="重新开启pages服务"><a href="#重新开启pages服务" class="headerlink" title="重新开启pages服务"></a>重新开启pages服务</h3><p>清空仓库后，pages服务默认关掉了，需要重新开启,点击<code>代码-&gt;Pages服务</code>。然后开启Pages服务：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/wenti/codingcangkubuzu/kaiqipages.png" alt=""></p><h3 id="重新绑定域名"><a href="#重新绑定域名" class="headerlink" title="重新绑定域名"></a>重新绑定域名</h3><p>开启服务后，就可以使用Coding默认的域名(<code>https://用户名.coding.me</code>)来访问了。如果使用coding的默认域名的话到这里就可以了。<br>如果之前绑定了自己买的域名的话，清空仓库后，之前绑定的域名也失效了，需要重新绑定。但是奇怪的是，我在coding上一直绑定不上。也不知道为什么，我猜是域名解析的问题，所以我到万网上，先删除coding和github的解析，然后在重新添加Coding的解析。然后回到Coding.net上绑定域名，神奇的是，这样就可以绑定上了，最后在重新添加github的解析就行了。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/wenti/codingcangkubuzu/bangdingyuming.png" alt=""><br>本文链接: <a href="https://www.lansheng.net.cn/blog/39481c48/">hexo Coding无法部署：Coding 提示 Repo size exceeded quota 512M 仓库容量超限 512M</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> 遇到问题 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JavaScript常用对象1 Window对象</title>
      <link href="/blog/7d3bc6dd/"/>
      <url>/blog/7d3bc6dd/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><p><strong>目录</strong></p><ul><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#JavaScript-Window-对象方法">JavaScript Window 对象方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#键盘焦点方法">键盘焦点方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#focus-方法">focus() 方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#实例-把焦点移到新窗口">实例 把焦点移到新窗口</a></li></ul></li><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#blur-方法">blur() 方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#实例-从新窗口移开焦点">实例 从新窗口移开焦点</a></li></ul></li></ul></li><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#定时器方法">定时器方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#setInterval-方法">setInterval() 方法</a></li><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#clearInterval-方法">clearInterval() 方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#实例-使用-setInterval-和-clearInterval-">实例 使用 setInterval() 和 clearInterval()</a></li></ul></li><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#setTimeout-方法">setTimeout() 方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#实例-简单的计时">实例 简单的计时</a></li><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#实例-另一个简单的计时">实例 另一个简单的计时</a></li><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#实例-递归无限计时">实例 递归无限计时</a></li><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#实例-时钟">实例 时钟</a></li></ul></li><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#clearTimeout-方法">clearTimeout() 方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#实例-带有停止按钮的计时程序">实例 带有停止按钮的计时程序</a></li></ul></li></ul></li><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#打开关闭窗口方法">打开关闭窗口方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#open-方法">open() 方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#实例-通过按钮来打开一个窗口">实例 通过按钮来打开一个窗口</a></li><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#实例-打开一个新窗口并设置该窗口的形状，坐标">实例 打开一个新窗口并设置该窗口的形状，坐标</a></li><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#实例-打开多个窗口">实例 打开多个窗口</a></li></ul></li><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#close-方法">close() 方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#实例-通过按钮打开和关闭浏览器窗口">实例 通过按钮打开和关闭浏览器窗口</a></li></ul></li></ul></li><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#调整窗口大小方法">调整窗口大小方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#resizeBy-方法">resizeBy() 方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#实例">实例</a></li></ul></li><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#resizeTo-方法">resizeTo() 方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#实例">实例</a></li></ul></li></ul></li><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#滚动页面方法">滚动页面方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#scrollBy-方法">scrollBy() 方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#实例-通过-scrollBy-滚动文档">实例 通过 scrollBy() 滚动文档</a></li></ul></li><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#scrollTo-方法">scrollTo() 方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#实例-回到顶部">实例 回到顶部</a></li></ul></li></ul></li><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#移动窗口方法">移动窗口方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#moveBy-方法">moveBy() 方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#实例-移动浏览器窗体">实例 移动浏览器窗体</a></li></ul></li></ul></li><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#弹窗方法">弹窗方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#弹窗警告框-alert-方法">弹窗警告框 alert()方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#实例">实例</a></li></ul></li><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#输入框-prompt-方法">输入框 prompt() 方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#实例">实例</a></li></ul></li><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#confirm-方法">confirm() 方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#实例">实例</a></li></ul></li></ul></li><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#其他方法">其他方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#createPopup-方法">createPopup() 方法</a></li><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#print-方法">print() 方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#实例-打印当前html页面">实例 打印当前html页面</a></li></ul></li></ul></li><li><a href="https://www.lansheng.net.cn/blog/7d3bc6dd/#参考链接">参考链接</a></li></ul></li></ul><a id="more"></a><h1 id="JavaScript-Window-对象方法"><a href="#JavaScript-Window-对象方法" class="headerlink" title="JavaScript Window 对象方法"></a>JavaScript Window 对象方法</h1><h2 id="键盘焦点方法"><a href="#键盘焦点方法" class="headerlink" title="键盘焦点方法"></a>键盘焦点方法</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>focus()</td><td>把键盘焦点给予一个窗口。</td></tr><tr><td>blur()</td><td>把键盘焦点从顶层窗口移开。</td></tr></tbody></table><p><strong>读音</strong></p><table><thead><tr><th style="text-align:left">单词</th><th style="text-align:left">读音</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://fanyi.baidu.com/?#en/zh/focus" target="_blank" rel="noopener">focus</a></td><td style="text-align:left"><input type="button" onclick="paly_audioID20181110171747()" value="播放"></td></tr><tr><td style="text-align:left"><a href="https://fanyi.baidu.com/?#en/zh/blur" target="_blank" rel="noopener">focus</a></td><td style="text-align:left"><input type="button" onclick="paly_audioID20181110171813()" value="播放"></td></tr></tbody></table><p><audio src="http://fanyi.baidu.com/gettts?lan=en&text=blur&spd=3&source=web" id="audioID20181110171813"></audio></p><script>function paly_audioID20181110171813(){var a=document.getElementById("audioID20181110171813");null!=a&&a.play()}</script><audio src="http://fanyi.baidu.com/gettts?lan=en&text=focus&spd=3&source=web" id="audioID20181110171747"></audio><script>function paly_audioID20181110171747(){var a=document.getElementById("audioID20181110171747");null!=a&&a.play()}</script><h3 id="focus-方法"><a href="#focus-方法" class="headerlink" title="focus() 方法"></a>focus() 方法</h3><blockquote><p><strong>定义和用法</strong><br>focus() 方法可<strong>把<code>键盘焦点</code>给予一个窗口</strong>。<br><strong>语法</strong><br><code>window.focus()</code><br>下面的例子可确保新的窗口得到焦点：</p></blockquote><h4 id="实例-把焦点移到新窗口"><a href="#实例-把焦点移到新窗口" class="headerlink" title="实例 把焦点移到新窗口"></a>实例 把焦点移到新窗口</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//打开新窗体</span></span></span><br><span class="line"><span class="javascript">    myWindow = <span class="built_in">window</span>.open(<span class="string">''</span>, <span class="string">''</span>, <span class="string">'width=200,height=100'</span>)</span></span><br><span class="line"><span class="javascript">    myWindow.document.write(<span class="string">"This is 'myWindow'"</span>)</span></span><br><span class="line"><span class="javascript">    <span class="comment">//让新窗体获取焦点</span></span></span><br><span class="line"><span class="undefined">    myWindow.focus()</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行该代码，浏览器将会打开一个新的窗体，让该窗体获取到焦点，然后在该窗体中写入<code>This is &#39;myWindow&#39;</code>:<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/javawebcongrumendaojingtong/3/windowObject/focusmethod.png" alt=""></p><h3 id="blur-方法"><a href="#blur-方法" class="headerlink" title="blur() 方法"></a>blur() 方法</h3><p><strong>定义和用法</strong></p><blockquote><p>blur() 方法可<strong>把键盘焦点从顶层窗口移开</strong>。<br><strong>语法</strong><br><code>window.blur()</code><br><strong>说明</strong><br><code>方法 blur() 可把键盘焦点从顶层浏览器窗口移走</code>，整个窗口由 Window 对象指定。哪个窗口最终获得键盘焦点并没有指定。<br><strong>提示和注释</strong><br>注释：在某些浏览器上，该方法可能无效。</p></blockquote><h4 id="实例-从新窗口移开焦点"><a href="#实例-从新窗口移开焦点" class="headerlink" title="实例 从新窗口移开焦点"></a>实例 从新窗口移开焦点</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS Windowns对象blur方法<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">//打开一个窗体</span></span></span><br><span class="line"><span class="javascript">        myWindow = <span class="built_in">window</span>.open(<span class="string">''</span>, <span class="string">''</span>, <span class="string">'width=200,height=100'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="comment">//写入页面中</span></span></span><br><span class="line"><span class="javascript">        myWindow.document.write(<span class="string">"This is 'myWindow'"</span>);</span></span><br><span class="line"><span class="javascript">        <span class="comment">//当前顶层窗体失去焦点,</span></span></span><br><span class="line"><span class="javascript">        myWindow.blur();<span class="comment">//让新窗体得到焦点</span></span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我看不出有什么效果，后续再补上吧。</p><h2 id="定时器方法"><a href="#定时器方法" class="headerlink" title="定时器方法"></a>定时器方法</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>setInterval()</td><td>按照指定的周期（以毫秒计）来调用函数或计算表达式。</td></tr><tr><td>clearInterval()</td><td>取消由 setInterval() 设置的 timeout。</td></tr><tr><td>setTimeout()</td><td>在指定的毫秒数后调用函数或计算表达式。</td></tr><tr><td>clearTimeout()</td><td>取消由 setTimeout() 方法设置的 timeout。</td></tr></tbody></table><p><strong>读音</strong>：</p><table><thead><tr><th style="text-align:left">单词</th><th style="text-align:left">读音</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://fanyi.baidu.com/?#en/zh/Interval" target="_blank" rel="noopener">Interval</a></td><td style="text-align:left"><input type="button" onclick="paly_audioID20181111121031()" value="播放"></td></tr></tbody></table><p><audio src="http://fanyi.baidu.com/gettts?lan=en&text=Interval&spd=3&source=web" id="audioID20181111121031"></audio></p><script>function paly_audioID20181111121031(){var a=document.getElementById("audioID20181111121031");null!=a&&a.play()}</script><h3 id="setInterval-方法"><a href="#setInterval-方法" class="headerlink" title="setInterval() 方法"></a>setInterval() 方法</h3><p><strong>定义和用法</strong></p><blockquote><p>setInterval() 方法可<strong>按照指定的周期（以毫秒计）来调用函数或计算表达式</strong>。<br>setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。<br><strong>语法</strong><br><code>setInterval(code,millisec[,&quot;lang&quot;])</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>code</td><td>必需。要调用的函数或要执行的代码串。</td></tr><tr><td>millisec</td><td>必须。周期性执行或调用 code 之间的时间间隔，以毫秒计。</td></tr></tbody></table><p><strong>返回值</strong><br>一个可以传递给 Window.clearInterval() 从而取消对 code 的周期性执行的值。</p></blockquote><h3 id="clearInterval-方法"><a href="#clearInterval-方法" class="headerlink" title="clearInterval() 方法"></a>clearInterval() 方法</h3><blockquote><p><strong>定义和用法</strong><br>clearInterval() 方法可取消由 setInterval() 设置的 timeout。<br>clearInterval() 方法的参数必须是由 setInterval() 返回的 ID 值。<br><strong>语法</strong><br><code>clearInterval(id_of_setinterval)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>id_of_setinterval</td><td>由 setInterval() 返回的 ID 值。</td></tr></tbody></table></blockquote><h4 id="实例-使用-setInterval-和-clearInterval"><a href="#实例-使用-setInterval-和-clearInterval" class="headerlink" title="实例 使用 setInterval() 和 clearInterval()"></a>实例 使用 setInterval() 和 clearInterval()</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS Windows对象setInterval clearInterval方法<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 函数输出框 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"clock"</span> <span class="attr">size</span>=<span class="string">"50"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">javascript</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">//每隔50毫秒调用一次clock()函数,并把id记录在变量id_of_setinterval中</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> id_of_setinterval = self.setInterval(<span class="string">"clock()"</span>, <span class="number">50</span>)</span></span><br><span class="line"><span class="javascript">        <span class="comment">//被周期调用的函数</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">clock</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> t = <span class="keyword">new</span> <span class="built_in">Date</span>()</span></span><br><span class="line"><span class="javascript">            <span class="comment">//写入日期</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">"clock"</span>).value = t</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用id_of_setinterval来停止周期调用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"id_of_setinterval=window.clearInterval(id_of_setinterval)"</span>&gt;</span>Stop interval<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="setTimeout-方法"><a href="#setTimeout-方法" class="headerlink" title="setTimeout() 方法"></a>setTimeout() 方法</h3><blockquote><p><strong>定义和用法</strong><br>setTimeout() 方法 <code>用于在指定的毫秒数后调用函数或计算表达式</code> 。<br><strong>语法</strong><br><code>setTimeout(code,millisecond)</code></p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">code</td><td style="text-align:center">必需。要调用的函数后要执行的 JavaScript 代码串</td></tr><tr><td style="text-align:center">millisecond</td><td style="text-align:center">必需。在执行代码前需等待的毫秒数。</td></tr></tbody></table><p><strong>提示和注释</strong><br>提示： <strong>setTimeout() 只执行 code 一次</strong> 。如果要多次调用，请使用 setInterval() 或者让 code 自身再次调用 setTimeout()。</p></blockquote><p><strong>读音</strong></p><table><thead><tr><th style="text-align:left">单词</th><th style="text-align:left">读音</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://fanyi.baidu.com/?#en/zh/millisecond" target="_blank" rel="noopener">millisecond</a></td><td style="text-align:left"><input type="button" onclick="paly_audioID20181110173032()" value="播放"></td></tr></tbody></table><p><audio src="http://fanyi.baidu.com/gettts?lan=en&text=millisecond&spd=3&source=web" id="audioID20181110173032"></audio></p><script>function paly_audioID20181110173032(){var a=document.getElementById("audioID20181110173032");null!=a&&a.play()}</script><h4 id="实例-简单的计时"><a href="#实例-简单的计时" class="headerlink" title="实例 简单的计时"></a>实例 简单的计时</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;JS Windows对象setTimeOut方法&lt;/title&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        function timedMsg() &#123;</span><br><span class="line">            //在5000毫秒后，也就是5秒后调用&quot;alert();&quot;</span><br><span class="line">            var t = setTimeout(&quot;alert(&apos;3秒钟到啦&apos;)&quot;, 3000)</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">        &lt;input type=&quot;button&quot; value=&quot;3秒钟后弹出警告框&quot; onClick=&quot;timedMsg()&quot;&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/javawebcongrumendaojingtong/3/windowObject/setTimeOutMethod.png" alt=""></p><h4 id="实例-另一个简单的计时"><a href="#实例-另一个简单的计时" class="headerlink" title="实例 另一个简单的计时"></a>实例 另一个简单的计时</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">timedText</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> t1 = setTimeout(<span class="string">"document.getElementById('txt').value='1 seconds!'"</span>, <span class="number">1000</span>)</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> t2 = setTimeout(<span class="string">"document.getElementById('txt').value='2 seconds!'"</span>, <span class="number">2000</span>)</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> t3 = setTimeout(<span class="string">"document.getElementById('txt').value='3 seconds!'"</span>, <span class="number">3000</span>)</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> t4 = setTimeout(<span class="string">"document.getElementById('txt').value='4 seconds!'"</span>, <span class="number">4000</span>)</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> t5 = setTimeout(<span class="string">"document.getElementById('txt').value='5 seconds!'"</span>, <span class="number">5000</span>)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"开始计时:"</span> <span class="attr">onClick</span>=<span class="string">"timedText()"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"txt"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/javawebcongrumendaojingtong/3/windowObject/setTimeOutMethod2.png" alt=""></p><h4 id="实例-递归无限计时"><a href="#实例-递归无限计时" class="headerlink" title="实例 递归无限计时"></a>实例 递归无限计时</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS Windows对象setTimeOut方法无限计时<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> c = <span class="number">0</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> t</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">timedCount</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">'txt'</span>).value = c</span></span><br><span class="line"><span class="undefined">            c = c + 1</span></span><br><span class="line"><span class="javascript">            <span class="comment">//递归</span></span></span><br><span class="line"><span class="javascript">            t = setTimeout(<span class="string">"timedCount()"</span>, <span class="number">1000</span>)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 按钮 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"开始计时！"</span> <span class="attr">onClick</span>=<span class="string">"timedCount()"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 输出框 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"txt"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/javawebcongrumendaojingtong/3/windowObject/setTimeOutMethodloop.png" alt=""></p><h4 id="实例-时钟"><a href="#实例-时钟" class="headerlink" title="实例 时钟"></a>实例 时钟</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS Windows对象setTimeOut方法时钟<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">startTime</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>()</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> h = today.getHours()</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> m = today.getMinutes()</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> s = today.getSeconds()</span></span><br><span class="line"><span class="javascript">            <span class="comment">// add a zero in front of numbers&lt;10</span></span></span><br><span class="line"><span class="undefined">            m = checkTime(m)</span></span><br><span class="line"><span class="undefined">            s = checkTime(s)</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">'txt'</span>).innerHTML = h + <span class="string">":"</span> + m + <span class="string">":"</span> + s</span></span><br><span class="line"><span class="javascript">            t = setTimeout(<span class="string">'startTime()'</span>, <span class="number">500</span>)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">checkTime</span>(<span class="params">i</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//如果该数小于10,在前面补上0</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (i &lt; <span class="number">10</span>) &#123; i = <span class="string">"0"</span> + i &#125;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> i</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"startTime()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"txt"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/javawebcongrumendaojingtong/3/windowObject/setTimeOutMethodshizhong.png" alt=""></p><h3 id="clearTimeout-方法"><a href="#clearTimeout-方法" class="headerlink" title="clearTimeout() 方法"></a>clearTimeout() 方法</h3><p><strong>定义和用法</strong></p><blockquote><p>clearTimeout() 方法可<strong>取消由 setTimeout() 方法设置的 timeout</strong>。<br><strong>语法</strong><br><code>clearTimeout(id_of_settimeout)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>id_of_settimeout</td><td>由 setTimeout() 返回的 ID 值。该值标识要取消的延迟执行代码块。</td></tr></tbody></table></blockquote><h4 id="实例-带有停止按钮的计时程序"><a href="#实例-带有停止按钮的计时程序" class="headerlink" title="实例 带有停止按钮的计时程序"></a>实例 带有停止按钮的计时程序</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS Windows对象setTimeOut方法clearTimeOUt方法<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> c = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> id_of_settimeout;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">timedCount</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">'txt'</span>).value = c</span></span><br><span class="line"><span class="undefined">            c = c + 1</span></span><br><span class="line"><span class="javascript">            id_of_settimeout = setTimeout(<span class="string">"timedCount()"</span>, <span class="number">1000</span>)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">stopCount</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">            clearTimeout(id_of_settimeout)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"开始计时"</span> <span class="attr">onClick</span>=<span class="string">"timedCount()"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"txt"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"停止计时"</span> <span class="attr">onClick</span>=<span class="string">"stopCount()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/javawebcongrumendaojingtong/3/windowObject/setTimeOutclearTimeOutMethod.png" alt=""></p><h2 id="打开关闭窗口方法"><a href="#打开关闭窗口方法" class="headerlink" title="打开关闭窗口方法"></a>打开关闭窗口方法</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>open()</td><td>打开一个新的浏览器窗口或查找一个已命名的窗口。</td></tr><tr><td>close()</td><td>关闭浏览器窗口。</td></tr></tbody></table><h3 id="open-方法"><a href="#open-方法" class="headerlink" title="open() 方法"></a>open() 方法</h3><blockquote><p><strong>定义和用法</strong><br>open() 方法用于打开一个新的浏览器窗口或查找一个已命名的窗口。<br><strong>语法</strong><br><code>window.open(URL,name,features,replace);</code><br>参数描述</p><ul><li><code>URL</code>：一个可选的字符串，声明了<strong>要在新窗口中显示的文档的 URL</strong>。如果省略了这个参数，或者它的值是空字符串，那么新窗口就不会显示任何文档。</li><li><code>name</code>：一个可选的字符串，该字符串是一个由逗号分隔的特征列表，其中包括数字、字母和下划线，该字符<strong>声明了新窗口的名称</strong>。这个名称可以用作标记 a 和 form 的属性 target 的值。如果该参数指定了一个已经存在的窗口，那么 open() 方法就不再创建一个新窗口，而只是返回对指定窗口的引用。在这种情况下，features 将被忽略。</li><li><p><code>features</code>: 一个可选的字符串，<strong>声明了新窗口要显示的标准浏览器的特征</strong>。如果省略该参数，新窗口将具有所有标准特征。详细说明如下：</p><ul><li>width=pixels 窗口的文档显示区的宽度。以像素计。</li><li>height=pixels 窗口文档显示区的高度。以像素计。</li><li>left=pixels 窗口的 x 坐标。以像素计。</li><li>top=pixels 窗口的 y 坐标。</li><li>channelmode=yes|no|1|0 是否使用剧院模式显示窗口。默认为 no。</li><li>directories=yes|no|1|0 是否添加目录按钮。默认为 yes。</li><li>fullscreen=yes|no|1|0 是否使用全屏模式显示浏览器。默认是 no。处于全屏模式的窗口必须同时处于剧院模式。</li><li>location=yes|no|1|0 是否显示地址字段。默认是 yes。</li><li>menubar=yes|no|1|0 是否显示菜单栏。默认是 yes。</li><li>resizable=yes|no|1|0 窗口是否可调节尺寸。默认是 yes。</li><li>scrollbars=yes|no|1|0 是否显示滚动条。默认是 yes。</li><li>status=yes|no|1|0 是否添加状态栏。默认是 yes。</li><li>titlebar=yes|no|1|0 是否显示标题栏。默认是 yes。</li><li>toolbar=yes|no|1|0 是否显示浏览器的工具栏。默认是 yes。</li></ul></li><li><p><code>replace</code>: 一个可选的布尔值。规定了装载到窗口的 URL 是<strong>在窗口的浏览历史中创建一个新条目，还是替换浏览历史中的当前条目</strong>。支持下面的值：</p><ul><li>true：URL 替换浏览历史中的当前条目。</li><li>false：URL 在浏览历史中创建新的条目。</li></ul></li></ul><p><strong>提示和注释</strong><br>重要事项：请不要混淆方法 Window.open() 与方法 Document.open()，这两者的功能完全不同。<strong>为了使您的代码清楚明白，请使用 Window.open()，而不要使用 open()</strong>。</p></blockquote><p><strong>读音</strong></p><table><thead><tr><th style="text-align:left">单词</th><th style="text-align:left">读音</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://fanyi.baidu.com/?#en/zh/features" target="_blank" rel="noopener">features</a></td><td style="text-align:left"><input type="button" onclick="paly_audioID20181110173318()" value="播放"></td></tr></tbody></table><p><audio src="http://fanyi.baidu.com/gettts?lan=en&text=features&spd=3&source=web" id="audioID20181110173318"></audio></p><script>function paly_audioID20181110173318(){var a=document.getElementById("audioID20181110173318");null!=a&&a.play()}</script><h4 id="实例-通过按钮来打开一个窗口"><a href="#实例-通过按钮来打开一个窗口" class="headerlink" title="实例 通过按钮来打开一个窗口"></a>实例 通过按钮来打开一个窗口</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Window对象 open方法<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">open_win</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.open(<span class="string">"http://www.lansheng.net.cn"</span>)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">button</span> <span class="attr">value</span>=<span class="string">"打开我的博客首页"</span> <span class="attr">onclick</span>=<span class="string">"open_win()"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="实例-打开一个新窗口并设置该窗口的形状，坐标"><a href="#实例-打开一个新窗口并设置该窗口的形状，坐标" class="headerlink" title="实例 打开一个新窗口并设置该窗口的形状，坐标"></a>实例 打开一个新窗口并设置该窗口的形状，坐标</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">opentest</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="undefined">    &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//打开新的页面,url为空,窗口宽度200,窗口高度100,x坐标100像素,y坐标100像素</span></span></span><br><span class="line"><span class="javascript">        myWindow = <span class="built_in">window</span>.open(<span class="string">''</span>, <span class="string">''</span>, <span class="string">'width=200,height=100,left=100,top=100'</span>)</span></span><br><span class="line"><span class="javascript">        myWindow.document.write(<span class="string">"This is 'myWindow'"</span>)</span></span><br><span class="line"><span class="undefined">        myWindow.focus()</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">button</span> <span class="attr">value</span>=<span class="string">"打开新页面"</span> <span class="attr">onclick</span>=<span class="string">"opentest()"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：<img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/javawebcongrumendaojingtong/3/windowObject/openMethodSetLooking.png" alt=""></p><h4 id="实例-打开多个窗口"><a href="#实例-打开多个窗口" class="headerlink" title="实例 打开多个窗口"></a>实例 打开多个窗口</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.open(<span class="string">"http://www.lansheng.net.cn/"</span>)</span><br><span class="line"><span class="built_in">window</span>.open(<span class="string">"http://www.w3school.com.cn/"</span>)</span><br></pre></td></tr></table></figure><h3 id="close-方法"><a href="#close-方法" class="headerlink" title="close() 方法"></a>close() 方法</h3><p><strong>定义和用法</strong><br>close() 方法用于<strong>关闭浏览器窗口</strong>。<br><strong>语法</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.close()</span><br></pre></td></tr></table></figure><p></p><p><strong>说明</strong><br>方法 close() 将关闭有 window 指定的顶层浏览器窗口。某个窗口可以通过调用 self.close() 或只调用 close() 来关闭其自身。<br><strong>只有通过 JavaScript 代码打开的窗口才能够由 JavaScript 代码关闭</strong>。这阻止了恶意的脚本终止用户的浏览器。</p><h4 id="实例-通过按钮打开和关闭浏览器窗口"><a href="#实例-通过按钮打开和关闭浏览器窗口" class="headerlink" title="实例 通过按钮打开和关闭浏览器窗口"></a>实例 通过按钮打开和关闭浏览器窗口</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">closeWin</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">      myWindow.close()</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">openWin</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="undefined">  &#123;</span></span><br><span class="line"><span class="javascript">    myWindow = <span class="built_in">window</span>.open(<span class="string">''</span>, <span class="string">'myWindow'</span>, <span class="string">'width=200,height=100,left=200,top=200'</span>)</span></span><br><span class="line"><span class="javascript">    myWindow.document.write(<span class="string">"This is 'myWindow'"</span>)</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"打开'myWindow'"</span> <span class="attr">onclick</span>=<span class="string">"openWin()"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"关闭'myWindow'"</span> <span class="attr">onclick</span>=<span class="string">"closeWin()"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>点击打开按钮：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/javawebcongrumendaojingtong/3/windowObject/openMethod.png" alt=""><br>点击关闭按钮：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/javawebcongrumendaojingtong/3/windowObject/close.png" alt=""></p><h2 id="调整窗口大小方法"><a href="#调整窗口大小方法" class="headerlink" title="调整窗口大小方法"></a>调整窗口大小方法</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>resizeBy()</td><td>按照指定的像素调整窗口的大小。</td></tr><tr><td>resizeTo()</td><td>把窗口的大小调整到指定的宽度和高度。</td></tr></tbody></table><h3 id="resizeBy-方法"><a href="#resizeBy-方法" class="headerlink" title="resizeBy() 方法"></a>resizeBy() 方法</h3><blockquote><p><strong>定义和用法</strong><br>resizeBy() 方法用于根据指定的像素来<strong>调整窗口的大小</strong>。<br><strong>语法</strong><br><code>resizeBy(width,height)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>width</td><td>必需。<code>要使窗口宽度增加的像素数</code>。可以是正、负数值。</td></tr><tr><td>height</td><td>可选。要使窗口高度增加的像素数。可以是正、负数值。</td></tr></tbody></table></blockquote><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>window对象 resizeBy方法.html<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">resizeWindow</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//窗体宽度和高度减少100像素,</span></span></span><br><span class="line"><span class="undefined">            openwin.resizeBy(-100, -100);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">openWin</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="undefined">        &#123;</span></span><br><span class="line"><span class="javascript">            openwin=<span class="built_in">window</span>.open(<span class="string">''</span>,<span class="string">''</span>,<span class="string">'width=200,height=200,left=200,top=200'</span>);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"openWin()"</span> <span class="attr">value</span>=<span class="string">"open window"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"resizeWindow()"</span> <span class="attr">value</span>=<span class="string">"Resize window"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>open window</code>：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/javawebcongrumendaojingtong/3/windowObject/resize/open.png" alt=""><br><code>Resize window</code>:<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/javawebcongrumendaojingtong/3/windowObject/resize/resize.png" alt=""></p><h3 id="resizeTo-方法"><a href="#resizeTo-方法" class="headerlink" title="resizeTo() 方法"></a>resizeTo() 方法</h3><p><strong>定义和用法</strong></p><blockquote><p>resizeTo() 方法用于<strong>把窗口大小调整为指定的宽度和高度</strong>。<br><strong>语法</strong><br><code>resizeTo(width,height)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>width</td><td>必需。想要调整到的窗口的宽度。以像素计。</td></tr><tr><td>height</td><td>可选。想要调整到的窗口的高度。以像素计。</td></tr></tbody></table></blockquote><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Window对象 resizeTo方法.html<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">resizeWindow</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">            openwin.resizeTo(100, 300);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">openWindow</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="undefined">        &#123;</span></span><br><span class="line"><span class="javascript">            openwin=<span class="built_in">window</span>.open(<span class="string">''</span>,<span class="string">''</span>,<span class="string">'width=200,height=200,left=200,top=100'</span>);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"openWindow()"</span> <span class="attr">value</span>=<span class="string">"opent window"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"resizeWindow()"</span> <span class="attr">value</span>=<span class="string">"ResizeTo window"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果<br><code>opent window</code>：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/javawebcongrumendaojingtong/3/windowObject/resizeto/open.png" alt=""><br><code>ResizeTo window</code>：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/javawebcongrumendaojingtong/3/windowObject/resizeto/resizeto.png" alt=""></p><h2 id="滚动页面方法"><a href="#滚动页面方法" class="headerlink" title="滚动页面方法"></a>滚动页面方法</h2><blockquote><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>scrollBy()</td><td>按照指定的像素值来滚动内容。</td></tr><tr><td>scrollTo()</td><td>把内容滚动到指定的坐标。</td></tr></tbody></table></blockquote><h3 id="scrollBy-方法"><a href="#scrollBy-方法" class="headerlink" title="scrollBy() 方法"></a>scrollBy() 方法</h3><blockquote><p><strong>定义和用法</strong><br>scrollBy() 方法可把内容滚动指定的像素数。<br><strong>语法</strong><br><code>scrollBy(xnum,ynum)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>xnum</td><td>必需。把文档向右滚动的像素数。</td></tr><tr><td>ynum</td><td>必需。把文档向下滚动的像素数。</td></tr></tbody></table></blockquote><h4 id="实例-通过-scrollBy-滚动文档"><a href="#实例-通过-scrollBy-滚动文档" class="headerlink" title="实例 通过 scrollBy() 滚动文档"></a>实例 通过 scrollBy() 滚动文档</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Windown对象 scrollBy方法.html<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">scrollWindow</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.scrollBy(<span class="number">500</span>, <span class="number">500</span>)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"scrollWindow()"</span> <span class="attr">value</span>=<span class="string">"Scroll"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.write(i + <span class="string">"&lt;br&gt;"</span>);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果<br>初始状态：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/javawebcongrumendaojingtong/3/windowObject/scrollBy/onload.png" alt=""><br>滚动后：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/javawebcongrumendaojingtong/3/windowObject/scrollBy/scrolBy.png" alt=""></p><h3 id="scrollTo-方法"><a href="#scrollTo-方法" class="headerlink" title="scrollTo() 方法"></a>scrollTo() 方法</h3><blockquote><p><strong>定义和用法</strong><br>scrollTo() 方法可把内容滚动到指定的坐标。<br><strong>语法</strong><br><code>scrollTo(xpos,ypos)</code></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>xpos</td><td>必需。要在窗口文档显示区左上角显示的文档的 x 坐标。</td></tr><tr><td>ypos</td><td>必需。要在窗口文档显示区左上角显示的文档的 y 坐标。</td></tr></tbody></table></blockquote><h4 id="实例-把内容滚动到指定坐标"><a href="#实例-把内容滚动到指定坐标" class="headerlink" title="实例 把内容滚动到指定坐标"></a>实例 把内容滚动到指定坐标</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Windown对象 scrollTo方法.html<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">scrollWindow</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.scrollTo(<span class="number">0</span>, <span class="number">1000</span>)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"scrollWindow()"</span> <span class="attr">value</span>=<span class="string">"Scroll"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.write(i + <span class="string">"&lt;br&gt;"</span>);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>滚动之前：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/javawebcongrumendaojingtong/3/windowObject/scrollTo/onload.png" alt=""><br>滚动之后:<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/javawebcongrumendaojingtong/3/windowObject/scrollTo/scrollTo.png" alt=""></p><h4 id="实例-回到顶部"><a href="#实例-回到顶部" class="headerlink" title="实例 回到顶部"></a>实例 回到顶部</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Windown对象 scrollTo方法.html<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">scrollWindow</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.scrollTo(<span class="number">0</span>, <span class="number">0</span>)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.write(i + <span class="string">"&lt;br&gt;"</span>);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"scrollWindow()"</span> <span class="attr">value</span>=<span class="string">"回到首部"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>文章底部按钮：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/javawebcongrumendaojingtong/3/windowObject/scrollTo/onloadTop.png" alt=""><br>回到顶部<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/javawebcongrumendaojingtong/3/windowObject/scrollTo/scrollToTop.png" alt=""></p><h2 id="移动窗口方法"><a href="#移动窗口方法" class="headerlink" title="移动窗口方法"></a>移动窗口方法</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>moveBy()</td><td>可相对窗口的当前坐标把它移动指定的像素。</td></tr><tr><td>moveTo()</td><td>把窗口的左上角移动到一个指定的坐标。</td></tr></tbody></table><h3 id="moveBy-方法"><a href="#moveBy-方法" class="headerlink" title="moveBy() 方法"></a>moveBy() 方法</h3><blockquote><p><strong>定义和用法</strong><br>moveBy() <strong>把窗口从当前的坐标移动指定的像素</strong>。<br><strong>语法</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.moveBy(x,y)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>x</td><td>要把窗口右移的像素数</td></tr><tr><td>y</td><td>要把窗口下移的像素数</td></tr></tbody></table></blockquote><h4 id="实例-移动浏览器窗体"><a href="#实例-移动浏览器窗体" class="headerlink" title="实例 移动浏览器窗体"></a>实例 移动浏览器窗体</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Window对象moveBy方法<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">moveWin</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">            myWindow.moveBy(200, 0)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">openWin</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            myWindow = <span class="built_in">window</span>.open(<span class="string">''</span>,<span class="string">''</span>,<span class="string">'width=200,height=100,top=200'</span>)</span></span><br><span class="line"><span class="javascript">            myWindow.document.write(<span class="string">"This is 'myWindow'"</span>)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"open 'myWindow'"</span> <span class="attr">onclick</span>=<span class="string">"openWin()"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Move 'myWindow'"</span> <span class="attr">onclick</span>=<span class="string">"moveWin()"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>移动前<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/javawebcongrumendaojingtong/3/windowObject/moveBy/onload.png" alt=""><br>移动后：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/javawebcongrumendaojingtong/3/windowObject/moveBy/moveby.png" alt=""></p><h2 id="弹窗方法"><a href="#弹窗方法" class="headerlink" title="弹窗方法"></a>弹窗方法</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>alert()</td><td>显示带有一段消息和一个确认按钮的警告框。</td></tr><tr><td>prompt()</td><td>显示可提示用户输入的对话框。</td></tr><tr><td>confirm()</td><td>显示带有一段消息以及确认按钮和取消按钮的对话框。</td></tr></tbody></table><p><strong>读音</strong></p><table><thead><tr><th style="text-align:left">列名</th><th style="text-align:left">列名</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://fanyi.baidu.com/?#en/zh/alert" target="_blank" rel="noopener">alert</a></td><td style="text-align:left"><input type="button" onclick="paly_audioID20181110173541()" value="播放"></td></tr><tr><td style="text-align:left"><a href="https://fanyi.baidu.com/?#en/zh/prompt" target="_blank" rel="noopener">prompt</a></td><td style="text-align:left"><input type="button" onclick="paly_audioID20181110173634()" value="播放"></td></tr><tr><td style="text-align:left"><a href="https://fanyi.baidu.com/?#en/zh/confirm" target="_blank" rel="noopener">confirm</a></td><td style="text-align:left"><input type="button" onclick="paly_audioID20181110173704()" value="播放"></td></tr></tbody></table><p><audio src="http://fanyi.baidu.com/gettts?lan=en&text=confirm&spd=3&source=web" id="audioID20181110173704"></audio></p><script>function paly_audioID20181110173704(){var a=document.getElementById("audioID20181110173704");null!=a&&a.play()}</script><audio src="http://fanyi.baidu.com/gettts?lan=en&text=prompt&spd=3&source=web" id="audioID20181110173634"></audio><script>function paly_audioID20181110173634(){var a=document.getElementById("audioID20181110173634");null!=a&&a.play()}</script><audio src="http://fanyi.baidu.com/gettts?lan=en&text=alert&spd=3&source=web" id="audioID20181110173541"></audio><script>function paly_audioID20181110173541(){var a=document.getElementById("audioID20181110173541");null!=a&&a.play()}</script><h3 id="弹窗警告框-alert-方法"><a href="#弹窗警告框-alert-方法" class="headerlink" title="弹窗警告框 alert()方法"></a>弹窗警告框 alert()方法</h3><blockquote><p><strong>定义和用法</strong><br>alert() 方法用于显示带有一条指定消息和一个 OK 按钮的警告框。<br><strong>语法</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(message)</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>message</td><td>要在 window 上弹出的对话框中显示的纯文本（而非 HTML 文本）</td></tr></tbody></table></blockquote><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS Windows对象alert方法<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">display_alert</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">"I am an alert box!!"</span>)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">disp_alert</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">"再打个招呼。这里演示了"</span> + <span class="string">"\n"</span> + <span class="string">"如何在消息框中添加折行。"</span>)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"display_alert()"</span> <span class="attr">value</span>=<span class="string">"Display alert box"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"disp_alert()"</span> <span class="attr">value</span>=<span class="string">"显示折行消息框"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/javawebcongrumendaojingtong/3/windowObject/alertshow.png" alt=""><br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/javawebcongrumendaojingtong/3/windowObject/newlinealert.png" alt=""></p><h3 id="输入框-prompt-方法"><a href="#输入框-prompt-方法" class="headerlink" title="输入框 prompt() 方法"></a>输入框 prompt() 方法</h3><blockquote><p><strong>定义和用法</strong><br>prompt() 方法用于显示可<strong>提示用户进行输入的对话框</strong>。<br><strong>语法</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prompt(text,defaultText)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>text</td><td>可选。要在对话框中显示的纯文本（而不是 HTML 格式的文本）。</td></tr><tr><td>defaultText</td><td>可选。默认的输入文本。</td></tr></tbody></table><p><strong>说明</strong><br>如果用户单击提示框的取消按钮，则返回 null。如果用户单击确认按钮，则返回输入字段当前显示的文本。<br>在用户点击确定按钮或取消按钮把对话框关闭之前，它将阻止用户对浏览器的所有输入。在调用 prompt() 时，将暂停对 JavaScript 代码的执行，在用户作出响应之前，不会执行下一条语句。</p></blockquote><h4 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Windown对象prompt方法.html<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">disp_prompt</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> name = prompt(<span class="string">"Please enter your name"</span>, <span class="string">"xiaoming"</span>)</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (name != <span class="literal">null</span> &amp;&amp; name != <span class="string">""</span>) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.write(<span class="string">"Hello "</span> + name + <span class="string">"!"</span>)</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"disp_prompt()"</span> <span class="attr">value</span>=<span class="string">"Display a prompt box"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>点击按钮，输入xiaoming(默认)：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/javawebcongrumendaojingtong/3/windowObject/prompt/input.png" alt=""><br>如果点击确定：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/javawebcongrumendaojingtong/3/windowObject/prompt/yes.png" alt=""><br>如果点击取消， prompt()方法返回null,显示输入错误：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/javawebcongrumendaojingtong/3/windowObject/prompt/no.png" alt=""></p><h3 id="confirm-方法"><a href="#confirm-方法" class="headerlink" title="confirm() 方法"></a>confirm() 方法</h3><blockquote><p><strong>定义和用法</strong><br>confirm() 方法用于显示一个带有指定消息和 OK 及取消按钮的对话框。<br><strong>语法</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">confirm(message)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>message</td><td>要在 window 上弹出的对话框中显示的纯文本（而非 HTML 文本）</td></tr></tbody></table><p><strong>说明</strong><br>如果用户点击确定按钮，则 confirm() 返回 true。如果点击取消按钮，则 confirm() 返回 false。<br>在用户点击确定按钮或取消按钮把对话框关闭之前，它将阻止用户对浏览器的所有输入。在调用 confirm() 时，将暂停对 JavaScript 代码的执行，在用户作出响应之前，不会执行下一条语句。</p></blockquote><h4 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Windown对象 confirm方法.html<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">disp_confirm</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> r = confirm(<span class="string">"Press a button"</span>)</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (r == <span class="literal">true</span>) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.write(<span class="string">"You pressed OK!"</span>)</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.write(<span class="string">"You pressed Cancel!"</span>)</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"disp_confirm()"</span> <span class="attr">value</span>=<span class="string">"Display a confirm box"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>点击按钮：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/javawebcongrumendaojingtong/3/windowObject/confirm/click.png" alt=""><br>如果点确认：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/javawebcongrumendaojingtong/3/windowObject/confirm/ok.png" alt=""><br>如果点取消：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/javawebcongrumendaojingtong/3/windowObject/confirm/cancle.png" alt=""></p><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>createPopup()</td><td>创建一个 pop-up 窗口。</td></tr><tr><td>print()</td><td>打印当前窗口的内容。</td></tr></tbody></table><h3 id="createPopup-方法"><a href="#createPopup-方法" class="headerlink" title="createPopup() 方法"></a>createPopup() 方法</h3><blockquote><p><strong>定义和用法</strong><br>createPopup() 方法用于创建一个 pop-up 窗口。pop-up窗口就是弹出窗口，经常用于弹窗广告窗口。<br><strong>语法</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.createPopup()</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p><strong>注意</strong>： <strong>只有 IE 浏览器支持 createPopup() 方法，其他浏览器都不支持</strong>。<br>既然这样，就不给出实例了，珍爱生命远离IE</p></blockquote><h3 id="print-方法"><a href="#print-方法" class="headerlink" title="print() 方法"></a>print() 方法</h3><p><strong>定义和用法</strong></p><blockquote><p>print() 方法用于打印当前窗口的内容。<br>调用 print() 方法所引发的行为就像用户单击浏览器的打印按钮。通常，这会产生一个对话框，让用户可以取消或定制打印请求。<br><strong>语法</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.print()</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p></p></blockquote><h4 id="实例-打印当前html页面"><a href="#实例-打印当前html页面" class="headerlink" title="实例 打印当前html页面"></a>实例 打印当前html页面</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Window对象print()方法.html<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">printpage</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.print()</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Print this page"</span> <span class="attr">onclick</span>=<span class="string">"printpage()"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/javawebcongrumendaojingtong/3/windowObject/print/print.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.w3school.com.cn/jsref/dom_obj_window.asp" target="_blank" rel="noopener">JavaScript Window 对象</a><br><a href="http://www.w3school.com.cn/jsref/met_win_settimeout.asp" target="_blank" rel="noopener">JavaScript Window 对象 setTimeOut方法</a><br>本文链接: <a href="https://www.lansheng.net.cn/blog/7d3bc6dd/">JavaScript常用对象1 Window对象</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Java Web从入门到精通 </category>
          
          <category> 第3章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hexo next 解决手机端表格英文显示错误 让td标签中英文按单词换行</title>
      <link href="/blog/200a993a/"/>
      <url>/blog/200a993a/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="https://www.lansheng.net.cn/blog/200a993a/#问题描述">问题描述</a></li><li><a href="https://www.lansheng.net.cn/blog/200a993a/#修改next主题样式文件">修改next主题样式文件</a></li><li><a href="https://www.lansheng.net.cn/blog/200a993a/#写表格时用空格分隔每个单词">写表格时用空格分隔每个单词</a><ul><li><a href="https://www.lansheng.net.cn/blog/200a993a/#实例-错误写法">实例 错误写法</a></li><li><a href="https://www.lansheng.net.cn/blog/200a993a/#实例-正确写法">实例 正确写法</a></li></ul></li><li><a href="https://www.lansheng.net.cn/blog/200a993a/#参考链接">参考链接</a></li></ul><a id="more"></a><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>最近写完文章后部署后，在手机端查看的时候，我发现英文显示不正确了，其他栏目特别大，英文行压缩成小小的一列，看起来很别扭，如下所示：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98/TableShowNotRight/showNoRightInPhone.jpg" alt=""></p><h2 id="修改next主题样式文件"><a href="#修改next主题样式文件" class="headerlink" title="修改next主题样式文件"></a>修改next主题样式文件</h2><p>修改样式文件,打开<strong>next主题样式文件</strong>：<code>E:\Blog\bolg5\themes\next\source\css\_custom\custom.styl</code>,在其中添加下面的CSS代码：<br></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">td</span>&#123;</span><br><span class="line">    <span class="attribute">word-break</span>: normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>然后<code>hexo clean&amp;&amp;hexo g&amp;&amp;hexo d</code>部署，在手机端打开就可以正常显示了。</p><h2 id="写表格时用空格分隔每个单词"><a href="#写表格时用空格分隔每个单词" class="headerlink" title="写表格时用空格分隔每个单词"></a>写表格时用空格分隔每个单词</h2><p>在表格太长的英文单词不要写成一串，中间用空格分隔开，这样手机端就能更好的从空格处换行。例如对于函数:<code>fontcolor(colorValue)</code>这种写法所有的单词写成一串，浏览器会把它当成一个单词,这样移动端显示的时候，无法拆分这个几个单词，这样就会显示在一行,从而让这一列特别大，挤占其他列的空间。<br>应该用空格把单词分开写成<code>fontcolor( colorValue )</code>，这样就可以正确的换行了。</p><h3 id="实例-错误写法"><a href="#实例-错误写法" class="headerlink" title="实例 错误写法"></a>实例 错误写法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|方法|描述|结果|</span><br><span class="line">|:--|:--|</span><br><span class="line">|`fontcolor(colorValue)`|字符串设置颜色|在字符串首尾加上 HTML的&amp;lt;font color=&quot;colorValue&quot;&amp;gt;&amp;lt;/font&amp;gt; 标记对, 设置 color属性的值为参数colorValuer， color属性可以是颜色的十六进制值,也可以是颜色的预定义名|</span><br><span class="line">|`fontsize(sizeValue)`|字符串设置大小|在字符串首尾加上 HTML的&amp;lt;font size=&quot;sizeValue&quot;&amp;gt;&amp;lt;/font&amp;gt; 标记对,并设置size属性的值为参数sizeValue|</span><br><span class="line">|`anchor(name)`|创建 HTML 锚|在字符串首尾加上 HTML的 &amp;lt;a name=&quot;name&quot;&amp;gt;&amp;lt;/a&amp;gt; 标记对|</span><br><span class="line">|`link(url)`|创建HTML超链接|在字符串首尾加上 HTML的 &amp;lt;a href=&quot;url&quot;&amp;gt;&amp;lt;/a&amp;gt; 标记对|</span><br></pre></td></tr></table></figure><p>显示效果(注意用手机打开这篇文章)：</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th><th>结果</th></tr></thead><tbody><tr><td style="text-align:left"><code>fontcolor(colorValue)</code></td><td style="text-align:left">字符串设置颜色</td><td>在字符串首尾加上 HTML的&lt;font color=”colorValue”&gt;&lt;/font&gt; 标记对, 设置 color属性的值为参数colorValuer， color属性可以是颜色的十六进制值,也可以是颜色的预定义名</td></tr><tr><td style="text-align:left"><code>fontsize(sizeValue)</code></td><td style="text-align:left">字符串设置大小</td><td>在字符串首尾加上 HTML的&lt;font size=”sizeValue”&gt;&lt;/font&gt; 标记对,并设置size属性的值为参数sizeValue</td></tr><tr><td style="text-align:left"><code>anchor(name)</code></td><td style="text-align:left">创建HTML锚</td><td>在字符串首尾加上 HTML的 &lt;a name=”name”&gt;&lt;/a&gt; 标记对</td></tr><tr><td style="text-align:left"><code>link(url)</code></td><td style="text-align:left">创建HTML超链接</td><td>在字符串首尾加上 HTML的 &lt;a href=”url”&gt;&lt;/a&gt; 标记对</td></tr></tbody></table><h3 id="实例-正确写法"><a href="#实例-正确写法" class="headerlink" title="实例 正确写法"></a>实例 正确写法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|方法|描述|结果|</span><br><span class="line">|:--|:--|</span><br><span class="line">|`fontcolor( colorValue )`|字符串设置颜色|在字符串首尾加上 HTML的&amp;lt;font color=&quot;colorValue&quot;&amp;gt;&amp;lt;/font&amp;gt; 标记对, 设置 color属性的值为参数colorValuer， color属性可以是颜色的十六进制值,也可以是颜色的预定义名|</span><br><span class="line">|`fontsize( sizeValue )`|字符串设置大小|在字符串首尾加上 HTML的&amp;lt;font size=&quot;sizeValue&quot;&amp;gt;&amp;lt;/font&amp;gt; 标记对,并设置size属性的值为参数sizeValue|</span><br><span class="line">|`anchor( name )`|创建 HTML 锚|在字符串首尾加上 HTML的 &amp;lt;a name=&quot;name&quot;&amp;gt;&amp;lt;/a&amp;gt; 标记对|</span><br><span class="line">|`link( url )`|创建HTML超链接|在字符串首尾加上 HTML的 &amp;lt;a href=&quot;url&quot;&amp;gt;&amp;lt;/a&amp;gt; 标记对|</span><br></pre></td></tr></table></figure><p>显示效果：</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th><th>结果</th></tr></thead><tbody><tr><td style="text-align:left"><code>fontcolor( colorValue )</code></td><td style="text-align:left">字符串设置颜色</td><td>在字符串首尾加上 HTML的 &lt;font color=”colorValue”&gt;&lt;/font&gt; 标记对, 设置 color属性的值为参数colorValuer， color属性可以是颜色的十六进制值,也可以是颜色的预定义名</td></tr><tr><td style="text-align:left"><code>fontsize( sizeValue )</code></td><td style="text-align:left">字符串设置大小</td><td>在字符串首尾加上 HTML的&lt;font size=”sizeValue”&gt;&lt;/font&gt; 标记对,并设置size属性的值为参数sizeValue</td></tr><tr><td style="text-align:left"><code>anchor( name )</code></td><td style="text-align:left">创建HTML锚</td><td>在字符串首尾加上 HTML的 &lt;a name=”name”&gt;&lt;/a&gt; 标记对</td></tr><tr><td style="text-align:left"><code>link(url)</code></td><td style="text-align:left">创建HTML超链接</td><td>在字符串首尾加上 HTML的 &lt;a href=”url”&gt;&lt;/a&gt; 标记对</td></tr></tbody></table><h2 id="css-word-break属性"><a href="#css-word-break属性" class="headerlink" title="css word-break属性"></a>css word-break属性</h2><p>word-break属性用来规定自动换行的处理方式，它不仅可以让浏览器在半角空格或连字符的后面换行，也可以实现在任意位置换行，可选值有 <code>normal | keep-all | break-all</code>，默认值为 normal。</p><ul><li><code>normal</code> 表示根据语言自身的换行规则，确定换行方式，<strong>中文将容器边界处的汉字换到下一行，西方文字则将整个单词换到下一行</strong>；</li><li><code>keep-all</code> 表示不允许把单词截断，<strong>只能在半角空格或连字符处换行</strong>；</li><li><code>break-all</code> 允许<strong>把单词截断，在单词内换行</strong>。</li></ul><h2 id="white-space、word-wrap、word-break的区别"><a href="#white-space、word-wrap、word-break的区别" class="headerlink" title="white-space、word-wrap、word-break的区别"></a>white-space、word-wrap、word-break的区别</h2><ul><li><code>white-space: nowrap</code> 让一段文本不换行，在一行内显示。</li><li><code>word-wrap: normal</code> 使一个单词或URL不折行，在一行内显示。</li><li><code>word-wrap: break-word</code> 在容器边界自动换行，会把整个长单词看成一个整体放到下一行，而不会把单词截断。</li><li><code>word-break: break-all</code> 在行末宽度不够显示整个单词时，会把单词截断。</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/qq_26702601/article/details/78497609#commentBox" target="_blank" rel="noopener">td自动换行时不切断英文单词</a><br><a href="https://blog.csdn.net/ixygj197875/article/details/79326788" target="_blank" rel="noopener">CSS 单词换行 word-break属性</a></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/200a993a/">hexo next 解决手机端表格英文显示错误 让td标签中英文按单词换行</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> 遇到问题 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JavaScript常用对象2 String对象</title>
      <link href="/blog/f52e78d1/"/>
      <url>/blog/f52e78d1/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><p><strong>目录</strong></p><ul><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#String对象属性">String对象属性</a><ul><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#实例-获取字符串对象的长度">实例 获取字符串对象的长度</a></li></ul></li><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#String对象方法">String对象方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#在字符串两端添加html标记的方法">在字符串两端添加html标记的方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#实例">实例</a></li></ul></li><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#获取字符串中某个下标对应的字符">获取字符串中某个下标对应的字符</a></li><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#字符串连接方法">字符串连接方法</a></li><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#查找子字符串的下标方法">查找子字符串的下标方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#实例：从一个邮箱地址中查找-所在的位置">实例：从一个邮箱地址中查找@所在的位置</a></li></ul></li><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#解码Unicode值">解码Unicode值</a><ul><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#实例">实例</a></li></ul></li><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#比较两个字符串是否相等">比较两个字符串是否相等</a></li><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#大小写转换方法">大小写转换方法</a></li><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#正则表达式相关方法">正则表达式相关方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#search-方法">search()方法</a></li><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#match-方法">match()方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#实例：不使用正则表达式">实例：不使用正则表达式</a></li><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#实例2：使用正则全局匹配">实例2：使用正则全局匹配</a></li></ul></li><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#replace-方法">replace()方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#实例-使用字符串替换匹配文本">实例 使用字符串替换匹配文本</a></li><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#实例-使用正则表达式进行替换">实例 使用正则表达式进行替换</a></li><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#实例-替换所有正则匹配的字串">实例 替换所有正则匹配的字串</a></li><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#实例-使用函数：把字符串中所有单词的首字母都转换为大写">实例 使用函数：把字符串中所有单词的首字母都转换为大写</a></li></ul></li><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#split-方法">split() 方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#实例：使用空格和空字符进行分割">实例：使用空格和空字符进行分割</a></li><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#实例-字符串分割为字符">实例 字符串分割为字符</a></li><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#实例:使用正则表达式进行分割">实例:使用正则表达式进行分割</a></li><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#实例：分隔符位于首部和尾部的情况">实例：分隔符位于首部和尾部的情况</a></li></ul></li></ul></li><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#截取子串相关方法">截取子串相关方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#slice-方法">slice() 方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#实例-提取字符串中从位置-6-开始的所有字符">实例 提取字符串中从位置 6 开始的所有字符</a></li><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#实例-提取字符串中从位置-6-到位置-11-的所有字符">实例 提取字符串中从位置 6 到位置 11 的所有字符</a></li><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#实例-提取字符串中从位置--1-到位置--6-的所有字符">实例 提取字符串中从位置 -1 到位置 -6 的所有字符</a></li></ul></li><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#substring-方法">substring() 方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#实例-">实例</a></li></ul></li><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#substr-方法">substr() 方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#实例">实例</a></li></ul></li></ul></li><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#对象方法">对象方法</a><ul><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#toString-方法">toString() 方法</a></li><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#valueOf-方法">valueOf() 方法</a></li></ul></li><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#String-对象描述">String 对象描述</a></li><li><a href="https://www.lansheng.net.cn/blog/f52e78d1/#参考链接">参考链接</a></li></ul></li></ul><a id="more"></a><p>String对象是动态对象,需要创建对象实例后才能引用其属性和方法。但是,由于在 JavaScript中可以将用单引号或双引号括起来的一个字符串当作一个字符串对象的实例,所以<strong>可以直接在某个字符串后面加上点“.”去调用Srng对象的属性和方法</strong>。下面对Strng对象的常用属性和方法进行详细介绍。</p><h1 id="String对象属性"><a href="#String对象属性" class="headerlink" title="String对象属性"></a>String对象属性</h1><p>String对象最常用的属性是 length,该属性用于返回String对象的长度。 length属性的语法格式如下<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string. length</span><br></pre></td></tr></table></figure><p></p><p>返回值:一个只读的整数,它代表指定<strong>字符串中的字符数</strong>,每<strong>个汉字按一个字符计算</strong></p><h2 id="实例-获取字符串对象的长度"><a href="#实例-获取字符串对象的长度" class="headerlink" title="实例 获取字符串对象的长度"></a>实例 获取字符串对象的长度</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.alert(<span class="string">"中文123abc"</span>+<span class="string">" 有 "</span>+<span class="string">"中文123abc"</span>.length+<span class="string">" 个字符"</span>);</span></span><br><span class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">中文123abc有8个字符</span><br></pre></td></tr></table></figure><p></p><h1 id="String对象方法"><a href="#String对象方法" class="headerlink" title="String对象方法"></a>String对象方法</h1><p>String对象提供了很多用于对字符串进行操作的方法,如下表所示。</p><h2 id="在字符串两端添加html标记的方法"><a href="#在字符串两端添加html标记的方法" class="headerlink" title="在字符串两端添加html标记的方法"></a>在字符串两端添加html标记的方法</h2><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th><th>结果</th></tr></thead><tbody><tr><td style="text-align:left"><code>italics()</code></td><td style="text-align:left">使用斜体显示字符串</td><td>在字符串首尾加上 HTML的 &lt;i&gt;&lt;/i&gt; 标记对</td></tr><tr><td style="text-align:left"><code>bold()</code></td><td style="text-align:left">使用粗体显示字符串</td><td>在字符串首尾加上 HTML的 &lt;b&gt;&lt;/b&gt; 标记对</td></tr><tr><td style="text-align:left"><code>big()</code></td><td style="text-align:left">用大号字体显示字符串</td><td>在字符串首尾加上 HTML的 &lt;big&gt;&lt;/big&gt; 标记对</td></tr><tr><td style="text-align:left"><code>small()</code></td><td style="text-align:left">使用小字号来显示字符串</td><td>在字符串首尾加上 HTML的 &lt;small&gt;&lt;/small&gt; 标记对</td></tr><tr><td style="text-align:left"><code>strike()</code></td><td style="text-align:left">使用删除线来显示字符串</td><td>在字符串首尾加上 HTML的 &lt;strike&gt;&lt;/strike&gt; 标记对</td></tr><tr><td style="text-align:left"><code>fixed()</code></td><td style="text-align:left">以打字机文本显示字符串</td><td>在字符串首尾加上 HTML的 &lt;fixed&gt;&lt;/fixed&gt; 标记对</td></tr><tr><td style="text-align:left"><code>blink()</code></td><td style="text-align:left">显示闪动字符串</td><td>在字符串首尾加上 HTML的 &lt;blink&gt;&lt;/blink&gt; 标记对</td></tr><tr><td style="text-align:left"><code>sup()</code></td><td style="text-align:left">把字符串显示为上标</td><td>在字符串首尾加上 HTML的 &lt;sup&gt;&lt;/sup&gt; 标记对</td></tr><tr><td style="text-align:left"><code>sub()</code></td><td style="text-align:left">把字符串显示为下标</td><td>在字符串首尾加上 HTML的 &lt;sub&gt;&lt;/sub&gt; 标记对</td></tr><tr><td style="text-align:left"><code>fontcolor( colorValue)</code></td><td style="text-align:left">字符串设置颜色</td><td>在字符串首尾加上 HTML的 &lt;font color=”colorValue”&gt;&lt;/font&gt; 标记对, 设置 color属性的值为参数colorValuer， color属性可以是颜色的十六进制值,也可以是颜色的预定义名</td></tr><tr><td style="text-align:left"><code>fontsize( sizeValue)</code></td><td style="text-align:left">字符串设置大小</td><td>在字符串首尾加上 HTML的 &lt;font size=”sizeValue”&gt;&lt;/font&gt; 标记对,并设置size属性的值为参数sizeValue</td></tr><tr><td style="text-align:left"><code>anchor( name)</code></td><td style="text-align:left">创建 HTML 锚</td><td>在字符串首尾加上 HTML的 &lt;a name=”name”&gt;&lt;/a&gt; 标记对</td></tr><tr><td style="text-align:left"><code>link( url)</code></td><td style="text-align:left">创建HTML超链接</td><td>在字符串首尾加上 HTML的 &lt;a href=”url”&gt;&lt;/a&gt; 标记对</td></tr></tbody></table><p>这里blink标签好像没有闪烁，我在火狐和谷歌浏览器中都打开了，都没有看到闪烁的效果。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.rightalign</span> &#123;</span></span><br><span class="line"><span class="undefined">            text-align: right;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">        code &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">color</span>: <span class="selector-id">#fc6423</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">background</span>: <span class="selector-id">#fbf7f8</span>;</span></span><br><span class="line"><span class="undefined">            margin: 2px;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> str = <span class="string">"显示效果"</span>;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.write(<span class="string">"&lt;table border=\"1\"&gt;"</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="xml">        document.write("<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">\</span>"<span class="attr">rightalign</span>\"&gt;</span>斜体:<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">\</span>"<span class="attr">rightalign</span>\"&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>str.italics()<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>" + "参考文本 "+str.italics() + "<span class="tag">&lt;/<span class="name">td</span>&gt;</span>");</span></span><br><span class="line"><span class="xml">        document.write("<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">\</span>"<span class="attr">rightalign</span>\"&gt;</span>粗体:<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">\</span>"<span class="attr">rightalign</span>\"&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>str.bold()<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>" + "参考文本 "+str.bold() + "<span class="tag">&lt;/<span class="name">td</span>&gt;</span>");</span></span><br><span class="line"><span class="xml">        document.write("<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">\</span>"<span class="attr">rightalign</span>\"&gt;</span>大号字:<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">\</span>"<span class="attr">rightalign</span>\"&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>str.big()<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>" + "参考文本 "+str.big() + "<span class="tag">&lt;/<span class="name">td</span>&gt;</span>");</span></span><br><span class="line"><span class="xml">        document.write("<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">\</span>"<span class="attr">rightalign</span>\"&gt;</span>小号字:<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">\</span>"<span class="attr">rightalign</span>\"&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>str.small()<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>" + "参考文本 "+str.small() + "<span class="tag">&lt;/<span class="name">td</span>&gt;</span>");</span></span><br><span class="line"><span class="xml">        document.write("<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">\</span>"<span class="attr">rightalign</span>\"&gt;</span>删除线:<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">\</span>"<span class="attr">rightalign</span>\"&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>str.strike()<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>" + "参考文本 "+str.strike() + "<span class="tag">&lt;/<span class="name">td</span>&gt;</span>");</span></span><br><span class="line"><span class="xml">        document.write("<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">\</span>"<span class="attr">rightalign</span>\"&gt;</span>打字机文本:<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">\</span>"<span class="attr">rightalign</span>\"&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>str.fixed()<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>" + "参考文本 "+str.fixed() + "<span class="tag">&lt;/<span class="name">td</span>&gt;</span>");</span></span><br><span class="line"><span class="xml">        document.write("<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">\</span>"<span class="attr">rightalign</span>\"&gt;</span>闪烁文本:<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">\</span>"<span class="attr">rightalign</span>\"&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>str.blink()<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>" + "参考文本 "+str.blink() + "<span class="tag">&lt;/<span class="name">td</span>&gt;</span>");</span></span><br><span class="line"><span class="xml">        document.write("<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">\</span>"<span class="attr">rightalign</span>\"&gt;</span>上标:<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">\</span>"<span class="attr">rightalign</span>\"&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>str.sup()<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>"+ "参考文本 "+str.sup() + "<span class="tag">&lt;/<span class="name">td</span>&gt;</span>");</span></span><br><span class="line"><span class="xml">        document.write("<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">\</span>"<span class="attr">rightalign</span>\"&gt;</span>下标:<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">\</span>"<span class="attr">rightalign</span>\"&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>str.sub()<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>" + "参考文本 "+str.sub() + "<span class="tag">&lt;/<span class="name">td</span>&gt;</span>");</span></span><br><span class="line"><span class="xml">        document.write("<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">\</span>"<span class="attr">rightalign</span>\"&gt;</span>红色字体:<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">\</span>"<span class="attr">rightalign</span>\"&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>str.fontcolor(\"red\")<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>" + "参考文本 "+str.fontcolor("red") + "<span class="tag">&lt;/<span class="name">td</span>&gt;</span>");</span></span><br><span class="line"><span class="xml">        document.write("<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">\</span>"<span class="attr">rightalign</span>\"&gt;</span>字体大小:<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">\</span>"<span class="attr">rightalign</span>\"&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>str.fontsize(18)<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>" + "参考文本 "+str.fontsize(18) + "<span class="tag">&lt;/<span class="name">td</span>&gt;</span>");</span></span><br><span class="line"><span class="xml">        document.write("<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">\</span>"<span class="attr">rightalign</span>\"&gt;</span>锚点:<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">\</span>"<span class="attr">rightalign</span>\"&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>str.anchor(\"锚点\")<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>" + "参考文本 "+str.anchor("锚点") + "<span class="tag">&lt;/<span class="name">td</span>&gt;</span>");</span></span><br><span class="line"><span class="xml">        document.write("<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">\</span>"<span class="attr">rightalign</span>\"&gt;</span>超链接:<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">\</span>"<span class="attr">rightalign</span>\"&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>str.link(\"http://www.lansheng.net.cn\")<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>" + "参考文本 "+str.link("http://www.lansheng.net.cn") + "<span class="tag">&lt;/<span class="name">td</span>&gt;</span>");</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.write(<span class="string">"&lt;/table&gt;"</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.write(<span class="string">"&lt;br&gt;"</span>);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#锚点"</span>&gt;</span>跳转到锚点<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>显示效果<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/javawebcongrumendaojingtong/3/6/StringAddhtmlTagMethods.png" alt=""></p><h2 id="获取字符串中某个下标对应的字符"><a href="#获取字符串中某个下标对应的字符" class="headerlink" title="获取字符串中某个下标对应的字符"></a>获取字符串中某个下标对应的字符</h2><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>charAt(index)</code></td><td style="text-align:left">返回字符串对象中指定索引号的字符组成的字符串,位置的有效值为0到字符串长度减1的数值。一个字符串的第一个字符的索引位置为0,第二个字符位于索引位置1,依此类推。当指定的索引位置超出有效范围时,<code>charAt()</code>方法返回一个空字符串</td></tr><tr><td style="text-align:left"><code>charCodeAt(index)</code></td><td style="text-align:left">返回一个整数,该整数表示字符串对象中指定位置处的字符的Unicode编码</td></tr></tbody></table><h2 id="字符串连接方法"><a href="#字符串连接方法" class="headerlink" title="字符串连接方法"></a>字符串连接方法</h2><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>concat(sl,…,sn)</code></td><td style="text-align:left">将调用方法的字符串与指定字符串结合,结果返回新字符串</td></tr></tbody></table><p>略</p><h2 id="查找子字符串的下标方法"><a href="#查找子字符串的下标方法" class="headerlink" title="查找子字符串的下标方法"></a>查找子字符串的下标方法</h2><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>indexOf(patterm)</code></td><td style="text-align:left">返回字符串中包含 pattern所代表参数第一次出现的位置值。 如果该字符串中不包含要查找的模式,则返回<code>-1</code></td></tr><tr><td style="text-align:left"><code>indexOf(patterm, startIndex)</code></td><td style="text-align:left">返回字符串中包含 pattern所代表参数最后一次出现的位置值,如果该字符串中不包含要查找的模式,则返回-1, 只是<strong>检索从 startIndex指定的位置开始</strong></td></tr><tr><td style="text-align:left"><code>lastIndexOf(pattern)</code></td><td style="text-align:left">返回字符串中包含 pattern所代表参数<strong>最后一次出现的位置</strong>值, 如果该字符串中不包含要查找的模式,则返回-1</td></tr><tr><td style="text-align:left"><code>lastIndexOf(pattern, startIndex)</code></td><td style="text-align:left">返回字符串中包含 patten所代表参数<strong>最后一次出现的位置</strong>值, 如果该字符串中不包含要査找的模式,则返回-1,只是<strong>检索从 startIndex指定的位置开始</strong></td></tr></tbody></table><h3 id="实例：从一个邮箱地址中查找-所在的位置"><a href="#实例：从一个邮箱地址中查找-所在的位置" class="headerlink" title="实例：从一个邮箱地址中查找@所在的位置"></a>实例：从一个邮箱地址中查找@所在的位置</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS String对象下标相关方法测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> email=<span class="string">"123456789@123.com"</span>;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.write(email+<span class="string">"中第一个@123的下标为："</span>+email.indexOf(<span class="string">"@123"</span>)+<span class="string">"&lt;br&gt;"</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.write(email+<span class="string">"中最后一个123的开始下标为："</span>+email.lastIndexOf(<span class="string">"123"</span>)+<span class="string">"&lt;br&gt;"</span>);</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果，浏览器显示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">123456789@123.com中第一个@123的下标为：9</span><br><span class="line">123456789@123.com中最后一个123的开始下标为：10</span><br></pre></td></tr></table></figure><p></p><h2 id="解码Unicode值"><a href="#解码Unicode值" class="headerlink" title="解码Unicode值"></a>解码Unicode值</h2><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">fromCharCode()</td><td style="text-align:left">可接受一个指定的 Unicode 值，然后返回一个字符串</td></tr></tbody></table><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="built_in">document</span>.write(<span class="built_in">String</span>.fromCharCode(<span class="number">72</span>,<span class="number">69</span>,<span class="number">76</span>,<span class="number">76</span>,<span class="number">79</span>))</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;br /&gt;"</span>)</span><br><span class="line"><span class="built_in">document</span>.write(<span class="built_in">String</span>.fromCharCode(<span class="number">65</span>,<span class="number">66</span>,<span class="number">67</span>))</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HELLO</span><br><span class="line">ABC</span><br></pre></td></tr></table></figure><p></p><h2 id="比较两个字符串是否相等"><a href="#比较两个字符串是否相等" class="headerlink" title="比较两个字符串是否相等"></a>比较两个字符串是否相等</h2><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>localeCompare(s)</code></td><td style="text-align:left">用特定比较方法比较字符串与s字符串。如果字符串相等,则返回0,否则返回非0数字值</td></tr></tbody></table><h2 id="大小写转换方法"><a href="#大小写转换方法" class="headerlink" title="大小写转换方法"></a>大小写转换方法</h2><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">toLocaleLowerCase()</td><td style="text-align:left">把字符串转换为小写。</td></tr><tr><td style="text-align:left">toLocaleUpperCase()</td><td style="text-align:left">把字符串转换为大写。</td></tr><tr><td style="text-align:left">toLowerCase()</td><td style="text-align:left">把字符串转换为小写。</td></tr><tr><td style="text-align:left">toUpperCase()</td><td style="text-align:left">把字符串转换为大写。</td></tr></tbody></table><p>实例：省略</p><h2 id="正则表达式相关方法"><a href="#正则表达式相关方法" class="headerlink" title="正则表达式相关方法"></a>正则表达式相关方法</h2><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">match()</td><td style="text-align:left">找到一个或多个正则表达式的匹配</td></tr><tr><td style="text-align:left">replace()</td><td style="text-align:left">替换与正则表达式匹配的子串</td></tr><tr><td style="text-align:left">search(regexp)</td><td style="text-align:left">检索与正则表达式相匹配的值</td></tr><tr><td style="text-align:left">split(separator, howmany)</td><td style="text-align:left">把一个字符串分割成字符串数组。</td></tr></tbody></table><p>javascript中的整个则表达式需要写在两个斜杠<code>//</code>之间</p><h3 id="search-方法"><a href="#search-方法" class="headerlink" title="search()方法"></a>search()方法</h3><blockquote><p><strong>定义和用法</strong><br>search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。<br><strong>语法</strong><br><code>stringObject.search(regexp)</code><br><strong>参数</strong><br>regexp: 该参数可以是需要在 stringObject 中检索的子串，也可以是需要检索的 RegExp 对象。<br>注释：<strong>search() 对大小写敏感，要执行忽略大小写的检索，要在正则表达式式标记后追加标志 i，也就是使用：<code>/正则表达式/i</code>的形式，而不是使用<code>/正则表达式/</code></strong>。<br><strong>返回值</strong><br>stringObject 中第一个<strong>与 regexp 相匹配的子串的<code>起始位置</code></strong>。<br>注释：如果没有找到任何匹配的子串，则返回 -1。<br>说明<br>search() 方法不执行全局匹配，它将忽略标志 g。它同时忽略 regexp 的 lastIndex 属性，并且总是从字符串的开始进行检索，这意味着它总是返回 stringObject 的第一个匹配的位置。</p></blockquote><p><strong>实例1 返回字符串中字母的第一个匹配位置：</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> str = <span class="string">"123456abc123456"</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(str + <span class="string">" 中第一个小写字母的起始下标: "</span> + str.search(<span class="regexp">/[a-z]/</span>)+<span class="string">"&lt;br&gt;"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(str + <span class="string">" 中第一个大写字母的起始下标: "</span> + str.search(<span class="regexp">/[A-Z]/</span>)+<span class="string">"&lt;br&gt;"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(str + <span class="string">" 中第一个字母(忽略大小写)的起始下标: "</span> + str.search(<span class="regexp">/[A-Z]/i</span>)+<span class="string">"&lt;br&gt;"</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">123456abc123456中第一个小写字母的起始下标: 6</span><br><span class="line">123456abc123456中第一个大写字母的起始下标: -1</span><br><span class="line">123456abc123456中第一个字母(忽略大小写)的起始下标: 6</span><br></pre></td></tr></table></figure><p></p><h3 id="match-方法"><a href="#match-方法" class="headerlink" title="match()方法"></a>match()方法</h3><blockquote><p><strong>定义和用法</strong><br>match() 方法可在字符串内检索指定的值，或<strong>找到一个或多个正则表达式的匹配</strong>。<br>该方法类似 indexOf() 和 lastIndexOf()，但是<strong>它返回指定的值，而不是字符串的位置</strong>。<br>语法<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; stringObject.match(searchvalue)</span><br><span class="line">&gt; stringObject.match(regexp)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p><strong>参数</strong><br>参数可以是字符串，也可以是正则表达式：<br>字符串：searchvalue。规定要检索的字符串值。<br>正则表达式：regexp。规定要匹配的模式的 RegExp 对象。如果该参数不是 RegExp 对象，则需要首先把它传递给 RegExp 构造函数，将其转换为 RegExp 对象。<br><strong>返回值</strong><br><strong>存放匹配结果的数组</strong>。该数组的内容依赖于 regexp 是否具有全局标志 g。<br><strong>说明</strong><br><strong>match() 方法将检索字符串 stringObject，以找到一个或多个与 regexp 匹配的文本</strong>。这个方法的行为在很大程度上有赖于 regexp 是否具有标志 g。</p><ul><li><p>**如果 regexp 没有标志 g，那么 match() 方法就只能在 stringObject 中执行一次匹配。</p><ul><li>如果没有找到任何匹配的文本，<strong>match() 将返回 null</strong>。</li><li><strong>如果找到匹配的文本</strong>，它将返回一个数组，其中存放了与它找到的匹配文本有关的信息。<strong>该数组的第 0 个元素存放的是匹配文本</strong>，<strong>而其余的元素存放的是与正则表达式的子表达式匹配的文本</strong>。除了这些常规的数组元素之外，返回的数组还含有两个对象属性。<ul><li>index 属性声明的是<strong>匹配文本的起始字符在 stringObject 中的位置</strong>，</li><li>input 属性声明的是对 stringObject 的引用。</li></ul></li></ul></li><li><p><strong>如果 regexp 具有标志 g</strong>，则 match() 方法将执行全局检索，找到 stringObject 中的所有匹配子字符串。</p><ul><li>若没有找到任何匹配的子串，则返回 null。</li><li>如果找到了一个或多个匹配子串，则返回一个数组。不过<strong>全局匹配返回的</strong>数组的内容与前者大不相同，它的<strong>数组元素中存放的是 stringObject 中所有的匹配子串，而且也没有 index 属性或 input 属性</strong>。<br>注意：在全局检索模式下，match() 即不提供与子表达式匹配的文本的信息，也不声明每个匹配子串的位置。如果您需要这些全局检索的信息，可以使用 RegExp.exec()。</li></ul></li></ul></blockquote><h4 id="实例：不使用正则表达式"><a href="#实例：不使用正则表达式" class="headerlink" title="实例：不使用正则表达式"></a>实例：不使用正则表达式</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> str = <span class="string">"Hello world!"</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(str.match(<span class="string">"world"</span>) + <span class="string">"&lt;br /&gt;"</span>)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(str.match(<span class="string">"World"</span>) + <span class="string">"&lt;br /&gt;"</span>)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(str.match(<span class="string">"worlld"</span>) + <span class="string">"&lt;br /&gt;"</span>)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(str.match(<span class="string">"world!"</span>))</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">world</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">world!</span><br></pre></td></tr></table></figure><p></p><h4 id="实例2：使用正则全局匹配"><a href="#实例2：使用正则全局匹配" class="headerlink" title="实例2：使用正则全局匹配"></a>实例2：使用正则全局匹配</h4><p>使用全局匹配将会返回所有匹配的子串，而不使用全局匹配只会得到第一个匹配的子串。<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> str = <span class="string">"1 plus 2 equal 3"</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(str+<span class="string">" 中的所有英文单词: "</span>+str.match(<span class="regexp">/[a-zA-Z]+/g</span>)+<span class="string">"&lt;br&gt;"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(str+<span class="string">" 中的英文单词: "</span>+str.match(<span class="regexp">/[a-zA-Z]+/</span>)+<span class="string">"&lt;br&gt;"</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 plus 2 equal 3 中的所有英文单词: plus,equal</span><br><span class="line">1 plus 2 equal 3 中的英文单词: plus</span><br></pre></td></tr></table></figure><p></p><h3 id="replace-方法"><a href="#replace-方法" class="headerlink" title="replace()方法"></a>replace()方法</h3><blockquote><p><strong>定义和用法</strong><br>replace() 方法用于<strong>在字符串中用一些字符替换另一些字符</strong>，<strong>或替换一个与正则表达式匹配的子串</strong>。<br><strong>语法</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; stringObject.replace(regexp/substr,replacement)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">regexp/substr</td><td style="text-align:left">必需。规定子字符串或要替换的模式的 RegExp 对象。请注意，如果该值是一个字符串，则将它作为要检索文本，而不是首先被转换为 RegExp 对象。</td></tr><tr><td style="text-align:left">replacement</td><td style="text-align:left">必需。一个字符串值。规定了替换文本或生成替换文本的函数。</td></tr></tbody></table><p><strong>返回值</strong><br><strong>一个新的字符串</strong>，是用 replacement 替换了 regexp 的第一次匹配或所有匹配之后得到的。<br><strong>说明</strong><br>字符串 stringObject 的 replace() 方法执行的是<strong>查找并替换的操作</strong>。它将在 stringObject 中查找与 regexp 相匹配的子字符串，然后用 replacement 来替换这些子串。<strong>如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串</strong>。<br><strong>replacement 可以是字符串，也可以是函数</strong>。如果它是字符串，那么每个匹配都将由字符串替换。但是 replacement 中的 $ 字符表示<strong>前向引用</strong>,也就是使用匹配文本的全部或部分类替换原来的文本,如下表所示</p><table><thead><tr><th>字符</th><th>替换文本</th></tr></thead><tbody><tr><td>$1、$2、…、$99</td><td>与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。</td></tr><tr><td>$&amp;</td><td>与 regexp 相匹配的子串。</td></tr><tr><td>$`</td><td>位于匹配子串左侧的文本。</td></tr><tr><td>$’</td><td>位于匹配子串右侧的文本。</td></tr><tr><td>$$</td><td>直接量符号。</td></tr></tbody></table><p><strong>注意</strong>：ECMAScript v3 规定，<strong>replace() 方法的参数 replacement 可以是函数而不是字符串。在这种情况下，每个匹配都调用该函数，它返回的字符串将作为替换文本使用</strong>。该函数的第一个参数是匹配模式的字符串。接下来的参数是与模式中的子表达式匹配的字符串，可以有 0 个或多个这样的参数。接下来的参数是一个整数，声明了匹配在 stringObject 中出现的位置。最后一个参数是 stringObject 本身。</p></blockquote><h4 id="实例-使用字符串替换匹配文本"><a href="#实例-使用字符串替换匹配文本" class="headerlink" title="实例 使用字符串替换匹配文本"></a>实例 使用字符串替换匹配文本</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> str=<span class="string">"Hello world!"</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(str.replace(<span class="regexp">/world/</span>, <span class="string">"java"</span>));</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello java</span><br></pre></td></tr></table></figure><p></p><h4 id="实例-使用正则表达式进行替换"><a href="#实例-使用正则表达式进行替换" class="headerlink" title="实例 使用正则表达式进行替换"></a>实例 使用正则表达式进行替换</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> str = <span class="string">"Hello 123 world 456"</span></span><br><span class="line">    <span class="built_in">document</span>.write(str.replace(<span class="regexp">/\d+/</span>, <span class="string">"java"</span>));</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello java world 456</span><br></pre></td></tr></table></figure><p></p><p>这里，只会替换第一正则表达式匹配的文本,如果想要全部替换的化，要使用全局匹配模式</p><h4 id="实例-替换所有正则匹配的字串"><a href="#实例-替换所有正则匹配的字串" class="headerlink" title="实例 替换所有正则匹配的字串"></a>实例 替换所有正则匹配的字串</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Hello 123 world 456"</span></span><br><span class="line"><span class="built_in">document</span>.write(str.replace(<span class="regexp">/\d+/g</span>, <span class="string">"java"</span>));</span><br></pre></td></tr></table></figure><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello java world java</span><br></pre></td></tr></table></figure><p></p><h4 id="实例-使用函数：把字符串中所有单词的首字母都转换为大写"><a href="#实例-使用函数：把字符串中所有单词的首字母都转换为大写" class="headerlink" title="实例 使用函数：把字符串中所有单词的首字母都转换为大写"></a>实例 使用函数：把字符串中所有单词的首字母都转换为大写</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'hello world java'</span>;</span><br><span class="line"><span class="comment">//使用函数返回的结果替换匹配的子串</span></span><br><span class="line"><span class="keyword">var</span> uw = name.replace(<span class="regexp">/\b\w+\b/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">word</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//word 表示匹配到的文本</span></span><br><span class="line">    <span class="comment">//首字母</span></span><br><span class="line">    <span class="keyword">var</span> first=word.substring(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//剩下的字母</span></span><br><span class="line">    <span class="keyword">var</span> rest=word.substring(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//首字母大写后返回</span></span><br><span class="line">    <span class="keyword">return</span> first.toUpperCase() + rest;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line"><span class="built_in">document</span>.write(uw);</span><br></pre></td></tr></table></figure><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World Java</span><br></pre></td></tr></table></figure><p></p><h3 id="split-方法"><a href="#split-方法" class="headerlink" title="split() 方法"></a>split() 方法</h3><blockquote><p><strong>定义和用法</strong><br><code>split() 方法用于把一个字符串分割成字符串数组。</code><br><strong>语法</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; stringObject.split(separator,howmany)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>separator</td><td>必需。字符串或正则表达式，从该参数指定的地方分割 stringObject。</td></tr><tr><td>howmany</td><td>可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。</td></tr></tbody></table><p><strong>返回值</strong><br><strong>一个字符串<code>数组</code></strong>。该数组是通过在 separator 指定的边界处将字符串 stringObject 分割成子串创建的。<strong>返回的数组中的字串不包括 separator 自身</strong>。<br>但是，<strong>如果 separator 是包含子表达式的正则表达式，那么返回的数组中<code>包括与这些子表达式匹配的字串</code>（但<code>不包括与整个正则表达式匹配的文本</code>）</strong>。<br><strong>提示和注释</strong><br>注释：<code>如果把空字符串 (&quot;&quot;) 用作 separator，那么 stringObject 中的每个字符之间都会被分割。</code><br>注释：String.split() 执行的操作与 Array.join 执行的操作是相反的。</p></blockquote><h4 id="实例：使用空格和空字符进行分割"><a href="#实例：使用空格和空字符进行分割" class="headerlink" title="实例：使用空格和空字符进行分割"></a>实例：使用空格和空字符进行分割</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> str = <span class="string">"How are you doing today?"</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(str.split(<span class="string">" "</span>) + <span class="string">"&lt;br /&gt;"</span>)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(str.split(<span class="string">""</span>) + <span class="string">"&lt;br /&gt;"</span>)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(str.split(<span class="string">" "</span>, <span class="number">3</span>))</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">How,are,you,doing,today?</span><br><span class="line">H,o,w, ,a,r,e, ,y,o,u, ,d,o,i,n,g, ,t,o,d,a,y,?</span><br><span class="line">How,are,you</span><br></pre></td></tr></table></figure><p></p><h4 id="实例-字符串分割为字符"><a href="#实例-字符串分割为字符" class="headerlink" title="实例 字符串分割为字符"></a>实例 字符串分割为字符</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> array=<span class="string">"hello"</span>.split(<span class="string">""</span>)<span class="comment">//可返回 ["h", "e", "l", "l", "o"]</span></span><br><span class="line">    array.forEach(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">document</span>.write(element+<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">h</span><br><span class="line">e</span><br><span class="line">l</span><br><span class="line">l</span><br><span class="line">o</span><br></pre></td></tr></table></figure><p></p><h4 id="实例-使用正则表达式进行分割"><a href="#实例-使用正则表达式进行分割" class="headerlink" title="实例:使用正则表达式进行分割"></a>实例:使用正则表达式进行分割</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> str = <span class="string">"How are you doing today?"</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> array = str.split(<span class="regexp">/\s+/</span>);</span></span><br><span class="line"><span class="javascript">    array.forEach(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.write(element+ <span class="string">"&lt;br /&gt;"</span>)</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">How</span><br><span class="line">are</span><br><span class="line">you</span><br><span class="line">doing</span><br><span class="line">today?</span><br></pre></td></tr></table></figure><p></p><h4 id="实例：分隔符位于首部和尾部的情况"><a href="#实例：分隔符位于首部和尾部的情况" class="headerlink" title="实例：分隔符位于首部和尾部的情况"></a>实例：分隔符位于首部和尾部的情况</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> str = <span class="string">"|How|are|you|doing|today?"</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> array1 = str.split(<span class="string">"|"</span>);<span class="comment">//分割结果: ["","How","are","you","doing","today?"]</span></span></span><br><span class="line"><span class="javascript">    array1.forEach(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.write(<span class="string">":"</span>+element+ <span class="string">"&lt;br/&gt;"</span>)</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(<span class="string">"-------------------------&lt;br&gt;"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> array2 = str.split(<span class="string">"?"</span>);<span class="comment">//分割结果: ["|How|are|you|doing|today",""]</span></span></span><br><span class="line"><span class="javascript">    array2.forEach(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.write(<span class="string">":"</span>+element+ <span class="string">"&lt;br/&gt;"</span>);</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(<span class="string">"-------------------------&lt;br&gt;"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> array3 = str.split(<span class="regexp">/\||\?/</span>);<span class="comment">//分割结果: ["","How","are","you","doing","today",""]</span></span></span><br><span class="line"><span class="javascript">    array3.forEach(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.write(<span class="string">":"</span>+element+ <span class="string">"&lt;br/&gt;"</span>);</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">:</span><br><span class="line">:How</span><br><span class="line">:are</span><br><span class="line">:you</span><br><span class="line">:doing</span><br><span class="line">:today?</span><br><span class="line">-------------------------</span><br><span class="line">:|How|are|you|doing|today</span><br><span class="line">:</span><br><span class="line">-------------------------</span><br><span class="line">:</span><br><span class="line">:How</span><br><span class="line">:are</span><br><span class="line">:you</span><br><span class="line">:doing</span><br><span class="line">:today</span><br><span class="line">:</span><br></pre></td></tr></table></figure><p></p><h2 id="截取子串相关方法"><a href="#截取子串相关方法" class="headerlink" title="截取子串相关方法"></a>截取子串相关方法</h2><h3 id="slice-方法"><a href="#slice-方法" class="headerlink" title="slice() 方法"></a>slice() 方法</h3><blockquote><p><strong>定义和用法</strong><br><code>slice() 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分</code>。<br><strong>语法</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; stringObject.slice(start,end)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>start</td><td>要抽取的片断的起始下标。如果是<strong><code>负数</code>，则该参数规定的是从字符串的尾部开始算起的位置</strong>。也就是说，-1 指字符串的最后一个字符，-2 指<code>倒数</code>第二个字符，以此类推。</td></tr><tr><td>end</td><td>紧接着要抽取的片段的结尾的下标。若未指定此参数，则要提取的子串包括 start 到原字符串结尾的字符串。如果该参数是<code>负数</code>，那么它规定的是从字符串的<code>尾部开始算起</code>的位置。</td></tr></tbody></table><p><strong>返回值</strong><br>一个新的字符串。包括字符串 stringObject <strong>从 start 开始（<code>包括 start</code>）到 end 结束（<code>不包括 end</code>）为止的所有字符</strong>。<br><strong>说明</strong><br>String 对象的方法 slice()、substring() 和 substr() （不建议使用）都可返回字符串的指定部分<strong>。slice() 比 substring() 要灵活一些，因为它允许使用负数作为参数</strong>。slice() 与 substr() 有所不同，因为它用两个字符的位置来指定子串，而 substr() 则用字符位置和长度来指定子串。<br>还要注意的是，String.slice() 与 Array.slice() 相似。</p></blockquote><h4 id="实例-提取字符串中从位置-6-开始的所有字符"><a href="#实例-提取字符串中从位置-6-开始的所有字符" class="headerlink" title="实例 提取字符串中从位置 6 开始的所有字符"></a>实例 提取字符串中从位置 6 开始的所有字符</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> str=<span class="string">"Hello happy world!"</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(str.slice(<span class="number">6</span>))</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>输出：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">happy world!</span><br></pre></td></tr></table></figure><p></p><h4 id="实例-提取字符串中从位置-6-到位置-11-的所有字符"><a href="#实例-提取字符串中从位置-6-到位置-11-的所有字符" class="headerlink" title="实例 提取字符串中从位置 6 到位置 11 的所有字符"></a>实例 提取字符串中从位置 6 到位置 11 的所有字符</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> str=<span class="string">"Hello happy world!"</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(str.slice(<span class="number">6</span>,<span class="number">11</span>))</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>输出：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">happy</span><br></pre></td></tr></table></figure><p></p><h4 id="实例-提取字符串中从位置-1-到位置-6-的所有字符"><a href="#实例-提取字符串中从位置-1-到位置-6-的所有字符" class="headerlink" title="实例 提取字符串中从位置 -1 到位置 -6 的所有字符"></a>实例 提取字符串中从位置 -1 到位置 -6 的所有字符</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> str=<span class="string">"Hello happy world!"</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(str.slice(<span class="number">-6</span>,<span class="number">-1</span>));</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">world</span><br></pre></td></tr></table></figure><p></p><p>需要注意的是,start和end要同时是整数和负数,同时start要小于end.</p><h3 id="substring-方法"><a href="#substring-方法" class="headerlink" title="substring() 方法"></a>substring() 方法</h3><blockquote><p><strong>定义和用法</strong><br>substring() 方法用于提取字符串中介于两个指定下标之间的字符。<br><strong>语法</strong><br>stringObject.substring(start,stop)</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">start</td><td style="text-align:left">必需。一个<code>非负</code>的整数，规定要提取的子串的<strong>第一个字符在 stringObject 中的位置</strong>。</td></tr><tr><td style="text-align:left">stop</td><td style="text-align:left">可选。一个<code>非负</code>的整数，比要提取的子串的最后一个字符在 stringObject 中的位置多 1。 如果<strong>省略</strong>该参数，则从start截取到真个字符串的结尾</td></tr></tbody></table><p><strong>返回值</strong><br>一个新的字符串，该字符串值包含 stringObject 的一个子字符串，其内容是<strong>从 start 处到 stop-1 处的所有字符</strong>，其长度为 stop 减 start。<br><strong>说明</strong></p><ul><li><code>substring() 方法返回的子串包括 start 处的字符，但不包括 stop 处的字符</code>。</li><li>如果参数 start 与 stop 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串）</li><li>如果 start 比 stop 大，那么该方法在提取子串之前会先交换这两个参数。<br><strong>提示和注释</strong><br>重要事项：与 slice() 和 substr() 方法不同的是，<strong>substring() 不接受负的参数</strong>。</li></ul></blockquote><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> str = <span class="string">"Hello world!"</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(<span class="string">"substring截取前开后闭,下标从0开始&lt;br&gt;"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(str+<span class="string">"&lt;br&gt;"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(<span class="string">"从下标3开始: "</span>+str.substring(<span class="number">3</span>)+<span class="string">"&lt;br&gt;"</span>)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(<span class="string">"从下标0截取到下标3之前的: "</span>+str.substring(<span class="number">0</span>,<span class="number">3</span>)+<span class="string">"&lt;br&gt;"</span>)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(<span class="string">"从下标4截取到下标0之前的: "</span>+str.substring(<span class="number">4</span>,<span class="number">0</span>)+<span class="string">"&lt;br&gt;"</span>)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">substring截取前开后闭,下标从0开始</span><br><span class="line">Hello world!</span><br><span class="line">从下标3开始: lo world!</span><br><span class="line">从下标0截取到下标3之前的: Hel</span><br><span class="line">从下标4截取到下标0之前的: Hell</span><br></pre></td></tr></table></figure><p></p><h3 id="substr-方法"><a href="#substr-方法" class="headerlink" title="substr() 方法"></a>substr() 方法</h3><blockquote><p><strong>定义和用法</strong><br>substr() 方法可在字符串中<strong>抽取从 start 下标开始的指定数目的字符</strong>。<br><strong>语法</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; stringObject.substr(start,length)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>start</td><td>必需。要抽取的子串的起始下标。必须是数值。如果是负数，那么该参数声明从字符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。</td></tr><tr><td>length</td><td>可选。子串中的字符数。必须是数值。如果省略了该参数，那么返回从 stringObject 的开始位置到结尾的字串。</td></tr></tbody></table><p><strong>返回值</strong><br>一个新的字符串，包含<strong>从 stringObject 的 start（包括 start 所指的字符） 处开始的 length 个字符</strong>。如果没有指定 length，那么返回的字符串包含从 start 到 stringObject 的结尾的字符。<br><strong>提示和注释</strong><br><strong>注释</strong>：substr() 的参数指定的是子串的开始位置和长度，因此它可以替代 substring() 和 slice() 来使用。<br><strong>重要事项</strong>：ECMAscript 没有对该方法进行标准化，因此<strong>反对使用它</strong>。<br><strong>重要事项</strong>：在 IE 4 中，参数 start 的值无效。在这个 BUG 中，start 规定的是第 0 个字符的位置。在之后的版本中，此 BUG 已被修正。</p></blockquote><h4 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h4><h2 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h2><h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString() 方法"></a>toString() 方法</h3><blockquote><p><strong>定义和用法</strong><br>toString() 方法返回字符串。<br><strong>语法</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; stringObject.toString()</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p><strong>返回值</strong><br>stringObject 的原始字符串值。一般不会调用该方法。<br><strong>抛出</strong><br>当调用该方法的对象不是 String 时抛出 TypeError 异常。</p></blockquote><h3 id="valueOf-方法"><a href="#valueOf-方法" class="headerlink" title="valueOf() 方法"></a>valueOf() 方法</h3><blockquote><p><strong>定义和用法</strong><br>valueOf() 方法可返回 String 对象的原始值。<br>原始值是由从 String 对象下来的所有对象继承的。<br>valueOf() 方法通常由 JavaScript 在后台自动进行调用，而不是显式地处于代码中。<br><strong>语法</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; stringObject.valueOf()</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p><strong>抛出</strong><br>当调用该方法的对象不是 String 时抛出 TypeError 异常。</p></blockquote><h1 id="String-对象描述"><a href="#String-对象描述" class="headerlink" title="String 对象描述"></a>String 对象描述</h1><blockquote><p>字符串是 JavaScript 的一种基本的数据类型。<br>String 对象的 length 属性声明了该字符串中的字符数。<br>String 类定义了大量操作字符串的方法，例如从字符串中提取字符或子串，或者检索字符或子串。<br>需要注意的是，<strong>JavaScript 的字符串是不可变的（immutable），String 类定义的方法都不能改变字符串的内容。像 String.toUpperCase() 这样的方法，返回的是全新的字符串，而不是修改原始字符串</strong>。</p></blockquote><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="http://www.w3school.com.cn/jsref/jsref_obj_string.asp" target="_blank" rel="noopener">JavaScript String 对象</a></li><li><a href="http://www.w3school.com.cn/jsref/jsref_search.asp" target="_blank" rel="noopener">JavaScript String 对象 search()方法</a></li><li><a href="http://www.w3school.com.cn/jsref/jsref_replace.asp" target="_blank" rel="noopener">JavaScript String 对象 replace()方法</a></li><li><a href="http://www.w3school.com.cn/jsref/jsref_split.asp" target="_blank" rel="noopener">JavaScript String 对象 split()方法</a></li></ul><p>本文链接: <a href="https://www.lansheng.net.cn/blog/f52e78d1/">JavaScript常用对象2 String对象</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Java Web从入门到精通 </category>
          
          <category> 第3章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hexo NexT主题自定义代码块样式过程</title>
      <link href="/blog/f270cba2/"/>
      <url>/blog/f270cba2/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:16 GMT+0800 (中国标准时间) --><h2 id="阅读文本前提"><a href="#阅读文本前提" class="headerlink" title="阅读文本前提"></a>阅读文本前提</h2><ul><li>使用工具：火狐浏览器查看器</li><li>准备：CSS知识</li><li>需要修改的样式文件：<code>~/blog/themes/next/source/css/_custom/custom.styl</code></li></ul><h2 id="修改Next主题样式实例"><a href="#修改Next主题样式实例" class="headerlink" title="修改Next主题样式实例"></a>修改Next主题样式实例</h2><ul><li>修改代码快文字大小</li></ul><a id="more"></a><h2 id="修改代码快文字大小"><a href="#修改代码快文字大小" class="headerlink" title="修改代码快文字大小"></a>修改代码快文字大小</h2><p>博客站点目录下,打开git-bash，输入hexo s启动本地服务器。然后打开火狐浏览器，点开你一篇文章，找到代码块部分，全选其中的文本，按下鼠标右键。选择查看元素。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/Next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/mycss/codeblockdakaichakanqi.png" alt=""><br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/Next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/mycss/openfirefoxchakanyuansu.png" alt=""><br>修改对应的对应的css样式，例如修改字体大小font-size，字体间距line-height:<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/Next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/mycss/changeCSS.png" alt=""><br>然后浏览器会显示修改后的样式，调到自己想要的效果之后，复制该CSS代码到<code>站点根目录\themes\next\source\css\_custom\custom.styl</code>中:<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/Next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/mycss/copytocustomfile.png" alt=""><br>然后保存即可。这样即使显示不正确，删掉<code>next\source\css\_custom\custom.styl</code>中的错误样式代码即可。尽量不要去修改<code>E:\Blog\bolg5\themes\next\layout\_custom</code>的样式，如果改蹦了可能不好改回来。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://www.cduyzh.com/hexo-settings-3/" target="_blank" rel="noopener">http://www.cduyzh.com/hexo-settings-3/</a><br>本文链接: <a href="https://www.lansheng.net.cn/blog/f270cba2/">hexo NexT主题自定义代码块样式过程</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> Next主题配置 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hexo NexT主题 添加背景图片</title>
      <link href="/blog/dea46275/"/>
      <url>/blog/dea46275/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:16 GMT+0800 (中国标准时间) --><p>通过 jquery-backstretch，具体操作呢，编辑文件：<br>文件位置：<code>~/blog/themes/next/layout/_layout.swig</code>，把下面的代码添加到<code>&lt;/body&gt;</code>标签之前。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js&quot;&gt;&lt;/script&gt;;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">$(&quot;body&quot;).backstretch(&quot;https://背景图.jpg&quot;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p></p><a id="more"></a><p>也就是：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js&quot;&gt;&lt;/script&gt;;</span><br><span class="line">+  &lt;script&gt;</span><br><span class="line">+  $(&quot;body&quot;).backstretch(&quot;https://背景图.jpg&quot;);</span><br><span class="line">+  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p></p><p>然后启动本地服务器即可看到效果：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/Next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/tianjiabeijingtupian/xianshixiaoguo.png" alt=""><br>参考文章：<a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html" target="_blank" rel="noopener">https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html</a><br>本文链接: <a href="https://www.lansheng.net.cn/blog/dea46275/">hexo NexT主题 添加背景图片</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> Next主题配置 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化</title>
      <link href="/blog/32d14fd/"/>
      <url>/blog/32d14fd/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>参考链接：<a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html#%E6%9B%B4%E6%96%B0%E6%8F%90%E7%A4%BA%EF%BC%88%E5%8F%AF%E4%BB%A5%E6%9C%80%E5%90%8E%E7%9C%8B%EF%BC%89" target="_blank" rel="noopener">https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html#%E6%9B%B4%E6%96%B0%E6%8F%90%E7%A4%BA%EF%BC%88%E5%8F%AF%E4%BB%A5%E6%9C%80%E5%90%8E%E7%9C%8B%EF%BC%89</a><br><a id="more"></a><br>本文链接: <a href="https://www.lansheng.net.cn/blog/32d14fd/">打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> Next主题配置 </category>
          
          <category> 主题个性化优化 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hexo 百度主动推送</title>
      <link href="/blog/7ac3f85/"/>
      <url>/blog/7ac3f85/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><ul><li>百度主动推送的作用</li><li>在hexo中添加百度主动推送功能<ul><li>安装hexo-baidu-url-submit插件</li><li>在站点配置文件中添加baidu-url-submit的配置项</li><li>在站点配置文件中加入新的deploy配置项</li><li>验证配置是否成功</li></ul></li><li>参考链接</li></ul><a id="more"></a><h2 id="百度主动推送的作用"><a href="#百度主动推送的作用" class="headerlink" title="百度主动推送的作用"></a>百度主动推送的作用</h2><blockquote><p>作用：某些主机，比如Github，禁止百度爬虫访问博客，导致博客无法被百度收录。多亏百度提供了主动提交的接口，这才有了个补救的方法。除此之外， 使用主动推送还会达到如下功效：</p><ul><li>及时发现：可以缩短百度爬虫发现您站点新链接的时间，使新发布的页面可以在第一时间被百度收录</li><li>保护原创：对于网站的最新原创内容，使用主动推送功能可以快速通知到百度，使内容可以在转发之前被百度发现</li></ul></blockquote><h2 id="在hexo中添加百度主动推送功能"><a href="#在hexo中添加百度主动推送功能" class="headerlink" title="在hexo中添加百度主动推送功能"></a>在hexo中添加百度主动推送功能</h2><h2 id="安装hexo-baidu-url-submit插件"><a href="#安装hexo-baidu-url-submit插件" class="headerlink" title="安装hexo-baidu-url-submit插件"></a>安装hexo-baidu-url-submit插件</h2><p>首先，在<strong>Hexo站点根目录</strong>下，打开git-bash，输入下面命令安装插件：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-baidu-url-submit --save</span><br></pre></td></tr></table></figure><p></p><h3 id="在站点配置文件中添加baidu-url-submit的配置项"><a href="#在站点配置文件中添加baidu-url-submit的配置项" class="headerlink" title="在站点配置文件中添加baidu-url-submit的配置项"></a>在站点配置文件中添加baidu-url-submit的配置项</h3><p>把以下内容配置到<strong>站点配置文件_config.yml</strong>中。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#设置百度主动推送</span><br><span class="line">baidu_url_submit:</span><br><span class="line">  count: 200  #比如200，代表提交最新的200个链接</span><br><span class="line">  host: www.lansheng.net.cn # 在百度站长平台中注册的域名，这个改为你自己的域名</span><br><span class="line">  token: your_token # 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里!</span><br><span class="line">  path: baidu_urls.txt # 文本文档的地址， 新链接会保存在此文本文档里，这个默认</span><br></pre></td></tr></table></figure><p></p><p>这个秘钥可以从百度站长平台的自动推送接口那里获取到，如下图所示：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/SEO/baiduzidongtuisong/baiduzidongtuisong.png" alt=""></p><h3 id="在站点配置文件中加入新的deploy配置项"><a href="#在站点配置文件中加入新的deploy配置项" class="headerlink" title="在站点配置文件中加入新的deploy配置项"></a>在站点配置文件中加入新的deploy配置项</h3><p>同样在<strong>站点配置文件</strong>中找到deploy项，添加新的推送项，如下所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">- type: git</span><br><span class="line">  repo:</span><br><span class="line">    coding: git@git.coding.net:你的coding用户名/你的coding用户名.coding.me.git #coding地址</span><br><span class="line">    github: git@github.com:你的github用户名/你的github用户名.github.io.git  # Github地址</span><br><span class="line">  branch: master</span><br><span class="line">- type: baidu_url_submitter</span><br></pre></td></tr></table></figure><p></p><h2 id="验证配置是否成功"><a href="#验证配置是否成功" class="headerlink" title="验证配置是否成功"></a>验证配置是否成功</h2><p>最后输入命令hexo s看看能不能启动本地服务器，如果就没问题了。可以输入命令hexo d部署即可。<br>成功不是可以在git-bash中看到如下的信息：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INFO  Deploying: baidu_url_submitter</span><br><span class="line">INFO  Submitting urls</span><br><span class="line">......</span><br><span class="line">&#123;&quot;remain&quot;:4999900,&quot;success&quot;:100&#125;</span><br><span class="line">INFO  Deploy done: baidu_url_submitter</span><br></pre></td></tr></table></figure><p></p><p>就说明主动推送成功了。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/baiduSEO/zidongtuisong/yes.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>参考文章:<a href="https://www.jianshu.com/p/f37452d4978e" target="_blank" rel="noopener">https://www.jianshu.com/p/f37452d4978e</a><br>插件GitHub地址:<a href="https://github.com/huiwang/hexo-baidu-url-submit" target="_blank" rel="noopener">https://github.com/huiwang/hexo-baidu-url-submit</a><br>官方说明文档：<a href="https://hui-wang.info/2016/10/23/Hexo%E6%8F%92%E4%BB%B6%E4%B9%8B%E7%99%BE%E5%BA%A6%E4%B8%BB%E5%8A%A8%E6%8F%90%E4%BA%A4%E9%93%BE%E6%8E%A5/" target="_blank" rel="noopener">https://hui-wang.info/2016/10/23/Hexo%E6%8F%92%E4%BB%B6%E4%B9%8B%E7%99%BE%E5%BA%A6%E4%B8%BB%E5%8A%A8%E6%8F%90%E4%BA%A4%E9%93%BE%E6%8E%A5/</a></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/7ac3f85/">hexo 百度主动推送</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> SEO </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>ERROR Deployer not found：baidu_xz_url_submitter</title>
      <link href="/blog/2740f49f/"/>
      <url>/blog/2740f49f/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>百度主动推送是没有问题的，但是报错：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INFO  Deploying: baidu_url_submitter</span><br><span class="line">INFO  Submitting urls</span><br><span class="line">......</span><br><span class="line">&#123;&quot;remain&quot;:4998354,&quot;success&quot;:20&#125;</span><br><span class="line">INFO  Deploy done: baidu_url_submitter</span><br><span class="line">ERROR Deployer not found: baidu_xz_url_submitter</span><br></pre></td></tr></table></figure><p></p><p>这是之前使用使用<code>npm install hexo-baidu-url-submit --save</code>安装的插件，最新版的<code>hexo-baidu-url-submit</code>还不能这样安装，需要换一种方式安装插件。</p><ul><li>解决方案<ul><li>修改package.json安装最新的hexo-baidu-url-submit插件</li><li>配置站点配置文件<ul><li>baidu_url_submit 配置</li><li>deploy 配置</li></ul></li></ul></li><li>部署</li><li>登录熊掌号查看提交效果</li><li>参考链接</li></ul><a id="more"></a><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="修改package-json安装最新的hexo-baidu-url-submit插件"><a href="#修改package-json安装最新的hexo-baidu-url-submit插件" class="headerlink" title="修改package.json安装最新的hexo-baidu-url-submit插件"></a>修改package.json安装最新的hexo-baidu-url-submit插件</h2><p>进入站点根目录，打开<code>package.json</code>,把hexo-baidu-url-submit配置项改为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">  &quot;hexo&quot;: &quot;^3.7.0&quot;,</span><br><span class="line">  &quot;hexo-baidu-url-submit&quot;: &quot;https://github.com/huiwang/hexo-baidu-url-submit&quot;,</span><br></pre></td></tr></table></figure><p></p><p>然后在站点目录下，输入<code>npm install</code>命令安装最新的<code>hexo-baidu-url-submit</code>插件。安装需要一段过程，中途不要管它。安装成功：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br><span class="line">npm WARN registry Unexpected warning for https://registry.npmjs.org/: Miscellaneous Warning ETIMEDOUT: request to https://registry.npmjs.org/xmlhttprequest failed, reason: connect ETIMEDOUT 104.16.17.35:443</span><br><span class="line">npm WARN registry Using stale package data from https://registry.npmjs.org/ due to a request error during revalidation.</span><br><span class="line">npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.4 (node_modules\fsevents):</span><br><span class="line">npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.4: wanted &#123;&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;&#125; (current: &#123;&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;&#125;)</span><br><span class="line"></span><br><span class="line">updated 1 package in 266.405s</span><br></pre></td></tr></table></figure><p></p><p>然后在<strong>站点配置文件</strong>中添加下面两个配置：</p><h2 id="配置站点配置文件"><a href="#配置站点配置文件" class="headerlink" title="配置站点配置文件"></a>配置站点配置文件</h2><h3 id="baidu-url-submit-配置"><a href="#baidu-url-submit-配置" class="headerlink" title="baidu_url_submit 配置"></a>baidu_url_submit 配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">baidu_url_submit:</span><br><span class="line">  count: 1000 ## 提交最新的一个链接</span><br><span class="line">  host: alili.tech ## 在百度站长平台中注册的域名</span><br><span class="line">  token: xxxxx ## 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里!</span><br><span class="line">  path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里</span><br><span class="line">  xz_appid: &apos;xxxxxx&apos; ## 你的熊掌号 appid</span><br><span class="line">  xz_token: &apos;xxxxxx&apos; ## 你的熊掌号 token</span><br><span class="line">  xz_count: 10 ## 从所有的提交的数据当中选取最新的10条,该数量跟你的熊掌号而定</span><br></pre></td></tr></table></figure><p>注意熊掌号的appid，支架填在单引号中就行了。不要去掉单引号。</p><h3 id="deploy-配置"><a href="#deploy-配置" class="headerlink" title="deploy 配置"></a>deploy 配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">- type: git</span><br><span class="line">  repo:</span><br><span class="line">    coding: git@git.coding.net:你的coding/你的coding.coding.me.git #coding地址</span><br><span class="line">    github: git@github.com:你的Github用户名/你的Github用户名.github.io.git  # Github pages地址</span><br><span class="line">  branch: master</span><br><span class="line">- type: baidu_url_submitter #百度主动推送</span><br><span class="line">- type: baidu_xz_url_submitter #百度熊掌号</span><br></pre></td></tr></table></figure><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>输入<code>hexo clean&amp;&amp;hexo g&amp;&amp;hexo d</code>部署即可，部署时结束后插件会自动向百度提交，成功推送到熊账号的命令输出：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">INFO  Deploying: baidu_xz_url_submitter</span><br><span class="line">INFO  new urls</span><br><span class="line">......</span><br><span class="line">&#123;&quot;success_realtime&quot;:10,&quot;remain_realtime&quot;:0&#125;</span><br><span class="line">INFO  最新数据提交完成</span><br><span class="line">INFO  all urls</span><br><span class="line">......</span><br><span class="line">&#123;&quot;success_batch&quot;:20,&quot;remain_batch&quot;:4999980&#125;</span><br><span class="line">INFO  历史数据提交完成</span><br><span class="line">INFO  Deploy done: baidu_xz_url_submitter</span><br></pre></td></tr></table></figure><p></p><h2 id="登录熊掌号查看提交效果"><a href="#登录熊掌号查看提交效果" class="headerlink" title="登录熊掌号查看提交效果"></a>登录熊掌号查看提交效果</h2><p>提交完毕后当了百度熊掌号的链接提页面，可以看到今日的10条额度已经用完了：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/baiduSEO/xiongzhanghao/yes.png" alt=""><br>好了，事情到这里就靠一段落了，过几天再来看效果吧。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>参考文章：<a href="https://alili.tech/archive/9d64fe09/" target="_blank" rel="noopener">https://alili.tech/archive/9d64fe09/</a><br><strong>hexo-baidu-url-submit</strong>插件官方位置：<a href="https://github.com/huiwang/hexo-baidu-url-submit" target="_blank" rel="noopener">https://github.com/huiwang/hexo-baidu-url-submit</a><br>本文链接: <a href="https://www.lansheng.net.cn/blog/2740f49f/">ERROR Deployer not found：baidu_xz_url_submitter</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> 遇到问题 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java网络编程 URLEncoder只编码URL中的中文,空格编码为百分之20</title>
      <link href="/blog/7865fbca/"/>
      <url>/blog/7865fbca/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>之前我自动生成的URL代码我发现转载到CSDN上CSDN不认识，这是因为我没有把URL进行编码，所以这里来介绍URL编码：</p><ul><li>只编码URL里的中文</li><li>同时编码中文和空格<ul><li>方案1：先把空格编码成加号，然后用%20替换</li><li>方案2：只编码中文,直接用%20替换空格</li></ul></li></ul><a id="more"></a><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>把下面的带中文的URL：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.lansheng.net.cn/2018/10/30/Java/Java IO流/Java IO流 使用RandomAccessFile快速读写文本文件最后一行/</span><br></pre></td></tr></table></figure><p></p><p>编码成：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.lansheng.net.cn/2018/10/30/Java/Java%20IO%E6%B5%81/Java%20IO%E6%B5%81%20%E4%BD%BF%E7%94%A8RandomAccessFile%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%86%99%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E6%9C%80%E5%90%8E%E4%B8%80%E8%A1%8C/</span><br></pre></td></tr></table></figure><p></p><h2 id="只编码URL里的中文"><a href="#只编码URL里的中文" class="headerlink" title="只编码URL里的中文"></a>只编码URL里的中文</h2><p>java中，默认的URLEcoder.encode()方法对URL进行编码的时候，会把特殊字符<code>:</code>,<code>.</code>,<code>空格</code>等都进行编码,这与我从浏览器中复制粘贴出来的显然不一样。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"https://www.lansheng.net.cn/2018/10/30/Java/Java IO流/Java IO流 使用RandomAccessFile快速读写文本文件最后一行/"</span>;</span><br><span class="line">System.out.println(URLEncoder.encode(str,<span class="string">"utf-8"</span>));</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https%3A%2F%2Fwww.lansheng.net.cn%2F2018%2F10%2F30%2FJava%2FJava+IO%E6%B5%81%2FJava+IO%E6%B5%81+%E4%BD%BF%E7%94%A8RandomAccessFile%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%86%99%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E6%9C%80%E5%90%8E%E4%B8%80%E8%A1%8C%2F</span><br></pre></td></tr></table></figure><p></p><p>可以看到默认的URLEncoder.encode(str,”utf-8”)方法，把<code>:</code>编码成<code>%3A</code>,<code>/</code>编码成<code>%2F</code>并不需要编码那么多，只需要编码中文即可,这里来使用正则表达式对中文进行编码：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encode</span><span class="params">(String str, String charset)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//匹配中文和空格的正则表达式</span></span><br><span class="line">String zhPattern = <span class="string">"[\u4e00-\u9fa5]+"</span>;</span><br><span class="line">Pattern p = Pattern.compile(zhPattern);</span><br><span class="line">Matcher m = p.matcher(str);</span><br><span class="line">StringBuffer b = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">while</span> (m.find())</span><br><span class="line">&#123;</span><br><span class="line">m.appendReplacement(b, URLEncoder.encode(m.group(<span class="number">0</span>), charset));</span><br><span class="line">&#125;</span><br><span class="line">m.appendTail(b);</span><br><span class="line"><span class="keyword">return</span> b.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.lansheng.net.cn/2018/10/30/Java/Java IO%E6%B5%81/Java IO%E6%B5%81 %E4%BD%BF%E7%94%A8RandomAccessFile%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%86%99%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E6%9C%80%E5%90%8E%E4%B8%80%E8%A1%8C/</span><br></pre></td></tr></table></figure><p></p><p>这里可以看到，空格没有被编码。</p><h2 id="同时编码中文和空格"><a href="#同时编码中文和空格" class="headerlink" title="同时编码中文和空格"></a>同时编码中文和空格</h2><p>这里有两个方案，方案1：在正则表达式中匹配空格，也就是把正则表达式改成<code>[\u4e00-\u9fa5 ]</code>这样空格就会被编码了。</p><h3 id="方案1：先把空格编码成加号，然后用-20替换"><a href="#方案1：先把空格编码成加号，然后用-20替换" class="headerlink" title="方案1：先把空格编码成加号，然后用%20替换"></a>方案1：先把空格编码成加号，然后用%20替换</h3><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.lansheng.net.cn/2018/10/30/Java/Java+IO%E6%B5%81/Java+IO%E6%B5%81+%E4%BD%BF%E7%94%A8RandomAccessFile%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%86%99%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E6%9C%80%E5%90%8E%E4%B8%80%E8%A1%8C/</span><br></pre></td></tr></table></figure><p></p><p>可以看到这里空格被编码为加号<code>+</code>,但是，不幸的是，我复制到浏览器中，还是打不开我的这篇文章。：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/Java/javaw%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/api/Ecoder/404.png" alt=""><br>解决方案，使用正则表达式把加号+，替换为<code>%20</code>即可：<br>只对中文和空格进行编码<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只对中文和空格进行编码。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment"> *            被替换的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> charset</span></span><br><span class="line"><span class="comment"> *            字符集</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 替换好的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="comment"> *             不支持的字符集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encodeSpaceChinese</span><span class="params">(String str, String charset)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//匹配中文和空格的正则表达式</span></span><br><span class="line">String zhPattern = <span class="string">"[\u4e00-\u9fa5 ]+"</span>;</span><br><span class="line">Pattern p = Pattern.compile(zhPattern);</span><br><span class="line">Matcher m = p.matcher(str);</span><br><span class="line">StringBuffer b = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">while</span> (m.find())</span><br><span class="line">&#123;</span><br><span class="line">m.appendReplacement(b, URLEncoder.encode(m.group(<span class="number">0</span>), charset));</span><br><span class="line">&#125;</span><br><span class="line">m.appendTail(b);</span><br><span class="line"><span class="keyword">return</span> b.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>main方法：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"https://www.lansheng.net.cn/2018/10/30/Java/Java IO流/Java IO流 使用RandomAccessFile快速读写文本文件最后一行/"</span>;</span><br><span class="line">String url=encodeSpaceChinese(str, <span class="string">"UTF-8"</span>);</span><br><span class="line">System.out.println(url);</span><br><span class="line">url=url.replaceAll(<span class="string">"\\+"</span>, <span class="string">"%20"</span>);</span><br><span class="line">System.out.println(url);</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://www.lansheng.net.cn/2018/10/30/Java/Java+IO%E6%B5%81/Java+IO%E6%B5%81+%E4%BD%BF%E7%94%A8RandomAccessFile%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%86%99%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E6%9C%80%E5%90%8E%E4%B8%80%E8%A1%8C/</span><br><span class="line">https://www.lansheng.net.cn/2018/10/30/Java/Java%20IO%E6%B5%81/Java%20IO%E6%B5%81%20%E4%BD%BF%E7%94%A8RandomAccessFile%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%86%99%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E6%9C%80%E5%90%8E%E4%B8%80%E8%A1%8C/</span><br></pre></td></tr></table></figure><p></p><p>这样就可以成功打来我的这篇文章了：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/Java/javaw%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/api/Ecoder/yes.png" alt=""><br>因为这与我从浏览器中复制粘贴的地址格式已经完全一样了：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.lansheng.net.cn/2018/10/30/Java/Java%20IO%E6%B5%81/Java%20IO%E6%B5%81%20%E4%BD%BF%E7%94%A8RandomAccessFile%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%86%99%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E6%9C%80%E5%90%8E%E4%B8%80%E8%A1%8C/</span><br></pre></td></tr></table></figure><p></p><h3 id="方案2：只编码中文-直接用-20替换空格"><a href="#方案2：只编码中文-直接用-20替换空格" class="headerlink" title="方案2：只编码中文,直接用%20替换空格"></a>方案2：只编码中文,直接用%20替换空格</h3><p>这里钻了个空子：我可以直接编码中文，然后把没有编码的空格<code></code>直接替换为<code>%20</code>。这样少了一步操作。<br>只对中文进行编码：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encodeChinese</span><span class="params">(String str, String charset)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//匹配中文和空格的正则表达式</span></span><br><span class="line">String zhPattern = <span class="string">"[\u4e00-\u9fa5]+"</span>;</span><br><span class="line">Pattern p = Pattern.compile(zhPattern);</span><br><span class="line">Matcher m = p.matcher(str);</span><br><span class="line">StringBuffer b = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">while</span> (m.find())</span><br><span class="line">&#123;</span><br><span class="line">m.appendReplacement(b, URLEncoder.encode(m.group(<span class="number">0</span>), charset));</span><br><span class="line">&#125;</span><br><span class="line">m.appendTail(b);</span><br><span class="line"><span class="keyword">return</span> b.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>main方法：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"https://www.lansheng.net.cn/2018/10/30/Java/Java IO流/Java IO流 使用RandomAccessFile快速读写文本文件最后一行/"</span>;</span><br><span class="line">String url=encodeChinese(str, <span class="string">"UTF-8"</span>);</span><br><span class="line">System.out.println(url);</span><br><span class="line">url=url.replaceAll(<span class="string">" "</span>, <span class="string">"%20"</span>);</span><br><span class="line">System.out.println(url);</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://www.lansheng.net.cn/2018/10/30/Java/Java IO%E6%B5%81/Java IO%E6%B5%81 %E4%BD%BF%E7%94%A8RandomAccessFile%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%86%99%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E6%9C%80%E5%90%8E%E4%B8%80%E8%A1%8C/</span><br><span class="line">https://www.lansheng.net.cn/2018/10/30/Java/Java%20IO%E6%B5%81/Java%20IO%E6%B5%81%20%E4%BD%BF%E7%94%A8RandomAccessFile%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%86%99%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E6%9C%80%E5%90%8E%E4%B8%80%E8%A1%8C/</span><br></pre></td></tr></table></figure><p></p><p>当然这两个方法基本差不多，我这里就简单记录一下两种可能，个人习惯用第二中方法。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> url.encoder.hz;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正则替换字符串里面的汉字部分。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URLEncoderCH</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">String str = <span class="string">"https://www.lansheng.net.cn/2018/10/30/Java/Java IO流/Java IO流 使用RandomAccessFile快速读写文本文件最后一行/"</span>;</span><br><span class="line"><span class="comment">//把URL中表示空格的+替换成%20,因为有些应用不认+表示的空格，只认%20</span></span><br><span class="line">String url = URLEncode(str);</span><br><span class="line">System.out.println(url);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**编码为浏览器可以直接访问的URL。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> UnsupportedEncodingException  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">URLEncode</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">String url=encodeChinese(str, <span class="string">"UTF-8"</span>);</span><br><span class="line">System.out.println(url);</span><br><span class="line">url=url.replaceAll(<span class="string">" "</span>, <span class="string">"%20"</span>);</span><br><span class="line"><span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只对中文进行编码。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment"> *            被替换的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> charset</span></span><br><span class="line"><span class="comment"> *            字符集</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 替换好的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="comment"> *             不支持的字符集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encodeChinese</span><span class="params">(String str, String charset)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//匹配中文和空格的正则表达式</span></span><br><span class="line">String zhPattern = <span class="string">"[\u4e00-\u9fa5]+"</span>;</span><br><span class="line">Pattern p = Pattern.compile(zhPattern);</span><br><span class="line">Matcher m = p.matcher(str);</span><br><span class="line">StringBuffer b = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">while</span> (m.find())</span><br><span class="line">&#123;</span><br><span class="line">m.appendReplacement(b, URLEncoder.encode(m.group(<span class="number">0</span>), charset));</span><br><span class="line">&#125;</span><br><span class="line">m.appendTail(b);</span><br><span class="line"><span class="keyword">return</span> b.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只对中文和空格进行编码。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment"> *            被替换的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> charset</span></span><br><span class="line"><span class="comment"> *            字符集</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 替换好的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="comment"> *             不支持的字符集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encodeSpaceChinese</span><span class="params">(String str, String charset)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//匹配中文和空格的正则表达式</span></span><br><span class="line">String zhPattern = <span class="string">"[\u4e00-\u9fa5 ]+"</span>;</span><br><span class="line">Pattern p = Pattern.compile(zhPattern);</span><br><span class="line">Matcher m = p.matcher(str);</span><br><span class="line">StringBuffer b = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">while</span> (m.find())</span><br><span class="line">&#123;</span><br><span class="line">m.appendReplacement(b, URLEncoder.encode(m.group(<span class="number">0</span>), charset));</span><br><span class="line">&#125;</span><br><span class="line">m.appendTail(b);</span><br><span class="line"><span class="keyword">return</span> b.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>URLEncoder的只编码中文字符的类：<a href="https://blog.csdn.net/a332324956/article/details/18991243" target="_blank" rel="noopener">https://blog.csdn.net/a332324956/article/details/18991243</a><br>URL中关于空格的编码转换成＋或转换成％20的问题：<a href="https://www.jianshu.com/p/4a7eb969235d" target="_blank" rel="noopener">https://www.jianshu.com/p/4a7eb969235d</a><br>本文链接: <a href="https://www.lansheng.net.cn/blog/7865fbca/">Java网络编程 URLEncoder只编码URL中的中文,空格编码为百分之20</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> java 网络编程 </category>
          
          <category> API </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java IO流 使用RandomAccessFile快速读写文本文件最后一行</title>
      <link href="/blog/4cd2c62c/"/>
      <url>/blog/4cd2c62c/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>今天写了一个使用RandomAccessFile来<strong>操作文本文件的最后一行</strong>的工具类，下面来介绍其中各个方法，我想以后我可能用的到。</p><ul><li>返回文本文件中最后一行的起始位置<ul><li>重载方法1 使用File参数表示的文件</li><li>重载方法2 使用RandomAccessFile参数表示的文件</li></ul></li><li>获取文本文件中最后一行文本</li><li>在文本文件最后一行追加文本<ul><li>重载方法1 使用File参数表示的文件</li><li>重载方法2 使用RandomAccessFile参数表示的文件</li></ul></li><li>在文本文件最后一行后插入另一行文本</li><li>删除文本文件最后一行<ul><li>重载方法1 使用File参数表示的文件</li><li>重载方法2 使用RandomAccessFile参数表示的文件</li></ul></li><li>更新文本文件最后一行</li><li>整个类的代码</li></ul><a id="more"></a><h2 id="返回文本文件中最后一行的起始位置"><a href="#返回文本文件中最后一行的起始位置" class="headerlink" title="返回文本文件中最后一行的起始位置"></a>返回文本文件中最后一行的起始位置</h2><h3 id="重载方法1-使用File参数表示的文件"><a href="#重载方法1-使用File参数表示的文件" class="headerlink" title="重载方法1 使用File参数表示的文件"></a>重载方法1 使用File参数表示的文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回文本文件的最后一行的起始位置。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file 文本文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最后一行的下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getLastLinePos</span><span class="params">(File file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> lastLinePos = <span class="number">0L</span>;</span><br><span class="line">RandomAccessFile raf;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"r"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文件占用字节数</span></span><br><span class="line"><span class="keyword">long</span> len = raf.length();</span><br><span class="line"><span class="keyword">if</span> (len &gt; <span class="number">0L</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 向前走一个字节</span></span><br><span class="line"><span class="keyword">long</span> pos = len - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (pos &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">pos--;</span><br><span class="line"><span class="comment">// 移动指针</span></span><br><span class="line">raf.seek(pos);</span><br><span class="line"><span class="comment">// 判断这个字节是不是回车符</span></span><br><span class="line"><span class="keyword">if</span> (raf.readByte() == <span class="string">'\n'</span>)</span><br><span class="line">&#123;</span><br><span class="line">lastLinePos = pos;<span class="comment">// 记录下位置</span></span><br><span class="line"><span class="keyword">break</span>;<span class="comment">// 前移到会第一个回车符后结束</span></span><br><span class="line"><span class="comment">// return pos;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> lastLinePos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重载方法2-使用RandomAccessFile参数表示的文件"><a href="#重载方法2-使用RandomAccessFile参数表示的文件" class="headerlink" title="重载方法2 使用RandomAccessFile参数表示的文件"></a>重载方法2 使用RandomAccessFile参数表示的文件</h3><p>返回最后一行的起始位置，并移动文件指针到最后一行的起始位置，这个方法适合于其他方法一起使用，以重用RandomAccessFile对象。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回最后一行的起始位置,并移动文件指针到最后一行的起始位置。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> raf RandomAccessFile对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最后一行的起始位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getLastLinePos</span><span class="params">(RandomAccessFile raf)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> lastLinePos = <span class="number">0L</span>;</span><br><span class="line"><span class="comment">// 获取文件占用字节数</span></span><br><span class="line"><span class="keyword">long</span> len = raf.length();</span><br><span class="line"><span class="keyword">if</span> (len &gt; <span class="number">0L</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 向前走一个字节</span></span><br><span class="line"><span class="keyword">long</span> pos = len - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (pos &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">pos--;</span><br><span class="line"><span class="comment">// 移动指针</span></span><br><span class="line">raf.seek(pos);</span><br><span class="line"><span class="comment">// 判断这个字节是不是回车符</span></span><br><span class="line"><span class="keyword">if</span> (raf.readByte() == <span class="string">'\n'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// lastLinePos = pos;// 记录下位置</span></span><br><span class="line"><span class="comment">// break;// 前移到会第一个回车符后结束</span></span><br><span class="line"><span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lastLinePos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>获取到最后一行的位置后就可以获取最后一行的文本了。如下所示：</p><h2 id="获取文本文件中最后一行文本"><a href="#获取文本文件中最后一行文本" class="headerlink" title="获取文本文件中最后一行文本"></a>获取文本文件中最后一行文本</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取文本文件最后一行中的字符串。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment"> *            目标文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> charset</span></span><br><span class="line"><span class="comment"> *            字符编码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 文本文件中最后一行中的字符串。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getLastLineStr</span><span class="params">(File file, String charset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">String lastLine = <span class="keyword">null</span>;</span><br><span class="line">RandomAccessFile raf = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rwd"</span>);</span><br><span class="line"><span class="comment">//获取最后一行的起始位置，并移动指针到指定位置。</span></span><br><span class="line"><span class="keyword">long</span> lastLinePos = getLastLinePos(raf);</span><br><span class="line"><span class="comment">//获取文件的大小：也就是占用的字节数</span></span><br><span class="line"><span class="keyword">long</span> length = raf.length();</span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) ((length - <span class="number">1</span>) - lastLinePos)];</span><br><span class="line"><span class="comment">//上面的getLastLinePos(raf);方法已经移动文件指针到最后一行的起始位置了，所以这里只需要读取即可。</span></span><br><span class="line">raf.read(bytes);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (charset == <span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">lastLine = (<span class="keyword">new</span> String(bytes));</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">lastLine = (<span class="keyword">new</span> String(bytes, charset));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lastLine;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在文本文件最后一行追加文本"><a href="#在文本文件最后一行追加文本" class="headerlink" title="在文本文件最后一行追加文本"></a>在文本文件最后一行追加文本</h2><h3 id="重载方法1-使用File参数表示的文件-1"><a href="#重载方法1-使用File参数表示的文件-1" class="headerlink" title="重载方法1 使用File参数表示的文件"></a>重载方法1 使用File参数表示的文件</h3><p>这个方法在最后一行后面追加文本，不会另起一行。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在文本文件最后一行末尾插入文本。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment"> *            目标文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newLastLine</span></span><br><span class="line"><span class="comment"> *            要插入的文本</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> charset</span></span><br><span class="line"><span class="comment"> *            字符编码名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertInLastLine</span><span class="params">(File file, String newLastLine,</span></span></span><br><span class="line"><span class="function"><span class="params">String charset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">RandomAccessFile raf = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rwd"</span>);</span><br><span class="line"><span class="comment">// 移动指针到最后一行</span></span><br><span class="line">raf.seek(raf.length());</span><br><span class="line">raf.write(newLastLine.getBytes(charset));</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (raf != <span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">raf.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="重载方法2-使用RandomAccessFile参数表示的文件-1"><a href="#重载方法2-使用RandomAccessFile参数表示的文件-1" class="headerlink" title="重载方法2 使用RandomAccessFile参数表示的文件"></a>重载方法2 使用RandomAccessFile参数表示的文件</h3><p>这个方法适合于其他方法一起使用，以重用RandomAccessFile对象。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在文本文件最后一行末尾追加文本。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newLastLine 要追加的文本</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> charset 字符编码名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> raf RandomAccessFile表示的文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertInLastLine</span><span class="params">(String newLastLine, String charset,</span></span></span><br><span class="line"><span class="function"><span class="params">RandomAccessFile raf)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, UnsupportedEncodingException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 移动指针到最后一行</span></span><br><span class="line">raf.seek(raf.length());</span><br><span class="line">raf.write(newLastLine.getBytes(charset));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="在文本文件最后一行后插入另一行文本"><a href="#在文本文件最后一行后插入另一行文本" class="headerlink" title="在文本文件最后一行后插入另一行文本"></a>在文本文件最后一行后插入另一行文本</h2><p>那么怎么在最后一行后面插入另一行文本呢，只需要在前面添加一个换行符就行了。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在最后一行中末尾中插入文本。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment"> *            目标文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newLastLine</span></span><br><span class="line"><span class="comment"> *            即将插入的文本</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> charset</span></span><br><span class="line"><span class="comment"> *            字符编码名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertAfterLastLine</span><span class="params">(File file, String newLastLine,</span></span></span><br><span class="line"><span class="function"><span class="params">String charset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">newLastLine = <span class="string">"\n"</span> + newLastLine;</span><br><span class="line">insertInLastLine(file, newLastLine, charset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="删除文本文件最后一行"><a href="#删除文本文件最后一行" class="headerlink" title="删除文本文件最后一行"></a>删除文本文件最后一行</h2><h3 id="重载方法1-使用File参数表示的文件-2"><a href="#重载方法1-使用File参数表示的文件-2" class="headerlink" title="重载方法1 使用File参数表示的文件"></a>重载方法1 使用File参数表示的文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除本文文件最后一行。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteLastLine</span><span class="params">(File file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">RandomAccessFile raf = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rwd"</span>);</span><br><span class="line"><span class="comment">// 获取最后一行的位置</span></span><br><span class="line"><span class="keyword">long</span> lastLinePos = getLastLinePos(raf);</span><br><span class="line"><span class="comment">// 删除最后一行</span></span><br><span class="line">raf.setLength(lastLinePos);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (raf != <span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">raf.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重载方法2-使用RandomAccessFile参数表示的文件-2"><a href="#重载方法2-使用RandomAccessFile参数表示的文件-2" class="headerlink" title="重载方法2 使用RandomAccessFile参数表示的文件"></a>重载方法2 使用RandomAccessFile参数表示的文件</h3><p>这个方法适合于其他方法一起使用，以重用RandomAccessFile对象。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除本文文件最后一行。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> raf</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteLastLine</span><span class="params">(RandomAccessFile raf)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 获取最后一行的位置</span></span><br><span class="line"><span class="keyword">long</span> lastLinePos = getLastLinePos(raf);</span><br><span class="line"><span class="comment">// 删除最后一行</span></span><br><span class="line">raf.setLength(lastLinePos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="更新文本文件最后一行"><a href="#更新文本文件最后一行" class="headerlink" title="更新文本文件最后一行"></a>更新文本文件最后一行</h2><p>更新的思想是：先删除最后一行，然后再在文件后面追加就行了。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新最后一行文本。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment"> *            目标文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newLastLine</span></span><br><span class="line"><span class="comment"> *            替换文本</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> charset</span></span><br><span class="line"><span class="comment"> *            字符编码名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">updateLastLine</span><span class="params">(File file, String newLastLine,</span></span></span><br><span class="line"><span class="function"><span class="params">String charset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">RandomAccessFile raf = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rwd"</span>);</span><br><span class="line"><span class="comment">// 删除最后一行文本</span></span><br><span class="line">deleteLastLine(raf);</span><br><span class="line"><span class="comment">// 在最后一行插入新的一行文本</span></span><br><span class="line">insertInLastLine(newLastLine, charset, raf);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (raf != <span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">raf.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="整个类的代码"><a href="#整个类的代码" class="headerlink" title="整个类的代码"></a>整个类的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LastLineInFileTools</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取文本文件最后一行中的字符串。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment"> *            目标文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> charset</span></span><br><span class="line"><span class="comment"> *            字符编码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 文本文件中最后一行中的字符串。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getLastLineStr</span><span class="params">(File file, String charset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">String lastLine = <span class="keyword">null</span>;</span><br><span class="line">RandomAccessFile raf = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rwd"</span>);</span><br><span class="line"><span class="keyword">long</span> lastLinePos = getLastLinePos(raf);</span><br><span class="line"><span class="keyword">long</span> length = raf.length();</span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) ((length - <span class="number">1</span>) - lastLinePos)];</span><br><span class="line">raf.read(bytes);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (charset == <span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// return new String(bytes);</span></span><br><span class="line">lastLine = (<span class="keyword">new</span> String(bytes));</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// return new String(bytes, charset);</span></span><br><span class="line">lastLine = (<span class="keyword">new</span> String(bytes, charset));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lastLine;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在最后一行中末尾中插入文本。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment"> *            目标文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newLastLine</span></span><br><span class="line"><span class="comment"> *            即将插入的文本</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> charset</span></span><br><span class="line"><span class="comment"> *            字符编码名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertAfterLastLine</span><span class="params">(File file, String newLastLine,</span></span></span><br><span class="line"><span class="function"><span class="params">String charset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">newLastLine = <span class="string">"\n"</span> + newLastLine;</span><br><span class="line">insertInLastLine(file, newLastLine, charset);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新最后一行文本。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment"> *            目标文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newLastLine</span></span><br><span class="line"><span class="comment"> *            替换文本</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> charset</span></span><br><span class="line"><span class="comment"> *            字符编码名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">updateLastLine</span><span class="params">(File file, String newLastLine,</span></span></span><br><span class="line"><span class="function"><span class="params">String charset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">RandomAccessFile raf = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rwd"</span>);</span><br><span class="line"><span class="comment">// 删除最后一行文本</span></span><br><span class="line">deleteLastLine(raf);</span><br><span class="line"><span class="comment">// 在最后一行插入新的一行文本</span></span><br><span class="line">insertInLastLine(newLastLine, charset, raf);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (raf != <span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">raf.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在文本文件最后一行末尾追加文本。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newLastLine 要追加的文本</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> charset 字符编码名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> raf RandomAccessFile表示的文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertInLastLine</span><span class="params">(String newLastLine, String charset,</span></span></span><br><span class="line"><span class="function"><span class="params">RandomAccessFile raf)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, UnsupportedEncodingException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 移动指针到最后一行</span></span><br><span class="line">raf.seek(raf.length());</span><br><span class="line">raf.write(newLastLine.getBytes(charset));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在文本文件最后一行末尾插入文本。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment"> *            目标文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newLastLine</span></span><br><span class="line"><span class="comment"> *            要插入的文本</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> charset</span></span><br><span class="line"><span class="comment"> *            字符编码名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertInLastLine</span><span class="params">(File file, String newLastLine,</span></span></span><br><span class="line"><span class="function"><span class="params">String charset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">RandomAccessFile raf = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rwd"</span>);</span><br><span class="line"><span class="comment">// 移动指针到最后一行</span></span><br><span class="line">raf.seek(raf.length());</span><br><span class="line">raf.write(newLastLine.getBytes(charset));</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (raf != <span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">raf.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除本文文件最后一行。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> raf</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteLastLine</span><span class="params">(RandomAccessFile raf)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 获取最后一行的位置</span></span><br><span class="line"><span class="keyword">long</span> lastLinePos = getLastLinePos(raf);</span><br><span class="line"><span class="comment">// 删除最后一行</span></span><br><span class="line">raf.setLength(lastLinePos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除本文文件最后一行。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteLastLine</span><span class="params">(File file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">RandomAccessFile raf = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rwd"</span>);</span><br><span class="line"><span class="comment">// 获取最后一行的位置</span></span><br><span class="line"><span class="keyword">long</span> lastLinePos = getLastLinePos(raf);</span><br><span class="line"><span class="comment">// 删除最后一行</span></span><br><span class="line">raf.setLength(lastLinePos);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (raf != <span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">raf.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回最后一行的起始位置,并移动文件指针到最后一行的起始位置。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> raf RandomAccessFile对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最后一行的起始位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getLastLinePos</span><span class="params">(RandomAccessFile raf)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> lastLinePos = <span class="number">0L</span>;</span><br><span class="line"><span class="comment">// 获取文件占用字节数</span></span><br><span class="line"><span class="keyword">long</span> len = raf.length();</span><br><span class="line"><span class="keyword">if</span> (len &gt; <span class="number">0L</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 向前走一个字节</span></span><br><span class="line"><span class="keyword">long</span> pos = len - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (pos &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">pos--;</span><br><span class="line"><span class="comment">// 移动指针</span></span><br><span class="line">raf.seek(pos);</span><br><span class="line"><span class="comment">// 判断这个字节是不是回车符</span></span><br><span class="line"><span class="keyword">if</span> (raf.readByte() == <span class="string">'\n'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// lastLinePos = pos;// 记录下位置</span></span><br><span class="line"><span class="comment">// break;// 前移到会第一个回车符后结束</span></span><br><span class="line"><span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lastLinePos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回文本文件的最后一行的起始位置。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file 文本文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最后一行的下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getLastLinePos</span><span class="params">(File file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> lastLinePos = <span class="number">0L</span>;</span><br><span class="line">RandomAccessFile raf;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"r"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文件占用字节数</span></span><br><span class="line"><span class="keyword">long</span> len = raf.length();</span><br><span class="line"><span class="keyword">if</span> (len &gt; <span class="number">0L</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 向前走一个字节</span></span><br><span class="line"><span class="keyword">long</span> pos = len - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (pos &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">pos--;</span><br><span class="line"><span class="comment">// 移动指针</span></span><br><span class="line">raf.seek(pos);</span><br><span class="line"><span class="comment">// 判断这个字节是不是回车符</span></span><br><span class="line"><span class="keyword">if</span> (raf.readByte() == <span class="string">'\n'</span>)</span><br><span class="line">&#123;</span><br><span class="line">lastLinePos = pos;<span class="comment">// 记录下位置</span></span><br><span class="line"><span class="keyword">break</span>;<span class="comment">// 前移到会第一个回车符后结束</span></span><br><span class="line"><span class="comment">// return pos;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> lastLinePos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文链接: <a href="https://www.lansheng.net.cn/blog/4cd2c62c/">Java IO流 使用RandomAccessFile快速读写文本文件最后一行</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java IO流 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hexo博客支持百度熊掌号推送</title>
      <link href="/blog/5f9ceba2/"/>
      <url>/blog/5f9ceba2/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><h2 id="首先注册熊掌号"><a href="#首先注册熊掌号" class="headerlink" title="首先注册熊掌号"></a>首先注册熊掌号</h2><p>点击：<a href="https://xiongzhang.baidu.com/site/register" target="_blank" rel="noopener">https://xiongzhang.baidu.com/site/register</a>注册一个熊账号：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/baiduSEO/xiongzhanghao/register.png" alt=""><br>然后选择个人：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/baiduSEO/zidongtuisong/filldata_geren.png" alt=""><br>然后填入其他信息，上传身份证，提交审核，略去不写。等待审核成功。<br><a id="more"></a><br>先写到这里，后续审核通过了我在再增加,注册这个只是为了，让我的博客站点在百度搜索中的排名靠前点。SEO还真心不容易啊。</p><h2 id="Hexo安装插件支持百度熊掌号自动推送"><a href="#Hexo安装插件支持百度熊掌号自动推送" class="headerlink" title="Hexo安装插件支持百度熊掌号自动推送"></a>Hexo安装插件支持百度熊掌号自动推送</h2><p>具体参照我的这篇文章：<a href="https://www.lansheng.net.cn/blog/2740f49f/">ERROR Deployer not found：baidu_xz_url_submitter</a><br>我不想再重复写一次了。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/5f9ceba2/">hexo博客支持百度熊掌号推送</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> SEO </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hexo 使用永久链接</title>
      <link href="/blog/7ac3f84/"/>
      <url>/blog/7ac3f84/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:16 GMT+0800 (中国标准时间) --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后浏览器上打开这篇文章，可以看到链接已经变成了：</span><br></pre></td></tr></table></figure><p><a href="https://www.lansheng.net.cn/blog/7ac3f84/">https://www.lansheng.net.cn/blog/7ac3f84/</a><br><code>`</code><br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/SEO/yongjiulianjie/liulanqixiaoguo.png" alt=""><br>这样链接就永远是这个<code>https://www.lansheng.net.cn/blog/7ac3f84/</code>地址了，后面我可以随意修改标题，部署后链接还是不变。这样有利于搜索引擎收录。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://muyunyun.cn/posts/f55182c5/#%E6%96%87%E7%AB%A0%E9%93%BE%E6%8E%A5%E5%94%AF%E4%B8%80%E5%8C%96" target="_blank" rel="noopener">http://muyunyun.cn/posts/f55182c5/#文章链接唯一化</a><br><a href="https://github.com/rozbo/hexo-abbrlink" target="_blank" rel="noopener">https://github.com/rozbo/hexo-abbrlink</a></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/7ac3f84/">hexo 使用永久链接</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> SEO </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java快速读取一个很大的文本文件的最后一行</title>
      <link href="/blog/487a7f53/"/>
      <url>/blog/487a7f53/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p><strong>用RandomAccessFile.seek(long pos) 跳到最后一个字节，然后一个字节一个字节往回查，查到换行符为止。</strong><br><a id="more"></a></p><h2 id="返回文本文件最后一行java代码"><a href="#返回文本文件最后一行java代码" class="headerlink" title="返回文本文件最后一行java代码"></a>返回文本文件最后一行java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readLastLine</span><span class="params">(File file, String charset)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!file.exists() || file.isDirectory() || !file.canRead())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">RandomAccessFile raf = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"r"</span>);</span><br><span class="line"><span class="comment">//获取文件占用字节数</span></span><br><span class="line"><span class="keyword">long</span> len = raf.length();</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">0L</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//向前走一个字节</span></span><br><span class="line"><span class="keyword">long</span> pos = len - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (pos &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">pos--;</span><br><span class="line"><span class="comment">//移动指针</span></span><br><span class="line">raf.seek(pos);</span><br><span class="line"><span class="comment">//判断这个字节是不是回车符</span></span><br><span class="line"><span class="keyword">if</span> (raf.readByte() == <span class="string">'\n'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//前移到会第一个回车符后结束</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pos == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">raf.seek(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录下当前位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) (len - pos)];</span><br><span class="line"><span class="comment">//读取从回车符位置到文件结尾的所有字节</span></span><br><span class="line">raf.read(bytes);</span><br><span class="line"><span class="keyword">if</span> (charset == <span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> String(bytes);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> String(bytes, charset);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e)</span><br><span class="line">&#123;</span><br><span class="line">&#125; <span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (raf != <span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">raf.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e2)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://blog.csdn.net/q_linchao/article/details/79630906" target="_blank" rel="noopener">https://blog.csdn.net/q_linchao/article/details/79630906</a></p><h2 id="读取本文文件最后一行，并记下最后一行的位置"><a href="#读取本文文件最后一行，并记下最后一行的位置" class="headerlink" title="读取本文文件最后一行，并记下最后一行的位置"></a>读取本文文件最后一行，并记下最后一行的位置</h2><p>如果文本文件最后一行也有特殊的意义，需要动态的更新最后一行，单单读取最后一行是远远不够的，所以我在上面代码的基础上进一步封装成一个工具类，<strong>把文本文件的最后一行，以及最后一行的位置。保存在内部成员属性中</strong>，源代码如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LastLineInFile</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> lastlinestart;</span><br><span class="line"><span class="keyword">private</span> String lastLine;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LastLineInFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.lastlinestart=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>.lastLine=<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLastlinestart</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> lastlinestart;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getLastLine</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> lastLine;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setLastlinestart</span><span class="params">(<span class="keyword">long</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.lastlinestart = pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setLastLine</span><span class="params">(String lastLine)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.lastLine = lastLine;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readLastLine</span><span class="params">(File file, String charset)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">RandomAccessFile raf = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"r"</span>);</span><br><span class="line"><span class="comment">//获取文件占用字节数</span></span><br><span class="line"><span class="keyword">long</span> len = raf.length();</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">0L</span>)</span><br><span class="line">&#123;</span><br><span class="line">setLastLine(<span class="string">""</span>);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//向前走一个字节</span></span><br><span class="line"><span class="keyword">long</span> pos = len - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (pos &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">pos--;</span><br><span class="line"><span class="comment">//移动指针</span></span><br><span class="line">raf.seek(pos);</span><br><span class="line"><span class="comment">//判断这个字节是不是回车符</span></span><br><span class="line"><span class="keyword">if</span> (raf.readByte() == <span class="string">'\n'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//前移到会第一个回车符后结束</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pos == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">raf.seek(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录下当前位置</span></span><br><span class="line">setLastlinestart(pos);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) (len - pos)];</span><br><span class="line"><span class="comment">//读取从回车符位置到文件结尾的所有字节</span></span><br><span class="line">raf.read(bytes);</span><br><span class="line"><span class="keyword">if</span> (charset == <span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">setLastLine(<span class="keyword">new</span> String(bytes));</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">setLastLine(<span class="keyword">new</span> String(bytes,charset));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e)</span><br><span class="line">&#123;</span><br><span class="line">&#125; <span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (raf != <span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">raf.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e2)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这样我记下了最后一行的位置之后，就可以动态的更新最后一行了,使用代码片段如下所示：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">LastLineInFile lastLineInFile=<span class="keyword">new</span> LastLineInFile();</span><br><span class="line">File localFile=<span class="keyword">new</span> File(localPath);</span><br><span class="line"><span class="comment">//读取最后一行，得到最后一行的位置，和最后一行的字符串</span></span><br><span class="line">lastLineInFile.readLastLine(localFile, <span class="string">"utf-8"</span>);</span><br><span class="line"><span class="comment">//获取最后一行的字符串</span></span><br><span class="line">String lastLine=lastLineInFile.getLastLine();</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新文章最后一行。</span></span><br><span class="line"><span class="comment">//以读写方式打开,同时要求每个更新都写入底层设备</span></span><br><span class="line">RandomAccessFile rf=<span class="keyword">new</span> RandomAccessFile(localFile, <span class="string">"rwd"</span>);</span><br><span class="line"><span class="comment">//获取最后一行的位置</span></span><br><span class="line"><span class="keyword">long</span> filelastpos=lastLineInFile.getLastlinestart();</span><br><span class="line">System.out.println(<span class="string">"最后一行位置："</span>+filelastpos);</span><br><span class="line"><span class="comment">//截取文件，是最后一行被截走，相当于删除掉最后一行</span></span><br><span class="line">rf.setLength(filelastpos);</span><br><span class="line"><span class="comment">//指针移动到文件末尾</span></span><br><span class="line">rf.seek(filelastpos);</span><br><span class="line"><span class="comment">//写入新的信息</span></span><br><span class="line">rf.write(hyperLinks.getBytes(<span class="string">"utf-8"</span>));</span><br><span class="line"><span class="comment">//关闭文件</span></span><br><span class="line">rf.close();</span><br></pre></td></tr></table></figure><p></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/487a7f53/">Java快速读取一个很大的文本文件的最后一行</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java IO流 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Git命令集合</title>
      <link href="/blog/504e809a/"/>
      <url>/blog/504e809a/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:16 GMT+0800 (中国标准时间) --><p>收集一下我常用到的一些git命令。<br><a id="more"></a></p><h2 id="分支相关"><a href="#分支相关" class="headerlink" title="分支相关"></a>分支相关</h2><h3 id="查询分支"><a href="#查询分支" class="headerlink" title="查询分支"></a>查询分支</h3><p><code>git branch</code></p><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev</span><br></pre></td></tr></table></figure><p><code>git checkout</code>命令加上-b参数表示创建并切换，相当于以下两条命令：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch dev</span><br><span class="line">git checkout dev</span><br></pre></td></tr></table></figure><p></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/504e809a/">Git命令集合</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用Java在每篇hexo文章中加入本文链接</title>
      <link href="/blog/c0eb3251/"/>
      <url>/blog/c0eb3251/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>使用Java在每篇hexo文章中加入本文链接<br>我发现的个人hexo博客很难再百度上搜索出来，所以我想先在自己的博客网站上写好，然后转载到CSDN上去，并在文章最后面，加上这篇文章在我的网站的链接。这样如果有人在CSDN上读取到我的文章后，有兴趣的话可以点到我的个人博客上来，增加访问量。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>获取文章(markdown文档)在本地的路径例如(<code>D:\Blog\bolg5\source\_posts\我的软件\Hexo博客工具程序\使用Java在每篇hexo文章中加入本文链接.md</code>)，然后从把本地站点的路径替换成发布后的路径即可。<br><a id="more"></a></p><h2 id="路径分析"><a href="#路径分析" class="headerlink" title="路径分析"></a>路径分析</h2><p>先拿本地一篇文章来分析路径：</p><ul><li>本地路径localpath: “D:\Blog\bolg5\source_posts\Hexo搭建博客\遇到问题\Coding内存不足\coding绑定腾讯云扩容项目容量到512M.md”</li><li>文章的date标记dateStr: date: 2018-10-28 13:48:34</li><li>发布路径URL：<code>https://www.lansheng.net.cn/2018/10/28/Hexo搭建博客/遇到问题/Coding内存不足/coding绑定腾讯云扩容项目容量到512M/</code></li></ul><h2 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h2><p>这里我先来自定义URL的格式：<code>headStr+dateStr+tailStr</code>,对于URL：<code>https://www.lansheng.net.cn/2018/10/28/Hexo搭建博客/遇到问题/Coding内存不足/coding绑定腾讯云扩容项目容量到512M/</code><br>首先，先把路径中的<code>D:\Blog\bolg5\source\_posts</code>去除掉：变成本地相对路径relativePath<code>\Hexo搭建博客\遇到问题\Coding内存不足\coding绑定腾讯云扩容项目容量到512M.md</code><br>headStr=<code>https://www.lansheng.net.cn</code>,这个也就是的根目录,因为是自己的网站，这个是固定的，不需要代码去生成<br>dateStr=<code>2018/10/28</code>,这个跟自己文章中front-matter中写的date字段有关。所以要读取一遍文章，找到文章中的dateStr字段。<br>tailStr=<code>/Hexo搭建博客/遇到问题/Coding内存不足/coding绑定腾讯云扩容项目容量到512M/</code>,这个跟文件在本地中的路径有关</p><h2 id="生成tailStr"><a href="#生成tailStr" class="headerlink" title="生成tailStr"></a>生成tailStr</h2><p>java代码：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String localRoot=<span class="string">"D:\\Blog\\bolg5\\source\\_posts"</span>;</span><br><span class="line">String localPath=<span class="string">"D:\\Blog\\bolg5\\source\\_posts\\Hexo搭建博客\\遇到问题\\Coding内存不足\\coding绑定腾讯云扩容项目容量到512M.md"</span>;</span><br><span class="line">String relativePath=localPath.substring(localPath.indexOf(localRoot)+localRoot.length());</span><br><span class="line"></span><br><span class="line">System.out.println(relativePath);</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\Hexo搭建博客\遇到问题\Coding内存不足\coding绑定腾讯云扩容项目容量到512M.md</span><br></pre></td></tr></table></figure><p></p><p>然后把,把相对路径relativePath中的斜杠”\”,替换成反斜杠”/“,这样就得到了：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Hexo搭建博客/遇到问题/Coding内存不足/coding绑定腾讯云扩容项目容量到512M.md</span><br></pre></td></tr></table></figure><p></p><p>对应java代码为：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">relativePath=relativePath.replace(<span class="string">"\\"</span>, <span class="string">"/"</span>);</span><br></pre></td></tr></table></figure><p></p><p>然后就是把relativePath中的<code>.md</code>替换为”<code>/</code>“，这样就得到了本地的相对地址：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Hexo搭建博客/遇到问题/Coding内存不足/coding绑定腾讯云扩容项目容量到512M/</span><br></pre></td></tr></table></figure><p></p><p>也就的到了URL的尾部：<code>https://www.lansheng.net.cn/2018/10/28/Hexo搭建博客/遇到问题/Coding内存不足/coding绑定腾讯云扩容项目容量到512M/</code></p><h2 id="生成dateStr"><a href="#生成dateStr" class="headerlink" title="生成dateStr"></a>生成dateStr</h2><h3 id="读取文章找到front-matter中的date标记"><a href="#读取文章找到front-matter中的date标记" class="headerlink" title="读取文章找到front-matter中的date标记"></a>读取文章找到front-matter中的date标记</h3><p>这个可以用java的字符流来实现：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">String frontMatterDate=<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(</span><br><span class="line"><span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(localPath)), <span class="string">"utf-8"</span>));</span><br><span class="line">String line=<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span>((line=reader.readLine())!=<span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(line.startsWith(<span class="string">"date:"</span>))</span><br><span class="line">&#123;</span><br><span class="line">frontMatterDate=line;</span><br><span class="line">System.out.println(<span class="string">"front-matter中的date  :"</span>+frontMatterDate);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">front-matter中的date  :date: 2018-10-28 13:48:34</span><br></pre></td></tr></table></figure><p></p><p>获取到front-matter中的date标记后，接下来就根据这个获取到的date标记来生成URL中的dateStr项了。首先要从frontMatterDate中取出<code>年月日</code>;这个功能可以通过正则表达式来实现:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"front-matter中的date---:"</span>+frontMatterDate);</span><br><span class="line">frontMatterDate=frontMatterDate.replaceAll(<span class="string">"date: (\\d&#123;4&#125;-\\d+-\\d+).*"</span>, <span class="string">"$1"</span>);</span><br><span class="line">System.out.println(<span class="string">"年月日:"</span>+frontMatterDate);</span><br></pre></td></tr></table></figure><p></p><p>获取到日期项之后，生成URL中的dateStr项就很简单了，只要把里面的连字符”<code>-</code>“替换成斜线就行了。java代码如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String dateStr=frontMatterDate.replace(<span class="string">"-"</span>, <span class="string">"/"</span>);</span><br><span class="line">System.out.println(<span class="string">"dateStr:"</span>+dateStr);</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dateStr:2018/10/28</span><br></pre></td></tr></table></figure><p></p><h2 id="加上网站根目录地址-生成完整的URL"><a href="#加上网站根目录地址-生成完整的URL" class="headerlink" title="加上网站根目录地址,生成完整的URL"></a>加上网站根目录地址,生成完整的URL</h2><p>java代码如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String webRoot=<span class="string">"https://www.lansheng.net.cn/"</span>;</span><br><span class="line">String URL=webRoot+dateStr+relativePath;</span><br><span class="line">System.out.println(URL);</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.lansheng.net.cn/2018/10/28/Hexo搭建博客/遇到问题/Coding内存不足/coding绑定腾讯云扩容项目容量到512M/</span><br></pre></td></tr></table></figure><p></p><p>测试能否用浏览器打开：<br><a href="https://www.lansheng.net.cn/2018/10/28/Hexo搭建博客/遇到问题/Coding内存不足/coding绑定腾讯云扩容项目容量到512M/">https://www.lansheng.net.cn/2018/10/28/Hexo搭建博客/遇到问题/Coding内存不足/coding绑定腾讯云扩容项目容量到512M/</a><br>嗯，是可以用浏览器打开的！链接算是拼接成功了。</p><h2 id="将拼接好的链接写到每篇文章尾部"><a href="#将拼接好的链接写到每篇文章尾部" class="headerlink" title="将拼接好的链接写到每篇文章尾部"></a>将拼接好的链接写到每篇文章尾部</h2><p>本文链接: <a href="https://www.lansheng.net.cn/blog/c0eb3251/">使用Java在每篇hexo文章中加入本文链接</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 我的软件 </category>
          
          <category> Hexo博客工具程序 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>markdown中让图片和表格显示在一行</title>
      <link href="/blog/f0d2185d/"/>
      <url>/blog/f0d2185d/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>原本的markdown表格语法是没有这个功能的,只能通过html代码来实现,在表格和图片外面再套上一个表格，外表格的第一个单元格放内表格，第二个单元格中放图片标签。这样图片和内表格就能显示在一行中了。具体html代码如下：<br><a id="more"></a><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">width</span>=<span class="string">"80%"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"right"</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"left"</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"right"</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"left"</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"right"</span>&gt;</span>电话<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"left"</span>&gt;</span>xxxx<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"right"</span>&gt;</span>邮箱<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"left"</span>&gt;</span>xxxxxxx@xxx<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">width</span>=<span class="string">"20%"</span> <span class="attr">height</span>=<span class="string">"100%"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"url"</span> <span class="attr">alt</span>=<span class="string">"我的照片"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>还有就是markdown中html表格标签中不要有换行符，显示的时候回出现好多空白行。删除上面的表格标签中的空白符后显示自效果如下：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/findjob/table_img_insameline.png" alt=""></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/f0d2185d/">markdown中让图片和表格显示在一行</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> markdown使用 </category>
          
          <category> markdown语法 </category>
          
          <category> 使用html标签 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>优秀个人博客收录</title>
      <link href="/blog/44df1069/"/>
      <url>/blog/44df1069/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>这里来收录一些看到的一些个人博客，有时间可以去看看，看看别人都在写什么。<br><a id="more"></a></p><h2 id="干货多"><a href="#干货多" class="headerlink" title="干货多"></a>干货多</h2><ul><li><a href="https://www.hollischuang.com/" target="_blank" rel="noopener">https://www.hollischuang.com/</a>：干货挺多，<a href="https://www.hollischuang.com/archives/category/java" target="_blank" rel="noopener">java</a>,框架都有。</li><li><a href="https://mrdear.cn/" target="_blank" rel="noopener">“屈定’s Blog”</a>：干货挺多，<a href="https://mrdear.cn/categories/%E5%A4%AF%E5%AE%9EJava%E5%9F%BA%E7%A1%80/" target="_blank" rel="noopener">夯实Java基础</a>,设计模式，Spring系列。</li><li><a href="https://www.se7ensec.cn/" target="_blank" rel="noopener">https://www.se7ensec.cn/</a> 网站UI做的很好。</li><li><a href="https://alili.tech/archives/" target="_blank" rel="noopener">https://alili.tech/archives/</a> 前段相关</li></ul><h2 id="有点东西"><a href="#有点东西" class="headerlink" title="有点东西"></a>有点东西</h2><ul><li><a href="http://www.fogsail.net/categories/index.html" target="_blank" rel="noopener">http://www.fogsail.net/categories/index.html</a></li><li><a href="https://suchenrain.github.io/categories/" target="_blank" rel="noopener">https://suchenrain.github.io/categories/</a>:github.io，东西有点，但是零散。</li><li><a href="http://shenzekun.cn/categories/" target="_blank" rel="noopener">shenzekun.cn</a>：文章，主要有前端的东西。还有前端相关的链接。</li></ul><p>本文链接: <a href="https://www.lansheng.net.cn/blog/44df1069/">优秀个人博客收录</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
          <category> 优秀个人博客收录 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>coding绑定腾讯云扩容项目容量到512M</title>
      <link href="/blog/71fcdb17/"/>
      <url>/blog/71fcdb17/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>今天写了文章,使用<code>hexo d</code>部署的时候，无法部署上去了，原因是我之前coding的空间只有128M的容量，让我扩容。然后我登录了coding,点击升级的链接：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98/Coding%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3/coding%E5%8D%87%E7%BA%A7%E6%96%87%E6%A1%A3.png" alt=""><br>发现Coding上的官方文档写的不清不楚的：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98/Coding%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3/coding_upgrade_show.png" alt=""><br>注册了腾讯云，但是却在腾讯云的链接里找不到地方绑定Coding的地方,反反复复搞得我好烦。</p><p>转念一想应该<strong>可以在Coding里面绑定腾讯云</strong>！操作如下：<br><a id="more"></a><br>登录coding,然后点击头像，打开个人设置。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98/Coding%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3/coding_binding_setting.png" alt=""><br>然后点击下面的绑定设置：在腾讯云项点击绑定即可：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98/Coding%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3/coding_binding_tencentcloud.png" alt=""><br>这样就可以免费升级到Coding的银牌会员了。项目的存储空间也就提升到512M,当然这比GitHub的1G要小一半。暂时先这样用吧。</p><p>参考<a href="https://www.jianshu.com/p/5ded8e64951e" target="_blank" rel="noopener">https://www.jianshu.com/p/5ded8e64951e</a></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/71fcdb17/">coding绑定腾讯云扩容项目容量到512M</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> 遇到问题 </category>
          
          <category> Coding内存不足 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hexo博客 百度sitemap无法抓取</title>
      <link href="/blog/ebaabcd4/"/>
      <url>/blog/ebaabcd4/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>之前有人说Github不允许百度蜘蛛抓取，我又再部署衣服到coding上，双线部署了。地址解析也改成默认解析到coding,境外解析到github。按理说这样应该没问题了，但是百度老是说我提交的sitemap地址不正确。真是的，我再重新来走一下配置流程！</p><ul><li>安装插件</li><li>配置站点配置文件_config.yml</li><li>部署</li><li>查看本地生成的baidusitemap.xml文件</li><li>确认浏览器中可以打开baidusitemap.xml文件</li><li>复制浏览器中的地址提交给百度</li></ul><a id="more"></a><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>在站点目录下，打开git-bash,输入下面的命令安装插件。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure><p></p><h2 id="配置站点配置文件-config-yml"><a href="#配置站点配置文件-config-yml" class="headerlink" title="配置站点配置文件_config.yml"></a>配置站点配置文件_config.yml</h2><p>在<strong>站点配置文件</strong><code>_config.yml</code>中添加如下配置，我之前就没有在站点配置文件中填写下面的配置项。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Plugins:</span><br><span class="line">- hexo-generator-baidu-sitemap</span><br><span class="line">- hexo-generator-sitemap</span><br><span class="line"></span><br><span class="line">baidusitemap:</span><br><span class="line">    path: baidusitemap.xml</span><br><span class="line">sitemap:</span><br><span class="line">    path: sitemap.xml</span><br></pre></td></tr></table></figure><p></p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>输入命令:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean&amp;&amp;hexo g&amp;&amp;hexo d</span><br></pre></td></tr></table></figure><p></p><p>部署到github和coding。</p><h2 id="查看本地生成的baidusitemap-xml文件"><a href="#查看本地生成的baidusitemap-xml文件" class="headerlink" title="查看本地生成的baidusitemap.xml文件"></a>查看本地生成的baidusitemap.xml文件</h2><p>部署后打开本地站点镜像目录：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98/%E7%99%BE%E5%BA%A6%E6%94%B6%E5%BD%95/baidusitemapIn_deploy_git.png" alt=""><br>可以看到站点目录下生成了<code>baidusitemap.xml</code>文件，把这个文件提交给百度即可。</p><h2 id="确认浏览器中可以打开baidusitemap-xml文件"><a href="#确认浏览器中可以打开baidusitemap-xml文件" class="headerlink" title="确认浏览器中可以打开baidusitemap.xml文件"></a>确认浏览器中可以打开baidusitemap.xml文件</h2><p>在这之前先来确认浏览器能不能打开<code>baidusitemap.xml</code>文件：<br>输入地址：<code>https://www.lansheng.net.cn/baidusitemap.xml</code>是可以访问到<code>baidusitemap.xml</code>的：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98/baidusitemapshow.png" alt=""></p><h2 id="复制浏览器中的地址提价给百度"><a href="#复制浏览器中的地址提价给百度" class="headerlink" title="复制浏览器中的地址提价给百度"></a>复制浏览器中的地址提价给百度</h2><p>那么剩下的就是提交到百度的链接不对了：复制浏览器上面<code>baidusitemap.xml</code>地址栏的地址：<code>https://www.lansheng.net.cn/baidusitemap.xml</code>填写到<a href="https://ziyuan.baidu.com/linksubmit/index" target="_blank" rel="noopener">百度sitemap提交位置</a>即可。<code>注意要写全url</code>,不要写成<code>www.lansheng.net.cn/baidusitemap.xml</code>,我之前就是没有写<code>https://</code>百度抓取的是<code>http://www.lansheng.net.cn/baidusitemap.xml</code>,这样就抓取失败了。抓取成功显示如下：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98/%E7%99%BE%E5%BA%A6%E6%97%A0%E6%B3%95%E6%8A%93%E5%8F%96.png" alt=""><br>等过两天后再查看提交量，应该就可以看到sitemap提交的数目了：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E7%99%BE%E5%BA%A6%E8%87%AA%E5%8A%A8%E6%8E%A8%E9%80%81/sitemapnotrue/sitemapyes.png" alt=""><br>其他配置可以点击的下面的参考链接查看：需要注意的是它这里的提交的百度链接不正确。<br>参考：<a href="https://www.jianshu.com/p/9c2d6db2f855" target="_blank" rel="noopener">https://www.jianshu.com/p/9c2d6db2f855</a></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/ebaabcd4/">Hexo博客 百度sitemap无法抓取</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> 遇到问题 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java Web从入门到精通第3章 3-6常用对象 JavaScript Windows对象</title>
      <link href="/blog/7d4ba91e/"/>
      <url>/blog/7d4ba91e/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><p>通过前面的学习,知道 JavaScript是一种基于对象的语言,它可以应用自己创建的对象,因此许多功能来自于脚本环境中对象的方法与脚本的相互作用。下面将对 JavaScript的常用对象进行详细介绍。</p><ul><li>Window对象<ul><li>Window对象的属性</li><li>Window对象的方法</li></ul></li><li>String对象</li></ul><a id="more"></a><h2 id="Window对象"><a href="#Window对象" class="headerlink" title="Window对象"></a>Window对象</h2><p>Window对象即浏览器窗口对象,是一个全局对象,是所有对象的顶级对象,在 JavaScript中起着举足轻重的作用。 Window对象提供了许多属性和方法,这些属性和方法被用来操作浏览器页面的内容。Window对象同Math对象一样,也不需要使用new关键字创建对象实例,而是直接使用“<code>对象名.成员</code>”的格式来访问其属性或方法。下面将对 Window对象的属性和方法进行介绍。</p><h3 id="Window对象的属性"><a href="#Window对象的属性" class="headerlink" title="Window对象的属性"></a>Window对象的属性</h3><p>Window对象的常用属性如下表所示：</p><hr><table border="1"><caption><center><strong>Window对象的常用属性</strong></center></caption><tr><th>属性</th><th>描述</th></tr><tr><td>document</td><td>对窗口或框架中含有文档的 Document对象的<strong>只读引用</strong></td></tr><tr><td>defaultStatus</td><td>一个可读写的字符,用于指定状态栏中的默认消息</td></tr><tr><td>frames</td><td>表示当前窗口中所有Frame对象的集合</td></tr><tr><td>location</td><td>用于代表窗口或框架的Location对象。如果将一个URL赋予该属性,则浏览器将加载并显示该URL指定的文档</td></tr><tr><td>length</td><td>窗口或框架包含的框架个数</td></tr><tr><td>histoy</td><td>对窗口或框架的History对象的只读引用</td></tr><tr><td>name</td><td>用于存放窗口对象的名称</td></tr><tr><td>status</td><td>一个可读写的字符,用于指定状态栏中的当前信息</td></tr><tr><td>top</td><td>表示最项层的浏览器窗口</td></tr><tr><td>parent</td><td>表示包含当前窗口的父窗口</td></tr><tr><td>opener</td><td>表示打开当前窗口的父窗口</td></tr><tr><td>closed</td><td>一个只读的布尔值,表示当前窗口是否关闭。当浏览器窗口关闭时,表示该窗口的 Window对象并不会消失,不过其 closed属性被设置为true</td></tr><tr><td>self</td><td>表示当前窗口</td></tr><tr><td>screen</td><td>对窗口或框架的 Screen 对象的只读引用,提供屏幕尺寸、颜色深度等信息</td></tr><tr><td>navigator</td><td>窗口或框架的 Navigator对象的只读引用,通过 Navigator对象可以获得与浏览器相关的信息</td></tr></table><hr><p></p><h3 id="Window对象的方法"><a href="#Window对象的方法" class="headerlink" title="Window对象的方法"></a>Window对象的方法</h3><p>Window对象的常用方法如下表所示:</p><hr><table border="1"><caption><center><strong>Window对象的常用方法</strong></center></caption><tr><th>方法</th><th>描述</th></tr><tr><td>alert()</td><td>弹出一个警告对话框</td></tr><tr><td></td><td></td></tr><tr><td>confirm()</td><td>显示一个确认对话框,单击“确认”按钮时返回true,否则返回 false</td></tr><tr><td>prompt()</td><td>弹出一个提示对话框,并要求输入一个简单的字符串</td></tr><tr><td>blur()</td><td>将键盘焦点从顶层浏览器窗口中移走。在多数平台上,这将使窗口移到最后面</td></tr><tr><td>close()</td><td>关闭窗口</td></tr><tr><td>focus()</td><td>将键盘焦点赋予顶层浏览器窗口。在多数平台上,这将使窗口移到最前面</td></tr><tr><td>open()</td><td>打开一个新窗口</td></tr><tr><td>scrollTo(x,y)</td><td>把窗口滚动到x,y坐标指定的位置</td></tr><tr><td>scrollBy(offsetx, offsety)</td><td>按照指定的位移量滚动窗口</td></tr><tr><td>setTimeout(timer)</td><td>在经过指定的时间后执行代码</td></tr><tr><td>clearTimeout()</td><td>取消对指定代码的延迟执行</td></tr><tr><td>moveTo(x,y)</td><td>将窗口移动到一个绝对位置</td></tr><tr><td>moveBy(offsetx,offsety)</td><td>将窗口移动到指定的位移量处</td></tr><tr><td>resizeTo(x,y)</td><td>设置窗口的大小</td></tr><tr><td>resizeBy(offsetx,offsety)</td><td>按照指定的位移量设置窗口的大小</td></tr><tr><td>print()</td><td>相当于浏览器工具栏中的“打印”按钮</td></tr><tr><td>setInterval()</td><td>周期性执行指定的代码</td></tr><tr><td>clearInterval()</td><td>停止周期性地执行代码</td></tr></table><hr><br>由于wmdw对象使用十分频繁,又是其他对象的父对象,所以<strong>在使用 Window对象的属性和方法时, JavaScript允许省略 Window对象的名称</strong>。例如,在使用 Window对象的alert方法弹出一个提示对话框时,可以使用下面的语句:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.alert(<span class="string">"提示对话框"</span>);</span><br></pre></td></tr></table></figure><p></p><p>也可以使用下面的语句:<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">"提示对话框"</span>);</span><br></pre></td></tr></table></figure><p></p><p>由于 Window对象的<code>open()</code>方法和<code>close()</code>方法在实际网站开发中经常用到,下面将对其进行详细的介绍。</p><h3 id="open-方法"><a href="#open-方法" class="headerlink" title="open()方法"></a>open()方法</h3><p>open()方法用于打开一个新的浏览器窗口,并在该窗口中装载指定URL地址的网页。open()方法的的语法格式如下:<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windowVar=<span class="built_in">window</span>.open(url,windowname[,location]);</span><br></pre></td></tr></table></figure><p></p><p>参数说明:<br>windowVar:当前打开窗口的句柄。如果open()方法执行成功,则windowVar的值为一个Window对象的句柄,否则windowVar的值是一个空值。</p><ul><li>url: 目标窗口的URL。如果URL是一个空字符串,则浏览器将打开一个空白窗口,允许用write()方法创建动态HTML。</li><li>windownane: 用于指定新窗口的名称,该名称可以作为<code>&lt;a&gt;</code>标记和<code>&lt;form&gt;</code>的 target属性的值。如果该参数指定了一个已经存在的窗口,那么 open方法将不再创建一个新的窗口,而只是返回对指定窗口的引用。</li><li>location: 对窗口属性进行设置,其可选参数如下表所示。<center><strong>对窗口属性进行设置的可选参数</strong></center></li></ul><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">width</td><td style="text-align:left">窗口的宽度</td></tr><tr><td style="text-align:left">height</td><td style="text-align:left">窗口的高度</td></tr><tr><td style="text-align:left">top</td><td style="text-align:left">窗口顶部距离屏幕顶部的像素数</td></tr><tr><td style="text-align:left">left</td><td style="text-align:left">窗口左端距离屏幕左端的像素数</td></tr><tr><td style="text-align:left">scrollbars</td><td style="text-align:left">是否显示滚动条,值为yes或no</td></tr><tr><td style="text-align:left">resizable</td><td style="text-align:left">设定窗口大小是否固定,值为yes或no</td></tr><tr><td style="text-align:left">toolbar</td><td style="text-align:left">浏览器工具栏,包括后退及前进按钮等,值为yes或no</td></tr><tr><td style="text-align:left">menubar</td><td style="text-align:left">菜单栏,一般包括文件、编辑及其他菜单项,值为yes或no</td></tr><tr><td style="text-align:left">location</td><td style="text-align:left">定位区,也叫地址栏,是可以输入URL的浏览器文本区,值为yes或no</td></tr></tbody></table><p>当 Window对象赋给变量后,也可以使用打开窗口句柄的 close()方法关闭窗口<br>例如,打开一个新的浏览器窗口,在该窗口中显示<code>openTest.htm</code>文件,设置打开窗口的名称为<code>openTest</code>,并设置窗口的顶边距、左边距、宽度和高度。代码如下:<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.open(<span class="string">"openTest.html"</span>,<span class="string">"OpenTest"</span>,<span class="string">"width=500,height=402,top=50,left=20"</span>);</span><br><span class="line"><span class="comment">//打开openTest.html文件，标题为OpenTest，窗体宽度500，高度402，窗体距离显示器上边50，距离左边20</span></span><br></pre></td></tr></table></figure><p></p><p>完整代码：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> openTest = <span class="built_in">window</span>.open(<span class="string">"openTest.html"</span>, <span class="string">"OpenTest"</span>, <span class="string">"width=600,height=200,top=100,left=100"</span>);</span></span><br><span class="line"><span class="javascript">        <span class="comment">/* openTest.close(); */</span></span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>运行结果,运行上面的代码，将打开一个窗口，该窗口中显示同目录下的openTest.html中的内容：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JavaWeb%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%B8%89%E7%AB%A0/%E5%B8%B8%E7%94%A8%E5%AF%B9%E8%B1%A1/window_openFunshow.png" alt=""></p><h3 id="close-方法"><a href="#close-方法" class="headerlink" title="close()方法"></a>close()方法</h3><p>close方法用于关闭当前窗口。其语法格式如下:<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.close()</span><br></pre></td></tr></table></figure><p></p><p>在上面的代码中，如果打开了获取到打开窗口的引用，则可以使用这个引用来关闭打来的窗口：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> openTest = <span class="built_in">window</span>.open(<span class="string">"openTest.html"</span>, <span class="string">"OpenTest"</span>, <span class="string">"width=600,height=200,top=100,left=100"</span>);</span><br><span class="line">openTest.close();</span><br></pre></td></tr></table></figure><p></p><p>运行效果是，浏览器打来一个窗口，然后又马上关掉这个窗口。</p><p>还有需要说明的是在firefox中我直接调用window.close()无法关闭当前窗口窗口的，控制台中显示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">脚本不得关闭非脚本打开的窗口。</span><br></pre></td></tr></table></figure><p></p><p>解决方案：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JavaWeb%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%B8%89%E7%AB%A0/%E5%B8%B8%E7%94%A8%E5%AF%B9%E8%B1%A1/%E8%A7%A3%E5%86%B3%E8%84%9A%E6%9C%AC%E4%B8%8D%E5%BE%97%E5%85%B3%E9%97%AD%E9%9D%9E%E8%84%9A%E6%9C%AC%E6%89%93%E5%BC%80%E7%9A%84%E7%AA%97%E5%8F%A3.png" alt=""><br>这样在Firefox中就可通过<code>window.close()</code>关闭当前窗口了。<br>参考：<a href="http://flyer0126.iteye.com/blog/865462" target="_blank" rel="noopener">http://flyer0126.iteye.com/blog/865462</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.w3school.com.cn/jsref/jsref_obj_string.asp" target="_blank" rel="noopener">JavaScript String 对象</a></li></ul><p>本文链接: <a href="https://www.lansheng.net.cn/blog/7d4ba91e/">Java Web从入门到精通第3章 3-6常用对象 JavaScript Windows对象</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Java Web从入门到精通 </category>
          
          <category> 第3章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java Web从入门到精通第3章 3-6常用对象</title>
      <link href="/blog/ba120c66/"/>
      <url>/blog/ba120c66/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><p>通过前面的学习,知道 JavaScript是一种基于对象的语言,它可以应用自己创建的对象,因此许多功能来自于脚本环境中对象的方法与脚本的相互作用。下面将对 JavaScript的常用对象进行详细介绍。</p><ul><li>Window对象<ul><li>Window对象的属性</li><li>Window对象的方法</li></ul></li><li>String对象</li></ul><a id="more"></a><h2 id="Window对象"><a href="#Window对象" class="headerlink" title="Window对象"></a>Window对象</h2><p>Window对象即浏览器窗口对象,是一个全局对象,是所有对象的顶级对象,在 JavaScript中起着举足轻重的作用。 Window对象提供了许多属性和方法,这些属性和方法被用来操作浏览器页面的内容。Window对象同Math对象一样,也不需要使用new关键字创建对象实例,而是直接使用“<code>对象名.成员</code>”的格式来访问其属性或方法。下面将对 Window对象的属性和方法进行介绍。</p><h3 id="Window对象的属性"><a href="#Window对象的属性" class="headerlink" title="Window对象的属性"></a>Window对象的属性</h3><p>Window对象的常用属性如下表所示：</p><hr><table border="1"><caption><center><strong>Window对象的常用属性</strong></center></caption><tr><th>属性</th><th>描述</th></tr><tr><td>document</td><td>对窗口或框架中含有文档的 Document对象的<strong>只读引用</strong></td></tr><tr><td>defaultStatus</td><td>一个可读写的字符,用于指定状态栏中的默认消息</td></tr><tr><td>frames</td><td>表示当前窗口中所有Frame对象的集合</td></tr><tr><td>location</td><td>用于代表窗口或框架的Location对象。如果将一个URL赋予该属性,则浏览器将加载并显示该URL指定的文档</td></tr><tr><td>length</td><td>窗口或框架包含的框架个数</td></tr><tr><td>histoy</td><td>对窗口或框架的History对象的只读引用</td></tr><tr><td>name</td><td>用于存放窗口对象的名称</td></tr><tr><td>status</td><td>一个可读写的字符,用于指定状态栏中的当前信息</td></tr><tr><td>top</td><td>表示最项层的浏览器窗口</td></tr><tr><td>parent</td><td>表示包含当前窗口的父窗口</td></tr><tr><td>opener</td><td>表示打开当前窗口的父窗口</td></tr><tr><td>closed</td><td>一个只读的布尔值,表示当前窗口是否关闭。当浏览器窗口关闭时,表示该窗口的 Window对象并不会消失,不过其 closed属性被设置为true</td></tr><tr><td>self</td><td>表示当前窗口</td></tr><tr><td>screen</td><td>对窗口或框架的 Screen 对象的只读引用,提供屏幕尺寸、颜色深度等信息</td></tr><tr><td>navigator</td><td>窗口或框架的 Navigator对象的只读引用,通过 Navigator对象可以获得与浏览器相关的信息</td></tr></table><hr><p></p><h3 id="Window对象的方法"><a href="#Window对象的方法" class="headerlink" title="Window对象的方法"></a>Window对象的方法</h3><p>Window对象的常用方法如下表所示:</p><hr><table border="1"><caption><center><strong>Window对象的常用方法</strong></center></caption><tr><th>方法</th><th>描述</th></tr><tr><td>alert()</td><td>弹出一个警告对话框</td></tr><tr><td></td><td></td></tr><tr><td>confirm()</td><td>显示一个确认对话框,单击“确认”按钮时返回true,否则返回 false</td></tr><tr><td>prompt()</td><td>弹出一个提示对话框,并要求输入一个简单的字符串</td></tr><tr><td>blur()</td><td>将键盘焦点从顶层浏览器窗口中移走。在多数平台上,这将使窗口移到最后面</td></tr><tr><td>close()</td><td>关闭窗口</td></tr><tr><td>focus()</td><td>将键盘焦点赋予顶层浏览器窗口。在多数平台上,这将使窗口移到最前面</td></tr><tr><td>open()</td><td>打开一个新窗口</td></tr><tr><td>scrollTo(x,y)</td><td>把窗口滚动到x,y坐标指定的位置</td></tr><tr><td>scrollBy(offsetx, offsety)</td><td>按照指定的位移量滚动窗口</td></tr><tr><td>setTimeout(timer)</td><td>在经过指定的时间后执行代码</td></tr><tr><td>clearTimeout()</td><td>取消对指定代码的延迟执行</td></tr><tr><td>moveTo(x,y)</td><td>将窗口移动到一个绝对位置</td></tr><tr><td>moveBy(offsetx,offsety)</td><td>将窗口移动到指定的位移量处</td></tr><tr><td>resizeTo(x,y)</td><td>设置窗口的大小</td></tr><tr><td>resizeBy(offsetx,offsety)</td><td>按照指定的位移量设置窗口的大小</td></tr><tr><td>print()</td><td>相当于浏览器工具栏中的“打印”按钮</td></tr><tr><td>setInterval()</td><td>周期性执行指定的代码</td></tr><tr><td>clearInterval()</td><td>停止周期性地执行代码</td></tr></table><hr><br>由于wmdw对象使用十分频繁,又是其他对象的父对象,所以<strong>在使用 Window对象的属性和方法时, JavaScript允许省略 Window对象的名称</strong>。例如,在使用 Window对象的alert方法弹出一个提示对话框时,可以使用下面的语句:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.alert(<span class="string">"提示对话框"</span>);</span><br></pre></td></tr></table></figure><p></p><p>也可以使用下面的语句:<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">"提示对话框"</span>);</span><br></pre></td></tr></table></figure><p></p><p>由于 Window对象的<code>open()</code>方法和<code>close()</code>方法在实际网站开发中经常用到,下面将对其进行详细的介绍。</p><h3 id="open-方法"><a href="#open-方法" class="headerlink" title="open()方法"></a>open()方法</h3><p>open()方法用于打开一个新的浏览器窗口,并在该窗口中装载指定URL地址的网页。open()方法的的语法格式如下:<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windowVar=<span class="built_in">window</span>.open(url,windowname[,location]);</span><br></pre></td></tr></table></figure><p></p><p>参数说明:<br>windowVar:当前打开窗口的句柄。如果open()方法执行成功,则windowVar的值为一个Window对象的句柄,否则windowVar的值是一个空值。</p><ul><li>url: 目标窗口的URL。如果URL是一个空字符串,则浏览器将打开一个空白窗口,允许用write()方法创建动态HTML。</li><li>windownane: 用于指定新窗口的名称,该名称可以作为<code>&lt;a&gt;</code>标记和<code>&lt;form&gt;</code>的 target属性的值。如果该参数指定了一个已经存在的窗口,那么 open方法将不再创建一个新的窗口,而只是返回对指定窗口的引用。</li><li>location: 对窗口属性进行设置,其可选参数如下表所示。<center><strong>对窗口属性进行设置的可选参数</strong></center></li></ul><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">width</td><td style="text-align:left">窗口的宽度</td></tr><tr><td style="text-align:left">height</td><td style="text-align:left">窗口的高度</td></tr><tr><td style="text-align:left">top</td><td style="text-align:left">窗口顶部距离屏幕顶部的像素数</td></tr><tr><td style="text-align:left">left</td><td style="text-align:left">窗口左端距离屏幕左端的像素数</td></tr><tr><td style="text-align:left">scrollbars</td><td style="text-align:left">是否显示滚动条,值为yes或no</td></tr><tr><td style="text-align:left">resizable</td><td style="text-align:left">设定窗口大小是否固定,值为yes或no</td></tr><tr><td style="text-align:left">toolbar</td><td style="text-align:left">浏览器工具栏,包括后退及前进按钮等,值为yes或no</td></tr><tr><td style="text-align:left">menubar</td><td style="text-align:left">菜单栏,一般包括文件、编辑及其他菜单项,值为yes或no</td></tr><tr><td style="text-align:left">location</td><td style="text-align:left">定位区,也叫地址栏,是可以输入URL的浏览器文本区,值为yes或no</td></tr></tbody></table><p>当 Window对象赋给变量后,也可以使用打开窗口句柄的 close()方法关闭窗口<br>例如,打开一个新的浏览器窗口,在该窗口中显示<code>openTest.htm</code>文件,设置打开窗口的名称为<code>openTest</code>,并设置窗口的顶边距、左边距、宽度和高度。代码如下:<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.open(<span class="string">"openTest.html"</span>,<span class="string">"OpenTest"</span>,<span class="string">"width=500,height=402,top=50,left=20"</span>);</span><br><span class="line"><span class="comment">//打开openTest.html文件，标题为OpenTest，窗体宽度500，高度402，窗体距离显示器上边50，距离左边20</span></span><br></pre></td></tr></table></figure><p></p><p>完整代码：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> openTest = <span class="built_in">window</span>.open(<span class="string">"openTest.html"</span>, <span class="string">"OpenTest"</span>, <span class="string">"width=600,height=200,top=100,left=100"</span>);</span></span><br><span class="line"><span class="javascript">        <span class="comment">/* openTest.close(); */</span></span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>运行结果,运行上面的代码，将打开一个窗口，该窗口中显示同目录下的openTest.html中的内容：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JavaWeb%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%B8%89%E7%AB%A0/%E5%B8%B8%E7%94%A8%E5%AF%B9%E8%B1%A1/window_openFunshow.png" alt=""></p><h3 id="close-方法"><a href="#close-方法" class="headerlink" title="close()方法"></a>close()方法</h3><p>close方法用于关闭当前窗口。其语法格式如下:<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.close()</span><br></pre></td></tr></table></figure><p></p><p>在上面的代码中，如果打开了获取到打开窗口的引用，则可以使用这个引用来关闭打来的窗口：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> openTest = <span class="built_in">window</span>.open(<span class="string">"openTest.html"</span>, <span class="string">"OpenTest"</span>, <span class="string">"width=600,height=200,top=100,left=100"</span>);</span><br><span class="line">openTest.close();</span><br></pre></td></tr></table></figure><p></p><p>运行效果是，浏览器打来一个窗口，然后又马上关掉这个窗口。</p><p>还有需要说明的是在firefox中我直接调用window.close()无法关闭当前窗口窗口的，控制台中显示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">脚本不得关闭非脚本打开的窗口。</span><br></pre></td></tr></table></figure><p></p><p>解决方案：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JavaWeb%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%B8%89%E7%AB%A0/%E5%B8%B8%E7%94%A8%E5%AF%B9%E8%B1%A1/%E8%A7%A3%E5%86%B3%E8%84%9A%E6%9C%AC%E4%B8%8D%E5%BE%97%E5%85%B3%E9%97%AD%E9%9D%9E%E8%84%9A%E6%9C%AC%E6%89%93%E5%BC%80%E7%9A%84%E7%AA%97%E5%8F%A3.png" alt=""><br>这样在Firefox中就可通过<code>window.close()</code>关闭当前窗口了。<br>参考：<a href="http://flyer0126.iteye.com/blog/865462" target="_blank" rel="noopener">http://flyer0126.iteye.com/blog/865462</a></p><h2 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a>String对象</h2><p>String对象是动态对象,需要创建对象实例后才能引用其属性和方法。但是,由于在 JavaScript中可以将用单引号或双引号括起来的一个字符串当作一个字符串对象的实例,所以<strong>可以直接在某个字符串后面加上点“.”去调用Srng对象的属性和方法</strong>。下面对Strng对象的常用属性和方法进行详细介绍。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/ba120c66/">Java Web从入门到精通第3章 3-6常用对象</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Java Web从入门到精通 </category>
          
          <category> 第3章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>html设置表格名称</title>
      <link href="/blog/5270044b/"/>
      <url>/blog/5270044b/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:16 GMT+0800 (中国标准时间) --><p>参考：<a href="http://www.w3school.com.cn/tags/tag_caption.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/tags/tag_caption.asp</a></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/5270044b/">html设置表格名称</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
          <category> 表格 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java Web从入门到精通第3章 3-5事件处理</title>
      <link href="/blog/3eb7f149/"/>
      <url>/blog/3eb7f149/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><p>通过前面的学习,知道 <strong>JavaScript可以以事件驱动的方式直接对客户端的输入作出响应,无须经过服务器端程序</strong>;也就是说, JavaScript是事件驱动的。它可以使在图形界面环境下的一切操作变得简单化。下面将对事件及事件处理程序进行详细介绍。</p><ul><li><a href="/2018/10/27/读书笔记/Java Web从入门到精通/第3章/Java Web从入门到精通第3章 3-5事件处理/#什么是事件处理程序">什么是事件处理程序</a></li><li><a href="/2018/10/27/读书笔记/Java Web从入门到精通/第3章/Java Web从入门到精通第3章 3-5事件处理/#JavaScript常用事件表">JavaScript常用事件</a></li><li><a href="/2018/10/27/读书笔记/Java Web从入门到精通/第3章/Java Web从入门到精通第3章 3-5事件处理/#事件处理程序的调用">事件处理程序的调用</a><ul><li><a href="/2018/10/27/读书笔记/Java Web从入门到精通/第3章/Java Web从入门到精通第3章 3-5事件处理/#在JavaScript中指定事件处理程序">在JavaScript中指定事件处理程序</a></li><li><a href="/2018/10/27/读书笔记/Java Web从入门到精通/第3章/Java Web从入门到精通第3章 3-5事件处理/#在HTML中指定事件处理程序">在HTML中指定事件处理程序</a></li></ul></li></ul><a id="more"></a><h2 id="什么是事件处理程序"><a href="#什么是事件处理程序" class="headerlink" title="什么是事件处理程序"></a>什么是事件处理程序</h2><p>JavaScript与web页面之间的交互是通过用户操作浏览器页面时触发相关事件来实现的。例如,</p><ul><li>在页面载入完毕时将触发 onload(载入)事件,</li><li>当用户单击按钮时将触发按钮的 onclick事件等。</li></ul><p><strong>事件处理程序则是用于响应某个事件而执行的处理程序</strong>。事件处理程序可以是任意 JavaScript语句,但通常使用特定的自定义函数( Function)来对事件进行处理。</p><h2 id="JavaScript常用事件表"><a href="#JavaScript常用事件表" class="headerlink" title="JavaScript常用事件表"></a>JavaScript常用事件表</h2><p>多数浏览器内部对象都拥有很多事件,下面将以表格的形式给出常用的事件及何时触发这些事件。</p><p></p><hr><table border="1"><caption><center><strong>Javascript的常用事件</strong></center></caption><th>事件</th><th>何时触发</th><tr><td>onabort</td><td>对象载入被中断时触发</td></tr><tr><td>onblur</td><td>元素或窗口本身失去焦点时触发</td></tr><tr><td>onchange</td><td><code>&lt;select&gt;</code>元素中的选项或其他表单失去焦点,并且在其获取焦点后<strong>内容发生过改变时触发</strong></td></tr><tr><td>onclick</td><td>单击鼠标左键时触发。当光标的焦点在按钮上,并按下 Enter键时,也会触发该事件</td></tr><tr><td>ondblclick</td><td>双击鼠标左键时触发</td></tr><tr><td>onerror</td><td>出现错误时触发</td></tr><tr><td>onfocus</td><td>任何元素或窗口本身获得焦点时触发</td></tr><tr><td>onkeydown</td><td>键盘上的按键(包括<kbd>Shift</kbd>或<kbd>Alt</kbd>等键)被按下时触发,<strong>如果一直按着某键,则会不断触发</strong>。当返回false时,取消默认动作</td></tr><tr><td>onkeypress</td><td>键盘上的按键被按下,并产生一个字符时发生。也就是说,当按下<kbd>Shift</kbd>或<kbd>At</kbd>等键时先不触发,在按下其他键时触发。如果一直按下某键时,会不断触发。当返回 false时,取消默认动作</td></tr><tr><td>onkeyup</td><td>释放键盘上的按键时触发</td></tr><tr><td>onload</td><td>页面完全载入后,在 Window对象上触发;所有框架都载入后,在框架集上触发;&lt;img&gt; 标记指定的图像完全载入后,在其上触发;或&lt;object&gt;标记指定的对象完全载入后,在其上触发</td></tr><tr><td>onmousedown</td><td>单击任何一个鼠标按键时触发</td></tr><tr><td>onmousemove</td><td>鼠标在某个元素上移动时持续触发</td></tr><tr><td>onmouseout</td><td>将鼠标从指定的元素上移开时触发</td></tr><tr><td>onmouseover</td><td>鼠标移到某个元素上时触发</td></tr><tr><td>onmouseup</td><td>释放任意一个鼠标按键时触发</td></tr><tr><td>onreset</td><td>单击重置按钮时,在&lt;form&gt;上触发</td></tr><tr><td>onresize</td><td>窗口或框架的大小发生改变时触发</td></tr><tr><td>onscroll</td><td>在任何带滚动条的元素或窗口上滚动时触发</td></tr><tr><td>onselect</td><td>选中文本时触发</td></tr><tr><td>onsubmit</td><td>单击提交按钮时,在&lt;form&gt;上触发</td></tr><tr><td>onunload</td><td>页面完全卸载后,在 Window对象上触发:或者所有框架都卸载后,在框架集上触发</td></tr></table><hr><p></p><h2 id="事件处理程序的调用"><a href="#事件处理程序的调用" class="headerlink" title="事件处理程序的调用"></a>事件处理程序的调用</h2><p>在使用事件处理程序对页面进行操作时,最主要的是如何通过对象的事件来指定事件处理程序。指定方式主要有以下两种。</p><h3 id="在JavaScript中指定事件处理程序"><a href="#在JavaScript中指定事件处理程序" class="headerlink" title="在JavaScript中指定事件处理程序"></a>在JavaScript中指定事件处理程序</h3><p>在 JavaScript中调用事件处理程序,首先需要获得要处理对象的引用,然后将要执行的处理函数值给对应的事件。<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"save_button"</span> <span class="attr">id</span>=<span class="string">"save_button"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"保存按钮"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> save_button = <span class="built_in">document</span>.getElementById(<span class="string">"save_button"</span>);</span></span><br><span class="line"><span class="javascript">save_button.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">alert(<span class="string">"单击了保存按钮"</span>);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>运行结果:<img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JavaWeb%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%B8%89%E7%AB%A0/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/%E5%9C%A8JavaScript%E4%B8%AD%E6%8C%87%E5%AE%9A%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F.png" alt=""><br>注意在上面的代码中,一定要将input标记放在JavaScript代码的上方,否则将出现”save_button”为空或不是对象”的错误提示。在 JavaScript中指定事件处理程序时,事件名称必须小写,才能正确响应事件。</p><h3 id="在HTML中指定事件处理程序"><a href="#在HTML中指定事件处理程序" class="headerlink" title="在HTML中指定事件处理程序"></a>在HTML中指定事件处理程序</h3><p>在HTML中分配事件处理程序,只需要在HTML标记中添加相应的事件,并在其中指定要执行的代码或是函数名即可。实例代码：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">save_buttonFun</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="undefined">&#123;</span></span><br><span class="line"><span class="javascript">alert(<span class="string">"单击了保存按钮"</span>);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"save_button"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"保存按钮"</span> <span class="attr">onclick</span>=<span class="string">"save_buttonFun()"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>运行结果：<img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JavaWeb%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%B8%89%E7%AB%A0/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/%E5%9C%A8HTML%E4%B8%AD%E6%8C%87%E5%AE%9A%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F.png" alt=""></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/3eb7f149/">Java Web从入门到精通第3章 3-5事件处理</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Java Web从入门到精通 </category>
          
          <category> 第3章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java Web从入门到精通第3章 3-4函数</title>
      <link href="/blog/431b8409/"/>
      <url>/blog/431b8409/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><ul><li>javascript函数的定义</li><li>javascript函数的调用</li></ul><a id="more"></a><p>函数实质上就是一组 JavaScript代码。使用函数可以使代码更为简提高重用性。在 JavaScript中,大约95%的代码都是包含在函数中的。由此可见,函数在 JavaScript中是非常重要的。</p><h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><p>函数是由关键字 function、函数名加一组参数以及置于大括号中需要执行的一段代码定义的。定义函数的基本语法如下:<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionName</span>(<span class="params">[parameter1, parameter2, ......]</span>) </span>&#123;</span><br><span class="line">    statements</span><br><span class="line">    [<span class="keyword">return</span> expression;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>参数说明:</p><ul><li>functionName: 必选项,用于指定函数名。在同一个页面中,函数名必须是唯一的,并且区分大小写。</li><li>parameter: 可选项,用于指定参数列表。当使用多个参数时,参数间使用逗号进行分隔。个函数最多可以有255个参数。</li><li>statements: 必选项,是函数体,用于实现函数功能的语句。</li><li>expression: 可选项,用于返回函数值。 expression为任意的表达式、变量或常量。</li></ul><p>实例：定义一个用于计算商品金额的函数 account(),该函数有两个参数,用于指定单价和数量,返回值为计算后的金额。具体代码如下:<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">account</span>(<span class="params">price,number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum=price*number;<span class="comment">//计算金额</span></span><br><span class="line">    <span class="keyword">return</span> sum;<span class="comment">//返回计算后的金额</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这里要注意的，这里的函数和Java中的方法是不一样的，参数列表中直接写变量名就行了。而java不行,上述方法的java版本为：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">account</span><span class="params">(<span class="keyword">int</span> price,<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=price*number;<span class="comment">//计算金额</span></span><br><span class="line">    <span class="keyword">return</span> sum;<span class="comment">//返回计算后的金额</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>对比可以看到java中的返回值有可以是基本数据类型也可以是引用数据类型。而javascript中这个位置直接写function就行了。</p><h2 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h2><p>函数的调用比较简单,如果要调用不带参数的函数,使用函数名加上括号即可;<br>如果要调用的函数带参数,则在括号中加上需要传递的参数;如果包含多个参数,各参数间用逗号分隔；<br>如果函数有返回值,则可以使用赋值语句将函数值赋给一个变量。<br>例如 上面的函数 account可以通过以下代码进行调用。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">account(<span class="number">10.6</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p></p><p>在JavaScript中,由于函数名区分大小写,在调用函数时也需要注意函数名的大小写。</p><p>实例：定义一个 JavaScript函数checkReaIName(),用于验证输入的字符串是否为汉字。<br>(1)在页面中添加用于输入真实姓名的表单及表单元素。具体代码如下：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">"form1"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">请输入真实姓名：</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"realName"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"realName"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"Button"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onClick</span>=<span class="string">"checkRealName()"</span> <span class="attr">value</span>=<span class="string">"检测"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>(2)编写自定义的 Javascript函数 checkRealName(),用于验证输入的真实姓名是否正确,即判断输入的内容是否为两个或两个以上的汉字。 checkRealName()函数的具体代码如下:<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">"javascript"</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkRealName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> str = form1.realName.value;<span class="comment">//获取输入的真实姓名</span></span><br><span class="line"><span class="keyword">if</span> (str == <span class="string">""</span>) &#123;<span class="comment">//当真实姓名为空时</span></span><br><span class="line">alert(<span class="string">"请输入真实姓名！"</span>); form1.realName.focus(); <span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">//当真实姓名不为空时</span></span><br><span class="line"><span class="keyword">var</span> objExp = <span class="regexp">/[\u4E00-\u9FA5]&#123;2,&#125;/</span>;<span class="comment">//创建正则表达式对象</span></span><br><span class="line"><span class="keyword">if</span> (objExp.test(str) == <span class="literal">true</span>) &#123;<span class="comment">//判断是否匹配</span></span><br><span class="line">alert(<span class="string">"姓名正确"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">alert(<span class="string">"非法姓名！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>非法姓名运行结果:<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JavaWeb%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%B8%89%E7%AB%A0/%E5%87%BD%E6%95%B0/IncorrectName.png" alt=""><br>正确姓名运行结果：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JavaWeb%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%B8%89%E7%AB%A0/%E5%87%BD%E6%95%B0/correctname.png" alt=""></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/431b8409/">Java Web从入门到精通第3章 3-4函数</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Java Web从入门到精通 </category>
          
          <category> 第3章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java读取jar包内的文件</title>
      <link href="/blog/18ab79a8/"/>
      <url>/blog/18ab79a8/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>怎么把资源文件打包到可执行jar包中<br>读取jar包中的文件<br>读取jar包中资源文件子目录中的文件<br><a id="more"></a></p><h2 id="首先介绍怎么把资源文件打包到可执行jar包中"><a href="#首先介绍怎么把资源文件打包到可执行jar包中" class="headerlink" title="首先介绍怎么把资源文件打包到可执行jar包中"></a>首先介绍怎么把资源文件打包到可执行jar包中</h2><p>打开eclipse，在你Java项目下建立一个资源文件夹res，然后在里面放入要打包到可执行jar包中的文件(我这里是JSTest.html)，如下图所示：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/Java/Java%20IO%E6%B5%81/java%E8%AF%BB%E5%8F%96jar%E5%8C%85%E5%86%85%E7%9A%84%E6%96%87%E4%BB%B6/new_res_folder.png" alt=""><br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/Java/Java%20IO%E6%B5%81/java%E8%AF%BB%E5%8F%96jar%E5%8C%85%E5%86%85%E7%9A%84%E6%96%87%E4%BB%B6/project_view.png" alt=""><br>这样等我们打包成可执行jar包时，JSTest.html被放到jar包里面的根目录下：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/Java/Java%20IO%E6%B5%81/java%E8%AF%BB%E5%8F%96jar%E5%8C%85%E5%86%85%E7%9A%84%E6%96%87%E4%BB%B6/afterpackingfilepath.png" alt=""></p><h2 id="读取jar包中的文件"><a href="#读取jar包中的文件" class="headerlink" title="读取jar包中的文件"></a>读取jar包中的文件</h2><p>那么我们怎么在JSTest类中读取jar包中的这个JSTest.html文件呢，使用下面的代码即可获取包内文件的InputStream实例。后面就跟读取普通文件一样了。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream inputStream = JSTest.class.getResourceAsStream(&quot;/JSTest.html&quot;);</span><br></pre></td></tr></table></figure><p></p><p>完整代码：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> js.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JSTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">InputStream inputStream = JSTest.class.getResourceAsStream(<span class="string">"/JSTest.html"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(</span><br><span class="line"><span class="keyword">new</span> InputStreamReader(inputStream, <span class="string">"UTF-8"</span>));</span><br><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">char</span>[] charArray = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">200</span>];</span><br><span class="line"><span class="keyword">int</span> number = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> ((number = reader.read(charArray)) != -<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">builder.append(charArray,<span class="number">0</span>,number);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(builder.toString());</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>JSTest.html文件内容：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>然后我们打包成可执行jar包，运行该可执行jar包即可读取它自己包内的<code>JSTest.html</code>文件：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/Java/Java%20IO%E6%B5%81/java%E8%AF%BB%E5%8F%96jar%E5%8C%85%E5%86%85%E7%9A%84%E6%96%87%E4%BB%B6/runjar_show.png" alt=""><br>可以看到，已经成功把JSTest.html中的内容输出到控制台了。</p><h2 id="读取jar包中资源文件子目录中的文件"><a href="#读取jar包中资源文件子目录中的文件" class="headerlink" title="读取jar包中资源文件子目录中的文件"></a>读取jar包中资源文件子目录中的文件</h2><p>如下图所示，如果想读取资源目录res下的子目录son中的文件inside.txt。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/Java/Java%20IO%E6%B5%81/java%E8%AF%BB%E5%8F%96jar%E5%8C%85%E5%86%85%E7%9A%84%E6%96%87%E4%BB%B6/fileInSonFolder.png" alt=""><br>只需要把上面的代码改成即可：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream inputStream = JSTest.class.getResourceAsStream(<span class="string">"/son/inside.txt"</span>);</span><br></pre></td></tr></table></figure><p></p><p>其他的代码不用改动。打包成可执行jar包红，inside.txt在jar包中的位置：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/Java/Java%20IO%E6%B5%81/java%E8%AF%BB%E5%8F%96jar%E5%8C%85%E5%86%85%E7%9A%84%E6%96%87%E4%BB%B6/fileInJarSonFolder.png" alt=""><br>运行可执行jar包：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/Java/Java%20IO%E6%B5%81/java%E8%AF%BB%E5%8F%96jar%E5%8C%85%E5%86%85%E7%9A%84%E6%96%87%E4%BB%B6/runjar_show_sonFolder.png" alt=""><br>同样运行成功。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/18ab79a8/">java读取jar包内的文件</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java IO流 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java Web从入门到精通第3章 3-3流程控制语句</title>
      <link href="/blog/3fb0a147/"/>
      <url>/blog/3fb0a147/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><p>流程控制语句对于任何一门编程语言都是至关重要的, JavaScript也不例外。在 JavaScript中提供了:</p><ul><li>if条件判断语句、</li><li>switch多分支语句、</li><li>for循环语句、</li><li>while循环语句、</li><li>do.. while循环语句、</li><li>break语句</li><li>continue语句<br>7种流程控制语句，下面来逐一进行介绍。</li></ul><h2 id="if条件语句"><a href="#if条件语句" class="headerlink" title="if条件语句"></a>if条件语句</h2><a id="more"></a><p>介绍，省略。</p><h3 id="实例：应用if语句验证用户登录信息"><a href="#实例：应用if语句验证用户登录信息" class="headerlink" title="实例：应用if语句验证用户登录信息"></a>实例：应用if语句验证用户登录信息</h3><p>(1)在页面中添加用户登录表单及表单元素。具体代码如下:<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">"form1"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">"221"</span> <span class="attr">border</span>=<span class="string">"1"</span> <span class="attr">cellspacing</span>=<span class="string">"0"</span> <span class="attr">cellpadding</span>=<span class="string">"0"</span> <span class="attr">bordercolor</span>=<span class="string">"#FFFFFF"</span> <span class="attr">bordercolordark</span>=<span class="string">"#CCCCCC"</span> <span class="attr">bordercolorlight</span>=<span class="string">"#FFFFFF"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">height</span>=<span class="string">"30"</span> <span class="attr">colspan</span>=<span class="string">"2"</span> <span class="attr">bgcolor</span>=<span class="string">"#eeeeee"</span>&gt;</span>用户登录<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">width</span>=<span class="string">"59"</span> <span class="attr">height</span>=<span class="string">"30"</span>&gt;</span>用户名：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">width</span>=<span class="string">"162"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">height</span>=<span class="string">"30"</span>&gt;</span>密&amp;nbsp;&amp;nbsp;码：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"pwd"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"pwd"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">height</span>=<span class="string">"30"</span> <span class="attr">colspan</span>=<span class="string">"2"</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"Button"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn_grey"</span> <span class="attr">value</span>=<span class="string">"登录"</span> <span class="attr">onClick</span>=<span class="string">"check()"</span>&gt;</span> &amp;nbsp;</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"Submit2"</span> <span class="attr">type</span>=<span class="string">"reset"</span> <span class="attr">class</span>=<span class="string">"btn_grey"</span> <span class="attr">value</span>=<span class="string">"重置"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>(2)编写自定义的 JavaScript函数 check(),用于通过if语句验证登录信息是否为空。 check函数的具体代码如下:<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (form1.user.value == <span class="string">""</span>) &#123;<span class="comment">//判断用户名是否为空</span></span></span><br><span class="line"><span class="javascript">      alert(<span class="string">"请输入用户名！"</span>);</span></span><br><span class="line"><span class="undefined">      form1.user.focus();</span></span><br><span class="line"><span class="undefined">      eturn;</span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (form1.pwd.value == <span class="string">""</span>) &#123;<span class="comment">//判断密码是否为空</span></span></span><br><span class="line"><span class="javascript">      alert(<span class="string">"请输入密码！"</span>); form1.pwd.focus(); <span class="keyword">return</span>;</span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">      form1.submit();<span class="comment">//提交表单</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>(3)在“登录”按钮的 onclick事件中调用 check函数。具体代码如下：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"Button"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">class</span>=<span class="string">"btn_grey"</span> <span class="attr">value</span>=<span class="string">"登录"</span> <span class="attr">onClick</span>=<span class="string">"check()"</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JavaWeb%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%B8%89%E7%AB%A0/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/if_example/if_example.png" alt=""></p><h2 id="switch多分支语句"><a href="#switch多分支语句" class="headerlink" title="switch多分支语句"></a>switch多分支语句</h2><p>介绍省略，</p><h3 id="实例：应用-switch语句输出今天是星期几"><a href="#实例：应用-switch语句输出今天是星期几" class="headerlink" title="实例：应用 switch语句输出今天是星期几"></a>实例：应用 switch语句输出今天是星期几</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();<span class="comment">//获取系统日期</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> day = now.getDay();<span class="comment">//获取星期</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> week;</span></span><br><span class="line"><span class="javascript"><span class="keyword">switch</span> (day) &#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="number">1</span>:</span></span><br><span class="line"><span class="javascript">week = <span class="string">"星期一"</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="number">2</span>:</span></span><br><span class="line"><span class="javascript">week = <span class="string">"星期二"</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="number">3</span>:</span></span><br><span class="line"><span class="javascript">week = <span class="string">"星期三"</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="number">4</span>:</span></span><br><span class="line"><span class="javascript">week = <span class="string">"星期四"</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="number">5</span>:</span></span><br><span class="line"><span class="javascript">week = <span class="string">"星期五"</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">case</span> <span class="number">6</span>:</span></span><br><span class="line"><span class="javascript">week = <span class="string">"星期六"</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">default</span>:</span></span><br><span class="line"><span class="javascript">week = <span class="string">"星期日"</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">break</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(<span class="string">"今天是"</span> + week);<span class="comment">//输出中文的星期</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>程序的运行结果如下图所示：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JavaWeb%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%B8%89%E7%AB%A0/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/switch_excample_show.png" alt=""><br>判断条件较少的使用if条件语句，多条件判断使用switch语句。</p><h2 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h2><p>for循环语句也称为计次循环语句,一般用于循环次数已知的情况。其他介绍，省略。</p><h3 id="实例：计算100以内所有奇数的和"><a href="#实例：计算100以内所有奇数的和" class="headerlink" title="实例：计算100以内所有奇数的和"></a>实例：计算100以内所有奇数的和</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> sum = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i += <span class="number">2</span>) &#123;</span></span><br><span class="line"><span class="undefined">sum = sum + i;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="javascript">alert(<span class="string">"100以内所有奇数的和为："</span> + sum);<span class="comment">//输出计算结果</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>显示效果：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JavaWeb%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%B8%89%E7%AB%A0/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/for_example_show.png" alt=""><br>注意避免死循环。</p><h2 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a>while循环语句</h2><p>介绍省略。<br>while循环语句经常用于循环执行的次数不确定的情况下。</p><h3 id="实例：列举出累加和不大于10的所有自然数"><a href="#实例：列举出累加和不大于10的所有自然数" class="headerlink" title="实例：列举出累加和不大于10的所有自然数"></a>实例：列举出累加和不大于10的所有自然数</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> i = <span class="number">1</span>;      <span class="comment">//由于是计算自然数，所以i的初始值设置为1</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> sum = i;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> result = <span class="string">""</span>;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(<span class="string">"累加和不大于10的所有自然数为：&lt;br&gt;"</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">while</span> (sum &lt; <span class="number">10</span>) &#123;</span></span><br><span class="line"><span class="javascript">sum = sum + i;<span class="comment">//累加i的值</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(i + <span class="string">'&lt;br&gt;'</span>);<span class="comment">//输出符合条件的自然数</span></span></span><br><span class="line"><span class="javascript">i++;        <span class="comment">//该语句一定不要少</span></span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果:<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JavaWeb%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%B8%89%E7%AB%A0/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/while_show.png" alt=""></p><h2 id="do…while循环语句"><a href="#do…while循环语句" class="headerlink" title="do…while循环语句"></a>do…while循环语句</h2><p>介绍省略</p><h3 id="实例-应用do-while循环语句列举出累加和不大于10的所有自然数"><a href="#实例-应用do-while循环语句列举出累加和不大于10的所有自然数" class="headerlink" title="实例: 应用do. while循环语句列举出累加和不大于10的所有自然数"></a>实例: 应用do. while循环语句列举出累加和不大于10的所有自然数</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> i = <span class="number">1</span>;      <span class="comment">//由于是计算自然数，所以i的初始值设置为1</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> sum = i;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> result = <span class="string">""</span>;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(<span class="string">"累加和不大于10的所有自然数为：&lt;br&gt;"</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">while</span> (sum &lt; <span class="number">10</span>) &#123;</span></span><br><span class="line"><span class="javascript">sum = sum + i;<span class="comment">//累加i的值</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(i + <span class="string">'&lt;br&gt;'</span>);<span class="comment">//输出符合条件的自然数</span></span></span><br><span class="line"><span class="javascript">i++;        <span class="comment">//该语句一定不要少</span></span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>显示效果如下所示：<img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JavaWeb%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%B8%89%E7%AB%A0/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/do_while_show.png" alt=""></p><h2 id="break与-continue语句"><a href="#break与-continue语句" class="headerlink" title="break与 continue语句"></a>break与 continue语句</h2><p>break与 continue语句都可以用于跳出循环,但两者也存在着一些区别。break语句用于退出本次循环或者退出一个 switch语句。continue语句用于中止本次循环,并开始下一次循环。</p><h3 id="break实例"><a href="#break实例" class="headerlink" title="break实例"></a>break实例</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(<span class="string">"测试break&lt;br&gt;"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span></span><br><span class="line"><span class="undefined">    &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)</span></span><br><span class="line"><span class="undefined">        &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.write(i+<span class="string">"---&gt;"</span>+j+<span class="string">"&lt;br&gt;"</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span>(j==<span class="number">2</span>)</span></span><br><span class="line"><span class="javascript">                <span class="keyword">break</span>;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JavaWeb%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%B8%89%E7%AB%A0/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/testbreak.png" alt=""><br>可以看到当j==2成立时，内层循环会直接退出，这里break对外层循环没有影响。</p><h3 id="continue实例"><a href="#continue实例" class="headerlink" title="continue实例"></a>continue实例</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(<span class="string">"测试continue&lt;br&gt;"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (j == <span class="number">2</span>)</span></span><br><span class="line"><span class="javascript">                <span class="keyword">continue</span>;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.write(i + <span class="string">"---&gt;"</span> + j + <span class="string">"&lt;br&gt;"</span>);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JavaWeb%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%B8%89%E7%AB%A0/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/testcontinue.png" alt=""><br>可以看到当j==2成立时，continue跳出内层循环，继续执行下一个循环。同样这里continue不影响到外层循环。<br>实例: 在for语句中通过 continue语句计算金额大于等于1000的数据的和的代码如下:<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> total = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> sum = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000</span>, <span class="number">1200</span>, <span class="number">100</span>, <span class="number">600</span>, <span class="number">736</span>, <span class="number">1107</span>, <span class="number">1205</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sum.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (sum[i] &lt; <span class="number">1000</span>)</span></span><br><span class="line"><span class="javascript">            <span class="keyword">continue</span>;</span></span><br><span class="line"><span class="undefined">        total += sum[i];</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.write(<span class="string">"累加和为："</span>+total);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>显示结果为：<img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JavaWeb%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%B8%89%E7%AB%A0/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/continuetotal.png" alt=""></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/3fb0a147/">Java Web从入门到精通第3章 3-3流程控制语句</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Java Web从入门到精通 </category>
          
          <category> 第3章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>正则应用 删除文章中空行</title>
      <link href="/blog/59f64c86/"/>
      <url>/blog/59f64c86/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><h2 id="匹配空行的正则表达式"><a href="#匹配空行的正则表达式" class="headerlink" title="匹配空行的正则表达式"></a>匹配空行的正则表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(?m)^\s*$(\n|\r\n)</span><br></pre></td></tr></table></figure><h2 id="替换正则表达式"><a href="#替换正则表达式" class="headerlink" title="替换正则表达式"></a>替换正则表达式</h2><p>使用空字符串(也就什么都不输入)，替换即可。<br><a id="more"></a></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>删除下面多余的空行：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">定义和用法</span><br><span class="line"></span><br><span class="line">&lt;kbd&gt; 标签定义键盘文本。</span><br><span class="line"></span><br><span class="line">说到技术概念上的特殊样式时，就要提到 &lt;kbd&gt; 标签。正如你已经猜到的，它用来表示文本是从键盘上键入的。</span><br><span class="line"></span><br><span class="line">浏览器通常用等宽字体来显示该标签中包含的文本。</span><br><span class="line"></span><br><span class="line">&lt;kbd&gt; 标签经常用在于计算机相关的文档和手册中。例如：</span><br><span class="line"></span><br><span class="line">键入 &lt;kbd&gt;quit&lt;/kbd&gt; 来退出程序，或者键入 &lt;kbd&gt;menu&lt;/kbd&gt; 来返回主菜单。</span><br></pre></td></tr></table></figure><p></p><p>在notepad++使用按下<kbd>Ctrl+H<kbd>打开替换，勾选上正则表达式功能，然后使用上面的正则表达式进行替换：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E5%AE%9E%E4%BE%8B/%E6%AD%A3%E5%88%99%E5%BA%94%E7%94%A8%20%E5%88%A0%E9%99%A4%E6%96%87%E7%AB%A0%E7%A9%BA%E8%A1%8C/notepadplusplus_settings.png" alt=""><br>替换结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">定义和用法</span><br><span class="line">&lt;kbd&gt; 标签定义键盘文本。</span><br><span class="line">说到技术概念上的特殊样式时，就要提到 &lt;kbd&gt; 标签。正如你已经猜到的，它用来表示文本是从键盘上键入的。</span><br><span class="line">浏览器通常用等宽字体来显示该标签中包含的文本。</span><br><span class="line">&lt;kbd&gt; 标签经常用在于计算机相关的文档和手册中。例如：</span><br><span class="line">键入 &lt;kbd&gt;quit&lt;/kbd&gt; 来退出程序，或者键入 &lt;kbd&gt;menu&lt;/kbd&gt; 来返回主菜单。</span><br></pre></td></tr></table></figure></kbd></kbd></p><p>在Java中使用,添加反斜杠注释即可。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string.replaceAll(<span class="string">"(?m)^\\s*$(\\n|\\r\\n)"</span>, <span class="string">""</span>);</span><br></pre></td></tr></table></figure><p></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/59f64c86/">正则应用 删除文章中空行</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 正则表达式 </category>
          
          <category> 实例 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>markdown文档中使用键盘键</title>
      <link href="/blog/6507a83c/"/>
      <url>/blog/6507a83c/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>markdown中可以插入html标签来实现更加丰富的显示效果。例如<code>&lt;kbd&gt;</code>标签来插入键盘按键：<kbd>Ctrl</kbd>+<kbd>H</kbd><br><a id="more"></a></p><h2 id="键盘键"><a href="#键盘键" class="headerlink" title="键盘键"></a>键盘键</h2><blockquote><p><strong>定义和用法</strong><br><code>&lt;kbd&gt;</code>标签定义键盘文本。<br>说到技术概念上的特殊样式时，就要提到 <code>&lt;kbd&gt;</code>标签。<br>正如你已经猜到的，它用来表示文本是从键盘上键入的。<br>浏览器通常用等宽字体来显示该标签中包含的文本。<code>&lt;kbd&gt;</code>标签经常用在于计算机相关的文档和手册中。例如：<br>键入<code>&lt;kbd&gt;quit&lt;/kbd&gt;</code>来退出程序，或者键入<code>&lt;kbd&gt;menu&lt;/kbd&gt;</code>来返回主菜单。<br></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Ctrl<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span>+<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>H<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p></p></blockquote><p>显示效果：<br><kbd>Ctrl</kbd>+<kbd>H</kbd><br>参考：<a href="http://www.w3school.com.cn/tags/tag_kbd.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/tags/tag_kbd.asp</a></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/6507a83c/">markdown文档中使用键盘键</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> markdown使用 </category>
          
          <category> markdown语法 </category>
          
          <category> 使用html标签 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hexo博客使用hexo-neat插件压缩页面以提高响应速度</title>
      <link href="/blog/d42afc7b/"/>
      <url>/blog/d42afc7b/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><ul><li>安装hexo-neat插件</li><li>在站点配置文件中添加配置</li><li>不压缩某文件的正确配置方式</li><li>解决桃心效果失效</li></ul><a id="more"></a><h2 id="安装hexo-neat插件"><a href="#安装hexo-neat插件" class="headerlink" title="安装hexo-neat插件"></a>安装hexo-neat插件</h2><p>在站点根目录下安装hexo-neat<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-neat --save</span><br></pre></td></tr></table></figure><p></p><h2 id="在站点配置文件中添加配置"><a href="#在站点配置文件中添加配置" class="headerlink" title="在站点配置文件中添加配置"></a>在站点配置文件中添加配置</h2><p>下边是我自己站点的相关配置，直接添加到<strong>站点配置文件</strong>_config.yml的<code>末尾</code>就可以。可以安装自己的需求去自定义那些文件需要压缩,主要是有些js可能压缩后会失效。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># hexo-neat</span><br><span class="line"># 博文压缩</span><br><span class="line">neat_enable: true</span><br><span class="line"># 压缩html</span><br><span class="line">neat_html:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line"># 压缩css  </span><br><span class="line">neat_css:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">    - &apos;**/*.min.css&apos;</span><br><span class="line"># 压缩js</span><br><span class="line">neat_js:</span><br><span class="line">  enable: true</span><br><span class="line">  mangle: true</span><br><span class="line">  output:</span><br><span class="line">  compress:</span><br><span class="line">  exclude:</span><br><span class="line">    - &apos;**/*.min.js&apos;</span><br><span class="line">    - &apos;**/jquery.fancybox.pack.js&apos;</span><br><span class="line">    - &apos;**/index.js&apos;</span><br></pre></td></tr></table></figure><p></p><h2 id="不压缩某文件的正确配置方式"><a href="#不压缩某文件的正确配置方式" class="headerlink" title="不压缩某文件的正确配置方式"></a>不压缩某文件的正确配置方式</h2><p>如果按照官方插件的文档说明来配置<code>exclude</code>排除项，你会发现完全不起作用。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">neat_css:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">    - &apos;*.min.css&apos;</span><br></pre></td></tr></table></figure><p></p><p><strong>这是因为配置的文件路径不对</strong>，压缩时找不到你配置的文件，自然也就无法跳过了。你需要给这些文件指定正确的路径，万能的配置方式如下，把路径改为<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">neat_css:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">    - &apos;**/*.min.css&apos;</span><br></pre></td></tr></table></figure><p></p><h2 id="解决桃心效果失效"><a href="#解决桃心效果失效" class="headerlink" title="解决桃心效果失效"></a>解决桃心效果失效</h2><p>当然有些博客加了桃心效果，需要添加配置项，让hexo-neat不压缩桃心的js文件。<a href="/2018/10/25/Hexo搭建博客/使用Hexo-neat压缩/使用hexo-neat压缩博客后桃心效果失效/">参见</a>，把上面的配置改为下面即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 博文压缩</span><br><span class="line">neat_enable: true</span><br><span class="line"># 压缩html</span><br><span class="line">neat_html:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line"># 压缩css  </span><br><span class="line">neat_css:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">    - &apos;**/*.min.css&apos;</span><br><span class="line"># 压缩js</span><br><span class="line">neat_js:</span><br><span class="line">  enable: true</span><br><span class="line">  mangle: true</span><br><span class="line">  output:</span><br><span class="line">  compress:</span><br><span class="line">  exclude:</span><br><span class="line">    - &apos;**/*.min.js&apos;</span><br><span class="line">    - &apos;**/jquery.fancybox.pack.js&apos;</span><br><span class="line">    - &apos;**/index.js&apos;  </span><br><span class="line">    - &apos;**/love.js&apos;</span><br><span class="line"></span><br><span class="line"># 压缩博文配置结束</span><br></pre></td></tr></table></figure><p>插件官方位置：<a href="https://github.com/rozbo/hexo-neat" target="_blank" rel="noopener">https://github.com/rozbo/hexo-neat</a><br>参考文章：<a href="https://blog.csdn.net/lewky_liu/article/details/82432003" target="_blank" rel="noopener">https://blog.csdn.net/lewky_liu/article/details/82432003</a></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/d42afc7b/">Hexo博客使用hexo-neat插件压缩页面以提高响应速度</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> 使用Hexo-neat压缩 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用hexo-neat压缩博客后桃心效果失效</title>
      <link href="/blog/3c08b8e0/"/>
      <url>/blog/3c08b8e0/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>可能桃心js文件不能被压缩吧，在站点配置文件中，找到hexo-neat的配置项，不压缩桃心js就行了。<br>在<strong>站点配置文件</strong>中的排除掉桃心的js文件,不压缩即可，即在<code>exclude</code>下面添加<code>- &#39;**/index.js&#39;</code>如下所示：<br><a id="more"></a><br>修改前hexo-neat的配置项：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 博文压缩</span><br><span class="line">neat_enable: true</span><br><span class="line"># 压缩html</span><br><span class="line">neat_html:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line"># 压缩css  </span><br><span class="line">neat_css:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">    - &apos;**/*.min.css&apos;</span><br><span class="line"># 压缩js</span><br><span class="line">neat_js:</span><br><span class="line">  enable: true</span><br><span class="line">  mangle: true</span><br><span class="line">  output:</span><br><span class="line">  compress:</span><br><span class="line">  exclude:</span><br><span class="line">    - &apos;**/*.min.js&apos;</span><br><span class="line">    - &apos;**/jquery.fancybox.pack.js&apos;</span><br><span class="line">    - &apos;**/index.js&apos;  </span><br><span class="line"></span><br><span class="line"># 压缩博文配置结束</span><br></pre></td></tr></table></figure><p></p><p>修改后整个hexo-neat的配置项如下所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 博文压缩</span><br><span class="line">neat_enable: true</span><br><span class="line"># 压缩html</span><br><span class="line">neat_html:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line"># 压缩css  </span><br><span class="line">neat_css:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">    - &apos;**/*.min.css&apos;</span><br><span class="line"># 压缩js</span><br><span class="line">neat_js:</span><br><span class="line">  enable: true</span><br><span class="line">  mangle: true</span><br><span class="line">  output:</span><br><span class="line">  compress:</span><br><span class="line">  exclude:</span><br><span class="line">    - &apos;**/*.min.js&apos;</span><br><span class="line">    - &apos;**/jquery.fancybox.pack.js&apos;</span><br><span class="line">    - &apos;**/index.js&apos;  </span><br><span class="line">    - &apos;**/love.js&apos;</span><br><span class="line"></span><br><span class="line"># 压缩博文配置结束</span><br></pre></td></tr></table></figure><p></p><p>后面没有发现什么问题。<br>参考：<a href="https://blog.csdn.net/lewky_liu/article/details/82432003" target="_blank" rel="noopener">https://blog.csdn.net/lewky_liu/article/details/82432003</a></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/3c08b8e0/">使用hexo-neat压缩博客后桃心效果失效</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> 使用Hexo-neat压缩 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hexo Next正确安装配置RSS插件</title>
      <link href="/blog/82e4ee34/"/>
      <url>/blog/82e4ee34/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><ul><li>安装插件</li><li>修改站点配置文件</li><li>修改主题配置文件</li><li>部署看效果</li></ul><a id="more"></a><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>进入本地hexo站点目录，打开git-bash。输入以下命令<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed</span><br></pre></td></tr></table></figure><p></p><h2 id="修改站点配置文件"><a href="#修改站点配置文件" class="headerlink" title="修改站点配置文件"></a>修改站点配置文件</h2><p>hexo站点根目录下的_config.yml文件中，添加以下配置。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 设置RSS插件</span><br><span class="line">plugin:</span><br><span class="line">- hexo-generator-feed</span><br><span class="line">#Feed Atom</span><br><span class="line">feed:</span><br><span class="line">  type: atom</span><br><span class="line">  path: atom.xml</span><br><span class="line">  limit: 0 #0表示生成全部文章的RSS链接，其他</span><br></pre></td></tr></table></figure><p></p><h2 id="修改主题配置文件"><a href="#修改主题配置文件" class="headerlink" title="修改主题配置文件"></a>修改主题配置文件</h2><p>打开主题目录下的_config.yml文件，找到rss配置项，在后面添加如下配置：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Set rss to false to disable feed link.</span><br><span class="line"># Leave rss as empty to use site&apos;s feed link, and install hexo-generator-feed: `npm install hexo-generator-feed --save`.</span><br><span class="line"># Set rss to specific value if you have burned your feed already.</span><br><span class="line">rss: /atom.xml</span><br><span class="line"></span><br><span class="line"># 配置RSS</span><br><span class="line">#feed: </span><br><span class="line">  #feed 类型 (atom/rss2)</span><br><span class="line">#  type: atom</span><br><span class="line">#  rss localhost:4000</span><br><span class="line">#  path: atom.xml</span><br><span class="line">#  #在 rss 中最多生成的文章数(0显示所有)</span><br><span class="line">#  limit: 0 #显示所有的文章</span><br></pre></td></tr></table></figure><p></p><p>主题配置文件中的feed配置项，注释掉,因为已经在站点配置文件配置了，在主题配置文件虽然也可以使用RSS，但是只能默认生成20条，及时就该limit也不行，不知道为什么。</p><h2 id="部署看效果"><a href="#部署看效果" class="headerlink" title="部署看效果"></a>部署看效果</h2><p>输入命令<code>hexo -d</code>部署到GithHub上，点击RSS按钮即可订阅整个站点的文章。</p><p>参考：<a href="https://blog.csdn.net/u011303443/article/details/52333695" target="_blank" rel="noopener">https://blog.csdn.net/u011303443/article/details/52333695</a></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/82e4ee34/">Hexo Next正确安装配置RSS插件</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> 给博客添加功能 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hexo Next使用RSS快速向百度主动推送自己的文章</title>
      <link href="/blog/b8b226f8/"/>
      <url>/blog/b8b226f8/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><ul><li>使用Hexo Next主题的博客</li><li>已经有了RSS功能，正确的配置请看<a href="/2018/10/25/Hexo搭建博客/给博客添加功能/Hexo Next正确安装配置RSS插件/">我的这篇文章</a></li><li>你的站点已经被百度收录</li><li>已经安装自动推送JS代码，可以向百度自动推送。</li></ul><blockquote><p>自动推送是百度搜索资源平台为提高站点新增网页发现速度推出的工具，安装自动推送JS代码的网页，在页面被访问时，页面URL将立即被推送给百度</p></blockquote><p>从上面可以知道，要向百度推送，我们只需要点击自己的文章即可。如果你写的文章有点多，为了向百度推送，我们得一次次的点击自己的文章。如果某一篇忘了点击了，就不会推送到百度。百度也就不会收录这篇文章。现在来介绍使用RSS订阅来快速访问新文章，这样这些新文章就会推送给百度让百度收录。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><a id="more"></a><p>1.使用hexo d部署到GitHub<br>2.访问自己的网站<br>3.订阅自己的网站<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E7%99%BE%E5%BA%A6%E8%87%AA%E5%8A%A8%E6%8E%A8%E9%80%81/%E4%BD%BF%E7%94%A8RSS%E5%BF%AB%E9%80%9F%E6%8E%A8%E9%80%81/rss_myself.png" alt=""><br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E7%99%BE%E5%BA%A6%E8%87%AA%E5%8A%A8%E6%8E%A8%E9%80%81/%E4%BD%BF%E7%94%A8RSS%E5%BF%AB%E9%80%9F%E6%8E%A8%E9%80%81/yes.png" alt=""><br>4.点击订阅按钮，展开链接列表，然后点击<code>以标签页打开书签组</code>。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E7%99%BE%E5%BA%A6%E8%87%AA%E5%8A%A8%E6%8E%A8%E9%80%81/%E4%BD%BF%E7%94%A8RSS%E5%BF%AB%E9%80%9F%E6%8E%A8%E9%80%81/openlist.png" alt=""><br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E7%99%BE%E5%BA%A6%E8%87%AA%E5%8A%A8%E6%8E%A8%E9%80%81/%E4%BD%BF%E7%94%A8RSS%E5%BF%AB%E9%80%9F%E6%8E%A8%E9%80%81/yes29.png" alt=""><br>这样我们一下子可以一下子访问了201篇文章，同时也向百度推动了201篇文章。当然一下子打开这么多标签，内存占用也是惊人的：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E7%99%BE%E5%BA%A6%E8%87%AA%E5%8A%A8%E6%8E%A8%E9%80%81/%E4%BD%BF%E7%94%A8RSS%E5%BF%AB%E9%80%9F%E6%8E%A8%E9%80%81/firefoxopen200pluspage.png" alt=""><br>都加载完毕后火狐内存占用：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E7%99%BE%E5%BA%A6%E8%87%AA%E5%8A%A8%E6%8E%A8%E9%80%81/%E4%BD%BF%E7%94%A8RSS%E5%BF%AB%E9%80%9F%E6%8E%A8%E9%80%81/firefoxopen200pluspageafter.png" alt=""><br>也还行，还在我电脑的承受范围之内哈哈，可惜的是这个操作向百度自动推送了所有的文章了。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/b8b226f8/">Hexo Next使用RSS快速向百度主动推送自己的文章</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> 给博客添加功能 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>eclipse导出可执行jar时Launch configuration下拉列表选项太多</title>
      <link href="/blog/956cc103/"/>
      <url>/blog/956cc103/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>我们知道，用eclipse打包jar的时候，需要指定一个main函数。需要先运行一下main函数，eclipse的Runnable JAR File Specification 下的<code>Launch configuration</code>下拉列表才会有记录。但是，有时候<code>Launch configuration</code>下拉列表的主方法记录实在是太多了，导出的时候需要花费好长时间才能找到主类。所以需要定时清理掉<code>Launch configuration</code>下拉列表里面这些主类的记录。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><a id="more"></a><p>如果想要删除<code>Launch configuration</code>下拉列表的主类历史记录，只要进入到要打包的这个<code>工程所在的目录</code>，也就是<code>工作空间目录</code>找到这个：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/.metadata/.plugins/org.eclipse.debug.core/.launches</span><br></pre></td></tr></table></figure><p></p><p>文件夹，清空里面的内容，然后重启eclipse即可：<img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/Java/IDE%E4%BD%BF%E7%94%A8/eclipse%E5%AF%BC%E5%87%BA%E5%8F%AF%E6%89%A7%E8%A1%8Cjar%E6%97%B6Launch%20configuration%E9%80%89%E9%A1%B9%E5%A4%AA%E5%A4%9A/qingli_launch.png" alt=""><br>参考：<a href="http://coderlxl201209164551.iteye.com/blog/2126652" target="_blank" rel="noopener">http://coderlxl201209164551.iteye.com/blog/2126652</a></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/956cc103/">eclipse导出可执行jar时Launch configuration下拉列表选项太多</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> IDE设置 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>hexo next主题修改分类页面的超链接样式</title>
      <link href="/blog/2c0fac8a/"/>
      <url>/blog/2c0fac8a/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:16 GMT+0800 (中国标准时间) --><p>分类页面的超链接都是黑色的，看起来不是很明显，如下所示：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/Next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/hexo%20next%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E5%88%86%E7%B1%BB%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%B6%85%E9%93%BE%E6%8E%A5%E6%A0%B7%E5%BC%8F/before.png" alt="">修改后的样式：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/Next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/hexo%20next%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E5%88%86%E7%B1%BB%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%B6%85%E9%93%BE%E6%8E%A5%E6%A0%B7%E5%BC%8F/result.png" alt=""></p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><a id="more"></a><p>而且我喜欢在文章首部添加摘要信息：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/Next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/hexo%20next%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E5%88%86%E7%B1%BB%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%B6%85%E9%93%BE%E6%8E%A5%E6%A0%B7%E5%BC%8F/article_zaiyao_link.png" alt=""><br>我希望文章中的链接也如上面所示：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/Next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/hexo%20next%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E5%88%86%E7%B1%BB%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%B6%85%E9%93%BE%E6%8E%A5%E6%A0%B7%E5%BC%8F/article_zaiyao_link_after.png" alt=""><br>这需要修改样式文件，可以参考：<a href="https://www.jianshu.com/p/9f0e90cc32c2" target="_blank" rel="noopener">这篇文章中的：修改文章内链接文本样式</a>。</p><p>首先把<a href="https://www.lansheng.net.cn/2018/10/09/读书笔记/Maven实战 许晓斌著/第3章/Maven实战 许晓斌著 第3章 Maven使用入门/">带摘要的文章例子</a>下载下来，用VScode打开看看页面的html源码。定位文章页面的源码：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-body"</span> <span class="attr">itemprop</span>=<span class="string">"articleBody"</span> <span class="attr">style</span>=<span class="string">"opacity: 1; display: block; transform: translateY(0px);"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"第三章Maven使用入门"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#第三章Maven使用入门"</span> <span class="attr">class</span>=<span class="string">"headerlink"</span> <span class="attr">title</span>=<span class="string">"第三章Maven使用入门"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>第三章Maven使用入门<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">"摘要"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#摘要"</span> <span class="attr">class</span>=<span class="string">"headerlink"</span> <span class="attr">title</span>=<span class="string">"摘要"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>摘要<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.lansheng.net.cn/2018/10/09/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Maven%E5%AE%9E%E6%88%98%20%E8%AE%B8%E6%99%93%E6%96%8C%E8%91%97/%E7%AC%AC3%E7%AB%A0/Maven%E5%AE%9E%E6%88%98%20%E8%AE%B8%E6%99%93%E6%96%8C%E8%91%97%20%E7%AC%AC3%E7%AB%A0%20Maven%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/#%E7%BC%96%E5%86%99POM"</span>&gt;</span>编写POM<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.lansheng.net.cn/2018/10/09/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Maven%E5%AE%9E%E6%88%98%20%E8%AE%B8%E6%99%93%E6%96%8C%E8%91%97/%E7%AC%AC3%E7%AB%A0/Maven%E5%AE%9E%E6%88%98%20%E8%AE%B8%E6%99%93%E6%96%8C%E8%91%97%20%E7%AC%AC3%E7%AB%A0%20Maven%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/#%E7%BC%96%E5%86%99%E4%B8%BB%E4%BB%A3%E7%A0%81"</span>&gt;</span>编写主代码<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">       ......</span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>可以看到摘要信息的链接标签位置为：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-body"</span>&gt;</span><span class="tag">&lt;<span class="name">ul</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span>&gt;</span>编写POM<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>我们只需要用CSS选中器选中该超链接，然后设置颜色样式即可：<br></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 文章无序列表超链接(文章摘要)样式:颜色为蓝色，选中该连接显示橙色</span><br><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span>&#123;</span><br><span class="line">  color: #0593d3;//默认的链接样式</span><br><span class="line">  <span class="selector-tag">border-bottom</span>: <span class="selector-tag">none</span>;</span><br><span class="line">  border-bottom: 1px solid #0593d3;//选时显示橙色</span><br><span class="line">  &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fc6423</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: none;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#fc6423</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>那么在哪里添加这超链接呢？,打开Next主题的下面的：<code>themes\next\source\css\_common\components\post\post.styl</code><br>在.post-body选择器下面添加上面的选择器：<br>如下图所示：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/Next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/hexo%20next%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E5%88%86%E7%B1%BB%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%B6%85%E9%93%BE%E6%8E%A5%E6%A0%B7%E5%BC%8F/add_cssInPost_styl.png" alt=""><br>然后启动本地服务器即可看到效果，确认无误后就部署到GitHub上。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/2c0fac8a/">hexo next主题修改分类页面的超链接样式</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> Next主题配置 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用java给Hexo博客内文章更新HexoFrontMatter</title>
      <link href="/blog/e767edb8/"/>
      <url>/blog/e767edb8/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>之前我已经用java写了一个自动生成HexoFrontMatter的工具程序，我用的也还行。但是，我之前写的文章很不规范，目录也乱放。后面我绝对markdown文件名不和是，或者所在的目录不合适我都会修改过来，但是这就要求对相应的HexoFrontMatter也要对应的修改过来。之前的程序不能满足这样的功能。我需要重新写一个工具程序，或者，修正之前的代码，支持更新功能。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/e767edb8/">使用java给Hexo博客内文章更新HexoFrontMatter</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 我的软件 </category>
          
          <category> Hexo博客工具程序 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hexo部署问题 Error Connection reset by 192.30.253.112 port 22</title>
      <link href="/blog/2842eab3/"/>
      <url>/blog/2842eab3/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>今天双线部署的时候遇到了下面的问题,<strong>因为网络中途断了,传输过程被打断，而导致传输失败,后面也一直部署不上</strong>。我发现部署到GitHub上是没问题的，部署到Coding的时候一直部署不上去。后面一通乱试了之后，解决了问题，下面是过程：<br><a id="more"></a><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">INFO  Deploying: git</span><br><span class="line">INFO  Clearing .deploy_git folder...</span><br><span class="line">INFO  Copying files from public folder...</span><br><span class="line">INFO  Copying files from extend dirs...</span><br><span class="line">[master 75140863] Site updated: 2018-10-24 22:50:16</span><br><span class="line"> 29 files changed, 347 insertions(+), 347 deletions(-)</span><br><span class="line">Connection reset by 192.30.253.112 port 22</span><br><span class="line">fatal: The remote end hung up unexpectedly</span><br><span class="line">fatal: The remote end hung up unexpectedly</span><br><span class="line">FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br><span class="line">Error: Connection reset by 192.30.253.112 port 22</span><br><span class="line">fatal: The remote end hung up unexpectedly</span><br><span class="line">fatal: The remote end hung up unexpectedly</span><br><span class="line"></span><br><span class="line">    at ChildProcess.&lt;anonymous&gt; (D:\Blog\bolg5\node_modules\hexo-util\lib\spawn.js:37:17)</span><br><span class="line">    at emitTwo (events.js:126:13)</span><br><span class="line">    at ChildProcess.emit (events.js:214:7)</span><br><span class="line">    at ChildProcess.cp.emit (D:\Blog\bolg5\node_modules\cross-spawn\lib\enoent.js:40:29)</span><br><span class="line">    at maybeClose (internal/child_process.js:915:16)</span><br><span class="line">    at Socket.stream.socket.on (internal/child_process.js:336:11)</span><br><span class="line">    at emitOne (events.js:116:13)</span><br><span class="line">    at Socket.emit (events.js:211:7)</span><br><span class="line">    at Pipe._handle.close [as _onclose] (net.js:561:12)</span><br></pre></td></tr></table></figure><p></p><p>有人建议删除<code>.deploy_git文件夹</code>，然后重新部署。</p><p>我试了无效，GitHub可以部署，Coding还是无法部署上去，因为我用的双线部署。我猜的GitHub已经部署成功了，在部署Coding的时候，网络刚好断开了。所以无法部署到Coding。</p><p>然后我尝试，单独部署到Coding看看，所以注释掉GitHub的部署配置项：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo:</span><br><span class="line">    #github: git@github.com:用户名/用户名.github.io.git  # Github pages地址</span><br><span class="line">    coding: git@git.coding.net:用户名/用户名.coding.me.git #coding地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p></p><p>单独部署到coding上，发现是可以的。然后我再重新重新尝试双部署。发现又可以了<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo:</span><br><span class="line">    github: git@github.com:用户名/用户名.github.io.git  # Github pages地址</span><br><span class="line">    coding: git@git.coding.net:用户名/用户名.coding.me.git #coding地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p></p><p>所以呢，这篇文章写得什么东西呢?额，就当是记录一个把问题范围缩小的思想吧，一个可能的解决方案，虽然我不知道发生了什么。</p><p>参考：<a href="http://www.cnblogs.com/wumz/p/9820295.html" target="_blank" rel="noopener">http://www.cnblogs.com/wumz/p/9820295.html</a><br>参考：<a href="http://www.cnblogs.com/wumz/p/9820314.html" target="_blank" rel="noopener">http://www.cnblogs.com/wumz/p/9820314.html</a></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/2842eab3/">Hexo部署问题 Error Connection reset by 192.30.253.112 port 22</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> 遇到问题 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>正则应用：匹配Windows路径</title>
      <link href="/blog/93d942f1/"/>
      <url>/blog/93d942f1/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>下面的文本中有好多路径如:<code>D:\dev\workspace\HexoTools</code>，我想用markdown<code>代码段标记</code>出来。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">### 文件位置 ###</span><br><span class="line">- java工程位置：D:\dev\workspace\HexoTools</span><br><span class="line">- java源码位置：D:\dev\workspace\HexoTools\src\front\matter\tools\HexoFrontMatter.java</span><br><span class="line">- jar包文件位置：D:\dev\java\my\runable\HexoTools\FrontMatter\HexoFrontMatter.jar</span><br><span class="line">- bat文件位置：D:\dev\java\my\runable\HexoTools\FrontMatter\HexoFrontMatter.bat</span><br><span class="line">- 快捷方式位置：D:\快捷方式\HexoFrontMatter.lnk</span><br></pre></td></tr></table></figure><p></p><p>也就是替换为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">### 文件位置 ###</span><br><span class="line">- java工程位置：`D:\dev\workspace\HexoTools`</span><br><span class="line">- java源码位置：`D:\dev\workspace\HexoTools\src\front\matter\tools\HexoFrontMatter.java`</span><br><span class="line">- jar包文件位置：`D:\dev\java\my\runable\HexoTools\FrontMatter\HexoFrontMatter.jar`</span><br><span class="line">- bat文件位置：`D:\dev\java\my\runable\HexoTools\FrontMatter\HexoFrontMatter.bat`</span><br><span class="line">- 快捷方式位置：`D:\快捷方式\HexoFrontMatter.lnk`</span><br></pre></td></tr></table></figure><p></p><a id="more"></a><p>这里使用的编辑器是：editplus，打开这篇文章，按下ctrl+h,打开查找替换，使用下面的正则表达式</p><p>查找正则:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(\w:(?:\\.+)+)</span><br></pre></td></tr></table></figure><p></p><p>替换正则：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`$1`</span><br></pre></td></tr></table></figure><p></p><p>这个匹配的不是很正确，使用的时候我还不敢点全部替换，我对正则表达式的掌握还不够,还得继续去学。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/93d942f1/">正则应用：匹配Windows路径</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 正则表达式 </category>
          
          <category> 实例 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hexo博客问题 新部署文章的加载不出来</title>
      <link href="/blog/6da07097/"/>
      <url>/blog/6da07097/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>这是因为浏览器缓存的原因，所以最新推送的文章可能不能很快刷新出来。<br>解决方法:<br>在浏览器中按下<code>Ctrl+F5</code>强制刷新,强制刷新会直接从服务器获取文件,这样就能看到新发布的文章了。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/6da07097/">Hexo博客问题 新部署文章的加载不出来</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> 遇到问题 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>EditPlus自定义markdown插件</title>
      <link href="/blog/35941a7a/"/>
      <url>/blog/35941a7a/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>因为MarkdownPad2不支持正则表达式，我不能进行匹配的操作，无意中发现EditPlus这个文本编辑器支持正则表达式。而且它还支持用户自定义插件，这点我很喜欢。网上找了一通，没有现成的EditPlus的Markdown插件(快捷键)。所以我就自己来写吧。现在支持的操作有：</p><ul><li>标题：H1H2H3H4</li><li>代码段</li><li>代码块</li><li>租体</li><li>斜体</li><li>引用</li><li>超链接</li><li>图片</li></ul><p>具体的实现步骤如下：<br><a id="more"></a></p><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>H1.java代码：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> editplus.markdown.tools.heads;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">H1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1级标题</span></span><br><span class="line">System.out.print(<span class="string">"# "</span>+args[<span class="number">0</span>]+<span class="string">" #"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>嗯，代码就真简单。然后把H1.java打包成可执行H1.jar包,记下H1.jar包的路径,我这里是：<code>D:\dev\java\my\runable\EditplusTools\heading</code><br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/markdown/editplustools/export_jar.png" alt=""><br>然后，打开editplus进行设置，点击<code>Tools--&gt;Configure User Tools…</code><br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/markdown/editplustools/Tools_Configure%20User%20Tools.png" alt=""><br>然后在<code>Groups and tool items:</code>下拉框中选择一个<code>Group</code>,然后点击<code>Group Name…</code>按钮，在弹出的对话框中，输入新的名字<code>MarkdownTools</code>,点击<code>OK</code>.<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/markdown/editplustools/selectGroup_GroupReName.png" alt=""><br>然后点击<code>Add Tool&gt;&gt;</code>，选择<code>Program</code><br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/markdown/editplustools/Add%20Tool.png" alt=""><br>然后在<code>Menu Text:</code>中输入工具的名称<code>H1</code>,在<code>Command：</code>中输入指令<code>java -jar</code>.接着点击Argument：对话框右边带<strong>黑色三角形的按钮</strong>，展开参数列表。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/markdown/editplustools/Tool_setting_menu%20text_command.png" alt=""><br>在参数列表中选择<code>Current Selection</code>,这个参数表示，我们当前选中的文本。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/markdown/editplustools/Tool_setting_Select%20Argument.png" alt=""><br>然后在参数前面，加上jar包的名称:<code>H1.jar</code>,然后打上一个空格分隔两个参数。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/markdown/editplustools/Tool_setting_input%20args.png" alt=""><br>这样参数就设置好了，现在来设置<code>Initial</code>项，点击右侧的按钮，然后点击<code>Browse…</code>找到<code>H1.jar</code>所在的目录(<code>D:\dev\java\my\runable\EditplusTools\heading</code>),或者直接把路径粘贴进来也行。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/markdown/editplustools/Tools_setting_select%20Initial.png" alt=""></p><p>然后来设置<code>Action</code>项，选择：<code>Run as Text Filter(Replace)</code>,这个选项表示，使用程序H1.jar的运行结果(这里的运行结构指的是控制台输出,也就是<code>System.out.print(&quot;# &quot;+args[0]+&quot; #&quot;);</code>),来替换当前选中的文本。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/markdown/editplustools/Tools_setting_input_Initial.png" alt=""><br>这样就设置完毕了，可以使用了。点击Apply或者Ok即可。<br>然后选择我们刚设置的插件：<code>Tools--&gt;User Tool Group--&gt;MarkdownTools</code>，我这里因为之前配置好了，所以有两个MarkdownTools。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/markdown/editplustools/Select_new_userTool.png" alt=""><br>然后，新建一个<code>测试.md</code>文件，随便写点东西，然后选中文本，点击<code>Tools--&gt;H1</code>,或者按下快捷键<code>ctrl+1</code>:<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/markdown/editplustools/select_some_world.png" alt=""><br>然后就可以看到效果了：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/markdown/editplustools/results.png" alt=""><br>其他插件H2,H3,H4都类似，只是代码不同而已，如，H4.java,就相应的设置为：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> editplus.markdown.tools.heads;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">H4</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//4级标题</span></span><br><span class="line">System.out.print(<span class="string">"#### "</span>+args[<span class="number">0</span>]+<span class="string">" ####"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> editpuls.markdown.tools.code;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeSegment</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"`"</span>+args[<span class="number">0</span>]+<span class="string">"`"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> editpuls.markdown.tools.code;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeBlock</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">System.out.print(<span class="string">"```\n"</span>+args[<span class="number">0</span>]+<span class="string">"\n```"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="粗体"><a href="#粗体" class="headerlink" title="粗体"></a>粗体</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> editpuls.markdown.tools.stong;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Strong</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">System.out.print(<span class="string">"**"</span>+args[<span class="number">0</span>]+<span class="string">"**"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> editpuls.markdown.tools.italic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Italic</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">System.out.print(<span class="string">"*"</span>+args[<span class="number">0</span>]+<span class="string">"*"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> editpuls.markdown.tools.quote;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quote</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">System.out.print(<span class="string">"&gt; "</span>+args[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> editpuls.markdown.tools.hyperlink;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> clipboard.util.SysClipboardUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hyperlink2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">System.out.print(<span class="string">"["</span>+args[<span class="number">0</span>]+<span class="string">"]("</span>+SysClipboardUtil.getSysClipboardText()+<span class="string">")"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的默认的超链接是放在剪贴板中的，一般在markdown中超链接也是通过粘贴的方式输入的。在editplus中传入更多的命令行参数来实现，但是比较复杂，而且效果也不好。所以先复制好超链接再来调用该插件。</p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> editpuls.markdown.tools.image;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> clipboard.util.SysClipboardUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Image</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">System.out.print(<span class="string">"!["</span>+args[<span class="number">0</span>]+<span class="string">"]("</span>+SysClipboardUtil.getSysClipboardText()+<span class="string">")"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和超链接一样，图片的链接也要实现放在剪贴板中。这样的方式代码量最小。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>主要看第一步，后面的代码都差不多。还可以接着设置更过的自定义插件。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/35941a7a/">EditPlus自定义markdown插件</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 我的软件 </category>
          
          <category> Markdown工具 </category>
          
          <category> 自定义插件 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java中BufferedImage类的用法</title>
      <link href="/blog/d819de9c/"/>
      <url>/blog/d819de9c/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>首先必须明确的是：<strong>要想操作一张图片，首先必须将其从磁盘加载到内存中，然后才能对图片做进一步的处理</strong>。<br><strong>继承关系</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object</span><br><span class="line">    |----&gt; java.awt.Image</span><br><span class="line">        |----&gt; java.awt.image.BufferedImage</span><br></pre></td></tr></table></figure><p></p><p>BufferedImage是Image的一个子类，Image和BufferedImage的主要作用就是将一副图片加载到内存中。BufferedImage生成的图片在内存里有一个图像缓冲区，利用这个缓冲区我们可以很方便的操作这个图片，通常用来做图片修改操作如大小变换、图片变灰、设置图片透明或不透明等。Java将一副图片加载到内存中的方法是：<br>1</p><p>BufferedImage bufferedImage = ImageIO.read(new FileInputStream(filePath));</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/d819de9c/">java中BufferedImage类的用法</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> java 图片操作 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>移除win10多余的微软拼音输入法</title>
      <link href="/blog/3cc3e684/"/>
      <url>/blog/3cc3e684/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p><strong>问题描述</strong><br>我不是很喜欢win10自带的微软拼音输入法，自己安装了搜狗拼音输入法，但是这样同时用两个输入法，经常需要按下shift+ctrl进行切换。我不喜欢来回切换输入法,现在来介绍移除多余的微软拼音输入法。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><a id="more"></a><ol><li>打开设置<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/others/Windows_Settings/windows_setting.png" alt=""></li><li>进入时间和语言<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/others/Windows_Settings/time_language.png" alt=""></li><li>选择区域和语言<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/others/Windows_Settings/region_language.png" alt=""></li><li>单击中文(中华人民共和国)，然后选择选项<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/others/Windows_Settings/ClickChinese.png" alt=""></li><li>然后再键盘中单机微软拼音，然后点击删除即可移除掉微软拼音输入法<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/others/Windows_Settings/delete_Microsoft_pinyin.png" alt=""></li></ol><p>本文链接: <a href="https://www.lansheng.net.cn/blog/3cc3e684/">移除win10多余的微软拼音输入法</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
          <category> Windows相关 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>markdown语法 待办事项</title>
      <link href="/blog/8859faa9/"/>
      <url>/blog/8859faa9/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><ul><li>Markdown待办事项语法</li><li>MarkdownPad2 中支持待办事项</li></ul><a id="more"></a><h2 id="Markdown待办事项语法"><a href="#Markdown待办事项语法" class="headerlink" title="Markdown待办事项语法"></a>Markdown待办事项语法</h2><p>不是所有的markdown都支持待办事项的，语法：<strong>横框+ 空格+方括号（方括号中必须有空格或者x） + 空格+ 文本</strong>。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- [x] test</span><br><span class="line">- [ ] test2</span><br><span class="line">- [ ] test4</span><br></pre></td></tr></table></figure><p></p><p>已经完成的事项，在中括号中写入英文<code>x</code>,未完成的事项在中括号中的写入空格,显示效果：</p><ul><li style="list-style:none"><input type="checkbox" checked>已经完成的事项</li><li style="list-style:none"><input type="checkbox">未完成的事项</li></ul><h2 id="MarkdownPad2-中支持待办事项"><a href="#MarkdownPad2-中支持待办事项" class="headerlink" title="MarkdownPad2 中支持待办事项"></a>MarkdownPad2 中支持待办事项</h2><p>点击左下角的<code>M图标</code>切换CSS模式，选择<code>GitHub Flavored Markdown (Offline)</code>。这样导出的html就支持待办事项了。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/markdown/undo/markdownPad2_css_settings.png" alt=""><br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/markdown/undo/markdownPad2_Undo_settings.png" alt=""><br>再按下<code>ctrl+shift+1</code>导出为html，就可查看效果了：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/markdown/undo/markdownPad2_Undo_show.png" alt=""></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/8859faa9/">markdown语法 待办事项</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> markdown使用 </category>
          
          <category> markdown语法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>重装系统后的Git配置</title>
      <link href="/blog/68ac5364/"/>
      <url>/blog/68ac5364/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><ul><li>第1步 重新创建SSH key</li><li>第2步 GitHub中添加新的公钥</li><li>第3步 配置GitHub上的邮箱和用户名</li><li>第4步: 部署到GitHub pages</li></ul><a id="more"></a><h2 id="第1步"><a href="#第1步" class="headerlink" title="第1步"></a>第1步</h2><p>创建SSH Key。在用户主目录(Windows中对应：<code>C:\Users\用户名\</code>)下：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/others/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/%E6%81%A2%E5%A4%8DGit%E9%85%8D%E7%BD%AE/%E6%9F%A5%E7%9C%8Bssh%E7%9B%AE%E5%BD%95.png" alt=""><br>看看有没有.ssh目录,如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了这两个文件，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure><p></p><p><strong>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可</strong>，由于这个Key也不是用于军事目的，所以也无需设置密码。</p><p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p><h2 id="第2步-GitHub中添加新的公钥"><a href="#第2步-GitHub中添加新的公钥" class="headerlink" title="第2步 GitHub中添加新的公钥"></a>第2步 GitHub中添加新的公钥</h2><p>登陆GitHub，点击头像上的下拉菜单，打开“Settings”，“SSH and GPG keys”页面：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/others/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/%E6%81%A2%E5%A4%8DGit%E9%85%8D%E7%BD%AE/github_settings.png" alt=""><br>然后，点击delete按钮删除掉之前的无效公钥，因为重装系统后私钥已经丢失了的。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/others/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/%E6%81%A2%E5%A4%8DGit%E9%85%8D%E7%BD%AE/github_settings_delete.png" alt=""><br>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/others/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/%E6%81%A2%E5%A4%8DGit%E9%85%8D%E7%BD%AE/github_settings_new.png" alt=""></p><h2 id="第3步-配置GitHub上的邮箱和用户名"><a href="#第3步-配置GitHub上的邮箱和用户名" class="headerlink" title="第3步 配置GitHub上的邮箱和用户名"></a>第3步 配置GitHub上的邮箱和用户名</h2><p>更换密钥后还需要再git中配置邮箱和用户名，如果没有配置邮箱和用户名的话无法部署到github中，错误信息如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br><span class="line">INFO  Deploying: git</span><br><span class="line">INFO  Clearing .deploy_git folder...</span><br><span class="line">INFO  Copying files from public folder...</span><br><span class="line">INFO  Copying files from extend dirs...</span><br><span class="line"></span><br><span class="line">*** Please tell me who you are.</span><br><span class="line"></span><br><span class="line">Run</span><br><span class="line"></span><br><span class="line">  git config --global user.email &quot;you@example.com&quot;</span><br><span class="line">  git config --global user.name &quot;Your Name&quot;</span><br><span class="line"></span><br><span class="line">to set your account&apos;s default identity.</span><br><span class="line">Omit --global to set the identity only in this repository.</span><br></pre></td></tr></table></figure><p></p><p>按照提示信息，输入你GitHub上的邮箱和用户名即可：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email &quot;you@example.com&quot;</span><br><span class="line">git config --global user.name &quot;Your Name&quot;</span><br></pre></td></tr></table></figure><p></p><h2 id="第4步-部署到GitHub-pages"><a href="#第4步-部署到GitHub-pages" class="headerlink" title="第4步: 部署到GitHub pages"></a>第4步: 部署到GitHub pages</h2><p>设置成功后，现在打开giit-bash中，cd到站点目录下，运行<code>Hexo d</code>：把博客部署到GitHub上：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br><span class="line">......</span><br><span class="line"> rewrite page/6/index.html (66%)</span><br><span class="line"> copy page/&#123;5 =&gt; 7&#125;/index.html (71%)</span><br><span class="line"> rename page/&#123;7 =&gt; 8&#125;/index.html (71%)</span><br><span class="line"> rename page/&#123;8 =&gt; 9&#125;/index.html (67%)</span><br><span class="line">Branch &apos;master&apos; set up to track remote branch &apos;master&apos; from &apos;git@github.com:lanlan2017/lanlan2017.github.io.git&apos;.</span><br><span class="line">To github.com:lanlan2017/lanlan2017.github.io.git</span><br><span class="line">   7090d3f9..69a6b246  HEAD -&gt; master</span><br><span class="line">INFO  Deploy done: git</span><br></pre></td></tr></table></figure><p></p><p>可以看到已经部署成功了。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/68ac5364/">重装系统后的Git配置</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
          <category> 重装系统 </category>
          
          <category> 备份与恢复 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>NodeJS安装以及环境变量配置</title>
      <link href="/blog/a99b2ae3/"/>
      <url>/blog/a99b2ae3/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>1、本机系统：Windows 10 专业版（64位）<br>2、Node.js：v8.12.0LTS（64位）</p><p>安装具体步骤看这篇博客，我懒得再写一遍了：<a href="https://www.cnblogs.com/zhouyu2017/p/6485265.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhouyu2017/p/6485265.html</a><br>安装完毕后，记下Node.js的安装位置，我这里是：<code>F:\Program Files\nodejs\</code>。<br><a id="more"></a></p><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><h3 id="创建全局模块安装目录，缓存目录"><a href="#创建全局模块安装目录，缓存目录" class="headerlink" title="创建全局模块安装目录，缓存目录"></a>创建全局模块安装目录，缓存目录</h3><p>说明：这里的<strong>环境配置主要配置的是npm安装的全局模块所在的路径，以及缓存cache的路径</strong>，之所以要配置，是因为在执行类似：npm install express [-g] （后面的可选参数-g，g代表global全局安装的意思）的安装语句时，会将安装的模块安装到【C:\Users\用户名\AppData\Roaming\npm】路径中，<code>这样会占用C盘空间</code>。</p><p>例如：我希望将全模块所在路径和缓存路径放在我node.js安装的文件夹中，则在我安装的文件夹【F:\Program Files\nodejs】下创建两个文件夹【node_global】及【node_cache】如：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/others/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/%E9%87%8D%E8%A3%85%E5%90%8EHexo%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/node_js%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png" alt=""></p><p>创建完两个空文件夹之后，打开cmd命令窗口，输入：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set prefix &quot;F:\Program Files\nodejs\node_global&quot;</span><br><span class="line">npm config set cache &quot;F:\Program Files\nodejs\node_cache&quot;</span><br></pre></td></tr></table></figure><p></p><p>这里的<code>F:\Program Files\nodejs</code>是我的node.js安装路径。以你的路径为准。</p><h3 id="配置环境变量-1"><a href="#配置环境变量-1" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>新建系统环境变量：<strong>NODE_PATH</strong>，输入：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F:\Program Files\nodejs\node_global\node_modules</span><br></pre></td></tr></table></figure><p></p><p>同样，我这里的<code>F:\Program Files\nodejs\</code>是Node.js的安装路径，以你的为准。<br>然后在Path环境变量中添加新的值:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F:\Program Files\nodejs\node_global</span><br></pre></td></tr></table></figure><p></p><h2 id="六、测试"><a href="#六、测试" class="headerlink" title="六、测试"></a>六、测试</h2><p>配置完后，安装个module测试下，我们就安装最常用的express模块，打开cmd窗口，<br>输入如下命令进行模块的全局安装：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express -g</span><br></pre></td></tr></table></figure><p></p><p><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/others/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/%E9%87%8D%E8%A3%85%E5%90%8EHexo%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/npm_install_express_g.png" alt=""><br>这样模块就安装到的F盘了,这样可以减少C盘的占用。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/a99b2ae3/">NodeJS安装以及环境变量配置</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
          <category> 重装系统 </category>
          
          <category> 备份与恢复 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>重装后Hexo相关配置</title>
      <link href="/blog/d299d5c4/"/>
      <url>/blog/d299d5c4/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>系统重装后,跟最初搭建的步骤一致：</p><ul><li>首先重新安装Node.js</li><li>然后安装Hexo</li><li>测试安装Hexo是否成功安装：输入hexo s命令查看效果。</li></ul><a id="more"></a><h2 id="安装配置Node-js"><a href="#安装配置Node-js" class="headerlink" title="安装配置Node.js"></a>安装配置Node.js</h2><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>重新配置好Node.js后：博客站点目录，输入下面命令安装Hexo:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p></p><h2 id="使用hexo-命令管理博客"><a href="#使用hexo-命令管理博客" class="headerlink" title="使用hexo 命令管理博客"></a>使用hexo 命令管理博客</h2><p>输入命令:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p></p><p>启动本地服务器，如果，启动成功，则说明没有问题，在浏览器中打开即可。</p><p>参考<a href="https://blog.csdn.net/gdutxiaoxu/article/details/53576018" target="_blank" rel="noopener">https://blog.csdn.net/gdutxiaoxu/article/details/53576018</a></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/d299d5c4/">重装后Hexo相关配置</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
          <category> 重装系统 </category>
          
          <category> 备份与恢复 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>重装后无法使用Node.js命令</title>
      <link href="/blog/287a2db3/"/>
      <url>/blog/287a2db3/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>电脑中毒崩溃后，我重装系统后我发现node命令无法使用了，hexo命令也无法使用。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li>如果node.js和hexo安装在系统盘，那么重装node.js,重装hexo</li><li>node.js和hexo安装在非系统盘，那重新配置环境变量即可。</li></ul><a id="more"></a><p>我这里采用第一中方案，虽然我的node.js安装在非系统盘，但是我现在并不知道，node.js需要什么环境变量。</p><p>所以我这里先重装，在看看Node.js会创建什么环境变量，我将记下这些变量，下次我就直接配置就行了，免得我在重新安装。</p><p>下载node.js和安装细节忽略</p><h2 id="Node-js需要的环境变量"><a href="#Node-js需要的环境变量" class="headerlink" title="Node.js需要的环境变量"></a>Node.js需要的环境变量</h2><p>安装后，我翻看了环境变量列表，发现新增Path环境变量：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F:\Program Files\nodejs\</span><br></pre></td></tr></table></figure><p></p><p>其他环境变量暂时没有找到，以后如果电脑再次崩溃，先给Node.js配置Path环境变量。应该不需要配置其他环境变量。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/287a2db3/">重装后无法使用Node.js命令</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
          <category> 重装系统 </category>
          
          <category> 备份与恢复 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java Web从入门到精通第3章 3-2了解 JavaScript</title>
      <link href="/blog/6b4d0bbb/"/>
      <url>/blog/6b4d0bbb/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><ul><li>什么是 JavaScript</li><li>JavaScript的主要特点</li><li>JavaScript的语法</li></ul><a id="more"></a><h2 id="什么是-JavaScript"><a href="#什么是-JavaScript" class="headerlink" title="什么是 JavaScript"></a>什么是 JavaScript</h2><p>JavaScript是一种<code>基于对象和事件驱动</code>并具有安全性能的<code>解释型脚本语言</code>,在Web应用中得到了非常广泛的应用。<strong>它不需要进行编译,而是直接嵌入在HTP页面中,把静态页面转变成支持用户交互并响应应用事件的动态页面</strong>。在 Java Web程序中,<strong>经常应用 JavaScript进行数据验证、控制浏览器以及生成时钟、日历和时间戳文档等</strong>。</p><h2 id="JavaScript的主要特点"><a href="#JavaScript的主要特点" class="headerlink" title="JavaScript的主要特点"></a>JavaScript的主要特点</h2><p>JavaScript适用于静态或动态网页,是一种被广泛使用的<code>客户端脚本语言</code>。它具有解释性、基于对象、事件驱动、安全性和跨平台等特点,下面进行详细介绍。</p><h3 id="解释性"><a href="#解释性" class="headerlink" title="解释性"></a>解释性</h3><p>JavaScript是一种<code>脚本语言</code>,采用小程序段的方式实现编程。和其他脚本语言一样, <code>JavaScript也是一种解释性语言,</code>它提供了一个简易的开发过程。</p><h3 id="基于对象"><a href="#基于对象" class="headerlink" title="基于对象"></a>基于对象</h3><p>javaScript是种基于对象的语言.它可以应用自己创建的对象,因此许多功能来自于脚本环境中象的方法与脚本的相互作用。</p><h3 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h3><p>JavaScript<strong>可以以事件驱动的方式直接对客户端的输入作出响应,无须经过服务器端程序</strong>。</p><hr><p><strong>说明</strong><br>事件驱动就是用户进行某种操作(如按下鼠标、选择菜单等),计算机随之作出相应的响应。这里的某种操作称之为事件,而计算机作出的响应称之为事件响应。</p><hr><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>JavaScript具有安全性。它<strong>不允许访问本地硬盘</strong>,<strong><code>不能将数据写入到服务器上</code>,并且<code>不允许对网络文档进行修改和删除</code>,只能通过浏览器实现信息浏览或动态交互,从而有效地防止数据的丢失</strong>。</p><h3 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h3><p><strong>JavaScript依赖于浏览器本身,与操作系统无关</strong>,只要浏览器支持 Javascript, JavaScript的程序代码就可以正确执行。</p><h2 id="JavaScript的语法"><a href="#JavaScript的语法" class="headerlink" title="JavaScript的语法"></a>JavaScript的语法</h2><p>JavaScript与Java在语法上有些相似,但也不尽相同。下面将结合Java语言对编写 JavaScript代码时需要注意的事项进行详细介绍</p><h3 id="JavaScript区分大小写"><a href="#JavaScript区分大小写" class="headerlink" title="JavaScript区分大小写"></a>JavaScript区分大小写</h3><p>JavaScript区分大小写,这一点与Java语言是相同的。例如,变量 username与变量 userName是两个不同的变量。</p><h3 id="每行结尾的分号可有可无"><a href="#每行结尾的分号可有可无" class="headerlink" title="每行结尾的分号可有可无"></a>每行结尾的分号可有可无</h3><p>与Java语言不同, <strong>JavaScript并不要求必须以分号(<code>;</code>)作为语句的结束标记</strong>。如果语句的结束处没有分号, JavaScript会自动将该行代码的结尾作为语句的结尾<br>每行末尾添加分号与不添加分号,实例代码如下:<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">"您好!欢迎访问我公司网站!"</span>)</span><br><span class="line">alert(<span class="string">"您好!欢迎访问我公司网站!"</span>);</span><br></pre></td></tr></table></figure><p></p><p>不过，<strong>最妤的代码编写习惯是在每行代码的结尾处加上分号</strong>,这样可以保证每行代码的准确性。</p><h3 id="变量是弱类型的"><a href="#变量是弱类型的" class="headerlink" title="变量是弱类型的"></a>变量是弱类型的</h3><p>与Java语言不同, JavaScript的变量是弱类型的。因此<strong>在定义变量时,只使用var运算符,就可以将变量初始化为任意的值</strong>。例如,通过以下代码可以将变量 username初始化为 “haha”,而将变量age初始化为20。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> username=<span class="string">"haha"</span>;</span><br><span class="line"><span class="keyword">var</span> age=<span class="number">20</span>;</span><br></pre></td></tr></table></figure><p></p><h3 id="使用大括号标记代码块"><a href="#使用大括号标记代码块" class="headerlink" title="使用大括号标记代码块"></a>使用大括号标记代码块</h3><p>与Java语言相同, JavaScript也是使用一对大括号标记代码块,被封装在大括号内的语句将<code>按顺序执行</code>。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>在 JavaScript中,提供了两种注释,即<code>单行注释</code>和<code>多行注释</code>。下面进行详细介绍。单行注释使用双斜线”\\”开头,在”\\”后面的文字为注释内容,在代码执行过程中不起任何作用。<br>多行注释以”<code>/*</code>“开头,以”<code>*/</code>“结尾,在”/“和”<code>*/</code>“之间的内容为注释内容,在代码执行过程中不起任何作用。</p><h2 id="JavaScript中的关键字"><a href="#JavaScript中的关键字" class="headerlink" title="JavaScript中的关键字"></a>JavaScript中的关键字</h2><p>JavaScript中的关键字是指在 JavaScript中具有特定含义的、可以成为 JavaScript语法中一部分的字符。与其他编程语言一样, JavaScript中也有许多关键字, JavaScript中的关键字如下表所示。</p><table><thead><tr><th style="text-align:center">列名</th><th style="text-align:center">列名</th><th style="text-align:center">列名</th><th style="text-align:center">列名</th><th style="text-align:center">列名</th><th style="text-align:center">列名</th></tr></thead><tbody><tr><td style="text-align:center">abstract</td><td style="text-align:center">continue</td><td style="text-align:center">finally</td><td style="text-align:center">instanceof</td><td style="text-align:center">private</td><td style="text-align:center">this</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">default</td><td style="text-align:center">foat</td><td style="text-align:center">int</td><td style="text-align:center">public</td><td style="text-align:center">throw</td></tr><tr><td style="text-align:center">break</td><td style="text-align:center">do</td><td style="text-align:center">for</td><td style="text-align:center">interface</td><td style="text-align:center">return</td><td style="text-align:center">typeof</td></tr><tr><td style="text-align:center">byte</td><td style="text-align:center">double</td><td style="text-align:center">function</td><td style="text-align:center">long</td><td style="text-align:center">short</td><td style="text-align:center">true</td></tr><tr><td style="text-align:center">case</td><td style="text-align:center">else</td><td style="text-align:center">goto</td><td style="text-align:center">native</td><td style="text-align:center">static</td><td style="text-align:center">var</td></tr><tr><td style="text-align:center">catch</td><td style="text-align:center">extends</td><td style="text-align:center">Implements</td><td style="text-align:center">new</td><td style="text-align:center">super</td><td style="text-align:center">void</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">false</td><td style="text-align:center">Import</td><td style="text-align:center">null</td><td style="text-align:center">switch</td><td style="text-align:center">while</td></tr><tr><td style="text-align:center">class</td><td style="text-align:center">final</td><td style="text-align:center">in</td><td style="text-align:center">ackage</td><td style="text-align:center">synchronized</td><td style="text-align:center">with</td></tr></tbody></table><p><strong>注意:</strong>javascript中的关键字不能用作变量名、函数名以及循环标签。</p><h2 id="JavaScript的数据类型"><a href="#JavaScript的数据类型" class="headerlink" title="JavaScript的数据类型"></a>JavaScript的数据类型</h2><p>JavaScript的数据类型比较简单,主要有<code>数值型</code>、<code>字符型</code>、<code>布尔型</code>、<code>转义字符</code>、<code>空值(null)</code>和<code>未定义值6</code>种,下面分别进行介绍。</p><h3 id="数值型"><a href="#数值型" class="headerlink" title="数值型"></a>数值型</h3><p>javaScript的数值型数据又可以分为整型和浮点型两种,下面分别进行介绍。</p><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>JavaScript的整型数据可以是正整数、负整数和0,并且可以采用十进制、八进制或十六进制来表示。例如<br><strong>定义整型变量:</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">789</span> <span class="comment">//十进制</span></span><br><span class="line"><span class="number">071</span> <span class="comment">//八进制</span></span><br><span class="line"><span class="number">0x9405B</span> <span class="comment">//十六进制</span></span><br></pre></td></tr></table></figure><p></p><p><strong>说明</strong>:以0开头的数为八进制数,以0x开头的数为十六进制数</p><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><p>浮点型数据由整数部分加小数部分组成,<code>只能采用十进制</code>,但是<code>可以使用科学记数法或是标准方法</code>来表示。例如:<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.1415926</span>; <span class="comment">//用标准方法表示</span></span><br><span class="line"><span class="number">1.6E5</span>;   <span class="comment">//用科学记数法表示,代表$1.6\time10^&#123;5&#125;$</span></span><br></pre></td></tr></table></figure><p></p><h4 id="字符串型"><a href="#字符串型" class="headerlink" title="字符串型"></a>字符串型</h4><p>字符型数据是使用<code>单引号</code>或<code>双引号</code>括起来的一个或多个字符<br><strong>JavaScrip</strong>t与Java不同,它没有char数据类型,<strong>要表示单个字符,必须使用长度为1的字符串</strong></p><h4 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h4><p>布尔型数据只有两个值,即true或fase,主要用来说明或代表一种状态或标志。<strong>在 JavaScript中,也可以使用整数0表示 false,使用非0的整数表示true</strong>。</p><h4 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h4><p><strong>以反斜杠开头的不可显示的特殊字符通常称为控制字符,也被称为转义字符</strong>。<strong>通过转义字符可以在字符串中添加不可显示的特殊字符,或者防止引号匹配混乱的问题</strong>。 JavaScript常用的转义字符如下表所示。</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">转义字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><code>\b</code></td><td style="text-align:left">退格</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><code>\f</code></td><td style="text-align:left">换页</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><code>\r</code></td><td style="text-align:left">回车符</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><code>\n</code></td><td style="text-align:left">换行符</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><code>\t</code></td><td style="text-align:left">Tab符</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><code>\&#39;</code></td><td style="text-align:left">单引号</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><code>\&quot;</code></td><td style="text-align:left">双引号</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><code>\\</code></td><td style="text-align:left">反斜杠</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"><code>\xnn</code></td><td style="text-align:left">十六进制代码<code>nn</code>表示的字符</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left"><code>\unnnn</code></td><td style="text-align:left">十六进制代码<code>nnnn</code>表示的Unicode字符</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left"><code>\0nnn</code></td><td style="text-align:left">八进制代码<code>nnn</code>表示的字符</td></tr></tbody></table><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>在网页中弹出一个提示对话框,并应用转义字符“r”将文字分为两行显示,代码如下:<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">"欢迎访问我公司网站!\n http://www.yousite.com"</span>);</span><br></pre></td></tr></table></figure><p></p><h3 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h3><p>JavaScript中有一个空值(null),用于定义空的或不存在的引用。如果试图引用一个没有定义的变量,则返回一个null值。<br><strong>注意</strong>：空值不等于空的字符串(\”)或0。</p><h3 id="未定义值"><a href="#未定义值" class="headerlink" title="未定义值"></a>未定义值</h3><p>当使用了一个并未声明的变量,或者使用了一个已经声明但没有赋值的变量时,将返回未定义值(undefined)。</p><p>JavaScript中还有<strong>一种特殊类型的数字常量<code>NaN</code>,即“非数字”</strong>。当在程序中由于某种原因发生计算错误后,将产生一个没有意义的数字,此时 JavaScript返回的数字值就是NaN</p><h2 id="变量的定义及使用"><a href="#变量的定义及使用" class="headerlink" title="变量的定义及使用"></a>变量的定义及使用</h2><p><strong>变量是指程序中<code>一个已经命名的存储单元</code>,其主要作用就是<code>为数据操作提供存放信息的容器</code></strong>。在使用变量前,必须明确变量的命名规则、变量的声明方法以及变量的作用域。</p><h3 id="变量的命名规则"><a href="#变量的命名规则" class="headerlink" title="变量的命名规则"></a>变量的命名规则</h3><p>JavaScript变量的命名规则如下:</p><ul><li>变量名由字母、数字或下划线组成,但必须以字母或下划线开头。</li><li>变量名中不能有空格、加号、减号或逗号等符号。</li><li>不能使用 Javascript中的关键字。</li><li>JavaScript的变量名是严格区分大小写的。例如, arr_week与 arr_Week代表两个不同的变量。</li></ul><h3 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h3><p>在 JavaScript中,可以使用关键字var声明变量,其语法格式如下:<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vanable;</span><br></pre></td></tr></table></figure><p></p><p>参数说明:<br>variable:用于指定变量名,该变量名必须遵守变量的命名规则。</p><h4 id="变量声明规则"><a href="#变量声明规则" class="headerlink" title="变量声明规则"></a>变量声明规则</h4><p>在声明变量时需要遵守以下规则:</p><ul><li>可以使用一个关键字var同时声明多个变量</li><li>可以在声明变量的同时对其进行赋值,即初始化</li><li>如果只是声明了变量,但未对其赋值,则其默认值为 undefined</li><li>当给一个尚未声明的变量赋值时, JavaScript会自动用该变量名创建一个全局变量。在一个函数内部,通常创建的只是一个仅在函数内部起作用的局部变量,而不是一个全局变量。<strong>要创建一个全局变量,则必须使用var关键字进行变量声明</strong>。</li><li>由于 JavaScript采用弱类型,所以在声明变量时不需要指定变量的类型,而变量的类型将根据变量的值来确定。</li></ul><h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><p>变量的<strong>作用域是指变量在程序中的有效范围</strong>。在 JavaScript中,根据变量的作用域可以将变量<strong>分为<code>全局变量</code>和<code>局部变量</code>两种</strong>。<strong>全局变量是定义在所有函数之外,作用于整个脚本代码的变量;局部变量是定义在函数体内,只作用于函数体内的变量</strong>。<br>下面的代码将说明变量的作用域<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var globalVar = &quot;全局变量&quot;; //该变量在函数外声明，作用于整个脚本代码</span><br><span class="line">    function show()</span><br><span class="line">    &#123;</span><br><span class="line">        var localVar=&quot;局部变量&quot;; //该变量在函数内声明，只作用于该函数体</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p></p><h2 id="运算符的应用"><a href="#运算符的应用" class="headerlink" title="运算符的应用"></a>运算符的应用</h2><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JavaWeb%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%B8%89%E7%AB%A0/%E4%BA%86%E8%A7%A3JavaScript/JavaScript%E4%B8%AD%E7%9A%84%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6.png" alt="赋值运算符"><br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JavaWeb%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%B8%89%E7%AB%A0/%E4%BA%86%E8%A7%A3JavaScript/JavaScript%E4%B8%AD%E7%9A%84%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%BB%AD%E8%A1%A8.png" alt=""></p><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JavaWeb%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%B8%89%E7%AB%A0/%E4%BA%86%E8%A7%A3JavaScript/%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6.png" alt=""></p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JavaWeb%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%B8%89%E7%AB%A0/%E4%BA%86%E8%A7%A3JavaScript/%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6.png" alt=""></p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JavaWeb%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%B8%89%E7%AB%A0/%E4%BA%86%E8%A7%A3JavaScript/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6.png" alt=""></p><h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><p>条件运算符是 JavaScript支持的一种特殊的<code>三目运算符</code>,其语法格式如下:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作数?结果1:结果2</span><br></pre></td></tr></table></figure><p></p><p>如果“操作数”的值为tue,则整个表达式的结果为“结果1”,否则为“结果2”。</p><h3 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h3><p>字符串运算符是用于两个字符型数据之间的运算符,除了比较运算符外,还可以是<code>+</code>和<code>+=</code>运算符。其中,</p><ul><li><strong><code>+</code>运算符</strong>用于连接两个字符串,</li><li>而<strong><code>+=</code>运算符</strong>则连接两个字符串,并将结果赋给第一个字符串。<br>【例317】在网页中弹出一个提示对话框,显示进行字符串运算后变量a的值。代码如下:<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> hello = <span class="string">"hello"</span>;</span></span><br><span class="line"><span class="javascript">hello += <span class="string">"world"</span>;</span></span><br><span class="line"><span class="undefined">alert(hello);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>显示效果：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JavaWeb%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E7%AC%AC%E4%B8%89%E7%AB%A0/%E4%BA%86%E8%A7%A3JavaScript/%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%93%BE%E6%8E%A5%E8%BF%90%E7%AE%97%E7%AC%A6.png" alt=""></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/6b4d0bbb/">Java Web从入门到精通第3章 3-2了解 JavaScript</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Java Web从入门到精通 </category>
          
          <category> 第3章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java Web从入门到精通第3章 3-1本章概述</title>
      <link href="/blog/9f6068bc/"/>
      <url>/blog/9f6068bc/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><p>JavaScript是Web页面中一种比较流行的脚本语言,它由客户端浏览器解释执行,可以应用在JSP、PHP、ASP等网站中。同时,随着Ajax进入Web开发的主流市场, JavaScript已经被推到了舞台的中心,因此,<strong>熟练掌握并应用 JavaScript对于网站开发人员来说非常重要</strong>。本章将详细介绍<strong> JavaScript的基本语法、常用对象及DOM技术</strong>。通过阅读本章,您可以:</p><ul><li>了解什么是 JavaScript以及 JavaScript的主要特点</li><li>掌握 JavaScript语言基础</li><li>掌握 JavaScript的流程控制语句</li><li>掌握 JavaScript中函数的应用</li><li>掌握 JavaScript常用对象的应用</li><li>掌握 DOM技术</li></ul><p>本文链接: <a href="https://www.lansheng.net.cn/blog/9f6068bc/">Java Web从入门到精通第3章 3-1本章概述</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Java Web从入门到精通 </category>
          
          <category> 第3章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>笔记本扬声器突然没有声音</title>
      <link href="/blog/d33f0352/"/>
      <url>/blog/d33f0352/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>我是因为前阵子收件吧瑞星驱动删除掉了，把瑞星驱动下载下来重新安装即可。<br><a id="more"></a><br>点击扬声器的按钮，识别扬声器的名字如：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/gaoxiao/%E7%AC%94%E8%AE%B0%E6%9C%AC%E6%89%AC%E5%A3%B0%E5%99%A8%E6%B2%A1%E6%9C%89%E5%A3%B0%E9%9F%B3/%E6%89%AC%E5%A3%B0%E5%99%A8%E5%90%8D%E5%AD%97.png" alt=""><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">扬声器( conexant20751 SmartAudio hd)</span><br></pre></td></tr></table></figure><p></p><p>然后下载对应的驱动，进行安装即可。我当初在卸载软件的时候，不小心把驱动删掉了。重新下载安装即可。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/d33f0352/">笔记本扬声器突然没有声音</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
          <category> Windows相关 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>word中使用MathType插入LaTeX公式</title>
      <link href="/blog/bff020ff/"/>
      <url>/blog/bff020ff/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>安装word2016</li><li>安装MathType</li><li>熟悉Latex语法</li></ul><a id="more"></a><p>首先需要先安装MathType,安装最新版即可。要安装到C盘，安装到其他地方可能使用不了。word2016成功集成了MathType的效果：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/gaoxiao/MathTypeInWorld2016.png" alt=""><br>Word2016中切换到MathType选项卡，点击Inline,把公式：<code>$c=\frac{a}{b}$</code>,复制，然后粘贴到MathTyte输入框即可显示公式。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/gaoxiao/Word_MathType_Latex/MathTypeInWorld2016IinserInline.png" alt=""><br>显示效果：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/gaoxiao/Word_MathType_Latex/MathTypeInWorld2016IinserInline_result.png" alt=""><br>word中显示效果：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/gaoxiao/Word_MathType_Latex/World_MathType_Latex_show.png" alt=""></p><p>但是这样好奇快啊，我总不能先在word中写好公式，然后在复制粘贴看效果，就先这么用吧。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/bff020ff/">word中使用MathType插入LaTeX公式</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
          <category> Windows相关 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>正则实例：多行html代码合并为一行</title>
      <link href="/blog/72162c39/"/>
      <url>/blog/72162c39/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>有时候为了阅读方便，可以使用正则表达式把多行html代码合并到一行。<br><a id="more"></a><br>有下面这样一段HTML代码：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:auto"</span>&gt;</span></span><br><span class="line">    Auto<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:crosshair"</span>&gt;</span></span><br><span class="line">    Crosshair<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:default"</span>&gt;</span></span><br><span class="line">    Default<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:pointer"</span>&gt;</span></span><br><span class="line">    Pointer<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:move"</span>&gt;</span></span><br><span class="line">    Move<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:e-resize"</span>&gt;</span></span><br><span class="line">    e-resize<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:ne-resize"</span>&gt;</span></span><br><span class="line">    ne-resize<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:nw-resize"</span>&gt;</span></span><br><span class="line">    nw-resize<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:n-resize"</span>&gt;</span></span><br><span class="line">    n-resize<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:se-resize"</span>&gt;</span></span><br><span class="line">    se-resize<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:sw-resize"</span>&gt;</span></span><br><span class="line">    sw-resize<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:s-resize"</span>&gt;</span></span><br><span class="line">    s-resize<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:w-resize"</span>&gt;</span></span><br><span class="line">    w-resize<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:text"</span>&gt;</span></span><br><span class="line">    text<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:wait"</span>&gt;</span></span><br><span class="line">    wait<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:help"</span>&gt;</span></span><br><span class="line">    help<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>例如第一句：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:auto"</span>&gt;</span></span><br><span class="line">    Auto<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>改成：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:auto"</span>&gt;</span>Auto<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>当然我是不可能一行行的来改的。使用正则表达式来做比较方便。匹配表达式：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&lt;span.*?&gt;)\n\s+(.*&lt;/span&gt;)\n\s+</span><br></pre></td></tr></table></figure><p></p><p>匹配效果(VScode中)：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E5%BA%94%E7%94%A8/%E5%8C%B9%E9%85%8DHTML/%E5%A4%9A%E8%A1%8Chtml%E5%90%88%E5%B9%B6%E4%B8%BA%E4%B8%80%E8%A1%8C.png" alt=""><br>html代码，会被括号捕获到，而换行符和空白符就不会被捕获，使用捕获到的html代码替换掉原来匹配的文本即可。所以替换的正则表达式为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$1$2</span><br></pre></td></tr></table></figure><p></p><p><code>$1</code>表示第一个捕获组，<code>$2</code>表示第二个捕获组。捕获组不同的软件(体系)中的表示方式不同。VScode中是使用$1,$2,… 而NotePad++中使用的是<code>\1,\2,\3...</code>。<br>使用上述正则表达式是进行替换即可。替换后的结果为：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>请把鼠标移动到单词上，可以看到鼠标指针发生变化：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:auto"</span>&gt;</span>Auto<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:crosshair"</span>&gt;</span>Crosshair<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:default"</span>&gt;</span>Default<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:pointer"</span>&gt;</span>Pointer<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:move"</span>&gt;</span>Move<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:e-resize"</span>&gt;</span>e-resize<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:ne-resize"</span>&gt;</span>ne-resize<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:nw-resize"</span>&gt;</span>nw-resize<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:n-resize"</span>&gt;</span>n-resize<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:se-resize"</span>&gt;</span>se-resize<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:sw-resize"</span>&gt;</span>sw-resize<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:s-resize"</span>&gt;</span>s-resize<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:w-resize"</span>&gt;</span>w-resize<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:text"</span>&gt;</span>text<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:wait"</span>&gt;</span>wait<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:help"</span>&gt;</span></span><br><span class="line">    help<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>当然最后一句，并没有能够成功匹配到。但这样的效果。还算满意,因为现在我只需要修改最后一行的效果。当然最佳的方式，应该是现在VScode中看匹配的结果。编写更好的正则表达式，尽可能匹配到所有的内容。完美的正则表达式为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&lt;span.*?&gt;)\n\s+(.*&lt;/span&gt;)(:?\n\s+)?</span><br></pre></td></tr></table></figure><p></p><p>这样所有的span标签都会被匹配到。替换后的效果为：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>请把鼠标移动到单词上，可以看到鼠标指针发生变化：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:auto"</span>&gt;</span>Auto<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:crosshair"</span>&gt;</span>Crosshair<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:default"</span>&gt;</span>Default<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:pointer"</span>&gt;</span>Pointer<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:move"</span>&gt;</span>Move<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:e-resize"</span>&gt;</span>e-resize<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:ne-resize"</span>&gt;</span>ne-resize<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:nw-resize"</span>&gt;</span>nw-resize<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:n-resize"</span>&gt;</span>n-resize<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:se-resize"</span>&gt;</span>se-resize<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:sw-resize"</span>&gt;</span>sw-resize<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:s-resize"</span>&gt;</span>s-resize<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:w-resize"</span>&gt;</span>w-resize<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:text"</span>&gt;</span>text<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:wait"</span>&gt;</span>wait<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"cursor:help"</span>&gt;</span>help<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/72162c39/">正则实例：多行html代码合并为一行</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 正则表达式 </category>
          
          <category> 实例 </category>
          
          <category> 匹配HTML标签 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java Web从入门到精通 第二章 小结，实践与练习</title>
      <link href="/blog/95fa3c8d/"/>
      <url>/blog/95fa3c8d/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><ul><li>小结</li><li><p>实践与练习</p><ul><li><p>练习1 创建HIML页面,实现在页面中使用删除线样式标注商品特价</p><ul><li>相关知识：<ul><li>span标签</li><li>CSS text-decoration 属性</li></ul></li></ul></li><li><p>练习2 创建HTML页面,并在其中添加表格,实现在浏览网站信息时鼠标经过表格的某个单元格,会显示相关的提示信息。</p><ul><li>相关知识：<ul><li>title属性</li></ul></li></ul></li></ul></li></ul><a id="more"></a><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本章介绍了网页设计中不可缺少的内容,即HTML标记与CSS样式。<strong>HTML是构成网页的灵魂,对于制作一般的网页,尤其是静态网页来说,HIML完全可以胜任,但如果要制作漂亮的网页,CSS是不可缺少的</strong>。本章除了对HTML与CSS样式表的基础内容进行讲解外,还对2010年较受关注的内容HTML5与CSS3进行了简单的介绍,以此来带领广大读者进入Web学习之旅。</p><h2 id="实践与练习"><a href="#实践与练习" class="headerlink" title="实践与练习"></a>实践与练习</h2><h3 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a>练习1</h3><h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h4><p>创建HIML页面,实现在页面中使用删除线样式标注商品特价。</p><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>使用删除线样式标注商品特价<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"bike.jpg"</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">height</span>=<span class="string">"165"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span> &amp;nbsp;&amp;nbsp;</span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"text-decoration:line-through"</span>&gt;</span>原价：796（元）<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&amp;nbsp;&amp;nbsp;&amp;nbsp;</span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>现价：399（元）<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>显示效果：</p><hr><p>这里，我不懂span标签，先来查一下<a href="http://www.w3school.com.cn/tags/tag_span.asp" target="_blank" rel="noopener"><code>&lt;span&gt;</code>元素</a>。</p><p><strong><code>&lt;span&gt;</code>元素定义和用法</strong><br><code>&lt;span&gt;</code>标签被用来组合文档中的行内元素。<br>span 没有固定的格式表现。当对它应用样式时，它才会产生视觉上的变化。<br><strong>例子</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>span中的文本。<span class="tag">&lt;/<span class="name">span</span>&gt;</span>其他文本<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>显示效果：</p><p><span>span中的文本。</span>其他文本</p><br><strong>如果不对 span 应用样式，那么 span 元素中的文本与其他文本不会任何视觉上的差异</strong>。尽管如此，上例中的 span 元素仍然为 p 元素增加了额外的结构。<br>可以为 span 应用 id 或 class 属性，这样既可以增加适当的语义，又便于对 span 应用样式。<p></p><p>可以对同一个<code>&lt;span&gt;</code> 元素应用 class 或 id 属性，但是更常见的情况是只应用其中一种。这两者的主要差异是，<strong>class 用于元素组（类似的元素，或者可以理解为某一类元素），而 id 用于标识单独的唯一的元素</strong>。</p><p>提示：事实上，您也许已经注意到了，W3School 站点上有一些文本的样式与其他文本是不同的。比如“提示”使用了粗体的橘红色。尽管实现这种效果的方法非常多，但是我们的做法是：使用“提示”使用 span 元素，然后对这个 span 元素的父元素，即 p 元素应用 class，这样就可以对这个类的子元素 span 应用相应的样式了。</p><p>HTML:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"tip"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>提示：<span class="tag">&lt;/<span class="name">span</span>&gt;</span>... ... ...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>CSS:<br></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.tip</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line"><span class="attribute">font-weight</span>:bold;</span><br><span class="line"><span class="attribute">color</span>:<span class="number">#ff9955</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>完整代码：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>测试span标签<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">        <span class="comment">/* 定义span标签的样式，这个span标签是是class为tip的p元素的子标签 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-tag">p</span><span class="selector-class">.tip</span> <span class="selector-tag">span</span> &#123;</span></span><br><span class="line"><span class="undefined">            font-weight: bold;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">color</span>: <span class="selector-id">#ff9955</span>;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"tip"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>提示：<span class="tag">&lt;/<span class="name">span</span>&gt;</span>事实上，您也许已经注意到了，W3School 站点上有一些文本的样式与其他文本是不同的。比如“提示”使用了粗体的橘红色。尽管实现这种效果的方法非常多，但是我们的做法是：使用“提示”使用 span 元素，然后对这个 span 元素的父元素，即 p 元素应用 class，这样就可以对这个类的子元素 span 应用相应的样式了。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>显示效果如下：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/Java%20Web%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/2/%E5%B0%8F%E7%BB%93_%E7%BB%83%E4%B9%A0/span%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E6%A0%87%E7%AD%BE.png" alt=""></p><hr><p>其次我也不懂这个<code>text-decoration</code>CSS属性，<a href="http://www.w3school.com.cn/cssref/pr_text_text-decoration.asp" target="_blank" rel="noopener">查资料</a></p><hr><p><strong>CSS text-decoration 属性</strong><br><strong>定义和用法</strong></p><p><strong>text-decoration 属性规定<code>添加到文本的修饰</code>。</strong></p><p>注释：修饰的颜色由 “color” 属性设置。<br><strong>说明</strong></p><p><strong>这个属性<code>允许对文本设置某种效果</code>，如加下划线</strong>。如果后代元素没有自己的装饰，祖先元素上设置的装饰会“延伸”到后代元素中。不要求用户代理支持 blink。<br><strong>可能的值</strong></p><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">none</td><td style="text-align:left">默认。定义标准的文本。</td></tr><tr><td style="text-align:left">underline</td><td style="text-align:left">下划线。</td></tr><tr><td style="text-align:left">overline</td><td style="text-align:left">上划线</td></tr><tr><td style="text-align:left">line-through</td><td style="text-align:left">定义穿过文本下的一条线。也就是删除线</td></tr><tr><td style="text-align:left">blink</td><td style="text-align:left">定义闪烁的文本。</td></tr><tr><td style="text-align:left">inherit</td><td style="text-align:left">规定应该<strong>从父元素继承 text-decoration 属性的值</strong>。</td></tr></tbody></table><p><strong>实例</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">h1</span> &#123;<span class="attribute">text-decoration</span>: overline&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">h2</span> &#123;<span class="attribute">text-decoration</span>: line-through&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">h3</span> &#123;<span class="attribute">text-decoration</span>: underline&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">h4</span> &#123;<span class="attribute">text-decoration</span>:blink&#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>使用上划线 1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>使用删除线 2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>使用下划线 3<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>使用闪烁   4<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>显示效果：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/Java%20Web%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/2/%E5%B0%8F%E7%BB%93_%E7%BB%83%E4%B9%A0/text-decoration_css.png" alt=""></p><hr><h3 id="练习2"><a href="#练习2" class="headerlink" title="练习2"></a>练习2</h3><p>创建HTML页面,并在其中添加表格,实现在浏览网站信息时鼠标经过表格的某个单元格,会显示相关的提示信息。<br>实例代码：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">"98%"</span> <span class="attr">height</span>=<span class="string">"114"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">cellpadding</span>=<span class="string">"0"</span> <span class="attr">cellspacing</span>=<span class="string">"1"</span> <span class="attr">bgcolor</span>=<span class="string">"#000000"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- bgcolor="#666666" --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- bgcolor="#FFFFFF" --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">"#FFFFFF"</span> <span class="attr">title</span>=<span class="string">"单元格1"</span>&gt;</span>单元格1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">"#FFFFFF"</span> <span class="attr">title</span>=<span class="string">"单元格2"</span>&gt;</span>单元格2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">"#FFFFFF"</span> <span class="attr">title</span>=<span class="string">"单元格3"</span>&gt;</span>单元格3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">"#FFFFFF"</span> <span class="attr">title</span>=<span class="string">"单元格4"</span>&gt;</span>单元格4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">"#FFFFFF"</span> <span class="attr">title</span>=<span class="string">"单元格5"</span>&gt;</span>单元格5<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">"#FFFFFF"</span>  <span class="attr">title</span>=<span class="string">"单元格6"</span>&gt;</span>单元格6<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">"#FFFFFF"</span> <span class="attr">title</span>=<span class="string">"单元格7"</span>&gt;</span>单元格7<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">"#FFFFFF"</span> <span class="attr">title</span>=<span class="string">"单元格8"</span>&gt;</span>单元格8<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">"#FFFFFF"</span> <span class="attr">title</span>=<span class="string">"单元格9"</span>&gt;</span>单元格9<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>显示效果：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/Java%20Web%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/2/%E5%B0%8F%E7%BB%93_%E7%BB%83%E4%B9%A0/title_css.png" alt=""><br><strong>分析</strong><br>通过<a href="http://www.w3school.com.cn/tags/att_standard_title.asp" target="_blank" rel="noopener">title属性</a>可以实现上述效果。</p><hr><p><strong>title属性</strong><br><strong>定义和用法</strong></p><p><strong>title 属性<code>规定关于元素的额外信息</code>。这些信息通常会在鼠标移到元素上时显示一段工具提示文本</strong>（tooltip text）<br><strong>提示</strong>：title 属性常与 form 以及 a 元素一同使用，以提供关于输入格式和链接目标的信息。同时它也是 abbr 和 acronym 元素的必需属性。<br><strong>语法</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">element</span> <span class="attr">title</span>=<span class="string">"value"</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><strong>title实例</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">abbr</span> <span class="attr">title</span>=<span class="string">"People's Republic of China"</span>&gt;</span>PRC<span class="tag">&lt;/<span class="name">abbr</span>&gt;</span> was founded in 1949.</span><br></pre></td></tr></table></figure><p></p><p><strong>bgcolor 属性</strong><br><strong>定义和用法</strong><br><strong>语法</strong><br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">bgcolor</span>=<span class="string">"value"</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><strong>bgcolor 属性规定文档的背景颜色。</strong></p><p><strong>bgcolor属性值</strong></p><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">color_name</td><td style="text-align:left">规定颜色值为<strong>颜色名称的字体颜色</strong>（比如 “red”）。</td></tr><tr><td style="text-align:left">hex_number</td><td style="text-align:left">规定颜色值为<strong>十六进制值的字体颜色</strong>（比如 “#ff0000”）。</td></tr><tr><td style="text-align:left">rgb_number</td><td style="text-align:left">规定颜色值为<strong> rgb 代码的字体颜色</strong>（比如 “rgb(255,0,0)”）。</td></tr></tbody></table><p>在上面上面的表格中，整个表格的背景颜色设置为黑色<code>#000000</code>而，单元格的背景颜色设置为白色<code>#FFFFFF</code>。这样达到了边框的效果。</p><p><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/Java%20Web%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/2/%E5%B0%8F%E7%BB%93_%E7%BB%83%E4%B9%A0/table_another_border.png" alt=""></p><hr><p>创建HTML页面,并在其中添加超链接,实现当鼠标经过超链接时,鼠标指针变为不同的形状。<br>代码：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>改变鼠标的形状<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">style</span>=<span class="string">"cursor:pointer"</span>&gt;</span>将鼠标移动到我上，鼠标指针将变形<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>解析：<br>这里主要是通过<a href="http://www.w3school.com.cn/cssref/pr_class_cursor.asp" target="_blank" rel="noopener">cursor属性</a>来实现的。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/95fa3c8d/">Java Web从入门到精通 第二章 小结，实践与练习</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Java Web从入门到精通 </category>
          
          <category> 第2章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>自动生成for循环</title>
      <link href="/blog/49b2f12a/"/>
      <url>/blog/49b2f12a/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>这里用java写了一个小工具，用来自动生成计数for循环。<br><a id="more"></a><br>在编程中经常用到计数循环，如循环10遍：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>经常要手动写还是很麻烦的，而eclipse中的自动补全代码生成的我并不满意。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/MyApplications/CodingTools/for/eclipse_for.png" alt=""><br>于是我自己来写一个for命令来自动生成计数for循环：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> auto.cerate.forloop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForNum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> times;</span><br><span class="line">String var=<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">switch</span> (args.length)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span> :</span><br><span class="line"><span class="comment">// 获取命令参数</span></span><br><span class="line">times = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">System.out.println(<span class="string">"for(int i=0;i&lt;"</span> + times + <span class="string">";i++)\n&#123;\n\n&#125;"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span> :</span><br><span class="line"><span class="comment">//第一个命令行参数表示 计数变量</span></span><br><span class="line">var=args[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//第一个命令行参数表示 次数</span></span><br><span class="line">times = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">System.out.println(<span class="string">"for(int "</span>+var+<span class="string">"=0;"</span>+var+<span class="string">"&lt;"</span> + times + <span class="string">";"</span>+var+<span class="string">"++)\n&#123;\n\n&#125;"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>现在把上面的代码打包成可执行jar,然后在运行窗口(快捷键：<code>win+r</code>)调用。</p><p>下面是命令的发布和调用步骤：</p><h2 id="打包为可执行jar"><a href="#打包为可执行jar" class="headerlink" title="打包为可执行jar"></a>打包为可执行jar</h2><p><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/MyApplications/CodingTools/for/for_jar.png" alt=""></p><h2 id="使用bat脚本调用jar"><a href="#使用bat脚本调用jar" class="headerlink" title="使用bat脚本调用jar"></a>使用bat脚本调用jar</h2><p>在可执行jar同目录下，创建for.bat，内容如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@echo</span> off</span><br><span class="line">start javaw -jar <span class="keyword">for</span>.jar %<span class="number">1</span> %<span class="number">2</span></span><br></pre></td></tr></table></figure><p></p><p>第一句代码表示关闭回显，<br>第二句代码表示：以后台进程程方式启动<code>for.jar</code>程序。<code>%1 %2</code>表示<code>for.bat</code>接收到的第一个和第二个命令行参数，我们把这两个命令行参数传递给<code>for.jar</code>进程。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/MyApplications/CodingTools/for/for_bat.png" alt=""><br>到这里程序就可在cmd命令行中通过<code>for.bat</code>来调用了，如输入：<code>for.bat 3</code>,运行程序不会有任何输出。这是因为以<code>javaw</code>方式运行的java程序不带控制台，不会像控制台输出信息。那运行结果在哪里呢，就在剪贴板里。只需要按下<code>ctrl+v</code>快捷键粘贴即可：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;3;i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>代码中也不可能只有一层循环，如果有内层循环，则循环变量就不能在为<code>i</code>了，这时一般设第二层的循环变量为<code>j</code>,第三次循环变量为<code>k</code>。当然这个根据个人洗好进行选择。<br>下面来测试两个参数的情况：cmd中输入<code>for.bat k 3</code>,命令执行完毕后，剪贴板中的内容：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(int k=0;k&lt;3;k++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>好的，得到的效果和我想的一样。<br>但是这样还是存在问题的，每次要先打开cmd命令行，然后cd到for.bat目录，然后再运行代码。这么多时间，我早就把代码打出来了。</p><h2 id="在运行窗口中运行java代码"><a href="#在运行窗口中运行java代码" class="headerlink" title="在运行窗口中运行java代码"></a>在运行窗口中运行java代码</h2><p><strong>接下来介绍如何在运行窗口中运行上述命令</strong>，首先应该创建一个名为<code>快捷方式</code>的文件夹。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/MyApplications/CodingTools/for/%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F.png" alt=""><br>并把该文件的路径配置到Path环境变量中。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/MyApplications/CodingTools/for/%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F_path.png" alt=""><br>然后把for.bat的快捷方式发送到桌面，<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/MyApplications/CodingTools/for/for_link.png" alt=""><br>然后，重名名为<code>for</code>,放到快捷方式文件夹中。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/MyApplications/CodingTools/for/for_link_rename.png" alt=""><br>这样之后就可以直接在win+r运行窗口中直接输入命令<code>for 次数</code>来生成计数循环了：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/MyApplications/CodingTools/for/run_for_3.png" alt=""><br>运行后剪贴板中的内容：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;3;i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>然后同时指定循环变量名和循环次数也是没问题的，如输入<code>for k 6</code>:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(int k=0;k&lt;6;k++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>嗯，我的要求达到了。。。然后回去写代码去。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/49b2f12a/">自动生成for循环</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 我的软件 </category>
          
          <category> 代码生成工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>自动生成Markdown表格(MDTable)</title>
      <link href="/blog/fb891bcd/"/>
      <url>/blog/fb891bcd/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>这里用java写了一个生成markdown表格的工具，使用命令行参数来控制表格的对齐方式和是否带编号。<br><a id="more"></a></p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li>支持对齐方式：<ul><li>center：表示居中对齐</li><li>left: 表示左对齐</li><li>right: 表示右对齐</li></ul></li><li>支持表格编号<ul><li>命令行参数：auto，该模式下使用默认对齐，也就是左对齐，而且在表格第一列加入自动编号，自动编号不计算在总列数中，也就是如果你输入的列数为4，那么加上自动编号的列，整个表格实际上有5列。</li></ul></li></ul><h2 id="程序运行效果"><a href="#程序运行效果" class="headerlink" title="程序运行效果"></a>程序运行效果</h2><h3 id="左对齐表格"><a href="#左对齐表格" class="headerlink" title="左对齐表格"></a>左对齐表格</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|列名|列名|列名|列名|</span><br><span class="line">|:--|:--|:--|:--|</span><br><span class="line">|1|2|3|4|</span><br><span class="line">|5|6|7|8|</span><br><span class="line">|1|2|3|4|</span><br></pre></td></tr></table></figure><p>显示效果如下：</p><table><thead><tr><th style="text-align:left">列名</th><th style="text-align:left">列名</th><th style="text-align:left">列名</th><th style="text-align:left">列名</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">2</td><td style="text-align:left">3</td><td style="text-align:left">4</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">6</td><td style="text-align:left">7</td><td style="text-align:left">8</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">2</td><td style="text-align:left">3</td><td style="text-align:left">4</td></tr></tbody></table><h3 id="右对齐表格"><a href="#右对齐表格" class="headerlink" title="右对齐表格"></a>右对齐表格</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|列名|列名|列名|列名|</span><br><span class="line">|--:|--:|--:|--:|</span><br><span class="line">|1|2|3|4|</span><br><span class="line">|1|2|3|4|</span><br><span class="line">|1|2|3|4|</span><br></pre></td></tr></table></figure><h3 id="显示效果如下"><a href="#显示效果如下" class="headerlink" title="显示效果如下"></a>显示效果如下</h3><table><thead><tr><th style="text-align:right">列名</th><th style="text-align:right">列名</th><th style="text-align:right">列名</th><th style="text-align:right">列名</th></tr></thead><tbody><tr><td style="text-align:right">1</td><td style="text-align:right">2</td><td style="text-align:right">3</td><td style="text-align:right">4</td></tr><tr><td style="text-align:right">1</td><td style="text-align:right">2</td><td style="text-align:right">3</td><td style="text-align:right">4</td></tr><tr><td style="text-align:right">1</td><td style="text-align:right">2</td><td style="text-align:right">3</td><td style="text-align:right">4</td></tr></tbody></table><h3 id="居中对齐表格"><a href="#居中对齐表格" class="headerlink" title="居中对齐表格"></a>居中对齐表格</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|列名|列名|列名|</span><br><span class="line">|:--:|:--:|:--:|</span><br><span class="line">|1|2|3|</span><br><span class="line">|1|2|3|</span><br><span class="line">|1|2|3|</span><br><span class="line">|1|2|3|</span><br></pre></td></tr></table></figure><p>显示效果如下：</p><table><thead><tr><th style="text-align:center">列名</th><th style="text-align:center">列名</th><th style="text-align:center">列名</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td></tr></tbody></table><h3 id="自动编号的表格"><a href="#自动编号的表格" class="headerlink" title="自动编号的表格"></a>自动编号的表格</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|序号|列名|列名|列名|</span><br><span class="line">|:--|:--|:--|:--|</span><br><span class="line">|1|1|2|3|</span><br><span class="line">|2|1|2|3|</span><br></pre></td></tr></table></figure><h3 id="显示效果如下-1"><a href="#显示效果如下-1" class="headerlink" title="显示效果如下"></a>显示效果如下</h3><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">列名</th><th style="text-align:left">列名</th><th style="text-align:left">列名</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">1</td><td style="text-align:left">2</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">1</td><td style="text-align:left">2</td><td style="text-align:left">3</td></tr></tbody></table><h3 id="自动编号右对齐"><a href="#自动编号右对齐" class="headerlink" title="自动编号右对齐"></a>自动编号右对齐</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|序号|列名|列名|列名|</span><br><span class="line">|--:|--:|--:|--:|</span><br><span class="line">|1|2|2|2|</span><br><span class="line">|2|3|3|3|</span><br></pre></td></tr></table></figure><p>显示效果：</p><table><thead><tr><th style="text-align:right">序号</th><th style="text-align:right">列名</th><th style="text-align:right">列名</th><th style="text-align:right">列名</th></tr></thead><tbody><tr><td style="text-align:right">1</td><td style="text-align:right">2</td><td style="text-align:right">2</td><td style="text-align:right">2</td></tr><tr><td style="text-align:right">2</td><td style="text-align:right">3</td><td style="text-align:right">3</td><td style="text-align:right">3</td></tr></tbody></table><h3 id="自动编号，左对齐-默认"><a href="#自动编号，左对齐-默认" class="headerlink" title="自动编号，左对齐(默认)"></a>自动编号，左对齐(默认)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|序号|列名|列名|列名|</span><br><span class="line">|:--|:--|:--|:--|</span><br><span class="line">|1||||</span><br><span class="line">|2||||</span><br></pre></td></tr></table></figure><p>填入列表项，显示效果：</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">列名</th><th style="text-align:left">列名</th><th style="text-align:left">列名</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">信息</td><td style="text-align:left">信息</td><td style="text-align:left">信息</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">信息</td><td style="text-align:left">信息</td><td style="text-align:left">信息</td></tr></tbody></table><h3 id="自动编号，居中对齐"><a href="#自动编号，居中对齐" class="headerlink" title="自动编号，居中对齐"></a>自动编号，居中对齐</h3><p>程序生成：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|序号|列名|列名|列名|</span><br><span class="line">|:--:|:--:|:--:|:--:|</span><br><span class="line">|1||||</span><br><span class="line">|2||||</span><br></pre></td></tr></table></figure><p></p><p>填入列表项，显示效果如下：</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">列名</th><th style="text-align:center">列名</th><th style="text-align:center">列名</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">上</td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr></tbody></table><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">列名</th><th style="text-align:center">列名</th><th style="text-align:center">列名</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">2</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p>实现代码如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> create.markdown.table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> clipboard.util.SysClipboardUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MDTable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (args.length)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span> :</span><br><span class="line">oneArgs(args);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span> :</span><br><span class="line">twoArgs(args);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span> :</span><br><span class="line">noArgs();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">oneArgs</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] rowsCols = getRowsCols();</span><br><span class="line"><span class="comment">// java7之后switch条件语句支持String</span></span><br><span class="line"><span class="comment">// 设置缓冲，默认长度为500</span></span><br><span class="line">StringBuilder buff = <span class="keyword">new</span> StringBuilder(<span class="number">300</span>);</span><br><span class="line"><span class="comment">// 假设一个表格每一行有20,300个字符是15行够了，一般的表格没这个长</span></span><br><span class="line"><span class="keyword">switch</span> (args[<span class="number">0</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"left"</span> :</span><br><span class="line">leftTable(rowsCols, buff);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"right"</span> :</span><br><span class="line">rightTable(rowsCols, buff);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"center"</span> :</span><br><span class="line">centerTable(rowsCols, buff);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"auto"</span> :</span><br><span class="line">autoTable(rowsCols, buff);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"into oneArgs()"</span>);</span><br><span class="line">System.out.println(<span class="string">"--------------------------------"</span>);</span><br><span class="line">System.out.println(buff.toString());</span><br><span class="line">SysClipboardUtil.setSysClipboardText(buff.toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">twoArgs</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] rowsCols = getRowsCols();</span><br><span class="line">StringBuilder buff = <span class="keyword">new</span> StringBuilder(<span class="number">300</span>);</span><br><span class="line">System.out.println(<span class="string">"into twoArgs()"</span>);</span><br><span class="line"><span class="comment">// 两个参数，如auto center,支持同时自动编号并且设定对齐方式。</span></span><br><span class="line"><span class="comment">// 相应的命令为：</span></span><br><span class="line"><span class="comment">// auto left</span></span><br><span class="line"><span class="comment">// auto right</span></span><br><span class="line"><span class="comment">// auto center</span></span><br><span class="line"><span class="comment">// 如果第一个参数是auto</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">"auto"</span>.equals(args[<span class="number">0</span>]))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (args[<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"left"</span> :</span><br><span class="line">autoLeftTable(rowsCols, buff);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"right"</span> :</span><br><span class="line">autoRightTable(rowsCols, buff);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"center"</span> :</span><br><span class="line">autoCenterTable(rowsCols, buff);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"--------------------------------"</span>);</span><br><span class="line">System.out.println(buff.toString());</span><br><span class="line">SysClipboardUtil.setSysClipboardText(buff.toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">noArgs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 没有收到参数，默认左对齐，不自动编号</span></span><br><span class="line"><span class="keyword">int</span>[] rowsCols = getRowsCols();</span><br><span class="line">StringBuilder buff = <span class="keyword">new</span> StringBuilder(<span class="number">300</span>);</span><br><span class="line">leftTable(rowsCols, buff);</span><br><span class="line">System.out.println(<span class="string">"--------------------------------"</span>);</span><br><span class="line">System.out.println(buff.toString());</span><br><span class="line">SysClipboardUtil.setSysClipboardText(buff.toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getRowsCols()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span>[] rowsCols = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.print(<span class="string">"行数:"</span>);</span><br><span class="line">rowsCols[<span class="number">0</span>] = scanner.nextInt();</span><br><span class="line">System.out.print(<span class="string">"列数:"</span>);</span><br><span class="line">rowsCols[<span class="number">1</span>] = scanner.nextInt();</span><br><span class="line">scanner.close();</span><br><span class="line"><span class="keyword">return</span> rowsCols;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">leftTable</span><span class="params">(<span class="keyword">int</span>[] rowsCols, StringBuilder buff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成表格首部</span></span><br><span class="line">createTableHead(rowsCols, buff);</span><br><span class="line"><span class="comment">// 生成左对齐格式</span></span><br><span class="line">crateTableLeftAlign(rowsCols, buff);</span><br><span class="line"><span class="comment">// 生成表格体</span></span><br><span class="line">createTableBody(rowsCols, buff);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rightTable</span><span class="params">(<span class="keyword">int</span>[] rowsCols, StringBuilder buff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 生成表格头</span></span><br><span class="line">createTableHead(rowsCols, buff);</span><br><span class="line"><span class="comment">// 生成表格对齐方式</span></span><br><span class="line">crateTableRightAlign(rowsCols, buff);</span><br><span class="line"><span class="comment">// 生成表格体</span></span><br><span class="line">createTableBody(rowsCols, buff);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">centerTable</span><span class="params">(<span class="keyword">int</span>[] rowsCols, StringBuilder buff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">createTableHead(rowsCols, buff);</span><br><span class="line">crateTableCenterAlign(rowsCols, buff);</span><br><span class="line">createTableBody(rowsCols, buff);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">autoTable</span><span class="params">(<span class="keyword">int</span>[] rowsCols, StringBuilder buff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">autoLeftTable(rowsCols, buff);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rowsCols</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> buff</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">autoLeftTable</span><span class="params">(<span class="keyword">int</span>[] rowsCols, StringBuilder buff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">createAutoTableHead(rowsCols, buff);</span><br><span class="line">createAutoTableLeftAlign(rowsCols, buff);</span><br><span class="line">createAutoTableBody(rowsCols, buff);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">autoRightTable</span><span class="params">(<span class="keyword">int</span>[] rowsCols, StringBuilder buff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">createAutoTableHead(rowsCols, buff);</span><br><span class="line">createAutoTableRightAlign(rowsCols, buff);</span><br><span class="line">createAutoTableBody(rowsCols, buff);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">autoCenterTable</span><span class="params">(<span class="keyword">int</span>[] rowsCols, StringBuilder buff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">createAutoTableHead(rowsCols, buff);</span><br><span class="line">createAutoTableCenterAlign(rowsCols, buff);</span><br><span class="line">createAutoTableBody(rowsCols, buff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createAutoTableLeftAlign</span><span class="params">(<span class="keyword">int</span>[] rowsCols,</span></span></span><br><span class="line"><span class="function"><span class="params">StringBuilder buff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 使用默认对齐：左对齐，列数多了一列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowsCols[<span class="number">1</span>] + <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">buff.append(<span class="string">"|:--"</span>);</span><br><span class="line">&#125;</span><br><span class="line">buff.append(<span class="string">"|\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createAutoTableRightAlign</span><span class="params">(<span class="keyword">int</span>[] rowsCols,</span></span></span><br><span class="line"><span class="function"><span class="params">StringBuilder buff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 使用默认对齐：左对齐，列数多了一列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowsCols[<span class="number">1</span>] + <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">buff.append(<span class="string">"|--:"</span>);</span><br><span class="line">&#125;</span><br><span class="line">buff.append(<span class="string">"|\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createAutoTableCenterAlign</span><span class="params">(<span class="keyword">int</span>[] rowsCols,</span></span></span><br><span class="line"><span class="function"><span class="params">StringBuilder buff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 使用默认对齐：左对齐，列数多了一列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowsCols[<span class="number">1</span>] + <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">buff.append(<span class="string">"|:--:"</span>);</span><br><span class="line">&#125;</span><br><span class="line">buff.append(<span class="string">"|\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rowsCols</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> buff</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createTableHead</span><span class="params">(<span class="keyword">int</span>[] rowsCols, StringBuilder buff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 生成表格名---&gt;这个所有的代码都不变</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowsCols[<span class="number">1</span>]; i++)</span><br><span class="line">&#123;</span><br><span class="line">buff.append(<span class="string">"|列名"</span>);</span><br><span class="line">&#125;</span><br><span class="line">buff.append(<span class="string">"|\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rowsCols</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> buff</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createAutoTableHead</span><span class="params">(<span class="keyword">int</span>[] rowsCols, StringBuilder buff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 列数多了一列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowsCols[<span class="number">1</span>] + <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">buff.append(<span class="string">"|序号"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">buff.append(<span class="string">"|列名"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">buff.append(<span class="string">"|\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rowsCols</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> buff</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">crateTableLeftAlign</span><span class="params">(<span class="keyword">int</span>[] rowsCols, StringBuilder buff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowsCols[<span class="number">1</span>]; i++)</span><br><span class="line">&#123;</span><br><span class="line">buff.append(<span class="string">"|:--"</span>);</span><br><span class="line">&#125;</span><br><span class="line">buff.append(<span class="string">"|\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rowsCols</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">crateTableRightAlign</span><span class="params">(<span class="keyword">int</span>[] rowsCols, StringBuilder buff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowsCols[<span class="number">1</span>]; i++)</span><br><span class="line">&#123;</span><br><span class="line">buff.append(<span class="string">"|--:"</span>);</span><br><span class="line">&#125;</span><br><span class="line">buff.append(<span class="string">"|\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rowsCols</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">crateTableCenterAlign</span><span class="params">(<span class="keyword">int</span>[] rowsCols, StringBuilder buff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowsCols[<span class="number">1</span>]; i++)</span><br><span class="line">&#123;</span><br><span class="line">buff.append(<span class="string">"|:--:"</span>);</span><br><span class="line">&#125;</span><br><span class="line">buff.append(<span class="string">"|\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rowsCols</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> buff</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createTableBody</span><span class="params">(<span class="keyword">int</span>[] rowsCols, StringBuilder buff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 生成表格体---&gt;这个所有的代码都不变</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowsCols[<span class="number">0</span>]; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; rowsCols[<span class="number">1</span>]; j++)</span><br><span class="line">&#123;</span><br><span class="line">buff.append(<span class="string">"|"</span>);</span><br><span class="line">&#125;</span><br><span class="line">buff.append(<span class="string">"|\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rowsCols</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> buff</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createAutoTableBody</span><span class="params">(<span class="keyword">int</span>[] rowsCols, StringBuilder buff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 生成表格体，行数不变</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowsCols[<span class="number">0</span>]; i++)</span><br><span class="line">&#123;</span><br><span class="line">buff.append(<span class="string">"|"</span> + (i + <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; rowsCols[<span class="number">1</span>]; j++)</span><br><span class="line">&#123;</span><br><span class="line">buff.append(<span class="string">"|"</span>);</span><br><span class="line">&#125;</span><br><span class="line">buff.append(<span class="string">"|\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/fb891bcd/">自动生成Markdown表格(MDTable)</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 我的软件 </category>
          
          <category> Markdown工具 </category>
          
          <category> 表格工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>正则表达式最短匹配</title>
      <link href="/blog/36444501/"/>
      <url>/blog/36444501/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>这里来介绍正则表达式的最短匹配，也叫非贪婪匹配。<br><a id="more"></a></p><h2 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h2><p>当正则表达式中包含能接受重复的限定符时，通常的行为是（<strong>在使整个表达式能得到匹配的前提下）匹配尽可能多的字符</strong>。考虑这个表达式：<code>a.*b</code>，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索<code>aabab</code>的话，它会匹配整个字符串<code>aabab</code>。<strong>这被称为贪婪匹配</strong>。<br>有时，我们更需要<strong>懒惰匹配</strong>，也就是<strong>匹配尽可能少的字符</strong>。前面给出的限定符都可以被转化为懒惰匹配模式，只要在<code>*</code>后面加上一个问号<code>?</code>,形成<code>*？</code>。这样<code>a.*?b</code>就意味着匹配任意数量的字符，但是在<strong>保证整个匹配成功的前提下，匹配最少的任意字符</strong>。现在看看懒惰版的例子吧：</p><p><code>a.*?b</code>匹配最短的，<strong>以a开始，以b结束的字符串</strong>。如果把它应用于<code>aabab</code>的话，它会匹配<code>aab</code>（第一到第三个字符）和<code>ab</code>（第四到第五个字符）。</p><h3 id="懒惰匹配量词表"><a href="#懒惰匹配量词表" class="headerlink" title="懒惰匹配量词表"></a>懒惰匹配量词表</h3><table><thead><tr><th style="text-align:left">量词</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">*?</td><td style="text-align:left">重复任意次，但尽可能少重复</td></tr><tr><td style="text-align:left">+?</td><td style="text-align:left">重复1次或更多次，但尽可能少重复</td></tr><tr><td style="text-align:left">??</td><td style="text-align:left">重复0次或1次，但尽可能少重复</td></tr><tr><td style="text-align:left">{n,m}?</td><td style="text-align:left">重复n到m次，但尽可能少重复</td></tr><tr><td style="text-align:left">{n,}?</td><td style="text-align:left">重复n次以上，但尽可能少重复</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/liliflashfly/article/details/5331685" target="_blank" rel="noopener">https://blog.csdn.net/liliflashfly/article/details/5331685</a></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/&#39;36444501&#39;/">正则表达式最短匹配</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 正则表达式 </category>
          
          <category> 语法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>正则应用：把Markdown中的加粗文本改为标题文本</title>
      <link href="/blog/1d153e30/"/>
      <url>/blog/1d153e30/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天在修订前面的文章的时候，我之前好多标题都是用加粗来显示的，这样阅读起来是没什么问题。但是不利于博客系统根据标题自动生成边栏书签。所以我需要把之前用加粗标记的标题，改用标题标记。</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>对于文章(markdown)中使用加粗表示的标题：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">**2、尽量重用对象**</span><br><span class="line">**特别是String对象的使用，出现大量字符串连接时应该使用StringBuilder/StringBuffer代替**。由于Java虚拟机不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理，因此，生成过多的对象将会给程序的性能带来很大的影响。</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p></p><p>改为使用三级标题：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">###2、尽量重用对象###</span><br><span class="line">**特别是String对象的使用，出现大量字符串连接时应该使用StringBuilder/StringBuffer代替**。由于Java虚拟机不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理，因此，生成过多的对象将会给程序的性能带来很大的影响。</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p></p><a id="more"></a><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>用notepad++打开该文章，按下ctrl+h打开替换，在查找模式选择框，选择正则表达式，然后输入查找正则表达式：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[*]&#123;2&#125;(\d+.+?)[*]&#123;2&#125;</span><br></pre></td></tr></table></figure><p></p><p>输入替换正则表达式：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">###\1###</span><br></pre></td></tr></table></figure><p></p><p>如图所示：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/java/my_regex_example/ctrl_b3ctrl_3.png" alt=""></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/1d153e30/">正则应用：把Markdown中的加粗文本改为标题文本</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 正则表达式 </category>
          
          <category> 实例 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用java上传图片到腾讯云对象存储并返回链接</title>
      <link href="/blog/5a1e201b/"/>
      <url>/blog/5a1e201b/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>不需要签名的公共链接：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](http://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/%E6%B5%8B%E8%AF%95COS%E7%9A%84Java%20SDK/blue.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDQikX6SPUAcqqcAxaT8ZmjPpyrUqwuKei%26q-sign-time%3D1540294349%3B1540294649%26q-key-time%3D1540294349%3B1540294649%26q-header-list%3Dhost%26q-url-param-list%3D%26q-signature%3D1e368fb926c8858b9ed65b923a9030bb54234129)</span><br></pre></td></tr></table></figure><p></p><p>显示效果：<br><img src="http://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/%E6%B5%8B%E8%AF%95COS%E7%9A%84Java%20SDK/blue.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDQikX6SPUAcqqcAxaT8ZmjPpyrUqwuKei%26q-sign-time%3D1540294349%3B1540294649%26q-key-time%3D1540294349%3B1540294649%26q-header-list%3Dhost%26q-url-param-list%3D%26q-signature%3D1e368fb926c8858b9ed65b923a9030bb54234129" alt=""><br>去掉签名的链接：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](http://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/%E6%B5%8B%E8%AF%95COS%E7%9A%84Java%20SDK/blue.jpg</span><br></pre></td></tr></table></figure><p></p><p>显示效果：<br><img src="http://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/%E6%B5%8B%E8%AF%95COS%E7%9A%84Java%20SDK/blue.jpg" alt=""><br>https的图片链接：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/%E6%B5%8B%E8%AF%95COS%E7%9A%84Java%20SDK/blue.jpg)</span><br></pre></td></tr></table></figure><p></p><p>显示效果：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/%E6%B5%8B%E8%AF%95COS%E7%9A%84Java%20SDK/blue.jpg" alt=""><br>使用https的其他图片<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/%E6%B5%8B%E8%AF%95COS%E7%9A%84Java%20SDK/blue.jpg" alt=""></p><p>最后的显示效果：<br><img src="http://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/%E6%B5%8B%E8%AF%95COS%E7%9A%84Java%20SDK/blue.jpg" alt=""></p><p>软件上传效果：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/%E6%B5%8B%E8%AF%95COS%E7%9A%84Java%20SDK/%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E4%B8%8A%E4%BC%A0/%E6%88%91%E5%B0%86%E4%BC%9A%E4%B8%8A%E4%BC%A0%E5%88%B0%E8%85%BE%E8%AE%AF%E4%BA%91.png" alt=""></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/5a1e201b/">使用java上传图片到腾讯云对象存储并返回链接</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 我的软件 </category>
          
          <category> 腾讯云对象存储COS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>把可执行jar打包成exe文件</title>
      <link href="/blog/d7d49994/"/>
      <url>/blog/d7d49994/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><ul><li>eclipse中导出可执行jar</li><li>exe4j下载安装破解</li><li>使用exe4j把可执行jar打包为exe</li></ul><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上次的程序我通过使用,我通过<code>javaw -jar xxx.jar</code>来启动一个程序，在任务管理器中显示如下：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/MyApplications/SwingBaiduOCR/runablejar2exe/javaw_process.png" alt=""><br>如果有一个javaw进行还好，但是我写的java工具程序可能比较多。进程名都是javaw的话不好分辨。<strong>在Windows下可以把可执行jar包打包成exe文件，这样就有自己的进程名，图标。便于我在任务管理器中管理</strong>(不需要时杀掉该进程)。</p><h2 id="使用eclipse把java项目打包为可执行jar包"><a href="#使用eclipse把java项目打包为可执行jar包" class="headerlink" title="使用eclipse把java项目打包为可执行jar包"></a>使用eclipse把java项目打包为可执行jar包</h2><p>在项目上右键选择<code>Export</code>:<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/MyApplications/SwingBaiduOCR/runablejar2exe/eclipse_export.png" alt=""><br>然后展开Java项，选择<code>Runable JAR File</code>:<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/MyApplications/SwingBaiduOCR/runablejar2exe/eclipse_export_runableJarFile.png" alt=""><br>然后选择主类，jar包的输出位置，依赖包的打包方式。最后点击Finish即可。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/MyApplications/SwingBaiduOCR/runablejar2exe/runableJarFileExport.png" alt=""></p><h2 id="下载安装破解exe4j"><a href="#下载安装破解exe4j" class="headerlink" title="下载安装破解exe4j"></a>下载安装破解exe4j</h2><h3 id="下载exe4j"><a href="#下载exe4j" class="headerlink" title="下载exe4j"></a>下载exe4j</h3><p>破解版下载路径:<a href="https://www.jb51.net/softs/541579.html" target="_blank" rel="noopener">https://www.jb51.net/softs/541579.html</a></p><h3 id="解压压缩包"><a href="#解压压缩包" class="headerlink" title="解压压缩包"></a>解压压缩包</h3><p>下载后，解压压缩包：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/MyApplications/SwingBaiduOCR/runablejar2exe/exe_install.png" alt=""></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>点击安装程序<code>exe4j_windows-x64_5_0_1.exe</code>进行安装。</p><h3 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h3><p>安装成功后启动<code>exe4j</code>,点击<code>Change License</code>按钮，然后运行压缩包中的<code>Keymaker.exe</code>生成秘钥。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/MyApplications/SwingBaiduOCR/runablejar2exe/exe4j_welcome.png" alt=""><br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/MyApplications/SwingBaiduOCR/runablejar2exe/exe4j_keymaker.png" alt=""><br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/MyApplications/SwingBaiduOCR/runablejar2exe/exe4j_License.png" alt=""><br>粘贴秘钥到exe4j，点击OK即可。</p><h2 id="打包jar为exe"><a href="#打包jar为exe" class="headerlink" title="打包jar为exe"></a>打包jar为exe</h2><h3 id="Project-type"><a href="#Project-type" class="headerlink" title="Project type"></a>Project type</h3><p>选择<code>JAR in EXE mode</code>,然后点击<code>next</code>.<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/MyApplications/SwingBaiduOCR/runablejar2exe/exe4j_JaxInExe.png" alt=""></p><h3 id="Application-info"><a href="#Application-info" class="headerlink" title="Application info"></a>Application info</h3><p>然后输入exe文件的简称，exe文件输出位置。然后<code>next</code><br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/MyApplications/SwingBaiduOCR/runablejar2exe/exe4j_Applicationinfo.png" alt=""></p><h3 id="Executable-info"><a href="#Executable-info" class="headerlink" title="Executable info"></a>Executable info</h3><p><code>Executable type:</code>中选择第一项<code>GUI application</code>,表示GUI程序，第二个选项表示控制台程序。<br><code>Executable name:</code>中输入软件的名称(<code>OCR</code>)<br><code>Icon file:</code>中选择图标的位置,图标需要实现下载好，图标不是必须的，没有也没关系。<br><strong>然后展开<code>Advanced options</code>选择第一项<code>Redirection</code></strong><br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/MyApplications/SwingBaiduOCR/runablejar2exe/exe4j_Executableinfo.png" alt=""></p><h4 id="Redirection"><a href="#Redirection" class="headerlink" title="Redirection"></a>Redirection</h4><p>然后勾选<code>Redirect stderr</code>,显示错误输出目录，然后点<code>next</code>,Service options 和Version info默认即可，所以点击<code>next</code>,<code>next</code>即可。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/MyApplications/SwingBaiduOCR/runablejar2exe/exej_Executableinfo_Redirection.png" alt=""></p><h4 id="32-bit-or-64-bit"><a href="#32-bit-or-64-bit" class="headerlink" title="32-bit or 64-bit"></a>32-bit or 64-bit</h4><p>然后选择<code>Generate 64-bit executable</code>,生成64位的exe程序。然后<code>next</code>,<code>next</code><br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/MyApplications/SwingBaiduOCR/runablejar2exe/exe4j_Executable%20info_64bit.png" alt=""></p><h3 id="Java-invocation"><a href="#Java-invocation" class="headerlink" title="Java invocation"></a>Java invocation</h3><p>到了第5个配置项<code>Java invocation</code>这里要把刚才生成的可执行jar包添加进来。以及<code>所有的依赖包</code>，点击绿色的加号，添加可执行Jar包<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/MyApplications/SwingBaiduOCR/runablejar2exe/exe4j_Java_Invocation_add_jar.png" alt=""></p><p><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/MyApplications/SwingBaiduOCR/runablejar2exe/exe4j_Java_Invocation_add_jar_archive.png" alt=""><br><strong>导入所有的依赖包</strong><br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/MyApplications/SwingBaiduOCR/runablejar2exe/exe4j_Java_Invocation_add_alljar.png" alt=""></p><p>然后在<code>Main class:</code>选择主类:<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/MyApplications/SwingBaiduOCR/runablejar2exe/exe4j_Java_Invocation_add_jar_mainclass.png" alt=""></p><h3 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h3><p>选择最小支持的版本，最大的版本可以默认不写。然后展开<code>Advanced options</code>,选择<code>Search sequence</code>。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/MyApplications/SwingBaiduOCR/runablejar2exe/exe4j_JRE_Serch%20sequency.png" alt=""><br>点击绿色的加号<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/MyApplications/SwingBaiduOCR/runablejar2exe/exe4j_JRE_Serchsequency_add.png" alt=""><br>然后，选择找到本地的jre：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/MyApplications/SwingBaiduOCR/runablejar2exe/exe4j_JRE_Serchsequency_add_jre.png" alt=""><br>然后把它移动到最顶端：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/MyApplications/SwingBaiduOCR/runablejar2exe/exe4j_JRE_Serchsequency_moveUp.png" alt=""><br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/MyApplications/SwingBaiduOCR/runablejar2exe/exe4j_JRE_Serchsequency_moveUp_yes.png" alt=""><br>然后<code>next</code>,</p><p>然后默认，<code>next</code>：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/MyApplications/SwingBaiduOCR/runablejar2exe/exej_JRE_Preferred%20VM.png" alt=""><br>后面一直next即可。</p><h2 id="运行生成的exe"><a href="#运行生成的exe" class="headerlink" title="运行生成的exe"></a>运行生成的exe</h2><p>打开输出目录双击运行exe文件即可运行<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/MyApplications/SwingBaiduOCR/runablejar2exe/run_exe.png" alt=""></p><p>参考：<a href="https://blog.csdn.net/qq_29232943/article/details/52861800" target="_blank" rel="noopener">https://blog.csdn.net/qq_29232943/article/details/52861800</a></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/d7d49994/">把可执行jar打包成exe文件</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 我的软件 </category>
          
          <category> 截图文字识别 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>如何修改java程序的进程名</title>
      <link href="/blog/217f0f86/"/>
      <url>/blog/217f0f86/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>我通过javaw -jar xxx.jar来启动一个程序,这个程序在任务管理器里面叫javaw,而我要运行多个程序,名字都叫javaw,我不能分辨名字,请问有什么办法改一下默认的名字吗?谢谢了<br>解决方案：</p><ul><li>把javaw.exe重名名为xxx.exe</li><li>将jar包打成exe,直接改名即可实现楼主要的效果。</li></ul><a id="more"></a><p>我的实现过程：<a href="/2018/10/10/MyApplications/截图文字识别/把可执行jar打包成exe文件/">把可执行jar打包成exe文件</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>相关论坛:<br><a href="https://bbs.csdn.net/topics/320018756" target="_blank" rel="noopener">https://bbs.csdn.net/topics/320018756</a><br><a href="https://bbs.csdn.net/topics/370063237" target="_blank" rel="noopener">https://bbs.csdn.net/topics/370063237</a><br><a href="https://bbs.csdn.net/topics/90400835" target="_blank" rel="noopener">https://bbs.csdn.net/topics/90400835</a></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/217f0f86/">如何修改java程序的进程名</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 我的软件 </category>
          
          <category> 截图文字识别 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Maven实战 许晓斌著 第3章 eclipse中Maven中的使用</title>
      <link href="/blog/a27ed7d9/"/>
      <url>/blog/a27ed7d9/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><ul><li>导入 Maven项目</li><li>创建 Maven项目</li><li>运行mvn命令</li></ul><a id="more"></a><h2 id="导入-Maven项目"><a href="#导入-Maven项目" class="headerlink" title="导入 Maven项目"></a>导入 Maven项目</h2><p>选择菜单项File,然后选择 Import,我们会看到一个 Import对话框。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/maven/3/eclipse_import.png" alt=""><br>在该对话框中选择 General目录下的 Maven Projects,然后单击Next按钮,<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/maven/3/eclipse_import_exist_maven.png" alt=""><br>就会出现 Import Projects对话框。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/maven/3/eclipse_import_exist_maven_Project.png" alt=""><br>在该对话框中单击 Browse按钮选择 Hello world的根目录(即包含pom.xml文件的那个目录),<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/maven/3/mavenProject.png" alt=""><br>这时对话框中的 Projects:部分就会显示该目录包含的 Maven项目。如下图：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/maven/3/select_pom.png" alt=""><br>单击 Finish按钮之后，eclipse中就会将该项目导入到当前的 workspace中,导入完成之后，就可以在 Package Explorer视图中看到如下图所示的项目结构。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/maven/3/maven_package_explorer.png" alt=""><br>我们看到<strong>主代码目录<code>src/main/java</code>和测试代码目录<code>src/test/java</code></strong>成了 Eclipse中的资源目录,包和类的结构也十分清晰。当然 <strong>pom.xml永远在项目的根目录下</strong>,而从这个视图中甚至还能看到项目的依赖<code>junit-3.8.1.jar</code>,其实际的位置指向了 Maven本地仓库(<code>~/.m2/repository</code>)。后续章节会介绍如何自定义本地仓库位置)。</p><h2 id="创建-Maven项目"><a href="#创建-Maven项目" class="headerlink" title="创建 Maven项目"></a>创建 Maven项目</h2><p>创建一个 Maven项目也十分简单,选择菜单项<code>File→New→ Other</code>,<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/maven/3/eclipse_new_other.png" alt=""><br>在弹出的对话框中选择 Maven下的 Maven Project,<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/maven/3/eclipse_new_other_maven_project.png" alt=""><br>然后单击Next按钮,在弹出的 New Maven Project对话框中,<strong>使用默认的选项</strong>(不要选择 Create a simple project选项,那样我们就能使用 Maven Archetype),<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/maven/3/New_MavenProject.png" alt=""><br>单击Next按钮,此时eclipse会提示我们选择一个 Archetype。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/maven/3/quickkstart.png" alt=""><br>这里选择 <code>maven-archetype-quickstart</code>,再单击Next按钮。由于 eclipse实际上是在使用 maven-archetype-plugin插件创建项目,因此这个步骤与上一节使用 archetype建项目骨架类似,输人 grouped、artifactId、 version、 package(暂时不考虑 Properties),如下图所示：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/maven/3/eclipse_groupId.png" alt=""><br>单击 Finish按钮, Maven项目就创建完成了。</p><h2 id="运行mvn命令"><a href="#运行mvn命令" class="headerlink" title="运行mvn命令"></a>运行mvn命令</h2><p>我们需要在命令行输入如 <code>mvn clean install</code>之类的命令来执行 maven构建,eclipse中也有对应的功能。<strong>在 Maven项目或者 pom.xml上右击,再在弹出的快捷菜单中选择 Run as,就能看到常见的 Maven命令</strong>,如下图所示：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/maven/3/eclipse_maven_command.png" alt=""></p><p>选择想要执行的 Maven命令就能执行相应的构建,同时也能在 Eclipse的 console中看到构建输出。这里常见的一个问题是,默认选项中没有我们想要执行的 Maven命令怎么办?比如,默认带有 mvn test,但我们想执行 myn clean test,很简单,选择 Maven build以自定义Maven运行命令,在弹出对话框的<strong>Goals</strong>一项中输入我们想要执行的命令,如 <code>clean test</code>,设置一下Name,单击Run即可。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/maven/3/eclipse_maven_build_command.png" alt=""><br>并且,下一次我们选择 Maven build时，上次的配置直接就能在历史记录中找到。具体的做法是：<strong>在Maven build上按按右键即可展开命令列表</strong>。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/maven/3/eclipse_maven_build_command_list.png" alt=""><br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/maven/3/eclipse_maven_build_command_list_list.png" alt=""></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/a27ed7d9/">Maven实战 许晓斌著 第3章 eclipse中Maven中的使用</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Maven实战 许晓斌著 </category>
          
          <category> 第3章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Maven实战 许晓斌著 第3章 Maven使用入门</title>
      <link href="/blog/f65e41ed/"/>
      <url>/blog/f65e41ed/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><ul><li><a href="/2018/10/09/读书笔记/Maven实战 许晓斌著/第3章/Maven实战 许晓斌著 第3章 Maven使用入门/#编写POM">编写POM</a></li><li><a href="/2018/10/09/读书笔记/Maven实战 许晓斌著/第3章/Maven实战 许晓斌著 第3章 Maven使用入门/#编写主代码">编写主代码</a></li><li><a href="/2018/10/09/读书笔记/Maven实战 许晓斌著/第3章/Maven实战 许晓斌著 第3章 Maven使用入门/#编写测试代码">编写测试代码</a></li><li><a href="/2018/10/09/读书笔记/Maven实战 许晓斌著/第3章/Maven实战 许晓斌著 第3章 Maven使用入门/#打包和运行">打包和运行</a><ul><li><a href="/2018/10/09/读书笔记/Maven实战 许晓斌著/第3章/Maven实战 许晓斌著 第3章 Maven使用入门/#打包">打包</a></li><li><a href="/2018/10/09/读书笔记/Maven实战 许晓斌著/第3章/Maven实战 许晓斌著 第3章 Maven使用入门/#在其他项目中使用该jar中的类">在其他项目中使用该jar中的类</a></li><li><a href="/2018/10/09/读书笔记/Maven实战 许晓斌著/第3章/Maven实战 许晓斌著 第3章 Maven使用入门/#打包为可执行jar">打包为可执行jar</a></li></ul></li><li><a href="/2018/10/09/读书笔记/Maven实战 许晓斌著/第3章/Maven实战 许晓斌著 第3章 Maven使用入门/#使用-Archetype生成项目骨架">使用 Archetype生成项目骨架</a></li><li><a href="/2018/10/09/读书笔记/Maven实战 许晓斌著/第3章/Maven实战 许晓斌著 第3章 Maven使用入门/#eclipse中maven的使用">eclipse中Maven插件的简单使用</a></li><li><a href="/2018/10/09/读书笔记/Maven实战 许晓斌著/第3章/Maven实战 许晓斌著 第3章 Maven使用入门/#小结">小结</a></li></ul><a id="more"></a><p>到目前为止,已经大概了解并安装好了 Maven,现在,我们开始<strong>创建一个最简单的Hello World项目</strong>。如果你是初次接触 Maven,建议按照本文的内容一步步地编写代码并执行,其中可能你会碰到一些概念暂时难以理解,不用着急,记下这些疑难点,相信后续的文章会帮你逐一解答。</p><h2 id="编写POM"><a href="#编写POM" class="headerlink" title="编写POM"></a>编写POM</h2><p>就像Make的 Makefile、Ant的 build.xml一样, <strong>Maven项目的核心是 pom.xml</strong>。<strong>POM(<code>Project Object Model,项目对象模型</code>)定义了项目的基本信息,用于描述项目如何构建,声明项目依赖</strong>,等等。现在先为 Hello World项目编写一个最简单的 pom. xml<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lan<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>helloworld<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Hello World Project<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>代码的第一行<code>&lt;?xml version=&quot;1.0&quot;?&gt;</code>是XML头,指定了该xml文档的版本和编码方式。紧接着是 project元素, <strong>project是所有 pom.xml的根元素,它还声明了一些POM相关的命名空间及xsd元素</strong>,虽然这些属性不是必须的,但使用这些属性能够让第三方工具(如IDE中的XML编辑器)帮助我们快速编辑POM。<br>根元素下的第一个子<strong>元素 modelVersion指定了当前POM模型的版本</strong>,对于 Maven2及Maven3来说,它只能是<code>4.0.0</code>。<br><strong>groupId定义了项目属于哪个组</strong>,<strong>这个组往往和项目所在的组织或公司存在关联</strong>，<strong>一般命名方式为你个<code>组织名反写+项目名</code></strong>。譬如在google.code.com上建立了一个名为myapp的项目,那么 groupId就应该是com.google.code.mapp,如果你的公司是 my.com,有一个项目为 myapp,那么 groupId就应该是 com.my.com.myapp。<br><strong>artifactId定义了当前 Maven项目在组中唯一的Id</strong>,我们为这个 HelloWorld项目定义artifectId为<code>hello-world</code>你可能会为不同的子项目(模块)分配不同的artifectId，如my-app-util,myapp-domain,myapp-web等。<br><strong>version指定了 Hello World项目当前的版本—0.0.1-SNAPSHOT</strong>。 <strong>SNAPSHOT</strong>意为快照,<strong>说明该项目还处于开发中,是不稳定的版本</strong>。随着项目的发展, version会不断更新,如升级为1.0.0、1.1- SNAPSHOT、1.1、2.0等。6.5节会详细介绍 SNAPSHOT,第13章会介绍如何使用 Maven管理项目版本的升级发布。<br>最后一个<code>name</code>元素声明了一个对于用户更为友好的<strong>项目名称</strong>,虽然这不是必须的,但还是推荐为每个POM声明name,以方便信息交流。<br>没有任何实际的Java代码,我们就能够定义一个 Maven项目的POM,这体现了<strong> Maven的一大优点,它能让项目对象模型最大程度地与实际代码相独立,我们可以称之为</strong>解耦<strong>,或者正交性</strong>。这在很大程度上避免了Java代码和POM代码的相互影响。比如当项目需要升级版本时,只需要修改POM,而不需要更改Java代码;而在POM稳定之后,日常的Java代码开发工作基本不涉及POM的修改。</p><h2 id="编写主代码"><a href="#编写主代码" class="headerlink" title="编写主代码"></a>编写主代码</h2><p>项目主代码和测试代码不同<strong>,项目的主代码会被打包到最终的构件中(如jar),而测试代码只在运行测试时用到,不会被打包</strong>。默认情况下, <strong>Maven假设项目主代码位于<code>src/main/java</code>目录</strong>,我们遵循 Maven的约定,在项目目录HelloWorld下创建该<code>src/main/java</code>目录,然后在该目录下创建包目录<code>com/lan/helloworld/</code>，在包目录<code>com/lan/helloworld/</code>下创建文件<code>HelloWorld.java</code>,主代码内容如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lan.helloworld;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">System.out.println(<span class="keyword">new</span> HelloWorld().sayHello());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这是一个简单的Java类,它有一个 sayHello()方法,返回一个String。同时这个类还带有一个main方法,创建一个 HelloWorld实例,调用它的sayHello()方法,并将结果输出到控制台。<br>关于该Java代码有两点需要注意。首先,在绝大多数情况下,<strong>应该把项目主代码放到src/main/java/目录下</strong>(遵循 Maven的约定),而无须额外的配置, Maven会自动搜寻该目录找到项目主代码。其次,该Java类的包名是<code>helloworld</code>,这与之前在POM中定义的 <code>&lt;groupId&gt;com.lan&lt;/groupId&gt;</code>和<code>&lt;artifactId&gt;helloworld&lt;/artifactId&gt;</code>相吻合。<br><strong>一般来说,项目中Java类的包都应该基于项目的groupId和 artifactId.这样更加清晰,更加符合逻辑,也方便搜索构件或者Java类。</strong><br>代码编写完毕后,使用Maven进行编译,打开cmd,在项目根目录下运行命令 <code>mvn clean compile</code>会得到如下输出:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">D:\学习9\Mave实战\MavenProject\HelloWorld&gt;mvn clean compile</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] -------------------------&lt; hello:hello-model &gt;--------------------------</span><br><span class="line">[INFO] Building hello-model 0.0.1-SNAPSHOT</span><br><span class="line">[INFO] --------------------------------[ jar ]---------------------------------</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ hello-model ---</span><br><span class="line">[INFO] Deleting D:\学习9\Mave实战\MavenProject\HelloWorld\target</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ hello-model ---</span><br><span class="line">[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent!</span><br><span class="line">[INFO] skip non existing resourceDirectory D:\学习9\Mave实战\MavenProject\HelloWorld\src\main\resources</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ hello-model ---</span><br><span class="line">[INFO] Changes detected - recompiling the module!</span><br><span class="line">[WARNING] File encoding has not been set, using platform encoding GBK, i.e. build is platform dependent!</span><br><span class="line">[INFO] Compiling 1 source file to D:\学习9\Mave实战\MavenProject\HelloWorld\target\classes</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time: 1.638 s</span><br><span class="line">[INFO] Finished at: 2018-10-09T22:21:19+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p></p><p><strong>clean告诉 Maven清理(删除)掉输出目录 target/</strong>, <strong>compile告诉 Maven编译项目<code>主代码</code></strong>,从输出中看到 Maven首先执行了<code>maven-clean-plugin:2.5:clean</code>任务,删除 target/目录。<strong>默认情况下, Maven构建的所有输出都在 target/目录中</strong>;接着执行 <code>maven-resources-plugin:2.6:resources</code>任务(未定义项目资源,暂且略过);最后执行 <code>maven-compiler-plugin:3.1:compile</code>任务,将<strong>项目主代码编译至 target/classes目录</strong>(编译好的类为<code>com\lan\helloworld\HelloWorld.class</code>)。<br>上文提到的 <code>maven-clean-plugin:2.5:clean</code>、 <code>maven-resources-plugin:2.6:resources</code>和 <code>maven-compiler-plugin:3.1:compile</code>对应了一些 Maven插及插件目标,比如 <code>maven-clean-plugin:2.5:clean</code>是<code>maven-clean-plugin:2.5</code>插件的 <code>clean</code>目标,<code>maven-compiler-plugin:3.1:compile</code>是<code>maven-compiler-plugin:3.1</code>插件的 <code>compile</code>目标。后文会详细讲述 Maven插件及其编写方法。<br>至此, Maven在没有任何额外的配置的情况下就执行了项目的清理和编译任务。接下来,编写一些单元测试代码并让 Maven执行自动化测试。</p><h2 id="编写测试代码"><a href="#编写测试代码" class="headerlink" title="编写测试代码"></a>编写测试代码</h2><p>为了使项目结构保持清晰,主代码与测试代码应该分别位于独立的目录中。<strong>Maven项目中默认的主代码目录是<code>src/main/java</code>,对应地, Maven项目中默认的测试代码目录是<code>src/test/java</code></strong>。因此,<strong>在编写测试用例之前,应当先创建该<code>src/test/java</code>目录</strong>。<br><strong>在Java世界中,JUnit是事实上的单元测试标准</strong>。要<strong>使用 JUnit,首先需要为Hello world项目添加一个 JUnit依赖</strong>,修改项目根目录下的POM.xml,如下所示:<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lan<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>helloworld<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Maven Hello World Project<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifectId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifectId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>代码中添加了<code>dependencies</code>元素,该元素下可以包含多个<code>dependency</code>元素以声明项目的依赖。这里添加了一个依赖:</p><ul><li>groupId是 junit,</li><li>artifactId是 junit,</li><li>version是4.7。</li></ul><p><strong>前面提到<code>groupId,artifactId和 version</code>是任何一个<code>Maven项目最基本的坐标</code></strong>, JUnit也不例外,<strong>有了这段声明, Maven就能够自动下载 Junit-4.7.jar</strong>。也许你会问, Maven从哪里下载这个jar呢?<br>在 Maven之前,我们可以去JUnit的官方网站下载分发包,使用Maven,它会自动访间中央仓库(<a href="http://repol.maven.org/maven2/" target="_blank" rel="noopener">http://repol.maven.org/maven2/</a>),下载需要的文件。读者<strong>也可以自己访问该仓库,打开路径junit/juni4.7/,就能看到junit-4.7.pom和junit-4.7.jar</strong>。第6章会详细介绍 Maven仓库及中央仓库。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/maven/3/web_repo_junit.png" alt=""><br>上述POM代码中还有一个值为test的<code>scope元素</code>, <strong>scope为依赖范围,若依赖范围为test则表示该依赖只对测试有效</strong>。换句话说,<strong>测试代码中的 import JUnit代码是没有问题的,是如果在主代码中用 import JUnit代码,就会造成编译错误</strong>。如果不声明依赖范围,那么默认值就是compile,表示该依赖对主代码和测试代码都有效。<br>配置了测试依赖,接着就可以编写测试类。回顾一下前面的 HelloWorld类<strong>,现在要测试该类的sayHello()方法,检查其返回值是否为“Hellomaven”</strong>。在<code>src/test/java</code>目录下,创建包目录<code>com.lan.helloworld</code>(对应：<code>&lt;groupId&gt;com.lan&lt;/groupId&gt;&lt;artifactId&gt;helloworld&lt;/artifactId&gt;</code>)，并在包目录下，创建文件<code>HelloWorldTest.java</code>,其内容如下所示所示:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lan.helloworld;</span><br><span class="line"><span class="keyword">import</span> org.junit.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.Assert.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldTest</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHello</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">            HelloWorld helloworld=<span class="keyword">new</span> HelloWorld();<span class="comment">//准备测试类及数据(这里是创建实例)</span></span><br><span class="line">            String result=helloworld.sayHello();<span class="comment">//执行要测试的行为(这里是运行方法)</span></span><br><span class="line">Assert.assertEquals(<span class="string">"Hello World!"</span>,<span class="keyword">new</span> HelloWorld().sayHello());<span class="comment">//检查结果(这里是对比返回值)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>一个典型的单元测试包含三个步骤</strong>:<br>①准备测试类及数据;<br>②执行要测试的行为<br>③检查结果。<br>上述样例首先初始化了一个要测试的 HelloWorld实例,接着执行该实例的sayHello()方法并保存结果到 result变量中,最后使用 JUnit框架的 Assert类检查结果是否为我们期望的“Hello World!”。在 JUnit3中,约定所有需要执行测试的方法都以test开头,这里使用了JUnit4,但仍然遵循这一约定。<strong>在JUnit4中,需要执行的测试方法都应该以<code>@Test</code>进行标注</strong>。<br>测试用例编写完毕之后就可以在cmd中调用 Maven执行测试。运行<code>mvn clean test</code>:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">D:\学习9\Mave实战\MavenProject\HelloWorld&gt;mvn clean test</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] -------------------------&lt; com.lan:helloworld &gt;-------------------------</span><br><span class="line">[INFO] Building Maven Hello World Project 0.0.1-SNAPSHOT</span><br><span class="line">[INFO] --------------------------------[ jar ]---------------------------------</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ helloworld ---</span><br><span class="line">[INFO] Deleting D:\学习9\Mave实战\MavenProject\HelloWorld\target</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ helloworld ---</span><br><span class="line">[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent!</span><br><span class="line">[INFO] skip non existing resourceDirectory D:\学习9\Mave实战\MavenProject\HelloWorld\src\main\resources</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ helloworld ---</span><br><span class="line">[INFO] Changes detected - recompiling the module!</span><br><span class="line">[WARNING] File encoding has not been set, using platform encoding GBK, i.e. build is platform dependent!</span><br><span class="line">[INFO] Compiling 1 source file to D:\学习9\Mave实战\MavenProject\HelloWorld\target\classes</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ helloworld ---</span><br><span class="line">[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent!</span><br><span class="line">[INFO] skip non existing resourceDirectory D:\学习9\Mave实战\MavenProject\HelloWorld\src\test\resources</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ helloworld ---</span><br><span class="line">[INFO] Changes detected - recompiling the module!</span><br><span class="line">[WARNING] File encoding has not been set, using platform encoding GBK, i.e. build is platform dependent!</span><br><span class="line">[INFO] Compiling 1 source file to D:\学习9\Mave实战\MavenProject\HelloWorld\target\test-classes</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ helloworld ---</span><br><span class="line">[INFO] Surefire report directory: D:\学习9\Mave实战\MavenProject\HelloWorld\target\surefire-reports</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------</span><br><span class="line"> T E S T S</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">Running com.lan.helloworld.HelloWorldTest</span><br><span class="line">Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.047 sec</span><br><span class="line"></span><br><span class="line">Results :</span><br><span class="line"></span><br><span class="line">Tests run: 1, Failures: 0, Errors: 0, Skipped: 0</span><br><span class="line"></span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time: 3.986 s</span><br><span class="line">[INFO] Finished at: 2018-10-09T23:03:44+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p></p><p>从命令输出中可以看到，命令行输入的是<code>mvn clean test</code>,但 Maven实际执行的可不止clean和test这两个任务，任务的执行顺序为：</p><ul><li><code>maven-clean-plugin:2.5:clean</code></li><li><code>maven-resources-plugin:2.6:resources</code></li><li><code>maven-compiler-plugin:3.1:compile</code></li><li><code>maven-resources-plugin:2.6:testResources</code></li><li><code>maven-compiler-plugin:3.1:testCompile</code></li></ul><p>最后才会执行到任务：</p><ul><li><code>maven-surefire-plugin:2.12.4:test</code></li></ul><p>暂时需要了解的是,在<strong> Maven执行测试(test)之前,它会先自动执行<code>项目主资源处理</code>(resources)、<code>主代码编译</code>(compile)、<code>测试资源处理</code>(testResources)、<code>测试代码编译</code>(testCompile)等工作</strong>,这是 Maven生命周期的一个特性。本书后续章节会详细解释 Maven的生命周期。</p><p>还可以看到<code>compiler: tesCompile</code>任务执行成功了,<strong>测试代码通过编译之后在 target/test-classes下生成了二进制文件</strong>。<br>紧接着 <code>surefire:test</code>任务运行测试, <strong>surefire是 Maven中负责执行测试的插件,这里它运行<code>测试用例 HelloWorldTest</code>,并且输出测试报告</strong>,显示一共运行了多少测试,失败了多少,出错了多少,跳过了多少(<code>Tests run: 1, Failures: 0, Errors: 0, Skipped: 0</code>)。显然,我们的测试通过了。</p><h2 id="打包和运行"><a href="#打包和运行" class="headerlink" title="打包和运行"></a>打包和运行</h2><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p><strong>将项目进行编译、测试之后,下一个重要步骤就是打包( package)</strong>。 HelloWorld的POM中没有指定打包类型,使用默认打包类型jar。简单地执行命令 mvn clean package进行打包,可以看到如下输出:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ helloworld ---</span><br><span class="line">......</span><br><span class="line">[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ helloworld ---</span><br><span class="line">......</span><br><span class="line">[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ helloworld ---</span><br><span class="line">......</span><br><span class="line">[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ helloworld ---</span><br><span class="line">......</span><br><span class="line">[INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ helloworld ---</span><br><span class="line">......</span><br><span class="line">[INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ helloworld ---</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ helloworld ---</span><br><span class="line">[INFO] Building jar: D:\ѧϰ9\Maveʵս\MavenProject\HelloWorld\target\helloworld-0.0.1-SNAPSHOT.jar</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time: 2.778 s</span><br><span class="line">[INFO] Finished at: 2018-10-09T23:32:58+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p></p><p>类似地, <strong>Maven会在打包之前执行编译、测试等操作</strong>。这里看到<code>maven-jar-plugin:2.4:jar</code>(<strong>以后简写为<code>jar:jar</code></strong>)<code>任务负责打包</code>,实际上就是jar插件的jar目标将项目主代码打包成一个名为<code>helloworld-0.0.1-SNAPSHOT.jar</code>的文件。该文件也位于 target/输出目录中,<strong>它是根据 artifact-version jar规则进行命名的,如有需要,还可以使用 finalName来自定义该文件的名称</strong>,这里暂且不展开,后面会详细解释。</p><h3 id="在其他项目中使用该jar中的类"><a href="#在其他项目中使用该jar中的类" class="headerlink" title="在其他项目中使用该jar中的类"></a>在其他项目中使用该jar中的类</h3><p>至此,我们得到了项目的输出,如果有需要的话,就<strong>可以复制这个jar文件到其他项目的 Classpath中从而使用 Hello world类</strong>。但是,如何才能<strong>让其他的 Maven项目直接引用我们刚打包的这个jar</strong>呢?还<strong>需要一个安装的步骤</strong>,执行 <code>mvn clean install</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ helloworld ---</span><br><span class="line">......</span><br><span class="line">[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ helloworld ---</span><br><span class="line">......</span><br><span class="line">[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ helloworld ---</span><br><span class="line">......</span><br><span class="line">[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ helloworld ---</span><br><span class="line">......</span><br><span class="line">[INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ helloworld ---</span><br><span class="line">...... </span><br><span class="line">[INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ helloworld ---</span><br><span class="line">......</span><br><span class="line">[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ helloworld ---</span><br><span class="line">......</span><br><span class="line">[INFO] --- maven-install-plugin:2.4:install (default-install) @ helloworld ---</span><br><span class="line">[INFO] Installing D:\学习9\Mave实战\MavenProject\HelloWorld\target\helloworld-0.0.1-SNAPSHOT.jar to C:\Users\lan\.m2\repository\com\lan\helloworld\0.0.1-SNAPSHOT\helloworld-0.0.1-SNAPSHOT.jar</span><br><span class="line">[INFO] Installing D:\学习9\Mave实战\MavenProject\HelloWorld\pom.xml to C:\Users\lan\.m2\repository\com\lan\helloworld\0.0.1-SNAPSHOT\helloworld-0.0.1-SNAPSHOT.pom</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time: 3.465 s</span><br><span class="line">[INFO] Finished at: 2018-10-09T23:39:58+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>同样的先执行编译,测试,打包任务,最后执行安装任务 instal: install.。从输出可以看到该任务将项目输出的jar安装到了Maven的本地仓库(C:\Users\lan.m2\repository)中,可以打开相应的文件夹看到 Helloworld项目的pom和jar。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/maven/3/mvn_install.png" alt=""></p><p>之前讲述 JUnit的POM及jar的下载的时候,我们说<strong>只有构件被下载到本地仓库后,才能由所有 Maven项目使用,这里是同样的道理,只有将HelloWorld的构件安装到本地仓库之后其他 Maven项目才能使用它</strong>。</p><p>我们已经体验了 Maven最主要的命令:<code>mvn clean compile</code>、 <code>mvn clean test</code>、 <code>mvn clean package</code>、 <code>mvn clean install</code>。<strong>在执行test之前是会先执行compile的,执 package之前是会先执行test的,而类似地, 执行install之前会执行 package</strong>。我们可以在任何一个 Maven项目中执行这些命令。</p><h3 id="打包为可执行jar"><a href="#打包为可执行jar" class="headerlink" title="打包为可执行jar"></a>打包为可执行jar</h3><p>到目前为止,还没有运行 Hello world项目,不要忘了 Hello World类可是有一个main方法的。默认打包生成的jar是不能够直接运行的,因为带有main方法的类信息不会添加到manifest中(打开jar文件中的 META-INF/ MANIFEST. MF文件,将无法看到Main- Class行)。为了生成可执行的jar文件,需要借助<code>maven- shade- plugin</code>插件,配置该插件如下:<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 插件坐标 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transformers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transformer</span> <span class="attr">implementation</span>=<span class="string">"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 项目中的类路径:全限定名(包名+类名) --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.lan.helloworld.HelloWorld<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transformer</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">transformers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>plugin元素在POM中的相对位置应该在<code>&lt;project&gt;&lt;build&gt;&lt;plugins&gt;</code>下面。我们配置了mainClass为<code>com.lan.helloworld.HelloWorld</code>,项目在打包时会将该信息放到MANIFEST中。现在执行<code>mvn clean install</code>,待构建完成之后打开 <code>target/</code>目录,可以看到<code>helloworld-0.0.1-SNAPSHOT.jar</code>和<code>original-helloworld-0.0.1-SNAPSHOT.jar</code>两个jar包。前者是带有Main-Class信息的可运行jar包。后者是原始的jar,<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/maven/3/runable_jar.png" alt=""></p><p>打开<code>helloworld-0.0.1-SNAPSHOT.jar</code>的<code>META-INF/MANIFEST.MF</code>:<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/maven/3/runable_jar_META-INF.png" alt=""><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Archiver-Version: Plexus Archiver</span><br><span class="line">Built-By: lan</span><br><span class="line">Created-By: Apache Maven 3.5.4</span><br><span class="line">Build-Jdk: 1.8.0_91</span><br><span class="line">Main-Class: com.lan.helloworld.HelloWorld</span><br></pre></td></tr></table></figure><p></p><p>可以看到它包含这样一行信息:<code>Main-Class: com.lan.helloworld.HelloWorld</code>这行信息指定了可执行jar包的主类。<br>现在,在项目根目录中执行该jar文件,运行结果如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\学习9\Mave实战\MavenProject\HelloWorld\target&gt;helloworld-0.0.1-SNAPSHOT.jar</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><p></p><p>控制台输出为<code>Hello World!</code>,这正是我们所期望的。到这里，本文介绍了HelloWorld项目,侧重点是 Maven而非Java代码本身,介绍了POM,Maven项目结构以及如何编译、测试、打包等。</p><h2 id="使用-Archetype生成项目骨架"><a href="#使用-Archetype生成项目骨架" class="headerlink" title="使用 Archetype生成项目骨架"></a>使用 Archetype生成项目骨架</h2><p>Hello world项目中有一些<strong> Maven的约定:在项目的根目录中放置 pom.xml</strong> ,<strong>在<code>src/main/java</code>目录中放置项目的主代码,在src/test/java中放置项目的测试代码。</strong>之所以一步步地展示这些步骤,是为了能让可能是 Maven初学者的你得到最实际的感受。<strong>我们称这些基本的目录结构和 pom.xml文件内容称为项目的骨架</strong>,当第一次创建项目骨架的时候,你还会饶有兴趣地去体会这些默认约定背后的思想,第二次,第三次,你也许还会满意自己的熟练程度,但第四、第五次做同样的事情,你可能就会恼火了。为此 <strong>Maven提供了Archetype以帮助我们快速勾勒出项目骨架</strong>。</p><p>还是以Hello World为例,我们使用 maven archetype来创建该项目的骨架,离开当前的Maven项目目录。<br>我这里用的是Maven3,简单地运行<code>mvn archetype:generate</code>,然后根据提示输入groupId,artifectId,version,package即可快递创建Maven项目骨架。</p><p>我这里遇到一个问题，输入上述<code>mvn archetype:generate</code>命令后，cmd窗口一直阻塞。</p><p>解决方案：使用下面的命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DarchetypeCatalog=internal</span><br></pre></td></tr></table></figure><p>紧接着会看到一段长长的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">D:\学习9\Mave实战\MavenProject&gt;mvn archetype:generate -DarchetypeCatalog=internal</span><br><span class="line">.........</span><br><span class="line">[INFO] &gt;&gt;&gt; maven-archetype-plugin:3.0.1:generate (default-cli) &gt; generate-sources @ standalone-pom &gt;&gt;&gt;</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] &lt;&lt;&lt; maven-archetype-plugin:3.0.1:generate (default-cli) &lt; generate-sources @ standalone-pom &lt;&lt;&lt;</span><br><span class="line">.........</span><br><span class="line">[INFO] --- maven-archetype-plugin:3.0.1:generate (default-cli) @ standalone-pom ---</span><br><span class="line">[INFO] Generating project in Interactive mode</span><br><span class="line">[INFO] No archetype defined. Using maven-archetype-quickstart (org.apache.maven.archetypes:maven-archetype-quickstart:1.0)</span><br><span class="line">Choose archetype:</span><br><span class="line">1: internal -&gt; org.apache.maven.archetypes:maven-archetype-archetype (An archetype which contains a sample archetype.)</span><br><span class="line">2: internal -&gt; org.apache.maven.archetypes:maven-archetype-j2ee-simple (An archetype which contains a simplifed sample J2EE application.)</span><br><span class="line">3: internal -&gt; org.apache.maven.archetypes:maven-archetype-plugin (An archetype which contains a sample Maven plugin.)</span><br><span class="line">4: internal -&gt; org.apache.maven.archetypes:maven-archetype-plugin-site (An archetype which contains a sample Maven plugin site.</span><br><span class="line">      This archetype can be layered upon an existing Maven plugin project.)</span><br><span class="line">5: internal -&gt; org.apache.maven.archetypes:maven-archetype-portlet (An archetype which contains a sample JSR-268 Portlet.)</span><br><span class="line">6: internal -&gt; org.apache.maven.archetypes:maven-archetype-profiles ()</span><br><span class="line">7: internal -&gt; org.apache.maven.archetypes:maven-archetype-quickstart (An archetype which contains a sample Maven project.)</span><br><span class="line">8: internal -&gt; org.apache.maven.archetypes:maven-archetype-site (An archetype which contains a sample Maven site which demonstrates</span><br><span class="line">      some of the supported document types like APT, XDoc, and FML and demonstrates how</span><br><span class="line">      to i18n your site. This archetype can be layered upon an existing Maven project.)</span><br><span class="line">9: internal -&gt; org.apache.maven.archetypes:maven-archetype-site-simple (An archetype which contains a sample Maven site.)</span><br><span class="line">10: internal -&gt; org.apache.maven.archetypes:maven-archetype-webapp (An archetype which contains a sample Maven Webapp project.)</span><br><span class="line">Choose a number or apply filter (format: [groupId:]artifactId, case sensitive contains): 7:</span><br></pre></td></tr></table></figure><p>有很多可用的 Archetype供选择,包括著名的 Appfuse项目的 Archetype、JPA项目的 Archetype等。<strong>每一个 Archetype前面都会对应有一个编号,同时命令行会提示一个默认的编号</strong>,<strong>默认其对应的 Archetype为 maven-archetype-quickstart</strong>,<strong>直接回车以选择该 Archetype,紧接着 Maven会提示输入要创建项目的 grouped、 artifact、 version以及包名 package</strong>。如下输入并确认:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Choose a number or apply filter (format: [groupId:]artifactId, case sensitive contains): 7:</span><br><span class="line">Define value for property &apos;groupId&apos;: com.lan.archetypeTest</span><br><span class="line">Define value for property &apos;artifactId&apos;: archetypeTest-test</span><br><span class="line">Define value for property &apos;version&apos; 1.0-SNAPSHOT: : 1.0.0-SNAPSHOT</span><br><span class="line">Define value for property &apos;package&apos; com.lan.archetypeTest: : test</span><br><span class="line">Confirm properties configuration:</span><br><span class="line">groupId: com.lan.archetypeTest</span><br><span class="line">artifactId: archetypeTest-test</span><br><span class="line">version: 1.0.0-SNAPSHOT</span><br><span class="line">package: test</span><br><span class="line"> Y: : y</span><br><span class="line">[INFO] ----------------------------------------------------------------------------</span><br><span class="line">[INFO] Using following parameters for creating project from Old (1.x) Archetype: maven-archetype-quickstart:1.1</span><br><span class="line">[INFO] ----------------------------------------------------------------------------</span><br><span class="line">[INFO] Parameter: basedir, Value: D:\学习9\Mave实战\MavenProject</span><br><span class="line">[INFO] Parameter: package, Value: test</span><br><span class="line">[INFO] Parameter: groupId, Value: com.lan.archetypeTest</span><br><span class="line">[INFO] Parameter: artifactId, Value: archetypeTest-test</span><br><span class="line">[INFO] Parameter: packageName, Value: test</span><br><span class="line">[INFO] Parameter: version, Value: 1.0.0-SNAPSHOT</span><br><span class="line">[INFO] project created from Old (1.x) Archetype in dir: D:\学习9\Mave实战\MavenProject\archetypeTest-test</span><br><span class="line">......</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p></p><p>Archetype插件将根据我们提供的信息创建项目骨架。在<strong>当前目录(MavenProject)</strong>下, Archetype插件会创个名为 <strong><code>archetypeTest-test</code>(我们定义的 artifactId)的子目录</strong>,从中可以看到项目的基本结构:<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/maven/3/archetype-quitstart.png" alt=""><br>基本的 <code>pom.xmI</code>已经被创建,里面包含了必要的信息以及一个junit依赖;<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lan.archetypeTest<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>archetypeTest-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>archetypeTest-test<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>主代码目录src/main/java已经被创建,在该目录下还有一个Java类<code>test.App.java</code><br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/maven/3/archetype-quitstart_main.png" alt="">,注意这里使用到了刚才定义的包名(<code>[INFO] Parameter: packageName, Value: test</code>),而这个类也仅仅只有一个简单的输出 <code>Hello World!</code>的main方法;<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hello world!</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println( <span class="string">"Hello World!"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>测试代码目录sre/test/java</strong>也被创建好了,并且包含了一个测试用例<code>test.AppTest.java</code><br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/maven/3/archetype-quitstart_test.png" alt=""><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> junit.framework.Test;</span><br><span class="line"><span class="keyword">import</span> junit.framework.TestCase;</span><br><span class="line"><span class="keyword">import</span> junit.framework.TestSuite;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Unit test for simple App.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppTest</span> <span class="keyword">extends</span> <span class="title">TestCase</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create the test case</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> testName name of the test case</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AppTest</span><span class="params">( String testName )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>( testName );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the suite of tests being tested</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Test <span class="title">suite</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestSuite( AppTest.class );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Rigourous Test :-)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testApp</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        assertTrue( <span class="keyword">true</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>Archetype可以帮助我们迅速地构建起项目的骨架</strong>,在前面的例子中,我们完全可以在Archetype生成的骨架的基础上开发 Hello world项目以节省大量时间。<br>此外,这里仅仅是看到了一个最简单的 Archetype,<strong>如果有很多项目拥有类似的自定义项目结构以及配置文件,则完全可以一劳永逸地开发自己的 Archetype,然后在这些项目中使用自定义的 Archetype来快速生成项目骨架。</strong>本书后面的章节会详细阐述如何开发 Maven Archetype。</p><h2 id="eclipse中maven的使用"><a href="#eclipse中maven的使用" class="headerlink" title="eclipse中maven的使用"></a>eclipse中maven的使用</h2><p>限于篇幅，跳转到<a href="eclipse中Maven中的使用/">eclipse中maven的使用</a></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本章以尽可能简单且详细的方式叙述了一个 Hello World项目,重点解释了POM的基本内容、 Maven项目的基本结构以及构建项目基本的 Maven命令。在此基础上,还介绍了如何使用 Archetype快速创建项目骨架。最后讲述的是如何在 Eclipse创建及构建 Maven项目。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/f65e41ed/">Maven实战 许晓斌著 第3章 Maven使用入门</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Maven实战 许晓斌著 </category>
          
          <category> 第3章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Maven实战 许晓斌著 第2章 Maven的安装和配置</title>
      <link href="/blog/a475368f/"/>
      <url>/blog/a475368f/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><h2 id="本章内容"><a href="#本章内容" class="headerlink" title="本章内容"></a>本章内容</h2><p>在 Windows上安装 Maven</p><ul><li>在基于UNⅨ的系统上安装 Maven</li><li>安装目录分析</li><li>设置HTP代理</li><li>安装m2eclipse</li><li>安装 NetBeans Maven插件</li><li>Maven安装最佳实践</li><li>小结</li></ul><a id="more"></a><p>第1章介绍了 Maven是什么,以及为什么要使用 Maven,我们将从本章开始实际接触Maven。<strong>本章首先将介绍如何在主流的操作系统下安装 Maven,并详细解释 Maven的安装文件;其次还会介绍如何在主流的IDE中集成 Maven,以及 Maven安装的最佳实践</strong>。</p><h2 id="在-Windows上安装-Maven"><a href="#在-Windows上安装-Maven" class="headerlink" title="在 Windows上安装 Maven"></a>在 Windows上安装 Maven</h2><h3 id="检查JDK安装"><a href="#检查JDK安装" class="headerlink" title="检查JDK安装"></a>检查JDK安装</h3><p><strong>在安装 Maven之前,首先要确认你已经正确安装了JDK。</strong> Maven可以运行在JDK1.4及以上的版本上。打开 Windows的命令行,运行如下的命令来检查Java安装:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\lan&gt;echo %Java_Home%</span><br><span class="line">D:\dev\java\jdk1.8.0_91</span><br><span class="line"></span><br><span class="line">C:\Users\lan&gt;java -version</span><br><span class="line">java version &quot;1.8.0_91&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_91-b14)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.91-b14, mixed mode)</span><br></pre></td></tr></table></figure><p></p><p>上述命令首先检查环境变量JAVA_HOME是否指向了正确的JDK目录,接着尝试运行java命令。如果 Windows无法执行java命令,或者无法找到JAVA_HOME环境变量,就需要检査Java是否安装了,或者环境变量是否设置正确。</p><h3 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装"></a>本地安装</h3><h4 id="下载压缩包"><a href="#下载压缩包" class="headerlink" title="下载压缩包"></a>下载压缩包</h4><p>参考:<a href="https://www.jianshu.com/p/41d07cf95482" target="_blank" rel="noopener">https://www.jianshu.com/p/41d07cf95482</a><br>去<a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">Maven官网下载界面</a>,下载想要的版本解压到你想要的目录就行了。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/maven/2/Maven%E5%AE%89%E8%A3%85%E5%8C%85%E4%B8%8B%E8%BD%BD.png" alt=""></p><h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><p>我这里解压到<code>D:/dev</code>目录下，解压的位置请随意。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/maven/2/unzipMaven.png" alt=""></p><h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><p>最后设置一下环境变量，将Maven安装配置到操作系统环境中，主要就是配置<code>M2_HOME</code> 和<code>PATH</code>两项</p><ul><li>新建环境变量名<code>M2_HOME</code>，对应的变量值设置为你解压的路径，我这里是<code>D:\dev\apache-maven-3.5.4</code></li><li>path环境变量中添加值：<code>%M2_HOME%\bin</code></li></ul><p><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/maven/2/M2_HOME.png" alt=""><br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/maven/2/Path.png" alt=""><br>值得注意的是Path环境变量。当我们<strong>在cmd中输入命令时, Windows首先会在当前目录中寻找可执行文件或脚本,如果没有找到, Windows会接着遍历环境变量Path中定义的路径。</strong>由于将%M2_HOME%\bin添加到了Path中,而这里%M2_HOME%实际上是引用了前面定义的另一个变量,其值是 Maven的安装目录。因此, Windows会在执行命令时搜索目录<code>D:\dev\apache-maven-3.5.4</code>,而mvn执行脚本的位置就是这里。</p><h4 id="验证是否配置成功"><a href="#验证是否配置成功" class="headerlink" title="验证是否配置成功"></a>验证是否配置成功</h4><p>了解环境变量的作用之后,现在打开一个新的cmd窗口(这里强调新的窗口是因为新的环境变量配置需要新的cmd窗口才能生效),运行如下命令检查 Maven的安装情况:<br>打开cmd，输入<code>echo %M2_HOME%</code>和<code>mvn -v</code>命令，如果显示下面的信息就说明配置成功了。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\lan&gt;echo %M2_HOME%</span><br><span class="line">D:\dev\apache-maven-3.5.4</span><br><span class="line">C:\Users\lan&gt;mvn -v</span><br><span class="line">Apache Maven 3.5.4 (1edded0938998edf8bf061f1ceb3cfdeccf443fe; 2018-06-18T02:33:14+08:00)</span><br><span class="line">Maven home: D:\dev\apache-maven-3.5.4\bin\..</span><br><span class="line">Java version: 1.8.0_91, vendor: Oracle Corporation, runtime: D:\dev\java\jdk1.8.0_91\jre</span><br><span class="line">Default locale: zh_CN, platform encoding: GBK</span><br><span class="line">OS name: &quot;windows 10&quot;, version: &quot;10.0&quot;, arch: &quot;amd64&quot;, family: &quot;windows&quot;</span><br></pre></td></tr></table></figure><p></p><p>第一条命令<code>echo%M2_HOM%</code>用来检查环境变量M2_HOME是否指向了正确的 Maven安装目录;而<code>mvn -v</code>执行了第一条 Maven命令,以检查 Windows是否能够找到正确的mvn执行脚本。</p><h3 id="升级-Maven"><a href="#升级-Maven" class="headerlink" title="升级 Maven"></a>升级 Maven</h3><p>Maven更新比较频繁,因此用户往往会需要更新 Maven安装以获得更多、更酷的新特性.并避免一些旧的bug。<br><strong>在 Windows上更新 Maven非常简便,只需要下载新的 Maven安装文件,解压至本地目录,然后更新M2_HOME环境变量即可</strong>。如果需要使用某一个旧版本的 Maven,也只需要编辑M2_HOME环境变量指向旧版本的安装目录。</p><h2 id="在基于∪NX的系统上安装-Maven"><a href="#在基于∪NX的系统上安装-Maven" class="headerlink" title="在基于∪NX的系统上安装 Maven"></a>在基于∪NX的系统上安装 Maven</h2><p>我现在在Windows系统上使用，这个暂时不需要了解。</p><h2 id="安装目录分析"><a href="#安装目录分析" class="headerlink" title="安装目录分析"></a>安装目录分析</h2><p>前面讲到设置<strong>M2_HOME环境变量指向 Maven的安装目录</strong>,本书之后所有使用M2_HOME的地方都指代了该安装目录。下面看一下该目录的结构和内容:</p><ul><li>bin/</li><li>boot/</li><li>conf/</li><li>lib/</li><li>LICENSE</li><li>NOTICE</li><li>README.txt</li></ul><p><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/maven/2/M2_HOME_FileList.png" alt=""></p><h3 id="bin-目录"><a href="#bin-目录" class="headerlink" title="bin/目录"></a><code>bin/</code>目录</h3><p><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/maven/2/M2_HOME_Bin_FileList.png" alt=""><br><strong>该目录包含了mvn运行的脚本,这些脚本用来配置Java命令,准备好 classpath和相关的Java系统属性,然后执行Java命令</strong>。<strong>其中mvn是基于UNX平台的shell脚本,<code>mvn.cmd</code>是基于 Windows平台的bat脚本</strong>。<strong>在命令行输入任何一条mvn命令时,实际上就是在调用这些脚本</strong>。该目录还包含了<code>mvnDebug</code>和 <code>mvnDebug.cmd</code>两个文件,同样,前者是UNIX平台的shell脚本,后者是 Windows平台的bat脚本。那么mvn和mvnDebug有什么区别和关系呢?打开文件我们就可以看到,两者基本是一样的,<strong>只是 mvnDebug多了一条 MAVEN_ DEBUG_OPTS配置,其作用就是在运行 Maven时开启debug,以便调试 Maven本身</strong>。此外,该目录还包含<code>m2.conf文件</code>,这是 classworlds的配置文件,后面会介绍 classworlds。</p><h3 id="boot-目录"><a href="#boot-目录" class="headerlink" title="boot/目录"></a><code>boot/</code>目录</h3><p><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/maven/2/M2_HOME_boot_FileList.png" alt=""><br>该目录只包含一个文件,以 <code>maven3.5.4</code>为例,该文件为 <code>plexus-classworlds-2.5.2.jar</code>。<strong><code>plexus-classworlds</code>是一个类加载器框架</strong>,相对于默认的java类加载器,它提供了更丰富的语法以方便配置, <strong>Maven使用该框架加载自己的类库</strong>。更多关于classworlds的信息请参考<a href="http://classworlds.codehaus.org/" target="_blank" rel="noopener">http://classworlds.codehaus.org/</a>。<strong>对于一般的 Maven用户来说,不必关心该文件</strong>。</p><h3 id="conf-目录"><a href="#conf-目录" class="headerlink" title="conf/目录"></a><code>conf/</code>目录</h3><p><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/maven/2/M2_HOME_Conf_FileList.png" alt=""><br>该目录包含了一个非常重要的文件<code>settings.xml</code>。直接修改该文件,就能在机器上全局地定制 Maven的行为。一般情况下,我们更偏向于复制该文件至<code>~/.m2/</code>目录下(<code>~</code>表示用户目录),然后修改该文件,在用户范围定制 Maven的行为。后面将会多次提到 settings.xml,并逐步分析其中的各个元素。</p><h3 id="lib-目录"><a href="#lib-目录" class="headerlink" title="lib/目录"></a><code>lib/</code>目录</h3><p><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/maven/2/M2_HOME_Lib_FileList.png" alt=""><br><strong>该目录包含了所有 Maven运行时需要的Java类库</strong>, Maven本身是分模块开发的,因此用户能看到诸如 maven-core-3.0.jar、 maven-model-3.0.jar之类的文件。此外这里还包含一些 Maven用到的第三方依赖,如 common-cli-1.2.juar、 google-collection-1.0.jar等。对于 Maven2来说,该目录只包含一个如 maven2.2.1-uber.jar的文件原本各为独立JAR文件的 Maven模块和第三方类库都被拆解后重新合并到了这个JAR文件中。<strong>可以说,lib目录就是真正的 Maven</strong>。关于该文件,还有一点值得一提的是,用户可以在这个目录中找到 Maven内置的超级POM,这一点在8.5节详细解释。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><code>LICENSE文件</code> 记录了 Maven使用的软件许可证 Apache License Version2.0;</li><li><code>NOTICE文件</code> 记录了 Maven包含的第三方软件;</li><li><code>README.txt文件</code> 则包含了 Maven的简要介绍,包括安装需求及如何安装的简要指令等。</li></ul><h3 id="m2"><a href="#m2" class="headerlink" title="~/. m2"></a>~/. m2</h3><p>在讲述该小节之前,我们先运行一条简单的命令: <code>mvn help:system</code>。该命令会打印出所有的Java系统属性和环境变量,这些信息对我们日常的编程工作很有帮助。这里暂不解释<code>help:system</code>涉及的语法,运行这条命令的目的是让 Maven执行一个真正的任务。我们可以从命令行输出看到 Maven会下载 maven-help- plugin,包括pom文件和jar文件。这些文件都被下载到了 Maven本地仓库中。</p><p>在用户目录下可以发现,<code>.m2</code>文件夹。默认情况下,该文件夹下放置了 Maven本地仓库<code>.m2/repository</code>。所有的 Maven构件都被存储到该仓库中,以方便重用。可以到<code>~/.m2/repository/org/apache/maven/plugin/ maven- help-plugin/</code>目录下找到刚才下载的<code>maven-help-plugin</code>的pom文件和jar文件。 Maven根据一套规则来确定任何一个构件在仓库中的位置,这一点在第6章将会详细阐述。由于Maven仓库是通过简单文件系统透明地展示给Maven用户的,有些时候<strong>可以绕过 Maven直接查看或修改仓库文件</strong>,在遇到疑难问题时,这往往十分有用。<br>默认情况下,<code>~/.m2/</code>目录下除了 repository仓库之外就没有其他目录和文件了,不过大多数 Maven用户需要复制<code>M2_HOME/conf/settings.xml</code>文件到<code>~/.m/settings.xml</code>。这是一条最佳实践,我们将在2.7小节详细解释。</p><h2 id="设置HTTP代理"><a href="#设置HTTP代理" class="headerlink" title="设置HTTP代理"></a>设置HTTP代理</h2><p>有时候你所在的公司基于安全因素考虑,要求你使用通过安全认证的代理访问因特网。这种情况下,就需要为 Maven配置HTTP代理,才能让它正常访问外部仓库,以下载所需要的资源。</p><p>我暂时不需要了解，后续需要再来看</p><h2 id="安装m2eclipse"><a href="#安装m2eclipse" class="headerlink" title="安装m2eclipse"></a>安装m2eclipse</h2><p>我这里的eclipse版本是4.5版本的，已经集成了Maven插件不需要再安装。点击eclipse的菜单栏<code>help-&gt;about eclipse</code>可以看到你的版本：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/maven/2/eclipse_version.png" alt=""><br>确认是否安装了maven插件：点击菜单Windows–&gt;Preferences。列表上有Maven项，则你的eclipse支持Maven。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/maven/2/eclipse_Preferences.png" alt=""><br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/maven/2/eclipse_Preferences_maven.png" alt=""></p><p>这是因为 Eclipse默认是运行在JRE上的,而m2eclipse的一些功能要求使用JDK。解决方法是配置 Eclipse安装目录的<code>eclipse.ini</code>文件,添加vm配置指向JDK。例如:<br>原来的<code>eclipse.ini</code>文件<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-startup</span><br><span class="line">plugins/org.eclipse.equinox.launcher_1.3.100.v20150511-1540.jar</span><br><span class="line">--launcher.library</span><br><span class="line">plugins/org.eclipse.equinox.launcher.win32.win32.x86_64_1.1.300.v20150602-1417</span><br><span class="line">-product</span><br><span class="line">org.eclipse.epp.package.jee.product</span><br><span class="line">--launcher.defaultAction</span><br><span class="line">openFile</span><br><span class="line">--launcher.XXMaxPermSize</span><br><span class="line">256M</span><br><span class="line">-showsplash</span><br><span class="line">org.eclipse.platform</span><br><span class="line">--launcher.XXMaxPermSize</span><br><span class="line">256m</span><br><span class="line">openFile</span><br><span class="line">--launcher.appendVmargs</span><br><span class="line">-vmargs</span><br><span class="line">-Dosgi.requiredJavaVersion=1.7</span><br><span class="line">-Xms256m</span><br><span class="line">-Xmx1024m</span><br></pre></td></tr></table></figure><p></p><p>在<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--launcher.XXMaxPermSize</span><br><span class="line">256m</span><br></pre></td></tr></table></figure><p></p><p><code>256m</code>下面添加一个配置项,如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--launcher.XXMaxPermSize</span><br><span class="line">256m</span><br><span class="line">-vm</span><br><span class="line">D:\dev\java\jdk1.8.0_91\bin\javaw.exe</span><br></pre></td></tr></table></figure><p></p><p>修改后的<code>eclipse.ini</code>完整如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-startup</span><br><span class="line">plugins/org.eclipse.equinox.launcher_1.3.100.v20150511-1540.jar</span><br><span class="line">--launcher.library</span><br><span class="line">plugins/org.eclipse.equinox.launcher.win32.win32.x86_64_1.1.300.v20150602-1417</span><br><span class="line">-product</span><br><span class="line">org.eclipse.epp.package.jee.product</span><br><span class="line">--launcher.defaultAction</span><br><span class="line">openFile</span><br><span class="line">--launcher.XXMaxPermSize</span><br><span class="line">256M</span><br><span class="line">-showsplash</span><br><span class="line">org.eclipse.platform</span><br><span class="line">--launcher.XXMaxPermSize</span><br><span class="line">256m</span><br><span class="line">-vm</span><br><span class="line">D:\dev\java\jdk1.8.0_91\bin\javaw.exe</span><br><span class="line">--launcher.defaultAction</span><br><span class="line">openFile</span><br><span class="line">--launcher.appendVmargs</span><br><span class="line">-vmargs</span><br><span class="line">-Dosgi.requiredJavaVersion=1.7</span><br><span class="line">-Xms256m</span><br><span class="line">-Xmx1024m</span><br></pre></td></tr></table></figure><p></p><p>然后重启eclipse即可</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/a475368f/">Maven实战 许晓斌著 第2章 Maven的安装和配置</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Maven实战 许晓斌著 </category>
          
          <category> 第2章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Maven实战 许晓斌著 第1章Maven简介</title>
      <link href="/blog/fee3067c/"/>
      <url>/blog/fee3067c/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><h2 id="本章内容"><a href="#本章内容" class="headerlink" title="本章内容"></a>本章内容</h2><ul><li>何为 Maven</li><li>为什么需要 Maven</li><li>Maven与极限编程</li><li>被误解的 Maven</li><li>小结</li></ul><a id="more"></a><h2 id="何为-Maven"><a href="#何为-Maven" class="headerlink" title="何为 Maven"></a>何为 Maven</h2><p>Maven这个词可以翻译为“知识的积累”,也可以翻译为“专家”或“内行”。本书将介绍 Maven这一<strong>跨平台的项目管理工具</strong>。作为<strong> Apache组织中的一个</strong>颇为成功的<strong>开源项目</strong>,<strong>Maven主要服务于基于Java平台的项目构建、依赖管理和项目信息管理</strong>。无论是小型的开源类库项目,还是大型的企业级应用;无论是传统的瀑布式开发,还是流行的敏捷模式,Maven都能大显身手。</p><h3 id="何为构建"><a href="#何为构建" class="headerlink" title="何为构建"></a>何为构建</h3><p>工作中,除了编写源代码,<strong>我们每天有相当一部分时间花在了编译、运行单元测试、生成文档、打包和部署等烦琐且不起眼的工作上,这就是<code>构建</code></strong>。如果我们现在还手工这样做,那成本也太高了,于是有人<strong>用软件的方法让这一系列工作完全自动化,使得软件的构建可以像全自动流水线一样,只需要一条简单的命令,所有烦琐的步骤都能够自动完成,很快就能得到最终结果</strong>。</p><h3 id="Maven是优秀的构建工具"><a href="#Maven是优秀的构建工具" class="headerlink" title="Maven是优秀的构建工具"></a>Maven是优秀的构建工具</h3><p>前面介绍了<strong>Maven的用途之一是服务于构建</strong>,它是一个异常强大的构建工具,<strong>能够帮我们自动化构建过程,从清理、编译、测试到生成报告,再到打包和部署</strong>。我们不需要也不应该一遍又一遍地输入命令,一次又一次地点击鼠标,我们要做的是使用 Maven配置好项目,然后输入简单的命令(如 <code>mvn clean install</code>), Maven会帮我们处理那些烦琐的任务。</p><p><strong>Maven是跨平台的</strong>,这意味着无论是在 Windows上,还是在 Linux或者Mac上,都可使用同样的命令。</p><p>我们一直在不停地寻找避免重复的方法。设计的重复、编码的重复、文档的重复,当然还有构建的重复。 <strong>Maven最大化地消除了构建的重复</strong>,抽象了构建生命周期,并且为绝大部分的构建任务提供了已实现的插件,我们不再需要定义过程,甚至不需要再去实现这些过程中的一些任务。<strong>最简单的例子是测试</strong>,我们没必要告诉 Maven去测试,更不需要告诉 Maven如何运行测试,<strong>只需要遵循 Maven的约定编写好<code>测试用例</code>,当我们运行构建的时候,这些测试便会自动运行</strong>。</p><p>想象一下,<strong> Maven抽象了一个完整的构建生命周期模型</strong>,这个模型吸取了大量其他的构建脚本和构建工具的优点,总结了大量项目的实际需求。<strong>如果遵循这个模型,可以避免很多不必要的错误</strong>,可以直接使用大量成熟的 Maven插件来完成我们的任务(很多时候我们可能都不知道自己在使用 Maven插件)。此外,如果有非常特殊的需求,我们也可以轻松实现自己的插件。<br><strong>Maven</strong>还有一个优点,它<strong>能帮助我们标准化构建过程</strong>。在 Maven之前,十个项目可能有十种构建方式;<strong>有了 Maven之后,<code>所有项目的构建命令都是简单一致的</code>,这<code>极大地避免了不必要的学习成本</code>,而且有利于促进项目团队的标准化</strong>。</p><h3 id="Maven不仅仅是构建工具"><a href="#Maven不仅仅是构建工具" class="headerlink" title="Maven不仅仅是构建工具"></a>Maven不仅仅是构建工具</h3><p>Java不仅是一门编程语言,还是一个平台,通过 JRuby和 Jython,我们<strong>可以在Java平台上编写和运行Ruby和 Python程序</strong>。我们也应该认识到, <strong>Maven不仅是构建工具,还是一个依赖管理工具和项目信息管理工具。它提供了中央仓库,能帮我们自动下载构件</strong>。<br>在这个开源的年代里,<strong>几乎任何Java应用都会借用一些第三方的开源类库,这些类库都可通过依赖的方式引人到项目中来。随着依赖的增多,版本不一致、版本冲突、依赖臃肿等问题都会接踵而来</strong>。手工解决这些问题是十分枯燥的,幸运的是 Maven提供了一个优秀的解决方案,它通过一个坐标系统准确地定位每一个构件( artifact),也就是<strong>通过一组坐标 Maven能够找到任何一个Java类库(如jar文件)</strong>。 Maven给这个类库世界引入了经纬,让它们变得有秩序,于是<strong>我们可以借助它来有序地管理依赖,轻松地解决那些繁杂的<code>依赖问题</code></strong>。<br>Maven还能帮助我们管理原本分散在项目中各个角落的项目信息,包括项目描述、开发者列表、版本控制系统地址、许可证、缺陷管理系统地址等。这些微小的变化看起来很琐碎,并不起眼,但却在不知不觉中为我们节省了大量寻找信息的时间。除了直接的项目信息,通过 Maven自动生成的站点,以及一些已有的插件,我们还能够轻松获得项目文档测试报告、静态分析报告、源码版本日志报告等非常具有价值的项目信息。</p><p><strong>Maven还为全世界的Java开发者提供了一个免费的中央仓库,在其中几乎可以找到任何的流行开源类库</strong>。通过一些 Maven的衍生工具(如 Nexus),我们还能对其进行快速地搜索。只要定位了坐标, Maven就能够帮我们自动下载,省去了手工劳动。<br>使用 Maven还能享受一个额外的好处,即 Maven对于项目目录结构、测试用例命名方式等内容都有既定的规则,只要遵循了这些成熟的规则,用户在项目间切换的时候就免去了额外的学习成本,可以说是约定优于配置( Convention Over Configuration)</p><h2 id="为什么需要-Maven"><a href="#为什么需要-Maven" class="headerlink" title="为什么需要 Maven"></a>为什么需要 Maven</h2><p>Maven不是Java领域唯一的构建管理的解决方案。本节将通过一些简单的例子解释Maven的必要性,并介绍其他构建解决方案,如IDE、Make和Ant,并将它们与 Maven进行比较。</p><h3 id="组装PC和品牌PC"><a href="#组装PC和品牌PC" class="headerlink" title="组装PC和品牌PC"></a>组装PC和品牌PC</h3><p>使用脚本建立高度自定义的构建系统就像买组装PC,耗时费力,结果也不一定很好。当然,你可以享受从无到有的乐趣,但恐怕实际项目中无法给你那么多时间。使用 Maven就像购买品牌PC,省时省力,并能得到成熟的构建系统,还能得到来自于 Maven社区的大量支持。唯一与购买品牌PC不同的是, Maven是开源的,你无须为此付费。如果有兴趣,你还能去了Maven是如何工作的,而我们无法知道那些PC巨头的商业秘密。</p><h3 id="IDE不是万能的"><a href="#IDE不是万能的" class="headerlink" title="IDE不是万能的"></a>IDE不是万能的</h3><p>当然,我们无法否认优秀的IDE能大大提高开发效率。当前主流的IDE如 Eclipse和NetBeans等都提供了强大的文本编辑、调试甚至重构功能。虽然使用简单的文本编辑器和命令行也能完成绝大部分开发工作,但很少有人愿意那样做。然而,IDE是有其天生缺陷的:</p><ul><li>IDE依赖大量的手工操作。编译、测试、代码生成等工作都是相互独立的,很难一键完成所有工作。手工劳动往往意味着低效,意味着容易出错。</li><li>很难在项目中统一所有的IDE配置,每个人都有自己的喜好。也正是由于这个原因，一</li><li>个在机器A上可以成功运行的任务,到了机器B的IDE中可能就会失败。</li></ul><p>我们应该合理利用IDE,而不是过多地依赖它。<strong>对于构建这样的任务,在IDE中一次次地点击鼠标是愚蠢的行为</strong>。 Maven是这方面的专家,而且<strong>主流IDE都集成了 Maven,我们可以在IDE中方便地运行 Maven执行构建</strong>。</p><h3 id="Make"><a href="#Make" class="headerlink" title="Make"></a>Make</h3><p><strong>Make也许是最早的构建工具</strong>,它由 Stuart Feldman于1977年在Bell实验室创建。 Stuart Feldman也因此于2003年获得了ACM国际计算机组织颁发的软件系统奖。<strong>目前Make有很多衍生实现,包括最流行的 GNU Make和 BSD Make,还有 Windows平台的 Microsoft nmake等</strong>。</p><p>Make由一个名为 Makefile的脚本文件驱动,该文件使用Make自己定义的语法格式。其基本组成部分为一系列规则( Rules),而<strong>每一条规则又包括<code>目标( Target)</code>、<code>依赖( Prerequsite)</code>和<code>命令( Command)</code></strong>。 Makefile的基本结构如下：<br></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Target... : Prerequsite...</span><br><span class="line">Command</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p></p><p>Make通过一系列目标和依赖将整个构建过程串联起来,同时利用本地命令完成每个目标的实际行为<strong>。Make的强大之处在于它可以利用所有系统的本地命令,尤其是UNIX/Linux系统</strong>,丰富的功能、强大的命令能够帮助Make快速高效地完成任务。<br>但是,Make将自己和操作系统绑定在一起了。也就是说,使<strong>用Make,就不能实现(至少很难)跨平台的构建,这对于Java来说是非常不友好的</strong>。此外, Makefile的语法也成问题,很多人抱怨Make构建失败的原因往往是<strong>一个难以发现的空格或Tab使用错误</strong>。</p><h3 id="Ant"><a href="#Ant" class="headerlink" title="Ant"></a>Ant</h3><p>Ant不是指蚂蚁,而是意指“另一个整洁的工具”( Another neat tool),它最早用来构建著名的 Tomcat,其作者 James Duncan Davidson创作它的动机就是因为受不了 Makefile的语法格式。我们<strong>可以将Ant看成是一个Java版本的Make</strong>,也正因为使用了Java,<strong>Ant是跨平台的</strong>。此外,<strong>Ant使用XML定义构建脚本</strong>,<strong>相对于 Makefile</strong>来说,这也<strong>更加友好</strong>。<br>与Make类似,Ant有一个构建脚本 build.xml,如下所示：<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">name</span>=<span class="string">"Hello"</span> <span class="attr">default</span>=<span class="string">"compile"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"compile"</span> <span class="attr">description</span>=<span class="string">"compile the Java source code to class files"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">makdir</span> <span class="attr">dir</span>=<span class="string">"classes"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javac</span> <span class="attr">srcdir</span>=<span class="string">"."</span> <span class="attr">destdir</span>=<span class="string">"classes"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"jar"</span> <span class="attr">depends</span>=<span class="string">"compile"</span> <span class="attr">description</span>=<span class="string">"create a Jar file"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jar</span> <span class="attr">destfile</span>=<span class="string">"hello.jar"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"classes"</span> <span class="attr">includes</span>=<span class="string">"**/*.class"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">name</span>=<span class="string">"Main-Class"</span> <span class="attr">value</span>=<span class="string">"HelloProgram"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jar</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><strong>build.xml的基本结构也是目标( target)、依赖( depends),以及实现目标的任务</strong>。比如在上面的脚本中,jar目标用来创建应用程序jar文件,该目标依赖于 compile目标(<strong><code>&lt;target name=&quot;jar&quot; depends=&quot;compile&quot;</code> description=”create a Jar file”&gt;</strong>),后者执行的任务是创建一个名为 classes的文件夹,编译当前目录的java文件至 classes目录。compile目标完成后,jar目标再执行自己的任务。A<strong>nt有大量内置的用Java实现的任务,这保证了其跨平台的特质,同时,Ant也有特殊的任务exec来执行本地命令</strong>。</p><p>和<strong>Make一样,Ant也都是过程式的,开发者要显式地指定每一个目标,以及完成该目标所需要执行的任务</strong>。针对每一个项目,开发者都需要重新编写这一过程,这里其实隐含着很大的重复。</p><p><strong>Maven是声明式的</strong>,项目构建过程和过程各个阶段所需的工作都由插件实现,并且大部分插件都是现成的,开发者只需要声明项目的基本元素, Maven就执行内置的、完整的构建过程。这在<strong>很大程度上消除了重复</strong>。</p><p><strong>Ant是没有依赖管理的</strong>,所以很长一段时间Ant用户都不得不手工管理依赖,这是一个令人头疼的问题。幸运的是,Ant用户现在可以借助lvy管理依赖。而对于<strong> Maven用户来说,依赖管理是理所当然的, Maven不仅内置了依赖管理,更有一个可能拥有全世界最多Java开源软件包的中央仓库, Maven用户无须进行任何配置就可以直接使用</strong>。</p><h3 id="不重复发明轮子"><a href="#不重复发明轮子" class="headerlink" title="不重复发明轮子"></a>不重复发明轮子</h3><p>作者举了个有趣的故事，这里略。</p><h2 id="Maven与极限编程"><a href="#Maven与极限编程" class="headerlink" title="Maven与极限编程"></a>Maven与极限编程</h2><p><strong>极限编程(XP)是</strong>近些年在软件行业红得发紫的<strong>敏捷开发方法</strong>,它强调拥抱变化。该软件开发方法的创始人 Kent Beck提出了XP所追求的价值、实施原则和推荐实践。下面看Maven如何适应XP的。<br>极限编程(XP)是近些年在软件行业红得发紫的敏捷开发方法,它强调拥抱变化。该软件开发方法的创始人 Kent Beck提出了XP所追求的价值、实施原则和推荐实践。下面看Maven如何适应XP的。</p><p>首先看一下 Maven如何帮助XP团队实现一些核心价值：</p><ul><li><strong>简单</strong>。 Maven暴露了一组一致、简洁的操作接口,能帮助团队成员从原来的高度自定义的、复杂的构建系统中解脱出来,使用 Maven现有的成熟的、稳定的组件也能简化构建系统的复杂度。</li><li><strong>交流与反馈</strong>。与版本控制系统结合后,所有人都能执行最新的构建并快速得到反馈。此外,自动生成的项目报告也能帮助成员了解项目的状态,促进团队的交流。</li></ul><p>此外, Maven更能无缝地支持或者融人到一些主要的XP实践中:</p><ul><li><strong>测试驱动开发(TDD)</strong>。<strong>TDD强调测试先行,所有产品都应该由测试用例覆盖</strong>。而测试是 Maven生命周期的最重要的组成部分之一,并且 Maven有现成的成熟插件支持业界流行的测试框架,如 JUnit和 TestNG。</li><li><strong>十分钟构建</strong>。十分钟构建强调我们能够随时快速地从源码构建出最终的产品。这正是 Maven所擅长的,只需要一些配置,之后用一条简单的命令就能让 Maven帮你清理、编译、测试、打包、部署,然后得到最终的产品。</li><li><strong>持续集成(CI)</strong>。CI强调项目以很短的周期(如15分钟)集成最新的代码。实际上,CI的前提是源码管理系统和构建系统。目前业界流行的CI服务器如 Hudson和CruiseControl都能很好地和 Maven进行集成。也就是说,使用 Maven后,持续集成会变得更加方便。</li><li><strong>富有信息的工作区</strong>。这条实践强调开发者能够快速方便地了解到项目的最新状态。当然, Maven并不会帮你把测试覆盖率报告贴到墙上,也不会在你的工作台上放个鸭子告诉你构建失败了。不过使用 Maven发布的项目报告站点,并配置你需要的项目报告,如测试覆盖率报告,都能帮你把信息推送到开发者眼前。<br>上述这些实践并非只在XP中适用。事实上,除了其他敏捷开发方法如 SCRUM之外，几乎任何软件开发方法都能借鉴这些实践。也就是说<strong>, Maven几乎能够很好地支持任何软件开发方法</strong>。<br>例如,在传统的瀑布模型开发中,项目依次要经历需求开发、分析、设计、编码、测试和集成发布阶段。从设计和编码阶段开始,就可以使用 Maven来建立项目的构建系统。在设计阶段,也完全可以针对设计开发测试用例,然后再编写代码来满足这些测试用例。然而,有了自动化构建系统,我们可以节省很多手动的测试时间。此外,尽早地使用构建系统集成团队的代码,对项目也是百利而无一害。最后, Maven还能帮助我们快速地发布项目。<h2 id="被误解的-Maven"><a href="#被误解的-Maven" class="headerlink" title="被误解的 Maven"></a>被误解的 Maven</h2>C++之父 Bjarne Stroustrup说过一句话:“<strong>只有两类计算机语言,一类语言天天被人骂,还有一类没人用</strong>。”当然这话也不全对,大红大紫的Ruby不仅有人用,而且骂的人也少。<strong>用户最多的Java得到的骂声就不绝于耳了</strong>。 Maven的用户也不少,它的邮件列表目前在Apache项目中排名第4(<a href="http://ww.nabble.com/Apache-f90.html)。" target="_blank" rel="noopener">http://ww.nabble.com/Apache-f90.html)。</a><br>让我们看看 Maven受到了哪些质疑,笔者将对这些质疑逐一解释。</li></ul><hr><p><strong>“Maven对于IDE(如 Eclipse和IDEA)的支持较差,bug多,而且不稳定。”</strong><br>相对于 JUnit和Ant来说, Maven比较年轻,IDE集成等衍生产品还不够全面和成熟但是,我们一定要知道,<strong>使用 Maven最高效的方式永远是命令行</strong>,<strong>IDE在自动化构建方面有天生的缺陷</strong>。此外,<strong> Eclipse的 Maven插件—m2 eclipse是一个比较优秀和成熟的工具</strong>,Neteans也在积极地为更好地集成 Maven而努力,自 Intelli J IDEA开源后,也有望看到其对Maven更好的集成。</p><hr><p>“Maven采用了一个糟糕的插件系统来执行构建,新的、破损的插件会让你的构建莫其妙地失败。”</p><hr><p>自 Maven2.0.9开始,所有核心的插件都设定了稳定版本,这意味着日常使用 Maven时几乎不会受到不稳定插件的影响。此外, Maven社区也提倡为你使用的任何插件设定稳定的版本。如果我们有好的实践不采纳,遇到了问题就抱怨,未免不够公允。从 Maven3开始,如果你使用插件时未设定版本,会看到警告信息。</p><hr><p>“ Maven过于复杂,它就是构建系统的EJB2。”</p><hr><p>不要指望Maven十分简单,这几乎是不可能的。 Maven是用来管理项目的,清理、编译、测试、打包、发布,以及一些自定义的过程本身就是一件复杂的事情。目前在Java社区还有比 Maven更强大、更简单的构建工具吗?答案是否定的。我们可以尝试去帮助 Maven让它变得更简单,而不是抛弃它,然后自己实现一套更加复杂的构建系统。</p><hr><hr><p>“ Maven的仓库十分混乱,当无法从仓库中得到需要的类库时,我需要手工下载复制到本地仓库中。”<br>Maven的中央仓库确实不完美,你也许会发现某个jar包出现在两个不同的路径下。这不是 Maven的错,这是开源项目本身改变了自身的坐标。如果没有中央仓库,你将不得不去开源项目首页寻找下载链接,这不是更费事吗?现在有很多的 Maven仓库搜索服务。无法从中央仓库找到你需要的类库?由于许可证等因素,这是完全有可能的,这时你需要做的是建立个组织内部的仓库服务器,你会发现这会给你带来许多意想不到的好处。</p><hr><p>“缺乏文档是理解和使用 Maven的一个主要障碍!”<br>这是事实。 Maven官方站点的文档十分凌乱,各种插件的文档更是需要费力寻找。<strong>Sonatte编写的《 Maven权威指南》很好地改善了这一状况,但由于该书的某些部分与国内的现状有些脱离,且翻译速度无法跟上原版的更新速度</strong>,于是笔者编写本书,目的也是帮助大家理解和使用 Maven</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本章只是从概念上简单地介绍了一下 Maven,通过本章我们应该能大致了解Maem是什么,以及它有什么用途,我们还将 Maven与其他流行的构建工具(如Make和Ant)做了一些比较和分析、如果你没用过 Maven,但有Make或者Ant的使用经验,相信通过比较你能更清楚地了解各种工具的优劣,并且会对 Maven有一个理性的认识。<br>将 Maven和极限编程结合起来分析是为了让大家从另-个角度了解 Maven,毕竟软件开发离不开对于软件过程的理解</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/fee3067c/">Maven实战 许晓斌著 第1章Maven简介</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Maven实战 许晓斌著 </category>
          
          <category> 第1章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Maven实战 许晓斌著 前言</title>
      <link href="/blog/6bc2392d/"/>
      <url>/blog/6bc2392d/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><ul><li>本书的主要内容</li><li>本书代码下载</li></ul><a id="more"></a><h2 id="本书的主要内容"><a href="#本书的主要内容" class="headerlink" title="本书的主要内容"></a>本书的主要内容</h2><p><strong>第1章对 Maven做了简要介绍</strong>,通过一些程序员熟悉的例子介绍了 Maven是什么,为什么需要 Maven。<strong>建议所有读者都阅读以获得一个大局的印象</strong>。<br><strong>第2-3章是对 Maven的一个入门介绍</strong>,这些内容<strong>对初学者很有帮助</strong>,如果你已经比轼熟悉 Maven,可以跳过。<br><strong>第4章</strong>介绍了<strong>本书使用的背景案例</strong>,后面的很多章节都会基于该案例展开,因此<strong>建议读者至少简单浏览一遍</strong>。<br><strong>第5~8章深人阐述了 Maven的核心概念</strong>,包括坐标、依赖、仓库、生命周期、插件、继承和多模块聚合,等等,<strong>每个知识点都有实际的案例相佐,建议读者仔细阅读</strong>。<br><strong>第9章介绍使用 Nexus建立私服</strong>,如果你要在实际工作中使用 Maven,这是必不可少的。<br><strong>第10-16章介绍了一些相对高级且离散的知识点</strong>,包括测试、持续集成与 Hudson、Web项目与自动化部署、自动化版本管理、智能适应环境差异的灵活构建、站点生成,<strong>以及 Maven的 Eclipse插件 myeclipse</strong>,等等。读者可以根据自己实际需要和兴趣选择性地阅读。<br><strong>第17-18章介绍了如何编写 Archetype和 Maven插件</strong>。<strong>一般的 Maven用户在实际工作中往往不需要接触这些知识</strong>,如果你需要编写插件扩展 Maven,或者需要编写 Archetype维护自己的项目骨架以方便团队开发,那么可以仔细阅读这两章的内容。</p><h2 id="本书代码下载"><a href="#本书代码下载" class="headerlink" title="本书代码下载"></a>本书代码下载</h2><p><a href="http://www.juvenxu.com/mvn-in-action/" target="_blank" rel="noopener">http://www.juvenxu.com/mvn-in-action/</a></p><hr><p><a href="https://fanyi.baidu.com/?aldtype=16047#en/zh/Maven" target="_blank" rel="noopener">Maven读音</a>：<br><strong>maven</strong><br>英 [ˈmeɪvn] 美 [ˈmevən]<br>n.<br>&lt;美口&gt;专家，内行<br><strong>实例</strong><br>Then He created a Eclipse project using Maven.<br>接着他使用Maven创建了一个Eclipse项目。</p><hr><p>本文链接: <a href="https://www.lansheng.net.cn/blog/6bc2392d/">Maven实战 许晓斌著 前言</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Maven实战 许晓斌著 </category>
          
          <category> 前言 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java生成Markdown代码块格式</title>
      <link href="/blog/e078718f/"/>
      <url>/blog/e078718f/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><h3 id="Java处理代码"><a href="#Java处理代码" class="headerlink" title="Java处理代码"></a>Java处理代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> markdowntools;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> clipboard.util.SysClipboardUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MDCodeBlock</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (args.length)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span> :</span><br><span class="line"><span class="comment">//没有命令行参数</span></span><br><span class="line">noArg();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span> :</span><br><span class="line"><span class="comment">//有一个命令参数</span></span><br><span class="line">oneArg(args);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">oneArg</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (args[<span class="number">0</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"j"</span> :</span><br><span class="line">SysClipboardUtil.setSysClipboardText(</span><br><span class="line"><span class="string">"```java\n"</span> + SysClipboardUtil.getSysClipboardText() + <span class="string">"\n```"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//javascript</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"js"</span> :</span><br><span class="line">SysClipboardUtil.setSysClipboardText(</span><br><span class="line"><span class="string">"```javascript\n"</span> + SysClipboardUtil.getSysClipboardText() + <span class="string">"\n```"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用命令行参数：如html,css,xml,php等</span></span><br><span class="line"><span class="keyword">default</span> :</span><br><span class="line">SysClipboardUtil.setSysClipboardText(</span><br><span class="line"><span class="string">"```"</span>+args[<span class="number">0</span>]+<span class="string">"\n"</span> + SysClipboardUtil.getSysClipboardText() + <span class="string">"\n```"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">noArg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SysClipboardUtil.setSysClipboardText(</span><br><span class="line"><span class="string">"```\n"</span> + SysClipboardUtil.getSysClipboardText() + <span class="string">"\n```"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eclipse中把上面的代码导出为可执行Jar包<code>MDCodeBlock.jar</code>,（我的导出路径为:<code>D:\dev\java\my\runable\MDCodeBlock.jar</code>）</p><h3 id="bat文件内容"><a href="#bat文件内容" class="headerlink" title="bat文件内容"></a>bat文件内容</h3><p>在导出的目录下，创建MDCodeBlock.bat文件,内容：<br></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">start</span> javaw -jar D:\dev\java\my\runable\MDCodeBlock.jar %<span class="number">1</span></span><br><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure><p></p><ul><li><code>%1</code>表示第一个命令行参数.</li><li><code>D:\dev\java\my\runable\MDCodeBlock.jar</code>是导出的Jar包路径</li><li><code>start javaw -jar</code>命令表示以后台进程运行该java程序</li></ul><p>本文链接: <a href="https://www.lansheng.net.cn/blog/e078718f/">Java生成Markdown代码块格式</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 我的软件 </category>
          
          <category> Markdown工具 </category>
          
          <category> 代码块工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>截图文字识别软件升级</title>
      <link href="/blog/d2e9fa85/"/>
      <url>/blog/d2e9fa85/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ul><li>加入保存保存快捷键<code>ctrl+s</code></li><li>修改代码，支持多次保存</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="加入保存快捷键"><a href="#加入保存快捷键" class="headerlink" title="加入保存快捷键"></a>加入保存快捷键</h3><p>在ScreenShotWindow.java中加入快捷键变量声明：<br>第1步：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义保存快捷键</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SaveImage_HOT_KEY = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p></p><p>第2步：<br>注册快捷键：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加保存快捷键</span></span><br><span class="line">JIntellitype.getInstance().registerHotKey(SaveImage_HOT_KEY,</span><br><span class="line">JIntellitype.MOD_CONTROL, (<span class="keyword">int</span>) <span class="string">'S'</span>);</span><br></pre></td></tr></table></figure><p></p><p>第3步：编写事件监听逻辑：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第3步：添加热键监听器JIntellitype</span></span><br><span class="line">JIntellitype.getInstance().addHotKeyListener(<span class="keyword">new</span> HotkeyListener()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onHotKey</span><span class="params">(<span class="keyword">int</span> markCode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (markCode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 按下alt+w快捷键表示再次截屏</span></span><br><span class="line"><span class="keyword">case</span> SCREENSHOT_HOT_KEY :</span><br><span class="line"><span class="comment">// showMessage();</span></span><br><span class="line"><span class="comment">//ScreenShotOCR.visiable();</span></span><br><span class="line"><span class="comment">//如果当前窗口可见的话</span></span><br><span class="line"><span class="comment">//再次截屏时,隐藏工具窗口</span></span><br><span class="line"><span class="keyword">if</span>(tools!=<span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">tools.setVisible(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重新截屏</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">createScreenCapture();</span><br><span class="line">&#125; <span class="keyword">catch</span> (AWTException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示窗口</span></span><br><span class="line">ScreenShotOCR.visiable();</span><br><span class="line"><span class="comment">////让窗口置顶</span></span><br><span class="line"><span class="comment">//这个应该在开始的时候就设置</span></span><br><span class="line"><span class="comment">//ScreenShotOCR.ssw.setAlwaysOnTop(true);</span></span><br><span class="line"><span class="comment">//tools.setAlwaysOnTop(true);</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// alt+q快捷键表示退出程序</span></span><br><span class="line"><span class="keyword">case</span> EXIT_KEY_MARK :</span><br><span class="line">System.exit(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EXIT_SCREENSHOT_HOT_KEY:</span><br><span class="line"><span class="comment">//让窗口不显示</span></span><br><span class="line">ScreenShotWindow.<span class="keyword">this</span>.setVisible(<span class="keyword">false</span>);<span class="comment">//不显示窗口</span></span><br><span class="line">tools.setLocation(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SaveImage_HOT_KEY:</span><br><span class="line"><span class="comment">//让窗口不显示</span></span><br><span class="line">ScreenShotWindow.<span class="keyword">this</span>.setVisible(<span class="keyword">false</span>);<span class="comment">//不显示窗口</span></span><br><span class="line">tools.setLocation(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">saveImage();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>关键代码：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SaveImage_HOT_KEY:</span><br><span class="line"><span class="comment">//让窗口不显示</span></span><br><span class="line">ScreenShotWindow.<span class="keyword">this</span>.setVisible(<span class="keyword">false</span>);<span class="comment">//不显示窗口</span></span><br><span class="line">tools.setLocation(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">saveImage();<span class="comment">//按下ctrl+s时调用保存图片函数</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p></p><p>这样就注册了保存快捷键了。接下来修改保存函数。</p><h3 id="支持多次保存保存后不退出"><a href="#支持多次保存保存后不退出" class="headerlink" title="支持多次保存保存后不退出"></a>支持多次保存保存后不退出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存图像到文件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveImage</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">JFileChooser jfc = <span class="keyword">new</span> JFileChooser();</span><br><span class="line">jfc.setDialogTitle(<span class="string">"保存"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件过滤器，用户过滤可选择文件</span></span><br><span class="line">FileNameExtensionFilter filter = <span class="keyword">new</span> FileNameExtensionFilter(<span class="string">"PNG"</span>,</span><br><span class="line"><span class="string">"png"</span>);</span><br><span class="line">jfc.setFileFilter(filter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个默认文件（此文件会生成到桌面上）</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH-mm-ss"</span>);</span><br><span class="line">String fileName = sdf.format(<span class="keyword">new</span> Date());</span><br><span class="line">File filePath = FileSystemView.getFileSystemView().getHomeDirectory();</span><br><span class="line">File defaultFile = <span class="keyword">new</span> File(</span><br><span class="line">filePath + File.separator + fileName + <span class="string">".png"</span>);</span><br><span class="line">jfc.setSelectedFile(defaultFile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> flag = jfc.showSaveDialog(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> (flag == JFileChooser.APPROVE_OPTION)</span><br><span class="line">&#123;</span><br><span class="line">File file = jfc.getSelectedFile();</span><br><span class="line">String path = file.getPath();</span><br><span class="line"><span class="comment">// 检查文件后缀，放置用户忘记输入后缀或者输入不正确的后缀</span></span><br><span class="line"><span class="keyword">if</span> (!(path.endsWith(<span class="string">".png"</span>) || path.endsWith(<span class="string">".PNG"</span>)))</span><br><span class="line">&#123;</span><br><span class="line">path += <span class="string">".png"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line">ImageIO.write(saveImage, <span class="string">"png"</span>, <span class="keyword">new</span> File(path));</span><br><span class="line"><span class="comment">//不退出</span></span><br><span class="line"><span class="comment">//System.exit(0);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原先的代码中截图后就退出了，关键代码：<code>System.exit(0);</code>把这一段话注释掉即可。</p><h2 id="出现问题"><a href="#出现问题" class="headerlink" title="出现问题"></a>出现问题</h2><p>无法使用ctrl+s快捷键，因为JIntellitype注册的是<strong>全局快捷键</strong>，在其他软件中按下<code>ctrl+s</code>进行保存文档的时候，系统会误认为是调用了保存图片。这样是不对的。这里解决方法是吧保存图片快捷键改成<code>ctrl+alt+s</code>。局部快捷键怎么设置为还不知道。先别管他，能用就行了，我先去学点其他东西。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/d2e9fa85/">截图文字识别软件升级</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 我的软件 </category>
          
          <category> 截图文字识别 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java Web从入门到精通 第1章 Java Web成功案例</title>
      <link href="/blog/5f77ba72/"/>
      <url>/blog/5f77ba72/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p><strong>Java语言具有很多的优点,例如面向对象、跨越平台、安全性高等,</strong>很多的大型企业级的应用都采用 Java Web进行开发。目前, Java Web开发的项目已经有很多成功案例,它们被应用于实际生活中的各行各业,例如清华大学的本科招生网、金网在线网等。<br>还有一些涉及安全级别非常高或需要多平台运行的,其<strong>银行类的项目应用较多</strong>,例如中国工商银行网站、中国光大银行网站、中国农业银行网站、中国建设银行网站、交通银行网站和中国邮政储蓄银行网站等,这些网站都应用了 Java Web技术。<br>上述的这些案例,只是一部分代表,应用 Java Web开发的项目还有很多,其成功案例数不胜数</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/5f77ba72/">Java Web从入门到精通 第1章 Java Web成功案例</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Java Web从入门到精通 </category>
          
          <category> 第1章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>快速使用NotePad++打开文件</title>
      <link href="/blog/951a2add/"/>
      <url>/blog/951a2add/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>在写文章的时候，我喜欢使用MarkdownPad2来写。不过MarkdownPad2好像不支持正则表达式替换。NotePad++支持正则表达式替换，每次频繁切换到桌面去打开NotePad++，使用正则表达式的功能，然后再切换回MarkdownPad2,显然很浪费时间,要是有人知道，有支持正则表达式的markdown编辑器，请告诉我。<br>我这里的做法是，使用运行窗口来快速打开notePad++,文件的地址通过快捷方式传给NotePad++。<br>步骤如下：<br><a id="more"></a><br>首先，把NotePad++的路径配置到Path环境变量中。</p><p>然后在markdownPad2中，复制markdown文档的路径。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/gaoxiao/MarkdwonPad2%E4%B8%AD%E5%8F%AF%E4%BB%A5%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84.png?q-sign-algorithm=sha1&amp;q-ak=AKIDPisreGs5avKdljcJrFTaGMSPG0d6Bntx&amp;q-sign-time=1538188964;1538189864&amp;q-key-time=1538188964;1538189864&amp;q-header-list=&amp;q-url-param-list=&amp;q-signature=2b048bc54f6da441e560b0fded423072d0ff113b" alt=""><br>然后按下Win+r快捷键打开运行窗口，输入命令:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notepad++ D:\Blog\bolg5\source\_posts\读书笔记\Java Web从入门到精通\第一章\Web应用技术.md</span><br></pre></td></tr></table></figure><p></p><p>这样就可以，使用notepad++快速打开这篇文章了。当然其他软件也类似打开文件也类似。打开之后我就可以愉快地使用notepad++的正则表达式替换功能了。<br>最后说一下，除了Notepad++，支持正则表达式的编辑器也很多，如eidtplus,VSCode等等。但是这些编辑器都不是专门用来写MarkDown的，主要是这些编辑器没有写markdown的快捷方式。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/951a2add/">快速使用NotePad++打开文件</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
          <category> Windows相关 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>CSS 3的新特征</title>
      <link href="/blog/3e61fe50/"/>
      <url>/blog/3e61fe50/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>1、模块与模块化结构<br>2、一个简单的CSS 3实例<br><a id="more"></a><br>从2010年开始,HTML5和CSS3就一直是互联网技术中最受关注的两个话题。<strong>CSS3是CSS技术的一个升级版本</strong>,<strong>是由</strong> Adobe Systems、 Apple、 Google、HP、IBM、 Microsoft、 Mozilla、 Opera、Sun、Microsystems等<strong>许多Web界的巨头联合组成的一个名为 CSS Working Group的组织共同协商策划的</strong>。虽然目前很多细节还在讨论中,但还是不断地向前发展着。</p><h2 id="模块与模块化结构"><a href="#模块与模块化结构" class="headerlink" title="模块与模块化结构"></a>模块与模块化结构</h2><p>在CSS 3中，并没有采用总体结构，而是<strong>采用了分工协作的模块化结构</strong>。采用这种模块化结构，<strong>是为了避免产生浏览器对于某个模块支持不完全的情况</strong>。如果把整体分成几个模块，各浏览器可以选择支持哪个模块，不支持哪个模块。例如，普通电脑中的浏览器和手机上用的浏览器应该针对不同的模块进行支持。<strong>如果采用模块分工协作的话。不同设备上所用的浏览器都可以选用不同模块进行支持，方便了程序的开发</strong>。CSS3中的常用模块如下表所示。</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">列名</th><th style="text-align:left">列名</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">basic box model</td><td style="text-align:left">定义各种与盒子相关的样式</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">Line</td><td style="text-align:left">定义各种与直线相关的样式</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">Lists</td><td style="text-align:left">定义各种与列表相关的样式</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">Text</td><td style="text-align:left">定义各种与文字相关的样式</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">Color</td><td style="text-align:left">定义各种与颜色相关的样式</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">Font</td><td style="text-align:left">定义各种与字体相关的样式</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">Background and border</td><td style="text-align:left">定义各种与背景和边框相关的样式</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left">Paged Media</td><td style="text-align:left">定义各种页眉、页脚、页数等页面元素数据的样式</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left">Writing Modes</td><td style="text-align:left">定义页面中文本数据的布局方式</td></tr></tbody></table><h2 id="一个简单的CSS-3实例"><a href="#一个简单的CSS-3实例" class="headerlink" title="一个简单的CSS 3实例"></a>一个简单的CSS 3实例</h2><p>对CSS 3中模块的概念有了一定的理解之后，本节通过实例为大家介绍CSS 3与CSS 2在页面设计中的区别。<strong>在CSS 2中如果要对页面中文字添加彩色边框，可以通过DIV层来进行控制</strong>，下面为大家介绍一个CSS 3应用实例。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>在CSS2中使用DIV层对页面中的文字添加彩色边框：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>使用CSS2对页面中的文字添加彩色边框<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-id">#boarder</span> &#123;</span></span><br><span class="line"><span class="undefined">margin: 3px;</span></span><br><span class="line"><span class="undefined">width: 180px;</span></span><br><span class="line"><span class="undefined">padding-left: 14px;</span></span><br><span class="line"><span class="undefined">border-width: 5px;</span></span><br><span class="line"><span class="undefined">border-color: blue;</span></span><br><span class="line"><span class="undefined">border-style: solid;</span></span><br><span class="line"><span class="undefined">height: 120px;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"boarder"</span>&gt;</span> 文字一</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span> 文字二</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span> 文字三</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span> 文字四</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span> 文字五</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>在 Firefox浏览器中运行该实例,结果如下图所示：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/Java%20Web%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/2/CSS3/css2_color_border.png" alt=""></p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>在CSS3中使用 border-radius属性对页面中的文字添加边框:<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-id">#boarder</span> &#123;</span></span><br><span class="line"><span class="undefined">border: solid 5px blue;</span></span><br><span class="line"><span class="undefined">                    </span></span><br><span class="line"><span class="undefined">border-radius: 20px;</span></span><br><span class="line"><span class="undefined">-moz-border-radius: 20px;</span></span><br><span class="line"><span class="undefined">padding: 20px;</span></span><br><span class="line"><span class="undefined">width: 180px;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"boarder"</span>&gt;</span> 文字一</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span> 文字二</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span> 文字三</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span> 文字四</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span> 文字五</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><hr><p><strong>说明</strong><br>在使用 border-radius属性时,如果使用 Firefox浏览器,需要将样式代码书写成“<code>- moz-border-radius</code>”;如果使用 Safari浏览器,需要将样式代码书写成“ <code>webkit-border-radius</code>“;如果使用 Opera浏览器,需要将样式代码书写成\” border-radius;如果使用 Chrome浏览器,需要将样式代码书写成“ <code>border-radius</code>”或“ <code>webkit-border-radius</code>”的形式</p><hr><p>在 Firefor浏览器中运行该实例,结果如下图所示。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/Java%20Web%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/2/CSS3/css3_color_border.png" alt=""><br>在上面的两个实例中,都是对页面中的文字添加了边框,但是如果在这两个实例中多添加几行文字,即可发现运行结果的变化,使用CSS2的版本中文字将溢出边框：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/Java%20Web%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/2/CSS3/css2_color_border_moreWorlds.png" alt=""><br>而CSS3中边框的文字不会溢出:<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/Java%20Web%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/2/CSS3/css3_color_border_moreWorlds.png" alt=""><br>在CSS3中新增的各种各样的属性,可以摆脱CSS2中存在的很多束缚,从而使整个网站的界面设计进入一个新的台阶。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/3e61fe50/">CSS 3的新特征</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Java Web从入门到精通 </category>
          
          <category> 第2章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>CSS样式表</title>
      <link href="/blog/6780a5e1/"/>
      <url>/blog/6780a5e1/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>1、CSS规则<br>2、选择器<br>3、在页面中包含CSS<br><a id="more"></a><br>CSS是W3C协会为弥补HTML在显示属性设定上的不足而制定的一套扩展样式标准,它的<strong>全称是 Cascading Style Sheet</strong>. <strong>CSS标准中重新定义了HTML中原来的文字显示样式</strong>,增加了一些新概念,如类、层等,可以对文字重叠、定位等。在CSS还没有引入到页面设计之前,传统的HTML语言要实现页面美化在设计上是十分麻烦的,例如要设计页面中文字的样式,如果使用传统的HTML语句来设计页面就不得不在每个需要设计的文字上都定义样式。CSS的出现改变了这一传统模式。</p><h2 id="CSS规则"><a href="#CSS规则" class="headerlink" title="CSS规则"></a>CSS规则</h2><p><strong>在CSS样式表中包括<code>3部分内容</code>：<code>选择符</code>、<code>属性</code>和<code>属性值</code></strong>。语法格式为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择符&#123;属性:属性值;&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li><strong>选择符：又称选择器</strong>，是CSS中很重要的概念，<strong>所有HTML语言中的标记都是通过不同的CSS选择器进行控制的</strong>。</li><li><strong>属性</strong>：<strong>主要包括字体属性、文本属性、背景属性、布局属性、边界属性、列表项目属性、表格属性等内容</strong>。<code>其中一些属性只有部分浏览器支持</code>，因此使CSS属性的使用变得更加的复杂。</li><li><strong>属性值</strong>：为某属性的有效值。<strong>属性与属性值之间以“:”号(英文冒号)分隔</strong>。<strong>当有多个属性时，使用“;”(英文分号)分隔</strong>。图2.17为大家标注了CSS语法中的选择器、属性与属性值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    h2 &#123;</span><br><span class="line">        font-family: 宋体;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/Java%20Web%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/2/CSS%E8%AF%AD%E6%B3%95.png" alt=""></p><h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><p><strong>CSS选择器</strong>常用的是<code>标记选择器</code>、<code>类选择器</code>、<code>包含选择器</code>、<code>ID选择器</code>等。<strong>使用选择器即可对不同的HTML标签进行控制，来实现各种效果</strong>。</p><h3 id="标记选择器"><a href="#标记选择器" class="headerlink" title="标记选择器"></a>标记选择器</h3><p>大家知道HTML页面是由很多标记组成，例如图片标记<code>&lt;img&gt;</code>、超链接标记<code>&lt;a&gt;</code>、表格标记<code>&lt;table&gt;</code>等。而CSS标记选择器就是声明页面中哪些标记采用哪些CSS样式。例如a选择器，就是用于声明页面中所有<code>&lt;a&gt;</code>标记的样式风格。<br></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    a&#123;</span><br><span class="line">        font-size: <span class="number">9</span>px;</span><br><span class="line">        color:#F93;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p></p><h3 id="2-类别选择器"><a href="#2-类别选择器" class="headerlink" title="2.类别选择器"></a>2.类别选择器</h3><p>使用标记选择器非常快捷,但是会有一定的局限性,如果声明标记选择器,那么页面中所有该标记内容会有相应的变化。假如页面中有3个</p><h2>标记,如果想要每个h2&gt;的显示效果都不一样,使用标记选择器就无法实现了,这时就需要引入类别选择器。<br>类别选择器的名称由用户自己定义,并以“<code>.</code>”号开头,定义的属性与属性值也要遵循CSS规范。要应用类别选择器的HTML标记，只需要使用class属性来声明即可。<p></p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>使用类别选择器控制页面中字体的样式<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--以下为定义的CSS样式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="comment">/* 定义类名为one的类别选择器*/</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-class">.one</span> &#123;</span></span><br><span class="line"><span class="css"><span class="comment">/* 定义字体 */</span></span></span><br><span class="line"><span class="undefined">font-family: 宋体;</span></span><br><span class="line"><span class="css"><span class="comment">/* 定义字体大小 */</span></span></span><br><span class="line"><span class="undefined">font-size: 24px;</span></span><br><span class="line"><span class="css"><span class="comment">/* 定义字体颜色 */</span></span></span><br><span class="line"><span class="css"><span class="selector-tag">color</span><span class="selector-pseudo">:red</span>;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-class">.two</span> &#123;</span></span><br><span class="line"><span class="undefined">font-family: 宋体;</span></span><br><span class="line"><span class="undefined">font-size: 16px;</span></span><br><span class="line"><span class="css"><span class="selector-tag">color</span><span class="selector-pseudo">:green</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-class">.three</span> &#123;</span></span><br><span class="line"><span class="undefined">font-family: 宋体;</span></span><br><span class="line"><span class="undefined">font-size: 12px;</span></span><br><span class="line"><span class="undefined">color: blue;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--定义样式后页面会自动加载样式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"one"</span>&gt;</span> 应用了类选择器one <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"two"</span>&gt;</span>应用了类选择器two<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"three"</span>&gt;</span>应用了类选择器three <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>在上面的代码中,页面中的第一个<code>&lt;h2&gt;</code>标记应用了one选择器,第二个<code>&lt;h2&gt;</code>标记应用了two选项器,第3个<code>&lt;h2&gt;</code>标记应用了 three选择器。运行结果如下图所示。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/Java%20Web%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/2/CSS%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8.png" alt=""></p><hr><p><strong>说明</strong><br>在HTML标记中,不仅可以应用一种类别选择器,也可以应用多种类别选择器,这样可使HIML标记同时加载多个类别选择器的样式。在多种类别选择器之间用空格进行分割即可,例如<code>&lt;h2 class=&quot;size color&quot;&gt;</code>。size这个类选择器设置该标签的字体，color这个类选择器设置该标签的颜色。</p><hr><h3 id="3-id选择器"><a href="#3-id选择器" class="headerlink" title="3.id选择器"></a>3.id选择器</h3><p>id选择器是通过HTML页面中的id属性来选择增添样式,与类别选择器基本相同。但需要注意的是,由于HTML页面中不能包含两个相同的id标记,因此定义的id选择器也就只能被使用一次命。</p><p>命名id选择器要以“#”号开始,后加HTML标记中的id属性值。<br>实例: 使用id选择器控制页面中字体的样式。<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--以下为定义的CSS样式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="comment">/* 定义id选择器 */</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-id">#first</span> &#123;</span></span><br><span class="line"><span class="undefined">font-size: 48px;</span></span><br><span class="line"><span class="undefined">color: red;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-id">#second</span> &#123;</span></span><br><span class="line"><span class="undefined">font-size: 36px;</span></span><br><span class="line"><span class="undefined">color: green;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-id">#three</span> &#123;</span></span><br><span class="line"><span class="undefined">font-size: 18px;</span></span><br><span class="line"><span class="undefined">color: blue;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="comment">/* 定义类选择器，让文本居中  */</span></span></span><br><span class="line"><span class="css"><span class="selector-class">.center</span> &#123;</span></span><br><span class="line"><span class="undefined">text-align: center;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 一个标签只能有一个id属性值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"first"</span>&gt;</span>first<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"second"</span>&gt;</span>second<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 一个标签可以有多个class属性值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"three"</span> <span class="attr">class</span>=<span class="string">"center red"</span>&gt;</span>three<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>显示效果：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/Java%20Web%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/2/ID%E9%80%89%E6%8B%A9%E5%99%A8.png" alt=""></p><h2 id="在页面中包含CSS"><a href="#在页面中包含CSS" class="headerlink" title="在页面中包含CSS"></a>在页面中包含CSS</h2><p>在对CSS有了一定的了解后,下面介绍如何实现在页面中包含CSS样式的几种方式,其中包括<code>行内样式</code>、<code>内嵌式</code>和<code>链接式</code>。</p><h3 id="行内样式"><a href="#行内样式" class="headerlink" title="行内样式"></a>行内样式</h3><p>行内样式是比较直接的一种样式,直接定义在HTML标记之内,通过标签中的<strong> style属性来实现</strong>。这种方式比较容易令初学者接受,但是灵活性不强。</p><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><p>通过行内定义样式的形式,实现控制页面文字的颜色和大小<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">border</span>=<span class="string">"1"</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--在页面中定义表格--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color:yellow; font-size:36px;"</span>&gt;</span>行内样式一<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--在页面文字中定义CSS样式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color:red; font-size:24px;"</span>&gt;</span>行内样式二<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color:green; font-size:18px;"</span>&gt;</span>行内样式三<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color:blue; font-size:14px;"</span>&gt;</span>行内样式四<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>显示效果：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/Java%20Web%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/2/CSS%E8%A1%8C%E5%86%85%E6%A0%B7%E5%BC%8F.png" alt=""></p><h3 id="2-内嵌式"><a href="#2-内嵌式" class="headerlink" title="2.内嵌式"></a>2.内嵌式</h3><p><strong>内嵌式样式表就是在页面中使用<code>&lt;style&gt;&lt;/style&gt;</code>标记将CSS样式包含在页面中</strong>。内嵌式样式表的形式没有行内标记表现的直接,但是能够使页面更加规整。<br><strong>与行内样式相比,内嵌式样式表更加便于维护</strong>。但是每个网站都不可能由一个页面构成,而每个页面中相同的HTML标记又都要求有相同的样式,此时使用内嵌式样式表就显得比较笨重,而使用链接式样式表即可轻松解决这一问题。</p><h3 id="3-链接式"><a href="#3-链接式" class="headerlink" title="3.链接式"></a>3.链接式</h3><p><strong>链接外部CSS样式表是最常用的一种引用样式表的方式</strong>,将CSS样式定义在一个单独的文件中,然后在HTML页面中通过<code>&lt;link&gt;</code>标记引用,是一种最为有效的使用CSS样式的方式。<br><code>&lt;link&gt;</code>标记的语法结构如下:<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"path"</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>参数说明:</p><ul><li>rel: 定义外部文档和调用文档间的关系。</li><li>href: CSS文档的绝对或相对路径。</li><li>type: 指的是外部文件的MIME类型。</li></ul><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>&#123;<span class="comment">/*定义CSS样式 */</span></span><br><span class="line"><span class="attribute">color</span>:red;</span><br><span class="line"><span class="attribute">font-family</span>:<span class="string">"Trebuchet MS"</span>, Arial, Helvetica, sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line"><span class="attribute">color</span>:blue;<span class="comment">/*定义颜色*/</span></span><br><span class="line"><span class="attribute">font-weight</span>:<span class="number">200</span>;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">16px</span>;<span class="comment">/*设置字体大小*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)在页面中通过<code>&lt;link&gt;</code>标记将CSS样式表引入到页面中,此时CSS样式表定义的内容将自动加载到页面中。代码如下:<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>通过链接形式引入CSS样式<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--页面引入CSS样式表--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css.css"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--在页面中添加文字--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>显示效果如下图所示：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/Java%20Web%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/2/CSS_%E9%93%BE%E6%8E%A5%E5%BC%8F.png" alt=""></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/6780a5e1/">CSS样式表</a></p></h2><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Java Web从入门到精通 </category>
          
          <category> 第2章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>HTML5新增内容</title>
      <link href="/blog/994450b9/"/>
      <url>/blog/994450b9/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>1、新增元素<br>2、新增的input元素类型<br><a id="more"></a></p><p>自从<strong>2010年HTML5正式推出</strong>以来，就以一种惊人的速度被迅速的推广，世界各知名浏览器厂商也对HTML5有很好的支持。例如微软就对下一代IE9做了标准上的改进，使其能够支持HTML5。而且<strong>HTML5还有一个特点是在老版本的浏览器上也可以正常运行</strong>。本节将为大家介绍与HTML4相比HTML5新增的元素与属性。</p><hr><p><strong>注意</strong><br>HTML5的出现代表着Web开进入了一个新的时代,但是并不表示现在用HTML4开发的网站要重新创建。因为HTML5内部功能并不是革命性的,而是发展性的。这正是HTML5兼容性的体验。</p><hr><h1 id="HTML5新增内容"><a href="#HTML5新增内容" class="headerlink" title="HTML5新增内容"></a>HTML5新增内容</h1><p>在HTML5中,新增了以下元素。</p><h2 id="lt-section元素-gt"><a href="#lt-section元素-gt" class="headerlink" title="&lt;section元素&gt;"></a>&lt;section元素&gt;</h2><p><strong><code>&lt;section&gt;</code>元素表示页面中的一个<code>区域</code></strong>。比如章节、页眉、页脚或页面中的其他部分。可以与h1、h2、h3、h4等元素结合起来使用，标示文档结构。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>section标记的使用<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>完成百分比：100%<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"请单击"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure><p>显示效果:</p><hr><p><section><h2>section标记的使用</h2><p>完成百分比：100%</p><input type="button" value="请单击"></section></p><hr><p>上面这段代码相当于在HTML4中使用<code>&lt;div&gt;</code>标记在页面中定义一个区域。</p><h3 id="lt-acticle-gt-元素"><a href="#lt-acticle-gt-元素" class="headerlink" title="&lt;acticle&gt;元素"></a><code>&lt;acticle&gt;</code>元素</h3><p><code>&lt;acticle&gt;</code>元素表示页面中的<code>一块与上下文不相关的独立内容</code>,例如博客中的一篇文章、一段用户评论等。除了内容部分,一个<code>&lt;acticle&gt;</code>元素通常有自己的标题、脚注等内容。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;acticle&gt;</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">        &lt;h1&gt;标题&lt;/h1&gt;</span><br><span class="line">    &lt;/header&gt;</span><br><span class="line">        &lt;p&gt;内容内容内容内容&lt;/p&gt;</span><br><span class="line">    &lt;footer&gt;</span><br><span class="line">        &lt;p&gt;脚注&lt;/p&gt;</span><br><span class="line">    &lt;/footer&gt;</span><br><span class="line">&lt;/acticle&gt;</span><br></pre></td></tr></table></figure><p></p><p>显示效果：</p><hr><p><acticle><header><h1>标题</h1></header><p>内容内容内容内容</p><footer><p>脚注</p></footer></acticle></p><hr><h4 id="lt-header-gt-元素"><a href="#lt-header-gt-元素" class="headerlink" title="&lt;header&gt;元素"></a><code>&lt;header&gt;</code>元素</h4><p><code>&lt;header&gt;</code>元素表示页面中<strong>一个内容区域中或整个页面的标题</strong></p><h4 id="lt-footer-gt-元素"><a href="#lt-footer-gt-元素" class="headerlink" title="&lt;footer&gt;元素"></a><code>&lt;footer&gt;</code>元素</h4><p><code>&lt;footer&gt;</code>元素表示整个页面或页面中<strong>一个内容区域块的<code>脚注</code></strong>。例如日期、作者信息等。</p><h4 id="lt-aside-gt-元素"><a href="#lt-aside-gt-元素" class="headerlink" title="&lt;aside&gt;元素"></a><code>&lt;aside&gt;</code>元素</h4><p><code>&lt;aside&gt;</code>元素用来表示<strong>当前页面或文章的<code>附属信息部分</code></strong>。可以包含与当前页面或主要内容相关的引用、侧边栏、广告、导航条等信息。<br><strong>实例</strong><br>应用<code>&lt;aside&gt;</code>元素定义页面侧栏。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;测试aside标签&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;aside&gt;</span><br><span class="line">        &lt;nav&gt;</span><br><span class="line">            &lt;h2&gt;侧栏&lt;/h2&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li&gt;</span><br><span class="line">                    &lt;a href=&quot;#&quot;&gt;侧边栏1&lt;/a&gt; 2011-9-27</span><br><span class="line">                &lt;/li&gt;</span><br><span class="line">                &lt;li&gt;</span><br><span class="line">                    &lt;a href=&quot;#&quot;&gt;侧边栏2&lt;/a&gt; 2011-9-27</span><br><span class="line">                &lt;/li&gt;</span><br><span class="line">                &lt;li&gt;</span><br><span class="line">                    &lt;a href=&quot;#&quot;&gt;侧边栏2&lt;/a&gt; 2011-9-27</span><br><span class="line">                &lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">        &lt;/nav&gt;</span><br><span class="line">    &lt;/aside&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p></p><p>显示效果：我看不出来有什么效果。</p><h2 id="新增input元素类型"><a href="#新增input元素类型" class="headerlink" title="新增input元素类型"></a>新增input元素类型</h2><p>HTML5中新增了很多input元素类型，这些新增元素的添加可以使程序员更加方便的创建页面。HTML5新增的input元素类型如下：</p><ul><li>email：将input元素的类型设置为email，表示文本框必须输入E-mail地址。</li><li>url：url表示必须输入URL地址。</li><li>number：表示必须输入数值的文本框。</li><li>range：表示必须输入一定范围内数字值的文本输入框。</li></ul><h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>HTML5新增Input表单<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"a.jsp"</span> <span class="attr">method</span>=<span class="string">"GET"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"right"</span>&gt;</span>邮箱:<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"left"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"email"</span> <span class="attr">name</span>=<span class="string">"email"</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"right"</span>&gt;</span>URL:<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"left"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"url"</span> <span class="attr">name</span>=<span class="string">"url"</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"right"</span>&gt;</span>整数:<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"left"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">name</span>=<span class="string">"number"</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"right"</span>&gt;</span>随机数<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"left"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"range"</span> <span class="attr">name</span>=<span class="string">"range"</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"submit1"</span> <span class="attr">id</span>=<span class="string">"submit1"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在输入信息的时候，浏览器会检查输入的信息，如果输入的信息不对会提示错误。如下图所示：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/Java%20Web%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/2/HTML5%E6%96%B0%E5%A2%9E%E7%9A%84input%E7%B1%BB%E5%9E%8B.png" alt=""><br>输入正取的格式：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/Java%20Web%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/2/HTML5%E6%AD%A3%E7%A1%AE%E8%BE%93%E5%85%A5.png" alt=""><br>提交结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file:///C:/Users/lan/Desktop/a.jsp?email=123@123.com&amp;url=file:///C:/Users/lan/Desktop/HTML5%E6%96%B0%E5%A2%9Einput%E8%A1%A8%E5%8D%95.html&amp;number=3&amp;range=54&amp;submit1=提交查询</span><br></pre></td></tr></table></figure><p></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/994450b9/">HTML5新增内容</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Java Web从入门到精通 </category>
          
          <category> 第2章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>正则实例：markdown文档中给HTML标记加反引号</title>
      <link href="/blog/de8eb4f9/"/>
      <url>/blog/de8eb4f9/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文介绍在NotePad++中使用正则表达式,对HTML标签加反引号,进而对Markdown文档中的HTML标签进行”转义”。<br><a id="more"></a></p><p>写到HTML这章的时候，在Markdown中添加了好多html标记，这样会引起文章渲染乱码。所以需要都让对一些HTML标记进行”转义”。我这里的做法是，使用反引号把HTML标记包裹起来。如下所示:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`&lt;h1&gt;`</span><br></pre></td></tr></table></figure><p></p><p>这样渲染的时候就以代码的方式渲染，而不是渲染为HTML标记。我写文章用的是MarkdownPad2,因为MarkdownPad2的快捷键很好用。不过MarkdownPad2好像只支持正则表达查找，不能替换，更不支持正则表达式替换。后来发现<strong>NotePad++支持正则表达式替换</strong>。<br>所以，就用<strong>NotePad++来完成正则表达式替换功能</strong>。</p><p>匹配HTML标签的正则表达式:<code>(&lt;/?[a-zA_Z]*&gt;)</code>。<br>在这个HTML标签两边加上反引号”转义”：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`\1`</span><br></pre></td></tr></table></figure><p></p><p>这里使用括号捕获这个HTML标签。然后使用反向引用<code>\1</code>即可引用到这个刚匹配的文本，用反引号包裹起来，替换掉原来的文本即可实现我的要求。<br>具体设置如下图所示:<br><a href="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/Java%20Web%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/2/Notepad%2B%2B%E6%AD%A3%E5%88%99%E6%9B%BF%E6%8D%A2.png" target="_blank" rel="noopener">https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/Java%20Web%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/2/Notepad%2B%2B%E6%AD%A3%E5%88%99%E6%9B%BF%E6%8D%A2.png</a><br>最后，说一下，NotePad++打开替换的快捷键是:<code>ctrl+H</code>。当然，这个正则表达式并不严谨，但是对我来说已经够用了。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/de8eb4f9/">正则实例：markdown文档中给HTML标记加反引号</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 正则表达式 </category>
          
          <category> 实例 </category>
          
          <category> 匹配HTML标签 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>HTML标记语言</title>
      <link href="/blog/b3e1ff37/"/>
      <url>/blog/b3e1ff37/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>1、创建第一个HTML文件<br>2、HTML文档结构<br>3、HTML常用标记<br>4、表格标记<br>5、超链接与图片标记<br><a id="more"></a><br>HTML是一种在互联网上常见的网页制作标注性语言,<strong>并不能算作一种程序设计语言</strong>.</p><hr><p>通常说的<strong>编程语言是指的那些实现代码逻辑和处理计算的语言</strong>，。<br>而<strong>HTML只是对于数据的标记，而不能用于对数据进行处理。所以不是编程语言！</strong></p><hr><p>HTML是通过浏览器的翻译,将网页中的内容呈现给用户。对于网站设计人员来说,只使用HTML是不够的,需要在页面中引入CSS样式。<strong>HTML与CSS的关糸是“内容”与“形式的关条,由HTML来确定网页的内容,CSS来实现页面的表现形式</strong>。HTML与CSS的完美搭配使页面更加美观、大方,且容易维护。</p><p>在浏览器的地址栏中输入一个网址,就会展示出相应的网页内容。在网页中包含有很多内容,如文字、图片、动画,以及声音和视频等。网页的最终目的是为访问者提供有价值的信息。提到网页设计不得不提到HTML标记语言,<strong>HTML全称 Hypertext Markup Language</strong>,译为<strong>超文本标记语言</strong>HTML用于描述超文本中内容的显示方式。使用HTML可以实现在网页中定义一个标题、文本或者表格等。本节将详细介绍HTML标记语言。</p><h2 id="创建第一个HTML文件"><a href="#创建第一个HTML文件" class="headerlink" title="创建第一个HTML文件"></a>创建第一个HTML文件</h2><p>编写HTML文件可以通过两种方式，一种是手工编写HTML代码，另一种是借助一些开发软件，比如Adobe公司的Dreamweaver或者微软公司的Expression Web这样的网页制作软件。在Windows操作系统中，最简单的文本编辑软件就是记事本。</p><h2 id="HTML文档结构"><a href="#HTML文档结构" class="headerlink" title="HTML文档结构"></a>HTML文档结构</h2><p><strong>HTML文档由4个主要标记组成，这4个标记主要有<code>&lt;html&gt;</code>、<code>&lt;head&gt;</code>、<code>&lt;title&gt;</code>、<code>&lt;body&gt;</code>。他们构成了HTML页面最基本的元素。</strong></p><h3 id="lt-html-gt-标记"><a href="#lt-html-gt-标记" class="headerlink" title="&lt;html&gt;标记"></a><code>&lt;html&gt;</code>标记</h3><ul><li><strong><code>&lt;html&gt;</code>标记是HTML文件的开头。所有HTML文件都是以<code>&lt;html&gt;</code>标记开头，以<code>&lt;/html&gt;</code>标记结束。</strong>HTML页面的所有标记都要放置在<code>&lt;html&gt;</code>与<code>&lt;/html&gt;</code>标记中,<code>&lt;html&gt;</code>标记并没有实质性的功能,但却是HTML文件不可缺少的内容。</li></ul><hr><p><strong>说明</strong><br><strong>HTML标记是不区分大小写的。</strong></p><hr><h3 id="lt-head-gt-标记"><a href="#lt-head-gt-标记" class="headerlink" title="&lt;head&gt;标记"></a><code>&lt;head&gt;</code>标记</h3><ul><li><strong><code>&lt;head&gt;</code>标记是HTML文件的头标记</strong>，作用是放置HTML文件的信息。。如定义CSS样式代码可放置在<code>&lt;head&gt;</code>与<code>&lt;/head&gt;</code>标记中。</li></ul><h3 id="lt-title-gt-标记"><a href="#lt-title-gt-标记" class="headerlink" title="&lt;title&gt;标记"></a><code>&lt;title&gt;</code>标记</h3><ul><li><strong><code>&lt;title&gt;</code>标记为标题标记</strong>。可将<strong>网页的标题</strong>定义在<code>&lt;title&gt;</code>与<code>&lt;/title&gt;</code>标记之中。</li></ul><h3 id="lt-body-gt-标记"><a href="#lt-body-gt-标记" class="headerlink" title="&lt;body&gt;标记"></a><code>&lt;body&gt;</code>标记</h3><ul><li><strong><code>&lt;body&gt;</code>是HTML页面的主体标记</strong>。页面中的所有内容都定义在<code>&lt;body&gt;</code>标记中。<code>&lt;body&gt;</code>标记也是成对使用的。<body>标记本身也具有控制页面的一些特性,例如控制页面的背景图片和颜色等。</body></li></ul><h2 id="HTML常用标记"><a href="#HTML常用标记" class="headerlink" title="HTML常用标记"></a>HTML常用标记</h2><p>HTML中提供了很多标记，可以用来设计页面中的文字、图片，定义超链接等。这些标记的使用可以使页面更加的生动，下面为大家介绍HTML中的常用标记。</p><h3 id="换行标记"><a href="#换行标记" class="headerlink" title="换行标记"></a>换行标记</h3><p>要让网页中的文字实现换行，在HTML文件中输入换行符（“Enter键”）是没有用的，如果要让页面中的文字实现换行，就必须用一个标记告诉浏览器在哪里要实现换行操作。<strong>在HTML语言中，换行标记为“<code>&lt;br&gt;</code>”</strong>。<br>前面为大家介绍的HTML标记不同,<strong>换行标记是一个单独标记,不是成对出现的</strong>。</p><h3 id="段落标记"><a href="#段落标记" class="headerlink" title="段落标记"></a>段落标记</h3><p>HTML中的段落标记也是一个很重要的标记，<strong>段落标记以<code>&lt;p&gt;</code>标记开头，以<code>&lt;/p&gt;</code>标记结束</strong>。<strong>段落标记在<code>段前</code>和<code>段后</code>各添加一个空行</strong>，而定义在段落标记中的内容，不受该标记的影响。</p><h3 id="标题标记"><a href="#标题标记" class="headerlink" title="标题标记"></a>标题标记</h3><p>要在HTML页面中创建不同级别的标题，可以使用HTML语言中的标题标记。在<strong>HTML标记中，设定了6个标题标记，分别为<code>&lt;h1&gt;</code>至<code>&lt;h6&gt;</code></strong>，其中<code>&lt;h1&gt;</code>代表1级标题，<code>&lt;h2&gt;</code>代表2级标题，<code>&lt;h6&gt;</code>代表6级标题等。<strong>数字越小，表示级别越高，文字的字体也就越大</strong>。</p><h3 id="居中标记"><a href="#居中标记" class="headerlink" title="居中标记"></a>居中标记</h3><p>HTML页面中的内容有一定的布局方式，<strong>默认的布局方式是从左到右依次排序</strong>。<strong>如果要想让页面中的内容在页面的居中位置显示，可以使用HTML中的<code>&lt;center&gt;</code>标记</strong>。<strong><code>&lt;center&gt;</code>居中标记以<code>&lt;center&gt;</code>标记开头，以<code>&lt;/center&gt;</code>标记结尾。标记之中的内容为居中显示</strong>。</p><h3 id="文字列表标记"><a href="#文字列表标记" class="headerlink" title="文字列表标记"></a>文字列表标记</h3><p>HTML语言中提供了文字列表标记，文字列表标记可以将文字以列表的形式依次排列。通过这种形式可以更加的方便网页的访问者。<strong>HTML中的列表标记主要有<code>无序的列表</code>和<code>有序的列表</code>两种。</strong></p><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><p>无序列表顾名思义，无序列表就是列表结构中的列表项没有先后顺序的列表形式。大部分网页应用中的列表均采用无序列表，无序列表在每个列表项的前面添加一个圆点符号。通过标签<code>&lt;ul&gt;&lt;/ul&gt;</code>可以创建一组无序列表,其中每一个列表项以<code>&lt;li&gt;列表&lt;/li&gt;</code>表示。下面的实例为大家演示了无序列表的应用。<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项一<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项二<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项三<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项四<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项五<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>显示效果:</p><p><ul><li>列表项一</li><li>列表项二</li><li>列表项三</li><li>列表项四</li><li>列表项五</li></ul></p><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><p>有序列表和无序列表的区别是，<strong>使用有序列表标记可以将列表项进行排号</strong>。<strong>有序列表的标记为<code>&lt;ol&gt;</code>，每一个列表项前使用<code>&lt;li&gt;</code></strong>。有序列表中项目项是有一定的顺序的。下面是有序列表的例子<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项一<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项二<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项三<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项四<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项五<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>显示效果：<ol><li>列表项一</li><li>列表项二</li><li>列表项三</li><li>列表项四</li><li>列表项五</li></ol></p><h3 id="表格标记"><a href="#表格标记" class="headerlink" title="表格标记"></a>表格标记</h3><p>表格是网页中十分重要的组成元素。表格用来存储数据。<strong>表格包含<code>标题</code>、<code>表头</code>、<code>行</code>和<code>单元格</code></strong>。在HTML语言中,表格标记使用符号<strong><table></table></strong>表示。定义表格仅使用<code>&lt;table&gt;</code>是不够的,还需要定义表格中的<code>行</code>、<code>列</code>、<code>标题</code>等内容。在HIML页面中定义表格,需要学会以下几个标记。</p><h4 id="表格标记-lt-table-gt"><a href="#表格标记-lt-table-gt" class="headerlink" title="表格标记&lt;table&gt;"></a>表格标记<code>&lt;table&gt;</code></h4><p><code>&lt;table&gt;...&lt;/table&gt;</code>标记表示整个表格。<code>&lt;table&gt;</code>标记中有很多属性,例如 <strong>width属性用来设置表格的宽度, border属性用来设置表格的边框, align属性用来设置表格的对齐方式, bgcolor属性用来设置表格的背景色等</strong>。</p><h4 id="标题标记-lt-caption-gt"><a href="#标题标记-lt-caption-gt" class="headerlink" title="标题标记&lt;caption&gt;"></a>标题标记<code>&lt;caption&gt;</code></h4><p>标题标记以<code>&lt;caption&gt;</code>开头,以<code>&lt;/caption&gt;</code>结束,标题标记也有一些属性,例如 <code>align</code>,<code>valign</code>等。</p><h4 id="表头标记-lt-th-gt"><a href="#表头标记-lt-th-gt" class="headerlink" title="表头标记&lt;th&gt;"></a>表头标记<code>&lt;th&gt;</code></h4><p>表头标记以<code>&lt;th&gt;</code>开头,以<code>&lt;/th&gt;</code>结束,也可以通过 align、 background、 colspan(列跨度,用于合并单元格)、 valign等属性来设置表头。</p><h4 id="表格行标记-lt-tr-gt"><a href="#表格行标记-lt-tr-gt" class="headerlink" title="表格行标记&lt;tr&gt;"></a>表格行标记<code>&lt;tr&gt;</code></h4><p>表格行标记以<code>&lt;tr&gt;</code>开头,以<code>&lt;/tr&gt;</code>结束,一组<code>&lt;tr&gt;</code>标记表示表格中的一行。<code>&lt;tr&gt;</code>标记要嵌套在<code>&lt;table&gt;</code>标记中使用,该标记也具有 align、 background等属性。</p><h4 id="单元格标记-lt-td-gt"><a href="#单元格标记-lt-td-gt" class="headerlink" title="单元格标记&lt;td&gt;"></a>单元格标记<code>&lt;td&gt;</code></h4><p>单元格标记<code>&lt;td&gt;</code>又称为列标记,一个<code>&lt;tr&gt;</code>标记中可以嵌套若干个<code>&lt;td&gt;</code>标记。该标记也具有 align、background、 valign等属性<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;table width=&quot;318&quot; height=&quot;167&quot; border=&quot;1&quot; align=&quot;center&quot;&gt;</span><br><span class="line">&lt;!--表格标题--&gt;</span><br><span class="line">&lt;caption&gt;学生考试成绩单&lt;/caption&gt;</span><br><span class="line">&lt;!--行标记--&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;!--单元格标记--&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;姓名&lt;/td&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;语文&lt;/td&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;数学&lt;/td&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;英语&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;张三&lt;/td&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;89&lt;/td&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;92&lt;/td&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;87&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;李四&lt;/td&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;93&lt;/td&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;86&lt;/td&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;80&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;王五&lt;/td&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;85&lt;/td&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;86&lt;/td&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;90&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><p></p><p>显示效果：<table width="318" height="167" border="1" align="center"><caption>学生考试成绩单</caption><tr><td align="center" valign="middle">姓名</td><td align="center" valign="middle">语文</td><td align="center" valign="middle">数学</td><td align="center" valign="middle">英语</td></tr><tr><td align="center" valign="middle">张三</td><td align="center" valign="middle">89</td><td align="center" valign="middle">92</td><td align="center" valign="middle">87</td></tr><tr><td align="center" valign="middle">李四</td><td align="center" valign="middle">93</td><td align="center" valign="middle">86</td><td align="center" valign="middle">80</td></tr><tr><td align="center" valign="middle">王五</td><td align="center" valign="middle">85</td><td align="center" valign="middle">86</td><td align="center" valign="middle">90</td></tr></table></p><hr><p>说明<br>表格不仅<strong>可以用于显示数据</strong>,在实际开发中,还常常<strong>用来设计页面</strong>。<strong>在页面中创建一个表格,并设置没有边框,之后通过该表格将页面划分为几个区域,之后分别对几个区域进行设计,这是一种非常方便的设计页面的方式</strong>。</p><hr><h3 id="HTML表单标记"><a href="#HTML表单标记" class="headerlink" title="HTML表单标记"></a>HTML表单标记</h3><p>对于经常上网的人来说,对网站中的登录等页面肯定不会感到陌生,在登录页面中,网站会提供给用户<code>用户名文本框</code>与<code>密码文本框</code>,以供访客输入信息。<strong>这里的用户名文本框与密码文本框就属于HTML中的<code>表单元素</code></strong>。表单在HTML页面中起着非常重要的作用,是用户与网页交互信息的重要手段。</p><h4 id="1-lt-form-gt-…-lt-form-gt-表单标记"><a href="#1-lt-form-gt-…-lt-form-gt-表单标记" class="headerlink" title="1.&lt;form&gt;…&lt;/form&gt;表单标记"></a>1.<code>&lt;form&gt;</code>…<code>&lt;/form&gt;</code>表单标记</h4><p>表单标记以<code>&lt;form&gt;</code>标记开头,以<code>&lt;form&gt;</code>标记结尾。在表单标记中可以定义处理表单数据程序的URL地址等信息。<code>&lt;form&gt;</code>标记的基本语法如下<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action =&quot;url&quot; method=&quot;get&quot;|&quot;post&quot; name=&quot;name&quot; onSubmit=&quot;&quot; target =&quot;&quot;&lt;/form&gt;</span><br></pre></td></tr></table></figure><p></p><h4 id="lt-form-gt-标记的各属性说明如下"><a href="#lt-form-gt-标记的各属性说明如下" class="headerlink" title="&lt;form&gt;标记的各属性说明如下:"></a><code>&lt;form&gt;</code>标记的各属性说明如下:</h4><ul><li>action属性: 该属性用来<strong>指定处理表单数据程序的URL地址</strong>。</li><li>method属性: 该属性用来<strong>指定数据传送到服务器的方式</strong>。它有两种属性值,分别为<strong>get与 post</strong>。<strong>get属性值表示将输入的数据<code>追加</code>在action指定的地址后面,并传送到服务器</strong>。当属性值为post时,会将输入的数据按照HTTP协议中的post传输方式传送到服务器。</li><li>name属性: 该属性指定<strong>表单的名称</strong>,其值程序员可以自定义。</li><li>target属性：该属性<strong>指定输入数据<code>结果显示在哪个窗口中</code></strong>,其属性值可以设置为_blank,_self、_parent和_top。其中, _blank表示在新窗口中打开目标文件;_sel表示在同一个窗口中打开,该项一般不用设置(默认是在同窗口); _parent表示在上一级窗口中打开,一般使用框架页时经常使用;_top表示在浏览器的整个窗口中打开,忽略任何框架。</li></ul><p>下面的例子为创建表单,设置表单名称为form,当用户提交表单时,提交至 action.html页面进行处理。代码如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;form id=&quot;form1&quot; name=&quot;form&quot; method=&quot;post&quot; action=&quot;action.html&quot; target=&quot;_blank&quot;&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure><p></p><h3 id="2-lt-input-gt-表单输入标记"><a href="#2-lt-input-gt-表单输入标记" class="headerlink" title="2.&lt;input&gt;表单输入标记"></a>2.<code>&lt;input&gt;</code>表单输入标记</h3><p>表单输入标记是使用最频繁的表单标记,通过这个标记可以向页面中添加单行文本输入框、多行文本输入框、按钮等。<code>&lt;input&gt;</code>标记的语法格式如下<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;image&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; width=&quot;digit&quot; height=&quot;digit&quot; maxlength=&quot;digit&quot; readonly=&quot;&quot; size=&quot;digit&quot; src=&quot;uni&quot; usemap=&quot;uri&quot; alt=&quot;&quot; name=&quot;checkbox&quot; value=&quot;checkbox&quot;&gt;</span><br></pre></td></tr></table></figure><p></p><p><code>&lt;input&gt;</code>标记的属性如表2.1所示。</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">type</td><td style="text-align:left">用于指定添加的是哪种类型的输入字段,共有10个可选值,如表2.2所示</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">disabled</td><td style="text-align:left">用于指定输入字段不可用,即字段变成灰色。其属性值可以为空值,也可以指定为 disabled</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">checked</td><td style="text-align:left">用于指定输入字段是否处于被选中状态,用于type属性值为 radio和 checkbox的情况下。其属性值可以为空值,也可以指定为 checked</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">width</td><td style="text-align:left">用于指定输入字段的宽度,<code>用于type属性值为 image的情况下</code></td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">height</td><td style="text-align:left">用于指定输入字段的高度,<code>用于type属性值为 image的情况下</code></td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">maxlength</td><td style="text-align:left">用于指定输入字段<strong>可输入文字的个数</strong>,用于type属性值为text和 password的情况下,默认没有字数限制</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">readonly</td><td style="text-align:left">用于指定输入字段是否为只读。其属性值可以为空值,也可以指定为 readonly</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left">size</td><td style="text-align:left">用于<strong>指定输入字段的宽度</strong>,当type属性为text和 password时,以文字个数为单位,当type属性为其他值时,以像素为单位</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left">src</td><td style="text-align:left">用于指定图片的来源,<code>只有当tpe属性为 image时有效</code></td></tr><tr><td style="text-align:left">10</td><td style="text-align:left">usemap</td><td style="text-align:left">为图片设置热点地图,<code>只有当type属性为 image时有效</code>。属性值为URI,URI格式为“<code>#+&lt;map&gt;标记的name属性值</code>”。例如,<code>&lt;map&gt;</code>标记的name属性值为Map,该URI为#Map</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left">alt</td><td style="text-align:left">用于指定<strong>当图片无法显示时显示的文字</strong>,<code>只有当type属性为 image时有效</code></td></tr><tr><td style="text-align:left">12</td><td style="text-align:left">name</td><td style="text-align:left">用于指定输入字段的名称</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left">value</td><td style="text-align:left">用于指定<strong>输入字段默认的数据值</strong>,当type属性为 checkbox和 radio时,不可省略此属性;为其他值时,可以省略。当type属性为 button,reset和submit时,指定的是按钮上的显示文字;当type属性为 checkbox和 radio时,指定的是数据项选定时的值</td></tr></tbody></table><p>type属性是<code>&lt;input&gt;</code>标记中非常重要的内容,决定了输入数据的类型。该属性值的可选项如表2.2所示。</p><table><thead><tr><th style="text-align:right">type属性的属性值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:right">text</td><td style="text-align:left">文本框</td></tr><tr><td style="text-align:right">password</td><td style="text-align:left">密码域</td></tr><tr><td style="text-align:right">file</td><td style="text-align:left">文件域</td></tr><tr><td style="text-align:right">radio</td><td style="text-align:left">单选按钮</td></tr><tr><td style="text-align:right">checkbox</td><td style="text-align:left">复选框</td></tr><tr><td style="text-align:right">submit</td><td style="text-align:left">提交按钮</td></tr><tr><td style="text-align:right">reset</td><td style="text-align:left">重置按钮</td></tr><tr><td style="text-align:right">button</td><td style="text-align:left">普通按钮</td></tr><tr><td style="text-align:right">hidden</td><td style="text-align:left">隐藏域</td></tr><tr><td style="text-align:right">image</td><td style="text-align:left">图像域</td></tr></tbody></table><p>【例2-8】在该文件中首先应用<code>&lt;form&gt;</code>标记添加一个表单,将表单的 action属性设置为 registerdeal.jsp, method属性设置为post,然后应用<code>&lt;input&gt;</code>标记添加获取用户名和E-mail的文本框、获取密码和确认密码的密码域、选择性别的单选按钮、选择爱好的复选框、提交按钮、重置按钮。代码如下:<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>&amp;lt;input&amp;gt;标记的典型应用<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">name</span>=<span class="string">"myform"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用表格进行布局，宽度设置为0--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--第一部分,这个表格中只有一行一列，用图片填充--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">"694"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">align</span>=<span class="string">"center"</span> <span class="attr">cellpadding</span>=<span class="string">"0"</span> <span class="attr">cellspacing</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/01.gif"</span> <span class="attr">width</span>=<span class="string">"694"</span> <span class="attr">height</span>=<span class="string">"168"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--第二部分--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">"694"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">align</span>=<span class="string">"center"</span> <span class="attr">cellpadding</span>=<span class="string">"0"</span> <span class="attr">cellspacing</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--第一行--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--第1第一个单元格，用图片填充作为左背景--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">width</span>=<span class="string">"103"</span> <span class="attr">height</span>=<span class="string">"231"</span> <span class="attr">valign</span>=<span class="string">"top"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/02.gif"</span> <span class="attr">width</span>=<span class="string">"35"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--第一行第2个单元格--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">width</span>=<span class="string">"547"</span> <span class="attr">valign</span>=<span class="string">"top"</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--用表格填充,内容表格--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">cellspacing</span>=<span class="string">"0"</span> <span class="attr">cellpadding</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--第一行--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--单元格1,文本提示符--&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">td</span> <span class="attr">width</span>=<span class="string">"17%"</span> <span class="attr">height</span>=<span class="string">"29"</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span>用 户 名：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--单元格2,文本输入框，表示用户名,用户名最长字符为20个，占据两个单元格--&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"UserName4"</span> <span class="attr">maxlength</span>=<span class="string">"20"</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--第2行,设置密码框--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">td</span> <span class="attr">height</span>=<span class="string">"28"</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span>密&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;码：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">td</span> <span class="attr">height</span>=<span class="string">"28"</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"pwd1"</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">id</span>=<span class="string">"PWD14"</span> <span class="attr">size</span>=<span class="string">"20"</span> <span class="attr">maxlength</span>=<span class="string">"20"</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--第2行，设置密码确认框--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">td</span> <span class="attr">height</span>=<span class="string">"28"</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span>确认密码：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">td</span> <span class="attr">height</span>=<span class="string">"28"</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"pwd2"</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">id</span>=<span class="string">"PWD25"</span> <span class="attr">size</span>=<span class="string">"20"</span> <span class="attr">maxlength</span>=<span class="string">"20"</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--第3行，设置性别单选项--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">td</span> <span class="attr">height</span>=<span class="string">"28"</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span>性&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;别：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--第1个单选项，默认选择男生，单选项，name属性要一样--&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">class</span>=<span class="string">"noborder"</span> <span class="attr">value</span>=<span class="string">"男"</span> <span class="attr">checked</span>&gt;</span> 男&amp;nbsp;</span><br><span class="line">                                <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">class</span>=<span class="string">"noborder"</span> <span class="attr">value</span>=<span class="string">"女"</span>&gt;</span> 女</span><br><span class="line">                            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--第4行，设置爱好项多选框--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">td</span> <span class="attr">height</span>=<span class="string">"28"</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span>爱&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;好：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--复选项的name属性和id属性要一致--&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span> <span class="attr">class</span>=<span class="string">"word_grey"</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"like"</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"like"</span> <span class="attr">value</span>=<span class="string">"体育"</span>&gt;</span> 体育</span><br><span class="line">                                <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"like"</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"like"</span> <span class="attr">value</span>=<span class="string">"旅游"</span>&gt;</span> 旅游</span><br><span class="line">                                <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"like"</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"like"</span> <span class="attr">value</span>=<span class="string">"听音乐"</span>&gt;</span> 听音乐</span><br><span class="line">                                <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"like"</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"like"</span> <span class="attr">value</span>=<span class="string">"看书"</span>&gt;</span> 看书</span><br><span class="line">                            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--第5行设置E-mail文本框--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">td</span> <span class="attr">height</span>=<span class="string">"28"</span> <span class="attr">align</span>=<span class="string">"center"</span> <span class="attr">style</span>=<span class="string">"padding-left:10px"</span>&gt;</span>E-mail：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--占据两个单元格--&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span> <span class="attr">class</span>=<span class="string">"word_grey"</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"email"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"PWD224"</span> <span class="attr">size</span>=<span class="string">"50"</span>&gt;</span> <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--第6行，设置提交按钮，重置按钮--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">td</span> <span class="attr">height</span>=<span class="string">"34"</span>&gt;</span>&amp;nbsp;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">td</span> <span class="attr">width</span>=<span class="string">"30%"</span> <span class="attr">class</span>=<span class="string">"word_grey"</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"Submit"</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">class</span>=<span class="string">"btn_grey"</span> <span class="attr">value</span>=<span class="string">"确定保存"</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"Reset"</span> <span class="attr">type</span>=<span class="string">"reset"</span> <span class="attr">class</span>=<span class="string">"btn_grey"</span> <span class="attr">id</span>=<span class="string">"Reset"</span> <span class="attr">value</span>=<span class="string">"重新填写"</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--设置保存图片按钮--&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">td</span> <span class="attr">width</span>=<span class="string">"53%"</span> <span class="attr">class</span>=<span class="string">"word_grey"</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"image"</span> <span class="attr">name</span>=<span class="string">"imageField"</span> <span class="attr">src</span>=<span class="string">"images/btn_bg.jpg"</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置右侧背景图片--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">width</span>=<span class="string">"44"</span> <span class="attr">valign</span>=<span class="string">"top"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/04.gif"</span> <span class="attr">width</span>=<span class="string">"44"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>在页面中添加表单元素后,即形成了网页的雏形。页面运行结果如下图所示。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/Java%20Web%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/2/Input%E8%A1%A8%E5%8D%95%E7%9A%84%E7%BB%8F%E5%85%B8%E5%BA%94%E7%94%A8.png" alt=""></p><h3 id="3-lt-select-gt-…-lt-select-gt-下拉列表框标记"><a href="#3-lt-select-gt-…-lt-select-gt-下拉列表框标记" class="headerlink" title="3.&lt;select&gt;…&lt;/select&gt;下拉列表框标记"></a>3.<code>&lt;select&gt;</code>…<code>&lt;/select&gt;</code>下拉列表框标记</h3><p><strong><code>&lt;select&gt;</code>标记可以在页面中创建下拉列表框</strong>,此时的下拉列表框是一个空的列表,要使用<code>&lt;option&gt;</code>标记向列表中添加内容。<code>&lt;select&gt;</code>标记的语法格式如下:<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">size</span>=<span class="string">"digit"</span> <span class="attr">multiple</span>=<span class="string">"multiple"</span> <span class="attr">disabled</span>=<span class="string">"disabled"</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><code>&lt;select&gt;</code>标记的属性如下表所示：</p><table><thead><tr><th>序号</th><th></th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>name</td><td>用于指定<strong>列表框的名称</strong></td></tr><tr><td>2</td><td>size</td><td>用于指定<strong>列表框中显示的选项数量</strong>,超出该数量的选项可以通过拖动滚动条查看</td></tr><tr><td>3</td><td>disabled</td><td>用于指定<strong>当前列表框不可使用</strong>(变成灰色)</td></tr><tr><td>4</td><td>multiple</td><td>用于让多行列表框支持多选</td></tr></tbody></table><p>这里的多选可以，按下ctrl然后点击选项即可实现多选。如果不设置多选的话，只能选一个，按下ctrl和shitf键是没有用的。</p><p>【例2-9】在页面中应用<code>&lt;select&gt;</code>标记和<code>&lt;option&gt;</code>标记添加下拉列表框和多行下拉列表框。代码如下：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>下拉列表实例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"b.html"</span> <span class="attr">method</span>=<span class="string">"GET"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"right"</span>&gt;</span>下拉列表框1:<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"right"</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--默认显示一个选项，剩下的以滚动条查看--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"select1"</span> <span class="attr">id</span>=<span class="string">"select1"</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--两个名字的水果:</span></span><br><span class="line"><span class="comment">                    芒果 香蕉 苹果 荔枝 石榴 橄榄 榴莲 </span></span><br><span class="line"><span class="comment">                     --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span>&gt;</span>芒果<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span>&gt;</span>荔枝<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span>&gt;</span>石榴<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span>&gt;</span>橄榄<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span>&gt;</span>榴莲<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>下拉列表框2(全部不可选):<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"select2"</span> <span class="attr">id</span>=<span class="string">"select2"</span> <span class="attr">size</span>=<span class="string">"3"</span> <span class="attr">disabled</span>=<span class="string">"disabled"</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--两个名字的水果:</span></span><br><span class="line"><span class="comment">                            桂圆 枇杷 西瓜 甘蔗 香瓜 菠萝 橘子 </span></span><br><span class="line"><span class="comment">                             --&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--当前的列表项不可用--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span> <span class="attr">disabled</span>=<span class="string">"disabled"</span>&gt;</span>桂圆<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span>&gt;</span>枇杷<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span>&gt;</span>西瓜<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span>&gt;</span>甘蔗<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span>&gt;</span>香瓜<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span>&gt;</span>菠萝<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span>&gt;</span>橘子<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>下拉列表框3(支持多选):<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"select3"</span> <span class="attr">id</span>=<span class="string">"select3"</span> <span class="attr">size</span>=<span class="string">"3"</span> <span class="attr">multiple</span>=<span class="string">"multiple"</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--两个名字的水果:</span></span><br><span class="line"><span class="comment">                            樱桃 油桃 树莓 草莓 蓝莓 葡萄 椰子 </span></span><br><span class="line"><span class="comment">                             --&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--当前的列表项不可用--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span> <span class="attr">disabled</span>=<span class="string">"disabled"</span>&gt;</span>樱桃<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span>&gt;</span>油桃<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span>&gt;</span>树莓<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span>&gt;</span>草莓<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span>&gt;</span>蓝莓<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span>&gt;</span>葡萄<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">option</span>&gt;</span>椰子<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>显示效果如下图所示：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/Java%20Web%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/2/%E4%B8%8B%E6%8B%89%E5%88%97%E8%A1%A8%E6%A1%86.png" alt=""><br>可以看到,第一个下拉列表框没有设置size属性，只显示一个选项，剩下的以滚动条显示。而第三个设置size属性为5,则显示5个选项，第二个下拉列表项设置disabled属性，该下拉列表的所有选项都不可选。第三个下列列表框设置了multiple属性，这样可以选择多个选型(按下shitf/ctrl)。现在点击提交按钮，跳转的URL如下所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file:///C:/Users/lan/Desktop/b.html?select1=香蕉&amp;select3=油桃&amp;select3=树莓</span><br></pre></td></tr></table></figure><p></p><p>可以看到三个多选下拉列表中我们成功的选了两个选项<code>&amp;select3=油桃&amp;select3=树莓</code>。</p><h3 id="4-lt-textarea-gt-多行文本标记"><a href="#4-lt-textarea-gt-多行文本标记" class="headerlink" title="4.&lt;textarea&gt;多行文本标记"></a>4.<code>&lt;textarea&gt;</code>多行文本标记</h3><p><strong><code>&lt;textarea&gt;</code>为多行文本标记</strong>,与单行文本相比,多行文本可以输入更多的内容。通常情况下,<code>&lt;textarea&gt;</code>标记出现在<code>&lt;form&gt;</code>标记的标记内容中。<code>&lt;textarea&gt;</code>标记的语法格式如下:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;textarea name=&quot;name&quot; id=&quot;id&quot; cols=&quot;列数&quot; rows=&quot;行数&quot; disabled=&quot;disabled&quot; readonly=&quot;readonly&quot; wrap=&quot;value&quot;&gt;&lt;/textarea&gt;</span><br></pre></td></tr></table></figure><p></p><p><code>&lt;textarea&gt;</code>标记的属性如下表所示。</p><table><thead><tr><th>序号</th><th><code>&lt;textarea&gt;</code>标记的属性</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>name</td><td>用于指定多行文本框的名称,当表单提交后,在服务器端获取表单数据时应用</td></tr><tr><td>2</td><td>id</td><td>和其他id属性一样</td></tr><tr><td>3</td><td>cols</td><td>用于指定多行文本框显示的列数(宽度)</td></tr><tr><td>4</td><td>rows</td><td>用于指定多行文本框显示的行数(高度)</td></tr><tr><td>5</td><td>disabled</td><td>用于指定当前多行文本框不可使用(变成灰色)</td></tr><tr><td>6</td><td>readonly</td><td>用于指定当前多行文本框为只读<em>**</em></td></tr><tr><td>7</td><td>wrrap</td><td>用于<strong>设置</strong>多行文本中的文字<strong>是否自动换行</strong>,可选值如下表所示</td></tr></tbody></table><table><thead><tr><th>序号</th><th>wrap属性的可选值</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>hard</td><td><strong>默认值,表示自动换行</strong>,<strong>如果文字超过cols属性所指的列数就自动换行</strong>,并且<strong>提交到服务器时换行符同时被提交</strong></td></tr><tr><td>2</td><td>soft</td><td>表示自动换行,如果文字超过cols属性所指的列数就自动换行,<code>但提交到服务器时换行符不被提交</code></td></tr><tr><td>3</td><td>off</td><td>表示<strong>不自动换行</strong>,如果想让文字换行,<strong>只能按下 Enter键强制换行</strong></td></tr></tbody></table><p>【例2.10】在页面中创建表单对象,并在表单中添加一个多行文本框,文本框的名称为 content,6行30列,文字换行方式为hard。关键代码如下:<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">"form1"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">"content"</span> <span class="attr">cols</span>=<span class="string">"30"</span> <span class="attr">rows</span>=<span class="string">"5"</span> <span class="attr">wrap</span>=<span class="string">"hard"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>显示效果：</p><form name="form1" method="post" action=""><textarea name="content" cols="30" rows="5" wrap="hard"></textarea></form><br>在页面中的多行文本框中可输入任意内容。<p></p><h3 id="2-1-6超链接与图片标记"><a href="#2-1-6超链接与图片标记" class="headerlink" title="2.1.6超链接与图片标记"></a>2.1.6超链接与图片标记</h3><p>HTML语言的标记有很多,限于篇幅,只能介绍一些常用标记。除了上面介绍的常用标记外,还有两个标记不得不向大家介绍,即<code>超链接标记</code>与<code>图片标记</code>。</p><h4 id="1-超链接标记"><a href="#1-超链接标记" class="headerlink" title="1.超链接标记"></a>1.超链接标记</h4><p><strong>超链接标记</strong>是页面中非常重要的元素,在网站中<strong>实现从一个页面跳转到另一个页面</strong>,这个功能就是通过超链接标记来完成的。超链接标记的语法非常简单。其语法格式如下:<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>属性href用来设定链接到哪个页面中。</p><h4 id="2-图片标记"><a href="#2-图片标记" class="headerlink" title="2.图片标记"></a>2.图片标记</h4><p>大家在浏览网站时通常会看到各式各样的漂亮图片,在页面中添加的图片是通过<code>&lt;img&gt;</code>标记来实现的。<code>&lt;img&gt;</code>标记的语法格式如下:<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"uri"</span> <span class="attr">width</span>=<span class="string">"value"</span> <span class="attr">height</span>=<span class="string">"value"</span> <span class="attr">border</span>=<span class="string">"value"</span> <span class="attr">alt</span>=<span class="string">"提示文本"</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><code>&lt;img&gt;</code>标记的属性如下表2.6所示。<br>|序号|<code>&lt;img&gt;标记的属性</code>|描述|<br>|-|-|-|<br>|1|src|用于指定图片的来源|<br>|2|width|用于指定图片的宽度|<br>|3|height|用于指定图片的高度|<br>|4|border|用于指定图片外边框的宽度，默认值为0|<br>|5|alt|用于指定图片无法显示时显示的文字|</p><p>下面给出具体实例,为读者演示超链接和图片标记的使用。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;超链接和图片标签&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        /*</span><br><span class="line">        定义图片和超链接外边框</span><br><span class="line">        */</span><br><span class="line">        a,img&#123;</span><br><span class="line">            border-style: outset;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;table border=&quot;0&quot; align=&quot;center&quot; valign=&quot;center&quot;&gt;</span><br><span class="line">        &lt;tr align=&quot;center&quot;&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">                &lt;img src=&quot;BlogImage/avatar.jpg&quot; alt=&quot;我的博客头像&quot; width=&quot;50%&quot;&gt;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;tr align=&quot;center&quot;&gt;</span><br><span class="line">            &lt;td&gt;&lt;a href=&quot;https://www.lansheng.net.cn&quot; target=&quot;_blank&quot;&gt;跳转到我的博客首页&lt;/a&gt;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p></p><p>显示效果如下：<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/Java%20Web%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/2/%E5%9B%BE%E7%89%87%E5%92%8C%E8%B6%85%E9%93%BE%E6%8E%A5.png" alt=""></p><hr><p>关键代码：<br><code>&lt;img src=&quot;BlogImage/avatar.jpg&quot; alt=&quot;我的博客头像&quot; width=&quot;50%&quot;&gt;</code>中图片的路径<code>src=&quot;BlogImage/avatar.jpg&quot;</code>表示图片在(当前html文档的路径)当前路径下的BlogImage目录下的avatar.jpg这个图片。这里图片使用相对了路径。使用相对路径好处是，可以把图片目录BlogImage和html文件一同发布,即使改变网站的地址也不会影响到网站的结构。</p><hr><p>本文链接: <a href="https://www.lansheng.net.cn/blog/b3e1ff37/">HTML标记语言</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Java Web从入门到精通 </category>
          
          <category> 第2章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java Web从入门到精通 第1章 Web应用技术</title>
      <link href="/blog/3e19e91d/"/>
      <url>/blog/3e19e91d/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>1、客户端应用的技术<br>2、服务器应用的技术</p><p>在开发Web应用程序时,通常需要应用客户端和服务器两方面的技术。其中,<strong>客户端应用的技术<code>主要用于展现信息内容</code></strong>,而<strong>服务器端应用的技术,则<code>主要用于进行业务逻辑的处理</code>和<code>与数据库的交互</code>等</strong>。下面进行详细介绍。</p><h2 id="客户端应用的技术"><a href="#客户端应用的技术" class="headerlink" title="客户端应用的技术"></a>客户端应用的技术</h2><p>在进行Web应用开发时,离不开客户端技术的支持。目前,比较常用的客户端技术包括HTML语言、CSS、 Flash和客户端脚本技术。下面进行详细介绍。<br>1、HTML语言<br>2、CSS<br>3、客户端脚本技术</p><h3 id="HTML语言"><a href="#HTML语言" class="headerlink" title="HTML语言"></a>HTML语言</h3><p>HTML语言是客户端技术的基础,<strong>主要用于显示网页信息</strong>,<strong>由浏览器解释执行,它不需要编译</strong>。HTML语言简单易用,它在文件中加入标签,使其可以显示各种各样的字体、图形及闪烁效果,还增加了结构和标记,如头元素、文字、列表、表格、表单、框架、图像和多媒体等,并且提供了与 Internet中其他文档的超链接。例如,在一个HTML页中,应用图像标记插入一个图片,可以使用下面的HTML代码:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;测试在HTML中插入图片&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;center&gt;&lt;img src=&quot;avatar.jpg&quot;/&gt;&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p></p><p>该HTML页运行后的效果如图1.6所示。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/Java%20Web%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/1/HTML%E4%BE%8B%E5%AD%90.png" alt=""></p><p><center>图1.6运行效果</center></p><hr><p><strong>说明</strong><br><strong>HTML语言不区分大小写</strong>,这一点与Java不同,例如HTML标<code>&lt;body&gt;`</code><code>也可以写为</code></p><body><code></code></body>`。<p></p><hr><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>CSS就是一种叫做样式表( Style Sheet)的技术,也有人称之为<strong>层叠样式表( Cascading Style Sheet)</strong>。在制作网页时采用CSS样式,可以有效地对页面的布局、字体、颜色、背景和其他效果实现更加精确的控制。只要对相应的代码做一些简单的修改,就可以改变整个页面的风格。CSS大大提高了开发者对信息展现格式的控制能力,特别是在目前比较流行的<strong>CSC+DⅣ布局</strong>的网站中,CSS的作用更是举足轻重。</p><hr><p>技巧在网页中使用CSS样式不仅可以美化页面,而且可以优化网页速度,因为CSS样式表文件只是简单的文本格式,不需要安装额外的第三方插件。另外,由于CSS提供了很多滤镜效果,从而避免使用大量的图片,这样将大大缩小文件的体积,提高下载速度。</p><hr><h3 id="客户端脚本技术"><a href="#客户端脚本技术" class="headerlink" title="客户端脚本技术"></a>客户端脚本技术</h3><p><strong>客户端脚本技术是指嵌入到web页面中的程序代码</strong>,这些程序代码是一种解释性的语言,浏览器可以对客户端脚本进行解释。<strong>通过脚本语言可以实现以编程的方式对页面元素进行控制,从而增加页面的灵活性</strong>。常用的客户端脚本语言有 JavaScript和VBSCript。目前,<strong>应用最为广泛的客户端脚本语言是JavaScript脚本</strong>,它是Ajax的重要组成部分。在本书的第3章将对 JavaScript脚本语言进行详细介绍</p><h2 id="服务器端应用的技术"><a href="#服务器端应用的技术" class="headerlink" title="服务器端应用的技术"></a>服务器端应用的技术</h2><a id="more"></a><p>在开发动态网站时，离不开服务器端技术，目前，比较常用的服务器端技术主要有CGI，ASP、PHP、ASP.NET和JSP。</p><h3 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h3><p>1、CGI是最早用来创建动态网页的一种技术，它可以使浏览器与服务器之间产生互动关系。<br><strong>CGI是最早用来创建动态网页的一种技术,它可以使浏览器与服务器之间产生互动关系</strong>。CGI的全称是 Common Gateway Interface,即<strong>通用网关接口</strong>。它允许使用不同的语言来编写适合的CGI程序。该程序被放在Web服务器上运行。当客户端发出请求给服务器时,服务器根据用户请求建立一个新的进程来执行指定的CGI程序,并将执行结果以网页的形式传输到客户端的浏览器上显示。CGI可以说是当前应用程序的基础技术,但这种技术编制方式比较困难而且效率低下,因为每次页面被请求时,都要求服务器重新将CGI程序编译成可执行的代码。<strong>在CGI中使用最为常见的语言为C,C++、Java和Perl( Practical Extraction and Report Language,文件分析报告语言)</strong>。</p><h3 id="ASP"><a href="#ASP" class="headerlink" title="ASP"></a>ASP</h3><p>ASP( Active Server Page)是一种使用很广泛的开发动态网站的技术。它<strong>通过在页面代码中嵌VBSCript或 JavaScript脚本语言,来生成动态的内容,在服务器端必须安装适当的解释器后,才可以通过调用此解释器来执行脚本程序,然后将执行结果与静态内容部分结合并传送到客户端浏览器上</strong>。对于一些复杂的操作,ASP可以调用存在于后台的COM组件来完成,所以说COM组件无限地扩充了ASP的能力,正因如此依赖本地的COM组件,使得<strong>它主要用于 Windows NT平台中</strong>,所以 Windows本身存在的问题都会映射到它的身上。当然该技术也存在很多优点,简单易学,并且ASP是与微软的IIS捆绑在一起,在安装 Windows操作系统的同时安装上ⅡS即可运行ASP应用程序。</p><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><p>PHP来自于 Personal Home Page一词,但现在的PHP已经不再表示名词的缩写,而是一种开发动态网页技术的名称。PHP语法类似于C,并且混合了Perl、C++和Java的一些特性。它是一种开源的web服务器脚本语言,与ASP一样可以在页面中加入脚本代码来生成动态内容。对于一些复杂的操作可以封装到函数或类中。在PHP中提供了许多已经定义好的函数,例如提供的标准的数据库接口,使得数据库连接方便,扩展性强。<strong>PHP可以被多个平台支持,但被广泛应用于 UNIX/Linux平台</strong>。由于PHP本身的代码对外开放,并且经过许多软件工程师的检测,因此到目前为止该技术具有公认的安全性能。</p><h3 id="ASP-NET"><a href="#ASP-NET" class="headerlink" title="ASP.NET"></a>ASP.NET</h3><p>ASP.NET是一种建立动态Web应用程序的技术。它是.NET框架的一部分,可以使用任何.NET兼容的语言来编写 ASP.NET应用程序。使用 Visual Basic .NET、C#、J#、 ASP.NET页面( Web Forms)进行编译,可以提供比脚本语言更出色的性能表现。 Web Forms允许在网页基础上建立强大的窗体。当建立页面时,可以使用 ASP.NET服务端控件来建立常用的UI元素,并对它们编程来完成一般的任务。这些控件允许开发者使用内建可重用的组件和自定义组件来快速建立 Web Forms,使代码简单化。</p><h3 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h3><p>Java Server Page简称JSP。JSP是以Java为基础开发的,所以它沿用Java强大的API功能。<strong>JSP页面中的HTML代码用来显示静态内容部分,嵌入到页面中的Java代码与JSP标记用来生成动态的内容部分</strong>。JSP允许程序员编写自己的标签库来完成应用程序的特定要求。JSP可以被预编译,提高了程序的运行速度。另外,<strong>JSP开发的应用程序经过一次编译后,便可随时随地运行。所以在绝大部分系统平台中,代码无须做修改即可在支持JSP的任何服务器中运行</strong>。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/3e19e91d/">Java Web从入门到精通 第1章 Web应用技术</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Java Web从入门到精通 </category>
          
          <category> 第1章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java Web从入门到精通 第1章 Web应用程序的工作原理</title>
      <link href="/blog/ce9c17a7/"/>
      <url>/blog/ce9c17a7/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p><strong>Web应用程序大体上可以分为</strong>两种，即<strong>静态网站和动态网站</strong>。早期的Web应用主要是静态页面的浏览，即<strong>静态网站</strong>。这些网站使用HTML语言来编写，放在Web服务器上，用户使用浏览器通过HTTP协议请求服务器上的Web页面，服务器上的Web服务器将接收到的用户请求处理后，再发送给客户端浏览器，显示给用户。整个过程如下图所示。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/Java%20Web%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/1/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E8%BF%87%E7%A8%8B.png" alt=""><br>随着网络的发展，很多线下业务开始向网上发展，基于Internet的Web应用也变得越来越复杂，<strong>用户所访问的资源已不能只是局限于服务器上保存的静态网页，更多的内容需要根据用户的请求动态生成页面信息，即动态网站</strong>。下面给出<strong>动态网站的工作流程图</strong>。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/Java%20Web%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/1/%E5%8A%A8%E6%80%81%E7%BD%91%E7%AB%99%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt=""></p><hr><p><strong>说明</strong><br>对于初学者,经常会<strong>错误地认为带有动画放果的网页就是动态网页</strong>,其实不然,<strong>动态网页是指具有交互性、内容可以自动更新,并且内容会根据访问的时间和访问者而改变</strong>。这里所说的<strong>交互性是指网页可以根据用户的要求动态改变或响应。</strong></p><hr><p>由此可见,静态网站类似于最早研制的手机,这种手机只能使用出厂时设置的功能和铃声,用户自己并不能对其铃声进行添加和删除等:而动态网站则类似于现在研制的手机,用户在使用这些手机时,不再是只能使用机器中默认的铃声,而是可以根据自己的喜好任意设置。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/ce9c17a7/">Java Web从入门到精通 第1章 Web应用程序的工作原理</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Java Web从入门到精通 </category>
          
          <category> 第1章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java Web从入门到精通 第1章 程序开发体系结构</title>
      <link href="/blog/6b646665/"/>
      <url>/blog/6b646665/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>随着网络技术的不断发展,单机的软件程序已难以满足网络计算的需要。为此,各种各样的网络程序开发体系结构应运而生。其中,<strong>运用最多的网络应用程序开发体系结构可以分为两种,一种是<code>基于浏览器服务器的B/S结构</code>,另一种是<code>基于客户端/服务器的C/S结构</code></strong>。下面进行详细介绍。</p><h2 id="C-S体系结构介绍"><a href="#C-S体系结构介绍" class="headerlink" title="C/S体系结构介绍"></a>C/S体系结构介绍</h2><p><strong>C/S是Client/Server的缩写</strong>，即<strong>客户端/服务器结构</strong>。在这种结构中，服务器通常采用高性能的PC机或工作站，并采用大型数据库系统（如Oracle或SQL Server），客户端则需要安装专用的客户端软件，如下图所示。这种结构可以充分利用两端硬件环境的优势，将任务合理分配到客户端和服务，从而降低了系统的通讯开销。<strong>在2000年以前，C/S结构占据网络程序开发领域的主流</strong>。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/Java%20Web%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%93%E6%9E%84.png" alt=""></p><h3 id="典型例子"><a href="#典型例子" class="headerlink" title="典型例子"></a>典型例子</h3><p>QQ就是基于C/S架构的，你本地的QQ程序只是一个客户端，而<strong>主程序运行在腾讯的服务器</strong>。<br><a id="more"></a></p><h2 id="B-S体系结构介绍"><a href="#B-S体系结构介绍" class="headerlink" title="B/S体系结构介绍"></a>B/S体系结构介绍</h2><p><strong>B/S是Brower/Server的缩写</strong>，即<strong>浏览器/服务器结构</strong>。在这种结构中，<strong>客户端不需要开发任何用户界面，而统一采用如IE和火狐等浏览器，通过Web浏览器向Web服务器发送请求，由Web服务器进行处理，并将处理结果逐级传回客户端</strong>，如下图所示。这种结构利用不断成熟和普及的浏览器技术实现原来需要复杂专用软件才能实现的强大功能，从而<strong>节约了开发成本</strong>，是一种全新的软件体系结构。<strong>这种体系结构已经成为当今应用软件的<code>首选体系结构</code></strong>。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/Java%20Web%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%93%E6%9E%84.png" alt=""></p><h3 id="典型例子-1"><a href="#典型例子-1" class="headerlink" title="典型例子"></a>典型例子</h3><p>网站是典型的B/S结构,通常所说的B/S架构则值得是基于网页的系统。</p><hr><p>说明:<br>B/S由美国微软公司研发,C/S由美国 Borland公司最早研发。</p><hr><h2 id="两种体系结构的比较"><a href="#两种体系结构的比较" class="headerlink" title="两种体系结构的比较"></a>两种体系结构的比较</h2><p>C/S结构和B/S结构是当今世界网络程序开发体系结构的两大主流。目前，这两种结构都有自己的市场份额和客户群。但是，这两种体系结构又各有各的优点和缺点。</p><h3 id="1-开发和维护成本方面"><a href="#1-开发和维护成本方面" class="headerlink" title="1.开发和维护成本方面"></a>1.开发和维护成本方面</h3><p><strong>C/S结构的开发和维护成本都比B/S高</strong>。采用C/S结构时,对于不同客户端要开发不同的程序,而且软件的安装、调试和升级均需要在所有的客户机上进行。例如,如果一个企业共有10个客户站点使用一套C/S结构的软件,则这10个客户站点都需要安装客户端程序。当这套软件进行了哪怕很微小的改动后,系统维护员都必须将客户端原有的软件卸载,再安装新的版本并进行配置,最可怕的是客户端的维护工作必须不折不扣地进行10次。若某个客户端忘记进行这样的更新,则该客户端将会因软件版本不一致而无法工作。<br>而<strong>B/S结构的软件,则不必在客户端进行安装及维护</strong>。如果将前面企业的C/S结构的软件换成B/S结构的,这样<strong>在软件升级后,系统维护员只需要将服务器的软件升级到最新版本</strong>,对于其他<strong>客户端,只要重新登录系统即可使用最新版本的软件。</strong></p><h3 id="2-客户端负载"><a href="#2-客户端负载" class="headerlink" title="2.客户端负载"></a>2.客户端负载</h3><p><strong>C/S结构的客户端</strong>不仅负责与用户的交互,收集用户信息,而且还需要完成通过网络向服务器请求对数据库、电子表格或文档等信息的处理工作。由此可见,<strong>应用程序的功能越复杂,客户端程序也就越庞大</strong>,这也给软件的维护工作带来了很大的困难。而<strong>B/S结构的客户端把事务处理逻辑部分交给了服务器,由服务器进行处理,客户端只需要进行显示</strong>,这样,将使应用程序服务器的运行数据负荷较重,一旦发生服务器“崩溃”等问题,后果不堪设想。因此,许多单位都备有数据库存储服务器,以防万一。</p><h3 id="3-安全性"><a href="#3-安全性" class="headerlink" title="3.安全性"></a>3.安全性</h3><p><strong>C/S结构适用于专人使用的系统</strong>,可以通过严格的管理派发软件,达到保证系统安全的目的,这样的软件<strong>相对来说安全性比较高</strong>。<br>而对于<strong>B/S结构的软件</strong>,由于使用的人数较多,且不固定,相对来说<strong>安全性就会低些</strong>。</p><p>总体来说,B/S相对于C/S来说具有更多的优势,<strong>现今大量的应用程序开始转移到应用B/S结构,许多软件公司也争相开发B/S版的软件,也就是Web应用程序</strong>。随着Internet的发展,基于HTTP协议和HTML标准的Web应用呈几何数量级的增长,而这些Web应用又是由各种Web技术所开发。</p><h2 id="两种结构优缺点总结"><a href="#两种结构优缺点总结" class="headerlink" title="两种结构优缺点总结"></a>两种结构优缺点总结</h2><h3 id="C-S"><a href="#C-S" class="headerlink" title="C/S"></a>C/S</h3><h4 id="1-优点"><a href="#1-优点" class="headerlink" title="1.优点"></a>1.优点</h4><p>(1)安全性:<strong>需要其特定的客户端</strong>,所以面向对象比较确定,将所进行的信息安全处于一个可控的范围<br>(2)效率:<strong>客户端的服务器直接相连</strong>,省却了中间环节,<strong>数据的传输比较快</strong><br>(3)个性化:有特定的客户端,所以<strong>可以在较大程度上满足客户的个性化要求</strong><br>(4)稳定性:结构比较稳定,有较强的事务处理能力,可以实现较复杂的业务逻辑</p><h4 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2.缺点"></a>2.缺点</h4><p>(1)特定的客户端:对PC机有一定的要求,如:操作系统<br>(2)中间环节:因为省却了中间环节,所以当客户端达到一定的量时,同时访问服务器,造成服务器的相应变慢,效率变低。</p><h3 id="B-S"><a href="#B-S" class="headerlink" title="B/S"></a>B/S</h3><h4 id="1-优点-1"><a href="#1-优点-1" class="headerlink" title="1.优点"></a>1.优点</h4><p>(1)范围:零安装,<strong>拥有一个浏览器,即可访问</strong>,面向的范围更广。<br>(2)维护性:维护简单,<strong>更新页面,即可实现面向所有用户的更新</strong>。<br>(3)共享性:通过浏览器访问,共享性强。</p><h4 id="2-缺点-1"><a href="#2-缺点-1" class="headerlink" title="2.缺点"></a>2.缺点</h4><p>(1)安全性:面向的范围广,安全性比较低<br>(2)个性化:因为面型的范围广,所以它是一种公共审美,无法满足个性化的需求</p><p>参考文章:<a href="https://blog.csdn.net/Sunny5319/article/details/78771239" target="_blank" rel="noopener">https://blog.csdn.net/Sunny5319/article/details/78771239</a></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/6b646665/">Java Web从入门到精通 第1章 程序开发体系结构</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Java Web从入门到精通 </category>
          
          <category> 第1章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JAVA学习之GUI组件中Toolkit的使用</title>
      <link href="/blog/514963fc/"/>
      <url>/blog/514963fc/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>在使用GUI中的组件进行窗体的设计时，<strong>当需要将窗体始终显示在屏幕的某一位置时</strong>，例如屏幕的中央。由于不同的电脑屏幕分辨率是不同的，所以在进行处理时会有一定的难度，还有就是当我们需要修改窗体的图标时，这些都要用到Tookit工具包。<br>首先，为了解决窗体的显示问题，进行如下设置：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Toolkit toolkit = getToolkit();<span class="comment">// 获得窗体工具包</span></span><br><span class="line">Dimension screenSize = toolkit.getScreenSize();<span class="comment">// 获取屏幕大小</span></span><br><span class="line"><span class="keyword">int</span> width = (<span class="keyword">int</span>) (screenSize.width * <span class="number">0.8</span>);<span class="comment">// 计算窗体新宽度</span></span><br><span class="line"><span class="keyword">int</span> height = (<span class="keyword">int</span>) (screenSize.height * <span class="number">0.8</span>);<span class="comment">// 计算窗体新宽度</span></span><br><span class="line">setSize(width, height);<span class="comment">// 设置窗体大小</span></span><br></pre></td></tr></table></figure><p></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/514963fc/">JAVA学习之GUI组件中Toolkit的使用</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> java_GUI </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hexo Valine评论系统设置头像--使用Gravatars头像</title>
      <link href="/blog/c4f9ab98/"/>
      <url>/blog/c4f9ab98/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>到<a href="https://en.gravatar.com/" target="_blank" rel="noopener">https://en.gravatar.com/</a>用你的邮箱注册一个账号，然后为你的邮箱账号上传一个图像即可。然后在填写评论系统的邮箱的时候，Valine会加载到你邮箱对应的Gravatars头像。这样头像就显示出来了。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/c4f9ab98/">Hexo Valine评论系统设置头像–使用Gravatars头像</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> 给博客添加功能 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hexo Next主题 添加Valine评论系统</title>
      <link href="/blog/8eadc39/"/>
      <url>/blog/8eadc39/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>Next主题已经集成了Valine评论系统了，我们只需要<strong>注册一个leanCloud账号</strong>，然后改一下<strong>主题配置文件</strong>即可使用。不得不说这个主题是真的强大。<br>参考文档:<a href="https://blog.csdn.net/blue_zy/article/details/79071414" target="_blank" rel="noopener">https://blog.csdn.net/blue_zy/article/details/79071414</a><br>官方文档:<a href="https://valine.js.org/quickstart.html" target="_blank" rel="noopener">https://valine.js.org/quickstart.html</a><br>为此介绍一下这个评论系统的内容:</p><ul><li>昵称:就是昵称</li><li>邮箱:先到<a href="https://en.gravatar.com/" target="_blank" rel="noopener">https://en.gravatar.com/</a>用你的邮箱注册一个账号，然后为你的邮箱账号设置一个头像。这样Valine就能加载到你的邮箱对应的头像。不然的你评论的头像就是默认的头像。</li><li>网址:设置网址的时候，可以看到昵称下面有下划线(表示这是一个超链接)，点击昵称可以跳转到该网址，一般填入自己博客的的地址。</li></ul><a id="more"></a><p><a href="/2018/09/27/Hexo搭建博客/添加功能/Hexo Valine使用Gravatars头像/">头像设置</a>参见</p><p>评论系统的具体介绍如下图所示:<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/Blog/Hexo/Valine/Gravatars/%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D.png" alt=""></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/8eadc39/">Hexo Next主题 添加Valine评论系统</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> 给博客添加功能 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hexo Next主题 添加搜索功能</title>
      <link href="/blog/85f813d6/"/>
      <url>/blog/85f813d6/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>Next主题已经集成了站内搜索功能了。<br>安装插件，然后改一下配置文件即可使用。<br><a id="more"></a></p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>安装下面两个插件:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure><p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><!--more--><h3 id="修改站点配置文件"><a href="#修改站点配置文件" class="headerlink" title="修改站点配置文件"></a>修改站点配置文件</h3><p>在站点配置文件中，添加下面的配置信息:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">    path: search.xml</span><br><span class="line">    field: post</span><br><span class="line">    format: html</span><br><span class="line">    limit: 10000</span><br></pre></td></tr></table></figure><p></p><h3 id="修改Next主题配置文件"><a href="#修改Next主题配置文件" class="headerlink" title="修改Next主题配置文件"></a>修改Next主题配置文件</h3><p>找到local_search配置项，把enable改为true即可。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local_search:</span><br><span class="line">    enable: true</span><br></pre></td></tr></table></figure><p></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/85f813d6/">Hexo Next主题 添加搜索功能</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> 给博客添加功能 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Swing入门1</title>
      <link href="/blog/475d5fec/"/>
      <url>/blog/475d5fec/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文介绍:<br>实例187 从上次关闭位置启动窗体</p><p>源码:<a href="https://pan.baidu.com/s/1kT1u8EN?fid=429117221217238" target="_blank" rel="noopener">https://pan.baidu.com/s/1kT1u8EN?fid=429117221217238</a></p><h2 id="实例187-从上次关闭位置启动窗体"><a href="#实例187-从上次关闭位置启动窗体" class="headerlink" title="实例187 从上次关闭位置启动窗体"></a>实例187 从上次关闭位置启动窗体</h2><p>实际开发中,有很多软件都有一个通用的功能:<strong>从上次关闭位置启动窗体</strong>,本实例将使用Java语言的<a href="/2018/09/24/读书笔记/Java经典编程300例/输入_输出/参考/Java-Preferences用法-入门/">Preferences首选项类</a>,把软件关闭时的坐标写到注册表(Windows系统)中,下次启动的时候读取注册表获取位置，然后设置窗体显示的位置。从而实现从上次关闭位置启动窗体的功能,实例的运行效果如图14.1所示。<br><img src="http://pefsyzdwh.bkt.clouddn.com/18-9-24/190641.jpg" alt=""></p><p><center>图14.1</center><br><a id="more"></a></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mingrisoft;</span><br><span class="line"><span class="keyword">import</span> java.awt.BorderLayout;</span><br><span class="line"><span class="keyword">import</span> java.awt.EventQueue;</span><br><span class="line"><span class="keyword">import</span> java.awt.Point;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JPanel;</span><br><span class="line"><span class="keyword">import</span> javax.swing.border.EmptyBorder;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ComponentAdapter;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ComponentEvent;</span><br><span class="line"><span class="keyword">import</span> java.util.prefs.Preferences;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowAdapter;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowEvent;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JLabel;</span><br><span class="line"><span class="keyword">import</span> javax.swing.SwingConstants;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartFormByLClosePosition</span> <span class="keyword">extends</span> <span class="title">JFrame</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">9068743130943151359L</span>;</span><br><span class="line"><span class="keyword">private</span> JPanel contentPane;</span><br><span class="line"><span class="keyword">private</span> JLabel label;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Launch the application.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">EventQueue.invokeLater(<span class="keyword">new</span> Runnable()</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">StartFormByLClosePosition frame = <span class="keyword">new</span> StartFormByLClosePosition();</span><br><span class="line">frame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create the frame.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StartFormByLClosePosition</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">addComponentListener(<span class="keyword">new</span> ComponentAdapter()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">componentMoved</span><span class="params">(ComponentEvent e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 窗体移动事件处理方法，</span></span><br><span class="line">do_this_componentMoved(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">setTitle(</span><br><span class="line"><span class="string">"\u4ECE\u4E0A\u6B21\u5173\u95ED\u4F4D\u7F6E\u542F\u52A8\u7A97\u4F53"</span>);</span><br><span class="line">addWindowListener(<span class="keyword">new</span> WindowAdapter()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowOpened</span><span class="params">(WindowEvent e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">do_this_windowOpened(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">do_this_windowClosing(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">setBounds(<span class="number">100</span>, <span class="number">100</span>, <span class="number">346</span>, <span class="number">237</span>);</span><br><span class="line">contentPane = <span class="keyword">new</span> JPanel();</span><br><span class="line">contentPane.setBorder(<span class="keyword">new</span> EmptyBorder(<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>));</span><br><span class="line">contentPane.setLayout(<span class="keyword">new</span> BorderLayout(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">setContentPane(contentPane);</span><br><span class="line"></span><br><span class="line">label = <span class="keyword">new</span> JLabel(<span class="string">""</span>);<span class="comment">// 原来的标签中不放字符串</span></span><br><span class="line">label.setHorizontalAlignment(SwingConstants.CENTER);</span><br><span class="line">contentPane.add(label, BorderLayout.CENTER);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 窗体打开的事件处理方法,该方法在窗体打开时被调用,方法中首先获取首选项对象中的坐标信息,然后利用该坐标重新为窗体定位。关键代码如下:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">do_this_windowOpened</span><span class="params">(WindowEvent e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Preferences root = Preferences.userRoot();<span class="comment">// 获取用户首选项</span></span><br><span class="line"><span class="keyword">int</span> x = root.getInt(<span class="string">"locationX"</span>, <span class="number">100</span>);<span class="comment">// 提取窗体X坐标</span></span><br><span class="line"><span class="keyword">int</span> y = root.getInt(<span class="string">"locationY"</span>, <span class="number">100</span>);<span class="comment">// 提取窗体Y坐标</span></span><br><span class="line">setLocation(x, y);<span class="comment">// 恢复窗体坐标</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 窗体关闭的事件处理方法,在进行关闭窗体的过程中,该方法会读取当前窗体的坐标信息并保存到`首选项对象中`。关键代码如下:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">do_this_windowClosing</span><span class="params">(WindowEvent e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Windows系统下对应: 注册表项: HKEY_CURRENT_USER\SOFTWARE\Javasoft\Prefs\</span></span><br><span class="line">Preferences root = Preferences.userRoot();<span class="comment">// 获取用户首选项</span></span><br><span class="line">Point location = getLocation();<span class="comment">// 获取窗体位置</span></span><br><span class="line"><span class="comment">//直接在用户首选项上设置"键值对"</span></span><br><span class="line">root.putInt(<span class="string">"locationX"</span>, location.x);<span class="comment">// 保存窗体X坐标</span></span><br><span class="line">root.putInt(<span class="string">"locationY"</span>, location.y);<span class="comment">// 保存窗体Y坐标</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 窗体移动的事件处理方法,在该方法中控制标签控件来显示当前窗体的位置。只要窗体移动就会立刻更新标签控件的信息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">do_this_componentMoved</span><span class="params">(ComponentEvent e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Point location = getLocation();<span class="comment">// 获取窗体坐标</span></span><br><span class="line"><span class="keyword">int</span> x = location.x;</span><br><span class="line"><span class="keyword">int</span> y = location.y;</span><br><span class="line"><span class="comment">// 把窗体当前坐标显示在标签控件中</span></span><br><span class="line">label.setText(<span class="string">"窗体当前坐标：X = "</span> + x + <span class="string">"        Y = "</span> + y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="技术要点"><a href="#技术要点" class="headerlink" title="技术要点"></a>技术要点</h3><p>本实例在实现时,主要是<strong> <a href="/2018/09/24/读书笔记/Java经典编程300例/输入_输出/参考/Java-Preferences用法-入门/">Preference首选项类</a></strong>的应用,该类的实例对象可以<strong>保存程序的各种参数与设置</strong>。</p><h2 id="实例188-始终在桌面最顶层显示窗体"><a href="#实例188-始终在桌面最顶层显示窗体" class="headerlink" title="实例188 始终在桌面最顶层显示窗体"></a>实例188 始终在桌面最顶层显示窗体</h2><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>Windows桌面上允许多个窗体同时显示,但是只有一个窗体能够得到焦点,当一个窗体得到焦点后在其上面的窗体会被得到焦点的窗体遮挡,<strong>得到焦点的窗体会显示在最上层</strong>,这样被覆盖的窗体就不能完全地显示给用户,也有某些窗体中具有实时性和比较重要的信息需要随时置顶的特殊情况。本实例将实现此功能,运行本实例后,<strong>主窗体会始终显示在桌面的最上面</strong>。实例的运行效果如图14-2所示。</p><hr><p>指点迷津:在图14.2中,画图程序与其弹出的保存窗口都位于本程序窗口之下,而且画图程序拥有系统与鼠标焦点</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mingrisoft;</span><br><span class="line"><span class="keyword">import</span> java.awt.BorderLayout;</span><br><span class="line"><span class="keyword">import</span> java.awt.EventQueue;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JLabel;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JPanel;</span><br><span class="line"><span class="keyword">import</span> javax.swing.SwingConstants;</span><br><span class="line"><span class="keyword">import</span> javax.swing.UIManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlwaysActiveWindows</span> <span class="keyword">extends</span> <span class="title">JFrame</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2637188442724889987L</span>;</span><br><span class="line"><span class="keyword">private</span> JPanel contentPane;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Launch the application.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">UIManager.setLookAndFeel(</span><br><span class="line"><span class="string">"com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e)</span><br><span class="line">&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">EventQueue.invokeLater(<span class="keyword">new</span> Runnable()</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">AlwaysActiveWindows frame = <span class="keyword">new</span> AlwaysActiveWindows();</span><br><span class="line">frame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create the frame.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AlwaysActiveWindows</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">setTitle(<span class="string">"始终在桌面最顶层显示的窗体"</span>);<span class="comment">// 设置窗体标题</span></span><br><span class="line">setAlwaysOnTop(<span class="keyword">true</span>);<span class="comment">// 设置窗体显示在最顶端。本实例的核心代码</span></span><br><span class="line">setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">setBounds(<span class="number">100</span>, <span class="number">100</span>, <span class="number">319</span>, <span class="number">206</span>);<span class="comment">// 设置窗体位置</span></span><br><span class="line">contentPane = <span class="keyword">new</span> JPanel();<span class="comment">// 创建内容面板</span></span><br><span class="line">contentPane.setLayout(<span class="keyword">new</span> BorderLayout(<span class="number">0</span>, <span class="number">0</span>));<span class="comment">//设置网格布局0行0列</span></span><br><span class="line">setContentPane(contentPane);<span class="comment">// 设置内容面板到窗体中</span></span><br><span class="line">JLabel label = <span class="keyword">new</span> JLabel(<span class="string">"我就在上面不下去了，咋滴。"</span>);</span><br><span class="line"><span class="comment">//设置标签内容沿 X 轴的对齐方式。</span></span><br><span class="line">label.setHorizontalAlignment(SwingConstants.CENTER);<span class="comment">//设置居中对齐</span></span><br><span class="line">contentPane.add(label, BorderLayout.CENTER);<span class="comment">// 添加标签控件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码:"></a>关键代码:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setAlwaysOnTop(<span class="keyword">true</span>);<span class="comment">// 设置窗体显示在最顶端。本实例的核心代码</span></span><br></pre></td></tr></table></figure><h3 id="技术要点-1"><a href="#技术要点-1" class="headerlink" title="技术要点"></a>技术要点</h3><p>在其他开发语言中<strong>实现窗体始终显示在最顶层</strong>比较复杂,但在Java中实现非常简单,<strong>只要调用窗体的 setAlwaysOnTop()方法即可</strong>。<br>setAlwaysOnTop()方法可以设置窗体是否置顶显示,也就是说是否使窗体始终显示在其他窗体之上。其语法格式如下:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setAlwaysOnTop</span><span class="params">(<span class="keyword">boolean</span> alwaysOnTop)</span> <span class="keyword">throws</span> SecurityException</span></span><br></pre></td></tr></table></figure><p></p><p>设置alwaysOnTop参数为true，则窗体保持置顶显示。</p><h2 id="实例189-设置窗体大小"><a href="#实例189-设置窗体大小" class="headerlink" title="实例189 设置窗体大小"></a>实例189 设置窗体大小</h2><h3 id="实例说明-1"><a href="#实例说明-1" class="headerlink" title="实例说明"></a>实例说明</h3><p>用户打开软件后,首先看到的就是软件窗体的大小,那么如何设置窗体的大小就成了摆在开发者面前的一个首要问题。本实例将告诉读者,如何使用Java语言实现限制窗体大小的功能。</p><h3 id="实例源码"><a href="#实例源码" class="headerlink" title="实例源码"></a>实例源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.mingrisoft;</span><br><span class="line"><span class="keyword">import</span> java.awt.BorderLayout;</span><br><span class="line"><span class="keyword">import</span> java.awt.EventQueue;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JLabel;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JPanel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControlFormSize</span> <span class="keyword">extends</span> <span class="title">JFrame</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2085588912441845548L</span>;</span><br><span class="line"><span class="keyword">private</span> JPanel contentPane;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Launch the application.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">EventQueue.invokeLater(<span class="keyword">new</span> Runnable()</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">ControlFormSize frame = <span class="keyword">new</span> ControlFormSize();</span><br><span class="line">frame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create the frame.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ControlFormSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">setTitle(<span class="string">"设置窗体大小"</span>);<span class="comment">// 设置窗体标题</span></span><br><span class="line">setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);<span class="comment">// 默认关闭方式</span></span><br><span class="line">setSize(<span class="number">400</span>, <span class="number">300</span>);<span class="comment">// 设置窗体大小</span></span><br><span class="line">contentPane = <span class="keyword">new</span> JPanel();<span class="comment">// 创建内容面板</span></span><br><span class="line">contentPane.setLayout(<span class="keyword">new</span> BorderLayout(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">setContentPane(contentPane);<span class="comment">// 设置内容面板</span></span><br><span class="line">JLabel label = <span class="keyword">new</span> JLabel(<span class="string">"宽度：400，高度：300"</span>);<span class="comment">// 创建标签控件</span></span><br><span class="line">contentPane.add(label, BorderLayout.CENTER);<span class="comment">// 添加标签控件到窗体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="技术要点-2"><a href="#技术要点-2" class="headerlink" title="技术要点"></a>技术要点</h2><p>本实例在实现设置窗体大小的功能时,主要用到了<strong>窗体的 setSize()方法</strong>。设置窗体大小的方法有以下两种重载格式。<br>(1) Dimension参数<br>第一个重载方法以 Dimension类的实例对象作为参数,其语法格式如下<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pulic <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(Dimension size)</span></span></span><br></pre></td></tr></table></figure><p></p><p>参数说明size:封装单个控件中宽度与高度的对象<br>(2)int参数<br>第二个重载方法以int类型常量作为参数,其语法格式如下:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br></pre></td></tr></table></figure><p></p><p>参数说明</p><ul><li>width:窗体的宽度(以像素为单位)</li><li>height:窗体的高度(以像素为单位)</li></ul><p>Dimension对象用于封装单个控件的宽度与高度,创建其对象的语法格式如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dimension</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br></pre></td></tr></table></figure><p></p><p>参数说明</p><ul><li>width:控件的宽度(以像素为单位)。</li><li>height:控件的高度(以像素为单位)。</li></ul><h2 id="实例190-根据桌面大小调整窗体大小"><a href="#实例190-根据桌面大小调整窗体大小" class="headerlink" title="实例190 根据桌面大小调整窗体大小"></a>实例190 根据桌面大小调整窗体大小</h2><h3 id="实例说明-2"><a href="#实例说明-2" class="headerlink" title="实例说明"></a>实例说明</h3><p>窗体与桌面的大小比例是软件运行时用户经常会注意到的一个问题,如在1024×768的桌面上,如果放置一个很大(如1280×104)或者很小(如10×10)的正方形窗体,会显得非常不协调。正是基于以上这种情况,所以<strong>大部分软件的窗体都是根据桌面的大小进行自动调整的</strong>,本实例就实现这样的功能。</p><h3 id="实例源码-1"><a href="#实例源码-1" class="headerlink" title="实例源码"></a>实例源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mingrisoft;</span><br><span class="line"><span class="keyword">import</span> java.awt.BorderLayout;</span><br><span class="line"><span class="keyword">import</span> java.awt.Dimension;</span><br><span class="line"><span class="keyword">import</span> java.awt.EventQueue;</span><br><span class="line"><span class="keyword">import</span> java.awt.Toolkit;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowAdapter;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JPanel;</span><br><span class="line"><span class="keyword">import</span> javax.swing.border.EmptyBorder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetFormSizeByDeskSize</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8256394807443698879L</span>;</span><br><span class="line">    <span class="keyword">private</span> JPanel contentPane;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Launch the application.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EventQueue.invokeLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    SetFormSizeByDeskSize frame = <span class="keyword">new</span> SetFormSizeByDeskSize();</span><br><span class="line">                    frame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create the frame.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SetFormSizeByDeskSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        addWindowListener(<span class="keyword">new</span> WindowAdapter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowOpened</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">                do_this_windowOpened(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        setTitle(<span class="string">"\u6839\u636E\u684C\u9762\u5927\u5C0F\u8C03\u6574\u7A97\u4F53\u5927\u5C0F"</span>);</span><br><span class="line">        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        setBounds(<span class="number">100</span>, <span class="number">100</span>, <span class="number">450</span>, <span class="number">300</span>);</span><br><span class="line">        contentPane = <span class="keyword">new</span> JPanel();</span><br><span class="line">        contentPane.setBorder(<span class="keyword">new</span> EmptyBorder(<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>));</span><br><span class="line">        contentPane.setLayout(<span class="keyword">new</span> BorderLayout(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        setContentPane(contentPane);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">do_this_windowOpened</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">        Toolkit toolkit = getToolkit();<span class="comment">// 获得窗体工具包</span></span><br><span class="line">        Dimension screenSize = toolkit.getScreenSize();<span class="comment">// 获取屏幕大小</span></span><br><span class="line">        <span class="keyword">int</span> width = (<span class="keyword">int</span>) (screenSize.width * <span class="number">0.8</span>);<span class="comment">// 计算窗体新宽度</span></span><br><span class="line">        <span class="keyword">int</span> height = (<span class="keyword">int</span>) (screenSize.height * <span class="number">0.8</span>);<span class="comment">// 计算窗体新宽度</span></span><br><span class="line">        setSize(width, height);<span class="comment">// 设置窗体大小</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关键代码-1"><a href="#关键代码-1" class="headerlink" title="关键代码:"></a>关键代码:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Toolkit toolkit = getToolkit();<span class="comment">// 获得窗体工具包</span></span><br><span class="line">Dimension screenSize = toolkit.getScreenSize();<span class="comment">// 获取屏幕大小</span></span><br><span class="line"><span class="keyword">int</span> width = (<span class="keyword">int</span>) (screenSize.width * <span class="number">0.8</span>);<span class="comment">// 计算窗体新宽度</span></span><br><span class="line"><span class="keyword">int</span> height = (<span class="keyword">int</span>) (screenSize.height * <span class="number">0.8</span>);<span class="comment">// 计算窗体新宽度</span></span><br><span class="line">setSize(width, height);<span class="comment">// 设置窗体大小</span></span><br></pre></td></tr></table></figure><h3 id="技术要点-3"><a href="#技术要点-3" class="headerlink" title="技术要点"></a>技术要点</h3><p>本实例实现的重点是如何获取桌面的大小,而获取桌面大小时,主要用到<strong>窗体的工具包Toolkit类</strong>。下面对本实例中用到的关键技术进行详细介绍。<br>(1)获取窗体工具包<br>每个窗体类都提供了 getToolkit()方法来获取窗体的工具包对象。在窗体内部已经封装了这个工具包,随时可以获取。该方法的声明如下:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Toolkit <span class="title">getToolkit</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p></p><p>(2)获取桌面屏幕大小<br><strong>窗体的工具包提供了 getScreenSize()方法来获取<code>当前屏幕的大小</code></strong>,该方法的声明如下:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Dimension <span class="title">getScreenSize</span><span class="params">()</span> <span class="keyword">throws</span> HeadlessException</span>;</span><br></pre></td></tr></table></figure><p></p><h2 id="实例191-自定义最大化、最小化和关闭按钮"><a href="#实例191-自定义最大化、最小化和关闭按钮" class="headerlink" title="实例191 自定义最大化、最小化和关闭按钮"></a>实例191 自定义最大化、最小化和关闭按钮</h2><h3 id="实例说明-3"><a href="#实例说明-3" class="headerlink" title="实例说明"></a>实例说明</h3><p>用户在制作应用程序时,为了使用户界面更加美观,一般都<strong>自己设计窗体的外观,以及窗体的最大化、最小化和关闭按钮</strong>。本实例实现设计窗体的外观,及最大化、最小化和关闭按钮,再通过鼠标来实现窗体移动效果。**</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/475d5fec/">Swing入门1</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Java经典编程300例 </category>
          
          <category> Swng入门 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java-Preferences用法-入门</title>
      <link href="/blog/4db92b83/"/>
      <url>/blog/4db92b83/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:20 GMT+0800 (中国标准时间) --><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要:"></a>摘要:</h2><p>我们经常需要<strong>将我们的程序中的配置</strong>(如窗口位置，本次打开过的文件，用户的选项设置)等数据<code>保存</code>下来，当再次运行的时候程序会自动加载这些配置信息，初始化程序。<br>例如:<strong>很多软件的菜单里都有“Setting”或“Preferences”这样的选项用来设定或修改软件的配置</strong>,如下图所示。</p><p><img src="http://pefsyzdwh.bkt.clouddn.com/18-9-26/16767765.jpg" alt=""><br><a id="more"></a></p><h2 id="保存程序配置的方式"><a href="#保存程序配置的方式" class="headerlink" title="保存程序配置的方式"></a>保存程序配置的方式</h2><p>保存配置文件有多种方式，比如使用<code>xml</code>文件、<code>properties</code>文件等，采用这些保存方式的一个问题就是如果程序是以jar,war 包等方式发布的那么这些配置文件就不能放在包中，因为包中的文件是不能在运行时改动的，只能放在磁盘的文件中，但是放在磁盘的文件中又很容易出现因为操作系统的差异、权限等问题造成程序的问题。<br>另一种方式是使用<code>java.util.prefs.Preferences</code>类(首选项类)来保存程序配置。</p><h2 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h2><p>使用配置文件的方式，通常的做法是通过使用<strong>Properties类</strong>来实现，它提供以下方法:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">load</span><span class="params">(InputStream inStream)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">store</span><span class="params">(OutputStream out, String header)</span></span></span><br><span class="line"><span class="function">String <span class="title">getProperty</span><span class="params">(String key, String defaultValue)</span></span></span><br><span class="line"><span class="function">String <span class="title">getProperty</span><span class="params">(String key)</span></span></span><br></pre></td></tr></table></figure><p></p><p>来操作配置文件。</p><h2 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h2><p>从JDK 1.4开始，Java在java.util下加入了<strong>一个专门处理用户和系统配置信息</strong>的java.util.prefs包，其中，java.util.prefs.Preferences类用来读写程序配置信息。Preferences提供一个与平台无关的中心知识库来存储配置信息，<strong>在Windows系统中，它存储在注册表中</strong>，<strong>Linux中它存在于用户目录下的一个隐藏文件中</strong>，但不管Windows还是Linux，都是使用相同的接口，程序员无需深究它的底层是如何实现的。不仅如此，你还可以把<strong>首选项导出为XML文件或从XML文件导入</strong>。<br><!--more--></p><p>Preferences的中心知识库是树状结构，内部的配置信息<code>以key-value的结构进行存储</code>。每个用户都有一棵用户树，存放与本用户有关的配置,<strong>不用用户数下可以有同名的子树，因此可以避免同名文件冲突</strong>。当然，还有一个系统树，用来存放全体用户的公共信息。</p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><p>首先要获取首选项对象，Preferences是一个抽象类，提供了一系列静态方法和抽象方法来获取首选项对象。</p><h3 id="获取首选项对象"><a href="#获取首选项对象" class="headerlink" title="获取首选项对象"></a>获取首选项对象</h3><p>为了区分不同的应用程序的首选项，在建立Preferences时要指定一个节点路径。</p><h4 id="得到系统配置节点"><a href="#得到系统配置节点" class="headerlink" title="得到系统配置节点"></a>得到系统配置节点</h4><ul><li><code>public static Preferences systemNodeForPackage(Class&lt;?&gt; c)</code>从<strong>系统首选项树</strong>返回首选项节点。<ul><li>//根据指定的Class对象得到一个Preferences对象，Windows中,这个对象的注册表是从“HKEY_LOCAL_MACHINE\”开始的</li></ul></li><li><code>Preferences myPrefs2 = Preferences.systemNodeForPackage(this);</code>// 这种方法是在“HKEY_LOCAL_MACHINE\”下按当前类的路径建立一个注册表项<h4 id="系统的根首选项节点"><a href="#系统的根首选项节点" class="headerlink" title="系统的根首选项节点"></a>系统的根首选项节点</h4></li><li><code>public static Preferences systemRoot()</code>返回<strong>系统的根首选项节点</strong><ul><li>得到以注册表路径<code>HKEY_LOCAL_MACHINE\SOFTWARE\Javasoft\Prefs</code> 为根结点的Preferences对象</li></ul></li><li><code>Preferences myPrefs4 = Preferences.systemRoot().node(&quot;com.jungleford.demo&quot;);</code><ul><li>// 这种方法是在“HKEY_LOCAL_MACHINE\SOFTWARE\Javasoft\Prefs\”下按“com\jungleford\demo”的路径建立一个注册表项</li></ul></li></ul><h4 id="得到用户配置节点"><a href="#得到用户配置节点" class="headerlink" title="得到用户配置节点"></a>得到用户配置节点</h4><ul><li><code>public static Preferences userNodeForPackage(Class&lt;?&gt; c)</code>从调用<strong>用户首选项树</strong>返回首选项节点<ul><li>//根据指定的Class对象得到一个Preferences对象，这个对象的注册表路径是<code>从“HKEY_CURRENT_USER\”开始</code>的<br>例如</li></ul></li><li><code>Preferences myPrefs1 = Preferences.userNodeForPackage(this);</code><ul><li>// 这种方法是在“HKEY_CURRENT_USER\”下按当前类的路径建立一个注册表项</li></ul></li></ul><h4 id="得到用户根首选项节点"><a href="#得到用户根首选项节点" class="headerlink" title="得到用户根首选项节点"></a>得到用户根首选项节点</h4><ul><li><code>public static Preferences userRoot()</code>返回调用用户的根首选项节点。<ul><li>//得到以注册表路径<code>HKEY_CURRENT_USER\SOFTWARE\Javasoft\Prefs</code>为根结点的Preferences对象</li></ul></li><li><code>Preferences myPrefs3 = Preferences.userRoot().node(&quot;com.jungleford.demo&quot;);</code><ul><li>// 这种方法是在“HKEY_CURRENT_USER\SOFTWARE\Javasoft\Prefs\”下按“com\jungleford\demo”的路径建立一个注册表项</li></ul></li></ul><h3 id="设置首选项"><a href="#设置首选项" class="headerlink" title="设置首选项"></a>设置首选项</h3><p>读取首选项的值</p><ul><li><code>putXXX()</code> //设置一个属性的值，这里XXX可以为基本数值型类型，如int、long等，但首字母大写，表示参数为相应的类型，也可以不写而直接用put，参数则为字符串</li></ul><p>获取到首选项对象后，就可以往首选项中添加键值对了。这通过putXXX()方法来实现,具体方法如下表所示。</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>abstract void put(String key, String value)</code></td><td style="text-align:left">将指定值与此首选项节点中的指定键相关联。</td></tr><tr><td style="text-align:left"><code>abstract void putBoolean(String key, boolean value)</code></td><td style="text-align:left">将表示指定 boolean 值的字符串与此首选项节点中的指定键相关联。</td></tr><tr><td style="text-align:left"><code>abstract void putByteArray(String key, byte[] value)</code></td><td style="text-align:left">将表示指定字节数组的字符串与此首选项节点中的指定键相关联。</td></tr><tr><td style="text-align:left"><code>abstract void putDouble(String key, double value)</code></td><td style="text-align:left">将表示指定 double 值的字符串与此首选项节点中的指定键相关联。</td></tr><tr><td style="text-align:left"><code>abstract void putFloat(String key, float value)</code></td><td style="text-align:left">将表示指定 float 值的字符串与此首选项节点中的指定键相关联。</td></tr><tr><td style="text-align:left"><code>abstract void putInt(String key, int value)</code></td><td style="text-align:left">将表示指定 int 值的字符串与此首选项节点中的指定键相关联。</td></tr><tr><td style="text-align:left"><code>abstract void putLong(String key, long value)</code></td><td style="text-align:left">将表示指定 long 值的字符串与此首选项节点中的指定键相关联。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myPrefs1.putInt(<span class="string">"key1"</span>, <span class="number">10</span>);<span class="comment">//添加Int类型的值</span></span><br><span class="line">myPrefs1.putDouble(<span class="string">"key2"</span>, -<span class="number">7.15</span>);<span class="comment">//添加浮点数类型的值</span></span><br><span class="line">myPrefs1.put(<span class="string">"key3"</span>, <span class="string">"value3"</span>);<span class="comment">//添加字符串类型的值</span></span><br></pre></td></tr></table></figure><h3 id="读取首选项"><a href="#读取首选项" class="headerlink" title="读取首选项"></a>读取首选项</h3><p>通过<code>getXXX(String key,xxx xxxvalue)</code>方法,得到一个键对应的值。详细的方法如下表所示。</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>abstract String get(String key, String def)</code></td><td style="text-align:left">返回与此首选项节点中指定键相关联的值。</td></tr><tr><td style="text-align:left"><code>abstract boolean getBoolean(String key, boolean def)</code></td><td style="text-align:left">返回与此首选项节点中指定的键相关联的、由字符串表示的 boolean 值。</td></tr><tr><td style="text-align:left"><code>abstract byte[] getByteArray(String key, byte[] def)</code></td><td style="text-align:left">返回与此首选项节点中指定键相关联的、由字符串表示的字节数组。</td></tr><tr><td style="text-align:left"><code>abstract double getDouble(String key, double def)</code></td><td style="text-align:left">返回与此首选项节点中指定的键相关联的、由字符串表示的 double 值。</td></tr><tr><td style="text-align:left"><code>abstract float getFloat(String key, float def)</code></td><td style="text-align:left">返回与此首选项节点中指定的键相关联的、由字符串表示的 float 值。</td></tr><tr><td style="text-align:left"><code>abstract int getInt(String key, int def)</code></td><td style="text-align:left">返回与此首选项节点中与指定键相关联的、由字符串表示的 int 值。</td></tr><tr><td style="text-align:left"><code>abstract long getLong(String key, long def)</code></td><td style="text-align:left">返回与此首选项节点中指定的键相关联的、由字符串表示的 long 值。</td></tr></tbody></table><p>getXXX(String key,xxx def)方法的第一个参数是键的名字key,如果首选项中有这个键key，就返回这个键对应的值。如果没有这个键key,就把第二个参数def返回。<br>下面是getInt()方法的说明:</p><blockquote><p><code>public abstract int getInt(String key,int def)</code><br>返回与此首选项节点中与指定键相关联的、由字符串表示的 int 值。<br><strong>参数</strong>：<br>key - 要作为 int 返回其关联值的键。<br>def - 此首选项节点不具有与 key 相关联的值或者无法将该关联值解释为 int 或者内部存储不可访问时要返回的值。<br><strong>返回</strong>：<br><strong>与此首选项节点的 key 相关联的字符串所表示的 int 值；如果该关联值不存在或无法被解释为 int，则返回 def</strong>。</p></blockquote><h3 id="首选项和XML文件的相互转换"><a href="#首选项和XML文件的相互转换" class="headerlink" title="首选项和XML文件的相互转换"></a>首选项和XML文件的相互转换</h3><ul><li><code>exportNode()</code> //将全部首选项导出为一个XML文件</li><li><code>exportSubtree()</code> //将部分首选项导出为一个XML文件</li><li><code>importPreferences()</code> //从XML文件导入首选项</li></ul><h2 id="Windows首选项实例-写注册表"><a href="#Windows首选项实例-写注册表" class="headerlink" title="Windows首选项实例(写注册表)"></a>Windows首选项实例(写注册表)</h2><h3 id="写注册表实例"><a href="#写注册表实例" class="headerlink" title="写注册表实例:"></a>写注册表实例:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> my.preference.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.prefs.Preferences;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//到 `HKEY_CURRENT_USER\SOFTWARE\Javasoft\Prefs\`下的创建(如果不存在)new_preferences这个注册表项。</span></span><br><span class="line">Preferences myPrefs1 = Preferences.userRoot().node(<span class="string">"new_preferences"</span>);</span><br><span class="line">myPrefs1.putInt(<span class="string">"key1"</span>, <span class="number">100</span>);<span class="comment">//添加Int类型的值</span></span><br><span class="line">myPrefs1.putDouble(<span class="string">"key2"</span>, -<span class="number">1.234</span>);<span class="comment">//添加浮点数类型的值</span></span><br><span class="line">myPrefs1.put(<span class="string">"key3"</span>, <span class="string">"value3"</span>);<span class="comment">//添加字符串类型的值</span></span><br><span class="line">String key3=<span class="keyword">null</span>;</span><br><span class="line">             <span class="comment">//查询注册表项</span></span><br><span class="line">key3=myPrefs1.get(<span class="string">"key3"</span>, <span class="string">"如果没有，就返回第二个参数"</span>);</span><br><span class="line">System.out.println(<span class="string">"注册表查询结果:key3--&gt;"</span>+key3);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注册表查询结果:key3--&gt;value3</span><br></pre></td></tr></table></figure><p></p><p>运行完毕后，打开注册表,可以看到我们新建的注册表项，如下图所示。<br><img src="http://pefsyzdwh.bkt.clouddn.com/18-9-24/37825815.jpg" alt=""></p><h2 id="把首选项导出为XML文件"><a href="#把首选项导出为XML文件" class="headerlink" title="把首选项导出为XML文件"></a>把首选项导出为XML文件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">"prefs.xml"</span>);</span><br><span class="line">myPrefs1.exportNode(out);</span><br></pre></td></tr></table></figure><p>上面我们已经在注册表中写入了一些键值对。现在我我们来把这些键值对导出为XML文件:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> my.preference.test;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.prefs.BackingStoreException;</span><br><span class="line"><span class="keyword">import</span> java.util.prefs.Preferences;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 得到HKEY_CURRENT_USER\SOFTWARE\Javasoft\Prefs\下的new_preferences这个注册表项。</span></span><br><span class="line">Preferences myPrefs1 = Preferences.userRoot().node(<span class="string">"new_preferences"</span>);</span><br><span class="line"><span class="keyword">try</span> (FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">"prefs.xml"</span>);)</span><br><span class="line">&#123;</span><br><span class="line">myPrefs1.exportNode(out);<span class="comment">//导出到xml文件</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e)</span><br><span class="line">&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (BackingStoreException e)</span><br><span class="line">&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>生成的XML文件内容如下:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE preferences SYSTEM &quot;http://java.sun.com/dtd/preferences.dtd&quot;&gt;</span><br><span class="line">&lt;preferences EXTERNAL_XML_VERSION=&quot;1.0&quot;&gt;</span><br><span class="line">  &lt;root type=&quot;user&quot;&gt;</span><br><span class="line">    &lt;map/&gt;</span><br><span class="line">    &lt;node name=&quot;new_preferences&quot;&gt;</span><br><span class="line">      &lt;map&gt;</span><br><span class="line">        &lt;entry key=&quot;key1&quot; value=&quot;100&quot;/&gt;</span><br><span class="line">        &lt;entry key=&quot;key2&quot; value=&quot;-1.234&quot;/&gt;</span><br><span class="line">        &lt;entry key=&quot;key3&quot; value=&quot;value3&quot;/&gt;</span><br><span class="line">      &lt;/map&gt;</span><br><span class="line">    &lt;/node&gt;</span><br><span class="line">  &lt;/root&gt;</span><br><span class="line">&lt;/preferences&gt;</span><br></pre></td></tr></table></figure><p></p><h3 id="实例2-程序从上次关闭位置启动窗体"><a href="#实例2-程序从上次关闭位置启动窗体" class="headerlink" title="实例2:程序从上次关闭位置启动窗体"></a>实例2:程序从上次关闭位置启动窗体</h3><p>具体实例<a href="/2018/09/24/读书笔记/Java经典编程300例/Swng入门/Swing入门1/#实例187-从上次关闭位置启动窗体">参见</a></p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p>参考1:<a href="https://www.cnblogs.com/qlong8807/p/3424834.html" target="_blank" rel="noopener">https://www.cnblogs.com/qlong8807/p/3424834.html</a><br>参考2:<a href="http://lugerman.blog.163.com/blog/static/264645720079144346158/" target="_blank" rel="noopener">http://lugerman.blog.163.com/blog/static/264645720079144346158/</a><br>参考3:<a href="https://www.cnblogs.com/pzy4447/p/4710539.html" target="_blank" rel="noopener">https://www.cnblogs.com/pzy4447/p/4710539.html</a><br>参考4:<a href="https://www.cnblogs.com/littlehb/p/3511689.html" target="_blank" rel="noopener">https://www.cnblogs.com/littlehb/p/3511689.html</a><br>参考5:<a href="https://blog.csdn.net/cilen/article/details/7762593" target="_blank" rel="noopener">https://blog.csdn.net/cilen/article/details/7762593</a><br>参考6:<a href="https://blog.csdn.net/fish1112/article/details/6536681" target="_blank" rel="noopener">https://blog.csdn.net/fish1112/article/details/6536681</a></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/4db92b83/">Java-Preferences用法-入门</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Java经典编程300例 </category>
          
          <category> 输入_输出 </category>
          
          <category> 参考 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>输入输出实例1</title>
      <link href="/blog/e34f172/"/>
      <url>/blog/e34f172/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><p><strong>在 Windows系统中,通过文件的扩展名来区别不同类型的文件</strong>。<strong>本实例将根据用户输入的扩展名,列出指定文件夹内该类型文件的文件名、文件大小和修改时间</strong>。实例的运行效果如图121所示。<br>com.mingrisoft</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/e34f172/">输入输出实例1</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Java经典编程300例 </category>
          
          <category> 输入_输出 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Cookie</title>
      <link href="/blog/8d4cbf50/"/>
      <url>/blog/8d4cbf50/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:20 GMT+0800 (中国标准时间) --><p>很多网站使用一些小文本串在连接之间存储持久的客户端状态,这些小文本串称为cookie。<strong>cookie在请求和响应的HTTP首部,从服务器传递到客户端,再从客户端传回服务器</strong>。服务器使用 cookie来指示会话ID、购物车内容、登录凭据、用户首选项等。例如,一个在线书店设置的 cookie可能值为ISBN=0802099912&amp;price=$34,95,指定我在购物车里放入的一本书。不过, cookie值更有可能是一个无意义的字符串,如ATVPDKIKXODER,标识某种数据库中的一个特定记录,实际信息存储在那个数据库中。 <strong>cookie值通常并不包含数据,只是指示服务器上的数据</strong>。</p><p><strong>cookies只能是非空白符的ASCII文本,不能包含逗号或分号</strong>。</p><p>要在浏览器中设置一个cookie,服务器会在HTTP首部中包含一个set-Cookie首部行。例如,下面的HTTP首部将cookie “cart”的值设置为“ATVPDKIKXODER”:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-type: text/html</span><br><span class="line">Set-Cookie: cart=ATVPDKIKXODER</span><br></pre></td></tr></table></figure><p></p><p>如果浏览器再向同一个服务器做出第二个请求,它会在HTTP请求首部行中的Cookie行发回这个 cookie,如下所示:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Get /index.html HTTP/1.1</span><br><span class="line">Host: www.example.org</span><br><span class="line">Cookie: cart=ATVPDKIKXODER</span><br><span class="line">Accept: text/html</span><br></pre></td></tr></table></figure><p></p><p>只要服务器不重用cookie,这会使它在多个(否则无状态的)HTTP连接上<strong>跟踪各个用户和会话</strong>。</p><p>服务器可以设置不止一个 cookie。例如,我向 Amazon发出的一个请求在我的浏览器上设置了5个 cookie:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: skin=hoskin</span><br><span class="line">Set-Cookie: ubid-main=176-5578236-9590213</span><br><span class="line">Set-Cookie: session-token=Zg6afPNqbaMv2WmYFOv57ZCU106Ktr</span><br><span class="line">Set-Cookie: session-id-time=20827872011</span><br><span class="line">Set-Cookie: session-id=187-4969589-3049309</span><br></pre></td></tr></table></figure><p></p><p>除了简单的name= value对, cookie可以有多个属性来控制它们的作用域,包括过期日期、路径、域、端口、版本和安全选项。</p><p>例如,默认情况下, cookie来自哪个服务器就应用于哪个服务器。如果一个 cookie由<code>www.foo.example.com</code>设置,浏览器就只把这个cookie发回给<code>www.foo.example.com</code>。不过网站也可以指示一个 cookie应用于整个子域,而不只是最初的服务器。例如,下面这个请求为整个foo.example.com域设置一个用户cookie:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-cookie: user=elharo;Domain=.foo.example.com</span><br></pre></td></tr></table></figure><p></p><p>浏览器不只是把这个cookie回送到<code>www.foo.example.com</code>,还会发送给<code>lothar.foo.example.com</code>、<code>eliza.foo.example.com</code>、<code>enoch.foo.example.com</code>和<code>foo.example.com</code>域中的任何其他主机。不过,服务器只能为它直接所属的域设置 cookie。<code>www.foo.example.com</code>就不能为<code>www.oreilly.com</code>、example.com或.com设置cookie,而不论它如何设置域。</p><hr><p>提示:<br>一些网站把一个域的一个图像或其他内容嵌入在另一个域的一个页面中,从而绕过限制。所嵌入内容设置的 cookie(而不是由页面本身设置)称为第三方 cookie。很多用会阻塞所有第三方 cookie,出于保密的原因,一些web浏览器也开始默认阻塞这些第三方cookie。</p><hr><p>Cookie的作用域还受路径限制,所以会返回到服务器上的某些目录,而不是全部。默认作用域是最初的URL和所有子目录。例如,如果为URL <code>http://www.cafeconleche.org/XOM</code>设置一个 cookie,那么这个 cookie还可以应用于<code>http://www.cafeconleche.org/XOM/apidocs/</code>,但不能应用于<code>http://www.cafeconleche.org/slides/</code>或<code>http://www.cafeconleche.org/</code>。不过<strong>,可以使用 cookie中的Path属性改变默认作用域</strong>。例如,下面的响应为浏览器发送了一个名为“user”、值为“ elharo”的 cookie,它只应用于服务器的/restricted子树,而不能应用于网站的其他部分:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: user=elharo; Path=/restricted</span><br></pre></td></tr></table></figure><p></p><p>请求相同服务器上子树/restricted中的一个文档时,客户端会回显这个 cookie。不过,它不会在网站的其他目录中使用这个 cookie。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/8d4cbf50/">Cookie</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第6章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>第六章其他部分还么看完</title>
      <link href="/blog/d216da09/"/>
      <url>/blog/d216da09/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:20 GMT+0800 (中国标准时间) --><p>本文链接: <a href="https://www.lansheng.net.cn/blog/d216da09/">第六章其他部分还么看完</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第6章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>请求主体</title>
      <link href="/blog/868d0199/"/>
      <url>/blog/868d0199/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:20 GMT+0800 (中国标准时间) --><p>GET方法获取URL所标识的资源的一个表示。用GET从服务器获取的资源的具体位置由路径和查询字符串的不同部分指定。不同的路径和查询字符串如何映射到不同的资源要由服务器来确定。URL类并不关心这些。只要它知道URL,就能从那里下载。</p><p>POST和PUT要更为复杂。在这些情况下,客户端除了要提供路径和查询字符串,还要提供资源的表示。资源表示在请求主体中发送,放在首部后面。也就是说,它会按顺序发送以下4项:</p><ol><li>一个起始行,包括方法、路径和查询字符串,以及HTTP版本。</li><li>一个HTTP首部</li><li>一个空行(两个连续的回车换行对)</li><li>主体</li></ol><p>例如,下面这个POST请求向服务器发送表单数据:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /cgi-bin/register.pl Http <span class="number">1.0</span></span><br><span class="line">Date: Sun, <span class="number">27</span> Apr <span class="number">2013</span> <span class="number">12</span>:<span class="number">32</span>:<span class="number">36</span></span><br><span class="line">Host: www.cafeaulait.org</span><br><span class="line">Content-type: application/x-www-form-urlencoded</span><br><span class="line">Content-length: <span class="number">54</span></span><br><span class="line"></span><br><span class="line">username=Elliotte+Harold&amp;email=elharo%<span class="number">40</span>ibiblio.org</span><br></pre></td></tr></table></figure><p></p><p>在这个例子中,主体包含一个 <code>application/x-www-form-urlencode</code>数据,但并不只有这种可能。一般来讲,主体可以包含任意的字节。不过,HTTP首部要包括两个字段来指定主体的性质:</p><ul><li>一个 Content-length字段,指定主体中有多少字节(前面的例子中为54字节)。</li><li>一个 Content-type字段,指定类型的MIME媒体类型(前面的例子中内容类型为application/x-www-form-urlencoded)</li></ul><p>前例中使用的 application/x-www-form-urlencode MIME类型很常见,因为Web浏览器对大多数提交表单就采用这种编码方式。因此很多服务器端程序都使用这个MIME类型与浏览器对话。不过,这绝不是主体能发送的唯一类型。例如,向一个照片共享网站上传图片的相机可以发送 image/jpeg。文本编辑器可以发送 text/html。最后都是作为字节传送。例如,下面是一个上传Atom文档的PUT请求:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PUT /blog/software-development/the-power-of-pomodoros/ HTTP/1.1</span><br><span class="line">Host: elharo.com</span><br><span class="line">User-Agent: AtomMaker/1.0</span><br><span class="line">Authorization: Basic ZGFmZnk6c2VjzXJIdA==</span><br><span class="line">Content-Type: application/atom+xml; type=entry</span><br><span class="line">Content-Length: 322</span><br><span class="line"></span><br><span class="line">&lt;?xml version=\&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;entry xmlns=&quot;http://www.w3.org/2005/Atom&quot;&gt;</span><br><span class="line">    &lt;title&gt;The Power of Pomodoros&lt;/title&gt;</span><br><span class="line">    &lt;id&gt;urn:uuid:101a41a6-722b-4dgb-8afb-ccfbo1d77499&lt;/id&gt;</span><br><span class="line">    &lt;updated&gt;2013-02-22T19:40:522&lt;/updated&gt;</span><br><span class="line">    &lt;author&gt;&lt;name&gt;Elliotte Harold&lt;/name&gt;&lt;/author&gt;</span><br><span class="line">    &lt;content&gt;I hadn&apos;t paid much attention to Pomodoro ...&lt;/content&gt;</span><br><span class="line">&lt;/entry&gt;</span><br></pre></td></tr></table></figure><p></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/868d0199/">请求主体</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第6章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>HTTP方法</title>
      <link href="/blog/af23364e/"/>
      <url>/blog/af23364e/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:20 GMT+0800 (中国标准时间) --><p>与HTTP服务器的通信遵循一种<strong>请求-响应模式</strong>:先是一个无状态的请求,后面是一个无状态的响应。<strong>每个HTTP请求包括两个或三个部分</strong>:</p><ul><li>起始行,包含HTTP方法和要执行这个方法的资源的路径。</li><li>一个包含名-值字段的首部,可以提供元信息,如认证凭据和请求中首选使用的格式。</li><li>一个请求主体,包含资源的一个表示(只针对POST和PUT)。</li></ul><p>主要有<strong>4个HTTP方法</strong>(也可以说是4个动词),来标识可以完成的操作:</p><ul><li>GET</li><li>POST</li><li>PUT</li><li>DELETE</li></ul><p>如果觉得这太少了,特别是你可能已经习惯了设计程序时数不胜数的面向对象方法,相比之下,这确实太少了,要知道这是因为HTTP把重点主要放在名词上,即由URI标识的资源。这<strong>4个方法提供的统一接口基本上已经足以满足所有实用用途</strong>。</p><h3 id="GET方法"><a href="#GET方法" class="headerlink" title="GET方法"></a>GET方法</h3><p>这4个方法并不是任意的。它们有特定的语义,应用程序必须遵循这些语义。<strong>GET方法可以获取一个资源的表示</strong>。GET没有副作用,如果失败,完全可以重复执行GET,而不用担心有任何问题。另外,GET的输出通常会缓存,不过这可以用正确的首部来控制,稍后就会介绍。在一个有适当体系结构的系统中,可以对GET请求加书签,也可以预取GET请求,这是没有问题的。例如,不允许通过一个链接删除文件,因为在用户请求之前,浏览器可能会GET页面上的所有链接。与之对应,如果没有明确的用户动作,好的浏览器或web蜘蛛程序( spider)不会POST链接。</p><h3 id="PUT方法"><a href="#PUT方法" class="headerlink" title="PUT方法"></a>PUT方法</h3><p><strong>PUT方法将资源的一个表示<code>上传到已知URL的服务器</code></strong>。这个方法并非没有副作用,不过它有<strong>幂等性( idempotent)</strong>。也就是说,<strong>可以重复这个方法而不用担心它是否失败</strong>。如果连续两次把同一个文档放在同一个服务器的同一个位置,与只放一次相比,服务器的状态是一样的。</p><h3 id="DELETE方法"><a href="#DELETE方法" class="headerlink" title="DELETE方法"></a>DELETE方法</h3><p><strong>DELETE方法从一个指定URL删除一个资源</strong>。同样的,这个方法也并非没有副作用,但它也是幂等的。如果你不确定一个删除请求是否成功(例如,有可能在你发送这个请求之后但在接收到响应之前, socket突然断开),在这种情况下,完全可以再次发送这个请求。<strong>将同一个资源删除两次不是错误</strong>。</p><h3 id="POST方法"><a href="#POST方法" class="headerlink" title="POST方法"></a>POST方法</h3><p><strong>POST方法</strong>是最通用的方法。它也<strong>将资源的一个表示上传到已知URL的服务器,**</strong>但是没有指定服务器如何处理这个新提供的资源<strong>。例如,服务器不一定把资源放在目标URL上,而是有可能把它移至另一个不同的URL。或者服务器可能使用这个数据来更新一个或多个完全不同的资源的状态。</strong>POST要用于不能重复的不安全的操作**,如完成一个交易。</p><p>由于GET请求在URL中包括了所有必要的信息,所以<strong>可以对GET请求<code>加书签</code>,或者进行<code>链接</code>和<code>搜索</code>等。</strong>POST、PUT和 DELETE请求则不能。这是有意这样设计的。<strong>GET用于非提交的动作,如浏览一个静态Web页面</strong>。而其他方法,尤其是<strong>POST,则用于提交某个东西的动作</strong>。例如,在购物车里增加一个商品应当发送一个GET,因为这个动作没有提交,用户还可以放弃这个购物车。不过,下订单就应当发送一个POST,因为这个动作完成了一个提交。正是因为这个原因,<strong>当你要返回一个使用POST的页面时,浏览器会询问你是否确定这样做</strong>(见图6-1)。重新提交数据可能会重复买两本同样的书,你的信用卡会支付两次。<br><img src="http://pefsyzdwh.bkt.clouddn.com/18-9-21/48376130.jpg" alt=""><br>在实际中,如今POST在Web上被大量滥用。<strong>不完成提交的所有安全操作应当使用GET而不是POST。只有真正提交的操作才应当使用POST</strong>。</p><hr><p>读者:我还是不明白什么叫真正提交的操作。</p><hr><p>之所以有时会错误地选择POST而不是GET,一个原因是表单可能需要大量输入。在这方面有一个老掉牙的误解,<strong>以为浏览器只能处理几百个字节的查询字符串。尽管在20世纪90年代中期确实是这样,但如今所有主流浏览器都能很好地应对至少2000个字符的URL</strong>。如果有更多的表单数据需要提交,可能确实要支持POST。不过,对于非浏览器客户端,安全操作还是倾向于使用GET方法。实际上,这种情况没有你想象得那么常见。只有当你向服务器上传数据来创建一个新资源时有可能超过这个限制(在这种情况下,POST或PUT往往是合适的选择),否则,如果只是在服务器上定位一个现有的资源,一般都不会超过这个限制。</p><p>除了这4个主要的HTTP方法,特殊场合下还会用到另外几个HTTP方法。其中最常用的方法是<strong>HEAD,这个方法就相当于GET,只不过它只返回资源的首部,而不返回具体数据</strong>。这个方法常用于检查文件的修改日期,查看本地缓存中存储的文件副本是否仍然有效。</p><p><strong>Java支持的另外两个HTTP方法是OPTIONS和TRACE</strong>。<strong>OPTIONS允许客户端询问服务器可以如何处理一个指定的资源, TRACE会回显客户端请求来进行调试</strong>,特别是代理服务器工作不正常时。不同的服务器还可能识别其他非标准的方法,包括COPY和MOVE,不过Java不支持这些方法。</p><p>上一章介绍的URL类使用GET与HTTP服务器通信。URLConnection类(第7章将介绍)可以使用所有这4种方法。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/af23364e/">HTTP方法</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第6章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Keep-Alive</title>
      <link href="/blog/4badba9c/"/>
      <url>/blog/4badba9c/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:20 GMT+0800 (中国标准时间) --><p><strong>HTTP 1.0会为每个请求打开一个新连接</strong>。<strong>实际上,一个典型Web会话中<code>打开和关闭所有连接所花费的时间远远大于实际传输数据的时间</code>,特别是有很多小文档的会话</strong>。对于使用SSL或TLS的加密 HTTPS连接,这个问题尤其严重,因为建立一个安全 socket的握手过程比建立常规的 socket需要做更多工作。</p><p>在HTTP 1.1和以后版本中,服务器不必在发送响应后就关闭连接。可以保持连接打开,在同一个 socket上等待来自客户端的新请求。可以在一个TCP连接上连续发送多个请求和响应。不过,服务器响应之后,客户端请求的锁步模式还是一样的。</p><p>客户可以在HTTP请求首部中包括一个<code>Connection</code>字段,指定值为<code>Keep-Alive</code>,指示它希望重用一个 socket:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure><p></p><p>URL类透明地支持 Http Keep-alive,除非显式地关闭这个特性。也就是说,<strong>在服务器关闭连接之前,如果再次连接到同一个服务器,就会重用 socket</strong>。可以利用多个系统属性来控制Java如何使用 HTTP Keep-alive:</p><ul><li>设置http.keepAlive为”true”或”false”,启用/禁用HTTPKeep-Alive(<strong>默认是启用的</strong>)。</li><li>设置http.maxConnections为你希望同时保持打开的socket数。默认为5。</li><li>设置http.keepAlive.remainingData为true,使Java在丢弃连接之后完成清理(Java6或以后版本)。默认为 false。</li><li>设置sun.net.http.errorstream.enableBuffering为true,尝试缓冲400和500级响应的相对小的错误流,从而能释放连接,以备稍后重用。默认为 false。</li><li>设置sun.net.http.errorstream.bufferSize为缓冲错误流使用的字节数。默认为4096字节。</li><li>设置Set sun.net.http.errorstream.timeout为读错误流超时前的毫秒数。默认为300毫秒。</li></ul><p>这些默认值是有合理的,不过,你可能确实希望把sun.net.http.errorstream.enableBuffering设置为true,除非你希望从失败的请求读取错误流。</p><hr><p>提示:<br><strong>HTTP 2.0</strong>主要基于Google发明的SPDY协议,<strong>通过首部压缩、管线传输请求和响应,以及异步连接多路复用,进一步优化了HTTP传输</strong>。不过,这些优化通常在传输层完成,具体细节对应用程序员是屏蔽的,所以你编写的代码仍然主要遵循前面的1-4步。Java还不支持HTTP 2.0,不过增加这个功能时,<strong>只要你通过URL和URLConnection类访问HTTP服务器,你的程序不需要做任何修改就能利用这个功能</strong>。</p><hr><p>本文链接: <a href="https://www.lansheng.net.cn/blog/4badba9c/">Keep-Alive</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第6章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>第六章前言</title>
      <link href="/blog/1c294/"/>
      <url>/blog/1c294/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:20 GMT+0800 (中国标准时间) --><h2 id="第6章HTTP"><a href="#第6章HTTP" class="headerlink" title="第6章HTTP"></a>第6章HTTP</h2><p><strong>超文本传输协议(HypertextTransferProtocol,HTTP)是一个标准,定义了web客户端如何与服务器对话,以及数据如何从服务器传回客户端</strong>。尽管通常认为HTTP是一种传输HTML文件及文件中内嵌图片的方法,但<strong>实际上HTTP是一个数据格式</strong>。它可以用来传输TIFF图片、 Microsoft word文档、 Windows的<code>.exe</code>文件,或者<code>任何其他可以用字节表示的东西。</code>要编写使用HTTP的程序,你需要比一般的Web页面设计人员更深入地了解HTTP。这一章将深入后台,向你展示在浏览器的地址栏输入<code>http://www.google.com</code>并按Enter键时到底发生了什么。</p><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p><strong>HTTP是web浏览器和web服务器之间通信的标准协议</strong>。<strong>HTTP指定客户端与服务器如何建立连接、客户端如何从服务器请求数据,服务器如何响应请求,以及最后如何关闭连接</strong>。HTTP连接<strong>使用TCP/IP来传输数据</strong>。对于从客户端到服务器的每一个请求,都有4个步骤:<br>1.默认情况下,客户端在端口80打开与服务器的一个TCP连接,URL中还可以指定其他端口。<br>2.客户端向服务器发送消息,请求指定路径上的资源。这个请求包括一个首部,可选地(取决于请求的性质)还可以有一个空行,后面是这个请求的数据。<br>3.服务器向客户端发送响应。响应以响应码开头,后面是包含元数据的首部、一个空行以及所请求的文档或错误消息。<br>4.服务器关闭连接。</p><h3 id="HTTP-1-0和HTTP-1-1的区别"><a href="#HTTP-1-0和HTTP-1-1的区别" class="headerlink" title="HTTP 1.0和HTTP 1.1的区别"></a>HTTP 1.0和HTTP 1.1的区别</h3><p>这是基本<code>HTTP 1.0</code>过程。<strong>在HTTP 1.1及以后版本中,可以通过一个TCP连接连续发送多个请求和响应。也就是说,在第1步和第4步之间,第2步和第3步可以反复多次</strong>。另外,<strong>在HTTP 1.1中,请求和响应可以分为多个块发送</strong>。这样有更好的扩展性。</p><p>每个请求和响应都有同样的基本形式:一个首部行、一个包含元数据的HTTP首部，一个空行,然后是一个消息体。一般的客户端请求如下所示:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Get /index. html Http/1.1</span><br><span class="line">User-Agent: Mozilla/5.0(Macintosh; Intel Mac oS X 10.8; rv: 20.0)</span><br><span class="line">Gecko/20100101 Firefox/20.0</span><br><span class="line">Host: en.wikipedia.org</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Accept-Language: en-US,en; q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept: text/html, application/xhtml+xml, application/xml; q=0.9, */*;9=0.8</span><br></pre></td></tr></table></figure><p></p><p>像这样的GET请求不包含消息体,所以请求以一个空行结束。</p><p>第一行称为请求行( request line):<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get /index. html Http/1.1</span><br></pre></td></tr></table></figure><p></p><p>包括一个方法、资源的路径以及HTTP的版本。方法指定了所请求的操作。GET方法请求服务器返回资源的一个表示。/index.hml是从服务器请求的资源的路径。HTTP/1.1是客户理解的协议的版本。</p><p>尽管所需要的就是GET行,但客户端请求通常还会在首部中包括其他信息。各行采用如:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Keyword: value</span><br></pre></td></tr></table></figure><p></p><p><strong>关键字不区分大小写</strong>。值有时区分大小写,有时也不区分。<strong>关键字和值都只能是ASCII</strong>。<strong>如果一个值太长,可以在下一行最前面增加一个空格或制表符,接续上一行</strong>。</p><p>首部中的行以一个回车换行对结束。</p><p>这个例子中的第一个关键字是User-Agent：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: Mozilla/5.0(Macintosh; Intel Mac oS X 10.8; rv: 20.0)</span><br></pre></td></tr></table></figure><p></p><p>这会让服务器知道使用的是什么浏览器,并允许服务器发送为特定浏览器类型而优化的文件。下面一行指出请求来自Lynx浏览器的2.4版本:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: Lynx/2.4 libwww/2.1.4</span><br></pre></td></tr></table></figure><p></p><p>除了最老的第一代浏览器,还可以包括一个Host域来指定服务器的名,允许Web服务器区分来自相同IP地址的不同名的主机:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host: www.cafeaulait.org</span><br></pre></td></tr></table></figure><p></p><p>这个例子中最后一个关键字是 Accept：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: text/html, application/xhtml+xml, application/xml; q=0.9, */*;9=0.8</span><br></pre></td></tr></table></figure><p></p><p>它告诉服务器客户端可以处理哪些数据类型(但服务器常常忽略这一点)。例如,下面一行指出客户端可以处理4种MIME媒体类型,分别对应HTML文档、纯文本及JPEG和GIF图片:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: text/html, text/plain, image/gif, image/jpeg</span><br></pre></td></tr></table></figure><p></p><p><strong>MIME类型分为两级:类型(type)和子类型( subtype)</strong>。<strong>类型非常概括地展示包含的是何种数据</strong>:图片、文本,还是影片。子类型标识数据的特定类型:GIF图像、JPEG图像、TIFF图像。例如,HTML的内容类型是text/html,那么类型是text,子类型是htmL。JPEG图像的内容类型是 image/jpeg,类型是 image,子类型是jpeg。<strong>已经定义了8个顶级类型</strong>:</p><ul><li><code>text/*</code>表示人可读的文字。</li><li><code>Image/*</code>表示图片。</li><li><code>model/*</code>表示3D模型,如VRML文件。</li><li><code>audio/*</code>表示声音。</li><li><code>video/*</code>表示移动的图片,可能包括声音。</li><li><code>application/*</code>表示二进制数据。</li><li><code>message/*</code>表示协议特定的信封,如emai消息和HTTP响应。</li><li><code>multipart/*</code>表示多个文档和资源的容器。</li></ul><p>每个类型分别有很多不同的子类型。</p><p>可以在<code>http://www.iana.org/assignments/media-types/</code>访问已注册的MIME类型最新列表。另外,可以自由定义非标准的定制类型和子类型,只要它们以x-开头。例如, Flash文件通常会指定为 <code>application/ x-shockwave-fash</code>类型。</p><p>最后,请求以一个空行结束,也就是说,包括<code>两个回车/换行对`</code>\r\n\r\n`。</p><p>一旦服务器看到这个空行,它就开始通过同一个连接向客户端发送它的响应。<strong>这个响应以一个状态行开始,后面是一个首部,这个首部采用请求首部同样的“名:值”语法描述响应,然后是一个空行,最后是所请求的资源</strong>。一个典型的成功响应如下所示:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Sun, 21 Apr 2013 15:12:46 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: text/html; charset=ISO-8859-1</span><br><span class="line">Content-length: 115</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;A Sample HTML file&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;The rest of the document goes here&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p></p><p>第一行：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure><p></p><p>指示了服务器使用的协议(HTTP/1.1),后面是一个响应码,<code>200 OK</code>是最常用的响应码,<strong>表示这个请求是成功的</strong>。</p><p>其他首部行：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Date: Sun, 21 Apr 2013 15:12:46 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: text/html; charset=ISO-8859-1</span><br><span class="line">Content-length: 115</span><br></pre></td></tr></table></figure><p></p><p>分别指出做出请求的日期(采用服务器的时间帧)、服务器软件( Apache)、承诺服务器结束发送时会关闭连接、MIME媒体类型,以及所传输文档的长度(不考虑这个首部),在这里就是107字节。</p><p>表6-1列出了你最有可能遇到的标准及试验响应码,这里不包括 WebDAV使用的几个响应码。<br>表6-1:HTTP1.1响应码<br><a href="https://www.cnblogs.com/isykw/p/6115469.html" target="_blank" rel="noopener">https://www.cnblogs.com/isykw/p/6115469.html</a><br>略，后续再补上。</p><p>不论哪个版本<strong>,响应码100到199总表示一个提供信息的响应,200到299总指示成功,300到399表示重定向,400到499总是指示一个客户端错误,而500到599总表示一个服务器错误</strong>。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/1c294/">第六章前言</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第6章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>第五章还没完，但是又太多看不懂的东西。</title>
      <link href="/blog/dd861dac/"/>
      <url>/blog/dd861dac/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:20 GMT+0800 (中国标准时间) --><p>第五章还没完，但是我感觉说了太多我不懂的东西，实例又太少了。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/dd861dac/">第五章还没完，但是又太多看不懂的东西。</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第5章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>通过GET与服务器端程序通信</title>
      <link href="/blog/f2b0eaf0/"/>
      <url>/blog/f2b0eaf0/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:20 GMT+0800 (中国标准时间) --><p><strong>URL类使得 Java applet和应用程序与服务器端程序</strong>(如CGI、 servlet、PHP页面和其他使用GET方法的程序)<strong>的通信非常容易</strong>(使用POST方法的服务器端程序需要使用URLConnection类,第7章将讨论有关内容)。你只需要知道程序希望接收怎样的名-值组合,然后用查询字符串构造URL,这个查询字符串提供所需的名和值。所有名和值都必须经过x-www-form-url-encoded编码,例如用 URLEncoder.encode()方法编码,如本章前面所述。</p><p>有很多种方法可以确定与特定程序对话的查询字符串的具体语法。如果你自己编写了服务器端程序,那么你已经知道它希望接收的名-值对。如果在你自己的服务器上安装了一个第三方程序,这个程序的文档会告诉你它希望接收什么。如果你在与一个外部网络API(已提供文档)对话,如 eBay Shopping API,这个服务通常会提供相当详细的文档,告诉你为了实现各种用途需要发送什么数据。</p><p>许多程序用于处理表单输入。如果是这种情况,要弄清程序希望得到什么输入会非常简单。<strong>表单使用的方法应当是FORM元素的 METHOD属性值。这个值要么是GET,要么是POST</strong>。如果是GET,就可以使用这里介绍的过程;如果是POST,则要使用第7章描述的过程。<strong>URL中查询字符串前面的部分由FORM元素的ACTION属性值给定</strong>。需要说明,这可能是一个相对URL,这里需要确定相应的绝对URL。最后,<strong>名-值对就是 INPUT元素的NAME属性</strong>。<strong><code>名-值对的值</code>就是用户在表单中输入的内容</strong>。</p><p>例如,考虑下面这个HTML表单,这个表单在我的 Cafe con Leche网站中作为本地搜索引擎。你会看到它使用了GET方法。处理表单的程序通过URL <code>http://www.google.com/search</code>进行访问。它有四个单独的名-值对,其中三个有默认值</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/f2b0eaf0/">通过GET与服务器端程序通信</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第5章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>代理</title>
      <link href="/blog/dde91df3/"/>
      <url>/blog/dde91df3/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:20 GMT+0800 (中国标准时间) --><p>许多系统通过代理服务器( proxy server)访问web,有时还会访问 Internet其他非HTTP部分。<strong>代理服务器接收到从本地客户端到远程服务器的请求。代理服务器向远程服务器发出请求,再将结果转发回本地客户端</strong>。有时这样做是出于安全原因,如防止远程主机了解关于本地网络配置的秘密细节。另外一些情况下,这样做是为了通过过滤出站请求,限制可以浏览的网站。例如,一所初级中学可能希望禁止访问<code>http://www.playboy.com</code>。还有一些情况则纯粹是出于性能的考虑,这样允许多个用户从本地缓存中获取同样的一些经常访问的文档,而不是重复从远程主机下载。</p><p>基于URL类的Java程序可以使用大多数常见的代理服务器和协议。事实上,正是出于这个原因,<strong>你要选择使用URL类,而不是在原始socket之上处理你自己的HTTP或其他客户</strong>。</p><h2 id="系统属性"><a href="#系统属性" class="headerlink" title="系统属性"></a>系统属性</h2><p>对于基本操作,所要做的就是设置一些系统属性,指示本地代理服务器的地址。如果使用纯粹的HTTP代理,则将http.proxyHost设置为代理服务器的域名或IP地址,将http.proxyPort设置为代理服务器的端口(默认为80)。还有一些其他方法,包括在Java代码中调用System.setProperty(),或在启动程序时使用-D选项。下面的例子将代理服务器设置为192.168.254.254,端口为9000:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dhttp.proxyHost=192.168.254.254 -Dhttp.proxyPort=9000</span><br></pre></td></tr></table></figure><p></p><p>如果代理需要一个用户名和口令,则需要安装一个 Authenticator,稍后将在“访问口令保护的网站”中介绍有关内容。</p><p><strong>如果希望一台主机不被代理,而是要直接连接,则要把http.nonProxyhosts系统属性设置为其主机名或IP地址</strong>。如果多个主机都不需要代理,可以用竖线分隔这些主机名。例如,下面的代码段会禁止代理<code>java.oreilly.com</code>和<code>xml.oreilly.com</code>:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置代理主机</span></span><br><span class="line">System.setProperty(<span class="string">"http.proxyHost"</span>,<span class="string">"192.168.254.254"</span>);</span><br><span class="line"><span class="comment">//设置代理端口</span></span><br><span class="line">System.setProperty(<span class="string">"http.proxyPort"</span>,<span class="string">"9000"</span>);</span><br><span class="line"><span class="comment">//设置多个主机不需要代理</span></span><br><span class="line">System.setProperty(<span class="string">"http.nonproxyHosts"</span>,<span class="string">"java.oreilly.com|xml.oreilly.com"</span>);</span><br></pre></td></tr></table></figure><p></p><p>还可以使用星号作为通配符,表示某个特定的域或子域内的所有主机都不应当代理。例如,要禁止代理oreilly.com域内的所有主机:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dhttp.proxyHost=192.168.254.254 -Dhttp.nonproxyHosts=*.oreilly.com</span><br></pre></td></tr></table></figure><p></p><p>如果使用FTP代理服务器,可以采用同样的方式设置 ftp.proxyHost、ftp.proxyPort和ftp.nonProxyHosts属性。</p><p>Java不支持任何其他应用层协议,但是如果对所有TCP连接都使用传输层 SOCKS代理,可以用 socks.ProxyHost和 socksProxyPort系统属性来确定。<strong>Java对于 SOCKS没有提供禁止代理选项</strong>。这是一个“全有或全无”的选择。</p><h2 id="Proxy类"><a href="#Proxy类" class="headerlink" title="Proxy类"></a>Proxy类</h2><p><strong>Proxy类</strong>允许从Java程序中对代理服务器进行更细粒度的控制。确切地讲,它<strong>允许你为不同的远程主机选择不同的代理服务器</strong>。代理本身用 java.net.Proxy类的实例来表示。仍然<strong>只有三种代理:HTTP、SOCKS和直接连接(即根本没有代理)</strong>,分别用Proxy.Type枚举中的三个常量来表示:</p><ul><li>Proxy.Type.DIRECT</li><li>Proxy.Type.HTTP</li><li>Proxy.Type.SOCKS</li></ul><p>除了类型之外,关于代理的其他重要信息包括它的地址和端口,用 SocketAddress对象表示。例如,下面的代码段创建了一个Proxy对象,表示proxy.example.com的端口80上的一个HTTP代理服务器:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SocketAddress address=<span class="keyword">new</span> InetSocketAddress(<span class="string">"proxy.example.com"</span>,<span class="number">80</span>);</span><br><span class="line">Proxy proxy = <span class="keyword">new</span> Proxy(proxy.Type.HTTP, address);</span><br></pre></td></tr></table></figure><p></p><p>虽然只有三种代理对象,但是对于不同主机上的不同代理服务器,可以有相同类型的多个不同代理。</p><h2 id="ProxySelector类"><a href="#ProxySelector类" class="headerlink" title="ProxySelector类"></a>ProxySelector类</h2><p>每个运行中的虛拟机都有一个java.net.ProxySelector对象,用来确定不同连接的代理服务器。默认的 ProxySelector只检查各种系统属性和URL的协议,来决定如何连接到不同的主机。不过,你可以安装自己的 ProxySelector子类来代替默认的选择器,用它根据协议、主机、路径、日期时间和其他标准来选择不同的代理。<br>这个类的关键是 select()抽象方法:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;Proxy&gt; <span class="title">select</span><span class="params">(URI uri)</span></span></span><br></pre></td></tr></table></figure><p></p><p>Java为这个方法传入一个URI对象(而不是URL对象),这表示需要连接的主机。举例来说,对于用URL类生成的连接,这个对象通常形式为<code>http://www.example.com/</code>或<code>ftp://fp.example.com/pub/iles</code>。对于用 Socket类生成的纯TCP连接,URI形式为 <code>socket://host:port</code>。例如,<code>socket://www.example.com:80</code>。然后ProxySelector为这种类型的对象选择正确的代理,并返回到一个 List&lt;Proxy中。</p><p>这个类中必须实现的第二个抽象方法是 connectFailed():<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectFailed</span><span class="params">(URI uri,SocketAddress address,IOException ex)</span></span></span><br></pre></td></tr></table></figure><p></p><p>这是一个回调方法,用于警告程序这个代理服务器实际上没有建立连接。示例5-9展示了一个ProxySelector,它尝试使用位于proxy.example.com的代理服务器完成所有HTTP连接,除非这个代理服务器之前未能成功解析与一个特定URL的连接。如果是这样,它会建议使用直接连接。</p><h3 id="示例5-9-ProxySelector会记住可以连接的URL"><a href="#示例5-9-ProxySelector会记住可以连接的URL" class="headerlink" title="示例5-9: ProxySelector会记住可以连接的URL"></a>示例5-9: ProxySelector会记住可以连接的URL</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalProxySelector</span> <span class="keyword">extends</span> <span class="title">ProxySelector</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;URI&gt; failed = <span class="keyword">new</span> ArrayList&lt;URI&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Proxy&gt; <span class="title">select</span><span class="params">(URI uri)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;Proxy&gt; result = <span class="keyword">new</span> ArrayList&lt;Proxy&gt;();</span><br><span class="line">        <span class="keyword">if</span> (failed.contains(uri) || !<span class="string">"http"</span>.equalsIgnoreCase(uri.getScheme())) </span><br><span class="line">        &#123;</span><br><span class="line">            result.add(Proxy.NO_PROXY);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            SocketAddress proxyAddress</span><br><span class="line">            = <span class="keyword">new</span> InetSocketAddress( <span class="string">"proxy.example.com"</span>, <span class="number">8000</span>);</span><br><span class="line">            Proxy proxy = <span class="keyword">new</span> Proxy(Proxy.Type.HTTP, proxyAddress);</span><br><span class="line">            result.add(proxy);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectFailed</span><span class="params">(URI uri, SocketAddress address, IOException ex)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        failed.add(uri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如前所述,每个虚拟机都只有一个ProxySelector。要改变这个 ProxySelector,需要把新的选择器传递给静态方法 ProxySelector.setDefault(),如下:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ProxySelector selector= new LocalProxySelector();</span><br><span class="line">ProxySelector.setDefault(selector);</span><br></pre></td></tr></table></figure><p></p><p>此后,虛拟机打开的所有连接都将向这个 ProxySelector询问将要使用的正确代理。一般不应在共享环境中运行的代码中使用这个方法。例如,<strong>不要在 servlet中改变ProxySelector,因为这会改变在同一个容器中运行的所有 servlet的 ProxySelector</strong>。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/dde91df3/">代理</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第5章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>URLDecoder</title>
      <link href="/blog/22d4526d/"/>
      <url>/blog/22d4526d/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:20 GMT+0800 (中国标准时间) --><p><strong>对应的 URLDecoder类有一个静态方法 decode(),它会对用 x-www-form-url-encoded格式编码的字符串进行<code>解码</code></strong>。也就是说,<strong>将所有加号转换为空格,所有百分号转义字符转换为对应的字符</strong>:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decode</span><span class="params">(String s, String encoding)</span> <span class="keyword">throws</span> UnsupportedEncodingException</span></span><br></pre></td></tr></table></figure><p></p><p>如果不确定使用哪种编码方式,那就选择UTF-8。它可能比所有其他方式都正确。</p><p>如果字符串包含一个百分号,但其后没有两个十六进制数字,或者字符串解码为无效的序列,就要抛出一个 IllegalArgumentException异常。由于这个方法对非转义字符不做处理,所以可以传入整个URL,而不需要首先将它分解为各个部分。例如:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stringinput=<span class="string">"https://www.google.com/"</span>+</span><br><span class="line">                <span class="string">"search?h1=en&amp;as_=Java&amp;as_epq=I%2F0"</span>;</span><br><span class="line">String output= URLDecoder.decode(input,<span class="string">"UTF-8"</span>);</span><br><span class="line">System.out.println(output);</span><br></pre></td></tr></table></figure><p></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/22d4526d/">URLDecoder</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第5章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>URLEncoder</title>
      <link href="/blog/ee64a91a/"/>
      <url>/blog/ee64a91a/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:20 GMT+0800 (中国标准时间) --><p><strong>要对字符串完成URL编码,需要将这个字符串和字符集名传入 URLEncoder.encode()方法</strong>。例如:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String encoded= URLEncoder.encode (<span class="string">"Thi*string*has*asterisks"</span>,<span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure><p></p><p>URLEncoder.encode()返回输入字符串的一个副本,不过有一些调整。所有非字母数字字符会转换为%序列(除空格、下划线、连字符、点号和星号字符以外)。它还会对所有非ASCI字符编码。空格转换为加号。<strong>这个方法有点过于积极,它还会把波浪线、单引号、感叹号和圆括号转换为百分号转义字符,即使它们并不一定需要转换</strong>。不过,URL规范不禁止这种转换,所以Web浏览器会合理地处理这些过度编码的URL。</p><p><strong>尽管这个方法允许指定字符集,但是最好只选择UTF-8</strong>。与你选择的其他任何编码方式相比,UTF-8与IRI规范、URI类、现代Web浏览器和其他软件更兼容。</p><p>示例5-7是一个使用 URLEncoder.encode()显示各种编码字符串的程序。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Chapter5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncoderTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 对字符串完成URL编码</span></span><br><span class="line">System.out.println(</span><br><span class="line">URLEncoder.encode(<span class="string">"This string has spaces"</span>, <span class="string">"UTF-8"</span>));</span><br><span class="line"><span class="comment">//星号不用百分号转义</span></span><br><span class="line">System.out.println(</span><br><span class="line">URLEncoder.encode(<span class="string">"This*string*has*asterisks"</span>, <span class="string">"UTF-8"</span>));</span><br><span class="line"><span class="comment">//百分号用转义为"%25"</span></span><br><span class="line">System.out.println(URLEncoder</span><br><span class="line">.encode(<span class="string">"This%string%has%percent%signs"</span>, <span class="string">"UTF-8"</span>));</span><br><span class="line"><span class="comment">//加号转义为"%2B"</span></span><br><span class="line">System.out.println(</span><br><span class="line">URLEncoder.encode(<span class="string">"This+string+has+pluses"</span>, <span class="string">"UTF-8"</span>));</span><br><span class="line"><span class="comment">//斜杠转义为"%2F"</span></span><br><span class="line">System.out.println(</span><br><span class="line">URLEncoder.encode(<span class="string">"This/string/has/slashes"</span>, <span class="string">"UTF-8"</span>));</span><br><span class="line"><span class="comment">//反斜杠转义为"%22"</span></span><br><span class="line">System.out.println(URLEncoder</span><br><span class="line">.encode(<span class="string">"This\"string\"has\"quote\"marks"</span>, <span class="string">"UTF-8"</span>));</span><br><span class="line"><span class="comment">//冒号转义为"3A"</span></span><br><span class="line">System.out.println(</span><br><span class="line">URLEncoder.encode(<span class="string">"This:string:has:colons"</span>, <span class="string">"UTF-8"</span>));</span><br><span class="line"><span class="comment">//"~"转义为"%7E"</span></span><br><span class="line">System.out.println(</span><br><span class="line">URLEncoder.encode(<span class="string">"This~string~has~tildes"</span>, <span class="string">"UTF-8"</span>));</span><br><span class="line"><span class="comment">//开括号"("转义为"%28",闭括号")"转义为"%29"</span></span><br><span class="line">System.out.println(</span><br><span class="line">URLEncoder.encode(<span class="string">"This(string)has(parentheses)"</span>, <span class="string">"UTF-8"</span>));</span><br><span class="line"><span class="comment">//点号不转义</span></span><br><span class="line">System.out.println(</span><br><span class="line">URLEncoder.encode(<span class="string">"This.string.has.periods"</span>, <span class="string">"UTF-8"</span>));</span><br><span class="line"><span class="comment">//等号转义为:%3D</span></span><br><span class="line">System.out.println(</span><br><span class="line">URLEncoder.encode(<span class="string">"This=string=has=equals=signs"</span>, <span class="string">"UTF-8"</span>));</span><br><span class="line"><span class="comment">//单位与"&amp;"转义为"%26"</span></span><br><span class="line">System.out.println(</span><br><span class="line">URLEncoder.encode(<span class="string">"This&amp;string&amp;has&amp;ampersands"</span>, <span class="string">"UTF-8"</span>));</span><br><span class="line"><span class="comment">//"é"转义为"%C3%A9"</span></span><br><span class="line">System.out.println(URLEncoder</span><br><span class="line">.encode(<span class="string">"Thiséstringéhasénon-ASCII characters"</span>, <span class="string">"UTF-8"</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (UnsupportedEncodingException ex)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Broken VM does not support UTF-8"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>下面是这个程序的输出(注意由于源代码中存在非ASCII字符,这个代码需要以非ASCII的方式保存,选择的编码方式应当作为参数传递给编译器)。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">This+string+has+spaces</span><br><span class="line">This*string*has*asterisks</span><br><span class="line">This%25string%25has%25percent%25signs</span><br><span class="line">This%2Bstring%2Bhas%2Bpluses</span><br><span class="line">This%2Fstring%2Fhas%2Fslashes</span><br><span class="line">This%22string%22has%22quote%22marks</span><br><span class="line">This%3Astring%3Ahas%3Acolons</span><br><span class="line">This%7Estring%7Ehas%7Etildes</span><br><span class="line">This%28string%29has%28parentheses%29</span><br><span class="line">This.string.has.periods</span><br><span class="line">This%3Dstring%3Dhas%3Dequals%3Dsigns</span><br><span class="line">This%26string%26has%26ampersands</span><br><span class="line">This%C3%A9string%C3%A9has%C3%A9non-ASCII+characters</span><br></pre></td></tr></table></figure><p></p><p>特别注意这个方法对斜线(<code>/</code>)、与号(<code>&amp;</code>)、等号(<code>=</code>)和冒号(<code>:</code>)进行了编码。它不去判断这些字符在URL中如何使用。因此,你必须逐部分地对URL进行编码,而不是在个方法调用中对整个URL编码。这是很重要的一点,因为 URLEncoder最常见的用法是准备查询字符串,从而与使用GET方法的服务器端程序通信。例如,假设你希望对下面这个 Google搜索的URL进行编码:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.googlecom/search?h1=en&amp;as_q=Java&amp;as_epq=I/O</span><br></pre></td></tr></table></figure><p></p><p>以下代码段将对它进行编码:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String query= URLEncoder.encode(&quot;https://www.google.com/search?h1=en&amp;as_q=Java&amp;as_epq=I/O&quot;,&quot;utf-8&quot;);</span><br><span class="line">System.out.println(query);</span><br></pre></td></tr></table></figure><p></p><p>但遗憾的是,输出为:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https%3A%2F%2Fwww.google.com%2Fsearch%3Fh1%3Den%26as_q%3DJava%26as_epq%3DI%2FO</span><br></pre></td></tr></table></figure><p></p><p><strong>问题就在于, URLEncoder.encode()会盲目地进行编码</strong>。它对URL或查询字符串中使用的特殊字符(比如<code>/</code>和<code>=</code>)和需要编码的字符不加区分。因此,需要一次编码URL的一部分,如下所示:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">String query = URLEncoder.encode(</span><br><span class="line"><span class="string">"https://www.google.com/search?h1=en&amp;as_q=Java&amp;as_epq=I/O"</span>,</span><br><span class="line"><span class="string">"utf-8"</span>);</span><br><span class="line">System.out.println(query);</span><br><span class="line">String url = <span class="string">"https://www.google.com/search?"</span>;</span><br><span class="line">url += URLEncoder.encode(<span class="string">"h1"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line">url += <span class="string">"="</span>;</span><br><span class="line">url += URLEncoder.encode(<span class="string">"en"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line">url += <span class="string">"&amp;"</span>;</span><br><span class="line">url += URLEncoder.encode(<span class="string">"as_q"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line">url += <span class="string">"="</span>;</span><br><span class="line">url += URLEncoder.encode(<span class="string">"Java"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line">url += <span class="string">"&amp;"</span>;</span><br><span class="line">url += URLEncoder.encode(<span class="string">"as_epq"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line">url += <span class="string">"="</span>;</span><br><span class="line">url += URLEncoder.encode(<span class="string">"I/O"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line">System.out.println(url);</span><br><span class="line">&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这一次会得到我们真正想要的输出:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.google.com/search?h1=en&amp;as_q=Java&amp;as_epq=I%2FO</span><br></pre></td></tr></table></figure><p></p><p>在这里,你也可以跳过一些常量字符串,如“Java”,不对它们进行编码,因为从观察可以知道,这些字符串中不包含需要编码的字符。不过,一般来讲,这些值将是变量,而不是常量。为了安全还是需要对每一部分进行编码。</p><p>示例5-8是一个 QueryString类,它使用 URLEncoder对一个Java对象中连续的<code>名-值对</code>编码,这个对象将用来向服务器端程序发送数据。为了增加名-值对,需要调用add()方法,它接受两个字符串作为参数,并进行编码。 getQuery()方法返回编码后名值对的累积列表。<br>示例5-8: QueryString类<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryString</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> StringBuilder query = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QueryString</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自动添加名值对的分割符"&amp;"</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String name, String value)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        query.append(<span class="string">'&amp;'</span>);</span><br><span class="line">        encode(name, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(String name, String value)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//对名字编码</span></span><br><span class="line">            query.append(URLEncoder.encode(name, <span class="string">"UTF-8"</span>));</span><br><span class="line">            <span class="comment">//添加等号，名值对连接符</span></span><br><span class="line">            query.append(<span class="string">'='</span>);</span><br><span class="line">            <span class="comment">//对值编码</span></span><br><span class="line">            query.append(URLEncoder.encode(value, <span class="string">"UTF-8"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Broken VM does not support UTF-8"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getQuery</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> query.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getQuery();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>使用这个类,现在可以对前面的例子进行编码:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QueryString qs= <span class="keyword">new</span> QueryString();</span><br><span class="line">qs.add(<span class="string">"h1"</span>,<span class="string">"en"</span>);</span><br><span class="line">qs.add(<span class="string">"as_q"</span>,<span class="string">"Java"</span>);</span><br><span class="line">qs.add (<span class="string">"as_epq"</span>,<span class="string">"I/O"</span>);</span><br><span class="line">String url=<span class="string">"http://www.google.com/search?"</span>+qs;</span><br><span class="line">System.out.println(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.google.com/search?&amp;h1=en&amp;as_q=Java&amp;as_epq=I%2FO</span><br></pre></td></tr></table></figure><p></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/ee64a91a/">URLEncoder</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第5章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>URI类</title>
      <link href="/blog/448e8023/"/>
      <url>/blog/448e8023/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:20 GMT+0800 (中国标准时间) --><p><strong>URI是对URL的抽象</strong>,不仅包括<code>统一资源定位符</code>( Uniform resource locators,<code>URL</code>)还包括<code>统一资源名</code>(Uniform Resource Names,<code>URN</code>)。实际使用的URI大多是URL,但大多数规范和标准(如XML)都是用URI定义的。在Java中,URI用 java.net.URI类表示。这个类与 java.net.URL类的区别表现在3个重要的方面：</p><ul><li>URI类完全有关于资源的标识和URI的解析。它没有提供方法来获取URI所标识资源的表示。</li><li>相比URL类,URI类与相关的规范更一致。</li><li>URI对象可以表示相对URI。URL类在存储URI之前会将其绝对化。</li></ul><p>简而言之,<strong>URL对象是对应网络获取的应用层协议的一个表示</strong>,而<strong>URI对象纯粹用于解析和处理字符串</strong>。<strong>URI类没有网络获取功能</strong>。尽管URL类有一些字符串解析方法,如getFile()和 getRef(),但其中很多方法都有问题,与相关规范所要求的行为不完全一致。<strong>正常情况下,假如你想下载一个URL的内容,应当使用URL类</strong>,<strong>如果想使用URL来完成标识而不是获取(例如表示一个XML命名空间),就应当使用URI类</strong>。<strong>二者都需要时,可以通过 toURL()方法将URI转换为URL,还可以使用 toURI()方法将URL转换为URI</strong>。</p><h2 id="构造一个URI"><a href="#构造一个URI" class="headerlink" title="构造一个URI"></a>构造一个URI</h2><p>URI从字符串构造。可以把整个URI通过一个字符串传入构造函数,也可以分部分传入:</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>URI(String str)</code></td><td style="text-align:left">通过解析给定的字符串构造一个 URI。</td></tr><tr><td style="text-align:left"><code>URI(String scheme, String ssp, String fragment)</code></td><td style="text-align:left">根据给定的组成部分构造 URI。</td></tr><tr><td style="text-align:left"><code>URI(String scheme, String host, String path, String fragment)</code></td><td style="text-align:left">根据给定的组成部分构造分层 URI。</td></tr><tr><td style="text-align:left"><code>URI(String scheme, String authority, String path, String query, String fragment)</code></td><td style="text-align:left">根据给定的组成部分构造分层 URI。</td></tr><tr><td style="text-align:left"><code>URI(String scheme, String userInfo, String host, int port, String path, String query, String fragment)</code></td><td style="text-align:left">根据给定的组成部分构造一个分层 URI。</td></tr></tbody></table><p>与URL类不同,URI类不依赖于底层协议处理器。只要是URI语法上正确,Java就不需要为了创建URI对象而理解其协议。因此,不同于URL类,URI类可以用于新的试验性的URI模式。</p><p>第一个构造函数根据任何满足条件的字符串创建一个新的URI对象。例如:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">URI voice= <span class="keyword">new</span> URI(<span class="string">"tel:1-800-9988-9938"</span>);</span><br><span class="line">URI web=<span class="keyword">new</span> URI(<span class="string">"http://www.xml.com/pub/a/2003/09/17/stax.html#tid=_hbc"</span>);</span><br><span class="line">URI book=<span class="keyword">new</span> URI(<span class="string">"urn: isbn: 1-565-92870-9"</span>);</span><br></pre></td></tr></table></figure><p></p><p>如果字符串参数不遵循URI语法。例如,如果URI以冒号开头,这个构造函数将抛出一个 URISyntaxException异常。这是一个受查异常,所以需要捕获这个异常,或者在调用构造函数的方法中声明可能抛出该异常。不过,有一条语法规则不会检查。与URI规范不同的是,URI中使用的字符不限于ASCII它可以包括其他 Unicode字符,如é。在语法上URI没有多少限制,具体来讲,一旦不再需要对非ASCII字符编码,并且允许相对URI,那就没有什么限制了。<strong>几乎所有字符串都可以解释为URI</strong>。</p><p>第二个构造函数需要一个模式特定部分,主要用于非层次URI。模式( scheme)是URI的协议,如http、urn、tel等。它必须由ASCI字母、数字及三个标点字符(<code>+</code>、<code>-</code>和<code>.</code>)组成。模式必须以字母开头。如果为这个参数传入null,则省略模式,这样会创建一个相对URI。例如:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URI absolute=<span class="keyword">new</span> URI(<span class="string">"http"</span>,<span class="string">"//www.ibiblio.org"</span>,<span class="keyword">null</span>);</span><br><span class="line">URI relative= <span class="keyword">new</span> URI(<span class="keyword">null</span>,<span class="string">"/javafaq/index. shtml"</span>,<span class="string">"today"</span>);</span><br></pre></td></tr></table></figure><p></p><p>模式特定部分取决于URI模式的语法。对于http URI是一种情况,对于mailto URI则是另一种情况,对于 tel URI情况又有所不同。因为URI类会用百分号转义字符来对无效字符编码,实际上这部分不会有任何语法错误。</p><p>最后,第三个参数包含一个片段标识符(如果有的话)。再次说明<strong>,片段标识符中禁止的字符会自动转义</strong>。为这个参数传入null时,会忽略片段标识符。</p><p>第三个构造函数用于层次URI,如http和ftp URL。主机和路径(用<code>/</code>分隔)共同构成这个URI的模式特定部分。例如:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URI today=<span class="keyword">new</span> URI(<span class="string">"http"</span>,<span class="string">"www.ibiblio.org"</span>,<span class="string">"/javafaq/index.html"</span>,<span class="string">"today"</span>);</span><br></pre></td></tr></table></figure><p></p><p>这会生成URI <code>http://www.ibiblio.org/javafaq/index.html#today</code>。</p><p>如果这个构造函数无法根据提供的各个部分构成一个有效的层次URI。例如,如果有一个模式,所以URI必须是绝对URI,但路径并不是以/开头,那么它将抛出一个URISyntaxException异常。</p><p>第四个构造函数与前一个基本相同,只是添加了一个查询字符串部分。例如:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URI today=<span class="keyword">new</span> URI(<span class="string">"http"</span>,<span class="string">"www.ibiblio.org"</span>,<span class="string">"/javafaq/index.html"</span>,referrer=cnet&amp;date=<span class="number">2014</span>-<span class="number">02</span>-<span class="number">23</span><span class="string">","</span>today<span class="string">");</span></span><br></pre></td></tr></table></figure><p></p><p>与以往一样,任何不可转义的语法错误都会导致抛出 URISyntaxException异常,所有参数都可以传入null从而忽略这一部分。</p><p>第5个构造函数是前面两个构造函数调用的主层次URI构造函数。这个方法将授权机构分解为用户信息、主机和端口部分,每个部分分别有自己的语法规则。例如:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URI styles=<span class="keyword">new</span> URI(<span class="string">"ftp"</span>,<span class="string">"anonymous:elharo@ibiblio.org"</span>,<span class="string">"ftp.oreilly.com"</span>,<span class="number">21</span>,<span class="string">"/pub/stylesheet"</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p></p><p>不过,生成的URI仍然必须遵循URI的所有通用规则,再次说明,<strong>任何参数都可以传入null,从而在结果中忽略这一部分</strong>。</p><p>如果你确信你的URI是有效的,不违反任何规则,那么可以使用静态工厂方法URI.create()。与构造函数不同,它不抛出 URISyntaxException异常。例如,下面的调用将使用电子邮件地址作为口令为匿名FTP访问创建一个URI:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URI styles=URI.create(<span class="string">"ftp://anonymous:elharo%40ibiblio.orge@ftp.oreilly.com:21/pub/stylesheet”);</span></span><br></pre></td></tr></table></figure><p></p><p>如果这个URI证明是不正确的,这个方法会抛出一个 IllegalArgumentException异常。这是一个<strong>运行时异常,所以不需要显式声明或捕获这个异常</strong>。</p><h2 id="URI的各部分"><a href="#URI的各部分" class="headerlink" title="URI的各部分"></a>URI的各部分</h2><p>URI引用包括最多三个部分:<code>模式</code>,<code>模式特定部分</code>和<code>片段标识符</code>。一般格式为:<strong><code>模式:模式特定部分:片段</code></strong><br>如果省略模式,这个URI引用则是相对的。如果省略片段标识符,这个URI引用就是一个纯URI。URI类提供了一些获取方法,可以返回各个URI对象的这三个部分getRawFoo()方法返回URI各部分的编码形式,相应的getFoo()方法首先对所有用百分号转义的字符进行解码,然后返回解码后的部分:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getScheme</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSchemeSpecificPart</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getRawSchemeSpecificPart</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFragment</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getRawFragment</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p></p><hr><p>提示:之所以没有 getRawScheme()方法,这是因为URI规范要求:所有模式名都要由对URI合法的ASCI字符组成,模式名中不允许百分号转义。</p><hr><p>如果某个URI对象中没有相应的部分,这些方法就返回null例如,没有模式的相对URI或没有片段标识符的 Http URI。</p><p>有模式的URI是绝对(absolute)URI。没有模式的URI是相对( relative)URI。如果URI是绝对的, isAbsolute()方法返回true,如果是相对URI则返回 false。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAbsolute</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p></p><p>模式特定部分的细节根据模式类型的不同会有所差别。例如,在 tel URI中,模式特定部分的语法类似于电话号码。不过,在许多有用的URI中(包括很常见的file和http URI),<strong>模式特定部分都有一个特定的分层格式,划分为授权机构、路径和查询字符串</strong>。<strong>授权机构进一步分为用户信息、主机和端口</strong>。如果URI是一个层次URI时,isOpaque()返回 false,如果不是分层的URI,也就是说,如果是不透明( opaque)的,isOpaque()则返回true:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isopaque</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p></p><p>如果URI不透明,只能得到模式、模式特定部分和片段标识符。不过,如果URI是层次URI,那么对于层次URI的所有不同部分都有相应的获取方法:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAuthority</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFragment</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getHost</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPath</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getQuery</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUserInfo</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p></p><p>这些方法都返回解码后的部分。换句话说,<strong>百分号转义会改为它们实际表示的字符</strong>,如<strong>%3C</strong>会改为<code>&lt;</code>。如果希望得到URI原始的编码部分,还有五个对应的 getRawFoo()方法:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getRawAuthority</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String getRaw <span class="title">Fragment</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getRawPath</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getRawQuery</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getRawUserInfo</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p></p><p>记住,URI类与URI规范不同,非ASCI字符如é和ü绝不会先完成百分号转义,这样就仍会出现在 getRawFoo()方法返回的字符串中,除非最初用于构造URI对象的字符串已经编码。</p><hr><p>提示:之所以没有 getRawPort()和 getRawHost()方法,这是因为可以保证这些部分总是由ASCII字符组成的。</p><hr><p>当特定URI不包含某个信息时,例如URI <a href="http://www.example.com没有用户信息、路径、端口和查询字符串,相应的方法会返回null。getPort()是个例外。由于它声明为返回一个int,所以它无法返回null。实际上,它会返回-1表示省略了端口。" target="_blank" rel="noopener">http://www.example.com没有用户信息、路径、端口和查询字符串,相应的方法会返回null。getPort()是个例外。由于它声明为返回一个int,所以它无法返回null。实际上,它会返回-1表示省略了端口。</a></p><p>出于各种技术原因,Java并不总是在开始就检测授权机构部分中的语法错误,但这没有多少实际影响。不做这个检测的直接后果是,一般无法返回授权机构的各个部分:端口、主机和用户信息。在这种情况下,可以<strong>调用 parseServerAuthority()强制重新解析授权机构</strong>:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> URI <span class="title">parseServerAuthority</span><span class="params">()</span> <span class="keyword">throws</span> URISyntaxException</span></span><br></pre></td></tr></table></figure><p></p><p>原来的URI没有改变(URI对象是不可变的),但返回的URI对应用户信息、主机和端口有单独的授权机构部分。如果无法解析授权机构,就会抛出一个 URISyntaxException异常。</p><h3 id="示例5-6-URI的各部分"><a href="#示例5-6-URI的各部分" class="headerlink" title="示例5-6:URI的各部分"></a>示例5-6:URI的各部分</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URISplitter</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                URI u = <span class="keyword">new</span> URI(args[i]);</span><br><span class="line">                System.out.println(<span class="string">"The URI is "</span> + u);</span><br><span class="line">                <span class="keyword">if</span> (u.isOpaque()) </span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(<span class="string">"This is an opaque URI."</span>);</span><br><span class="line">                    System.out.println(<span class="string">"The scheme is "</span> + u.getScheme());</span><br><span class="line">                    System.out.println(<span class="string">"The scheme specific part is "</span></span><br><span class="line">                    + u.getSchemeSpecificPart());</span><br><span class="line">                    System.out.println(<span class="string">"The fragment ID is "</span> + u.getFragment());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"This is a hierarchical URI."</span>);</span><br><span class="line">                    System.out.println(<span class="string">"The scheme is "</span> + u.getScheme());</span><br><span class="line">                    <span class="keyword">try</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        u = u.parseServerAuthority();</span><br><span class="line">                        System.out.println(<span class="string">"The host is "</span> + u.getHost());</span><br><span class="line">                        System.out.println(<span class="string">"The user info is "</span> + u.getUserInfo());</span><br><span class="line">                        System.out.println(<span class="string">"The port is "</span> + u.getPort());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (URISyntaxException ex) &#123;</span><br><span class="line"><span class="comment">//                      Must be a registry based authority</span></span><br><span class="line">                        System.out.println(<span class="string">"The authority is "</span> + u.getAuthority());</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">"The path is "</span> + u.getPath());</span><br><span class="line">                    System.out.println(<span class="string">"The query string is "</span> + u.getQuery());</span><br><span class="line">                    System.out.println(<span class="string">"The fragment ID is "</span> + u.getFragment());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (URISyntaxException ex) &#123;</span><br><span class="line">                System.err.println(args[i] + <span class="string">" does not seem to be a URI."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是对本节中3个URI例子运行这个程序的结果:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java URISplitter tel:+1-800-9988-9938 \</span><br><span class="line">http://www.xml.com/pub/a/2003/09/17/stax.html#id=_hbc \</span><br><span class="line">urn:isbn:1-565-92870-9</span><br></pre></td></tr></table></figure><p></p><p>运行结果:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">The URI is tel:+1-800-9988-9938</span><br><span class="line">This is an opaque URI.</span><br><span class="line">The scheme is tel</span><br><span class="line">The scheme specific part is +1-800-9988-9938</span><br><span class="line">The fragment ID is null</span><br><span class="line"></span><br><span class="line">The URI is http://www.xml.com/pub/a/2003/09/17/stax.html#id=_hbc</span><br><span class="line">This is a hierarchical URI.</span><br><span class="line">The scheme is http</span><br><span class="line">The host is www.xml.com</span><br><span class="line">The user info is null</span><br><span class="line">The port is -1</span><br><span class="line">The path is /pub/a/2003/09/17/stax.html</span><br><span class="line">The query string is null</span><br><span class="line">The fragment ID is id=_hbc</span><br><span class="line"></span><br><span class="line">The URI is urn:isbn:1-565-92870-9</span><br><span class="line">This is an opaque URI.</span><br><span class="line">The scheme is urn</span><br><span class="line">The scheme specific part is isbn:1-565-92870-9</span><br><span class="line">The fragment ID is null</span><br></pre></td></tr></table></figure><p></p><h2 id="解析相对URI"><a href="#解析相对URI" class="headerlink" title="解析相对URI"></a>解析相对URI</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> URI <span class="title">resolve</span><span class="params">(URI uri)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> URI <span class="title">resolve</span><span class="params">(String uri)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> URI <span class="title">relativize</span><span class="params">(URI uri)</span></span></span><br></pre></td></tr></table></figure><p>resolve()方法将uri参数与这个URI进行比较,并用它构造一个新的URI对象,这个对象包装了一个绝对URI。例如,考虑下面3行代码:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">URI absolute =<span class="keyword">new</span> URI(<span class="string">"http://www.example.com/"</span>);</span><br><span class="line">URI relative =<span class="keyword">new</span> URI(<span class="string">"images/logo.png"</span>);</span><br><span class="line">URI resolved =absolute.resolve(relative);</span><br></pre></td></tr></table></figure><p></p><p>执行之后,resolved包含绝对URI <code>http://www.example.com/images/logo.png</code>。</p><p>如果调用URI本身不包含绝对URI,那么 resolve()方法将尽可能地解析URI,并返回个新的相对URI对象作为结果。例如,考虑下面的语句:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URI top= <span class="keyword">new</span> URI(<span class="string">"javafaq/books/"</span>);</span><br><span class="line">URI resolved =top.resolve(<span class="string">"jnp3/examples/07/index.html"</span>);</span><br></pre></td></tr></table></figure><p></p><p>执行之后,现在 resolved包含相对 URI <code>javafag/books/jnp3/examples/07/index.html</code>,没有模式和授权机构。</p><p>还可以反向完成以上过程,即从绝对URI变成相对URI。relativize()方法根据相对于调用URI的uri参数创建一个新的URI对象。参数没有改变。例如：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">URI absolute=newURI(<span class="string">"http://www.example.com/images/logo.png"</span>);</span><br><span class="line">URI top=newURI(<span class="string">"http://www.example.com/"</span>);</span><br><span class="line">URI relative= top.relativize(absolute);</span><br></pre></td></tr></table></figure><p></p><p>URI对象 relative现在包含相对 URI images/logo.png。</p><h2 id="相等性和比较"><a href="#相等性和比较" class="headerlink" title="相等性和比较"></a>相等性和比较</h2><p>如你所期望的,可以测试URI的相等性。这不是直接的字符串比较。相等的URI必须都是层次的或不透明的。<strong>比较模式和授权机构时不考虑大小写</strong>。也就是说<code>http</code>和<code>HTTP</code>是相同的模式,<code>www.example.com</code>与<code>www.EXAMPLE.com</code>是相同的授权机构。<strong>URI的其余部分要区分大小写</strong>(除了用于转义无效字符的十六进制数字外)。转义字符在比较前不解码,<code>http://www.example.com/A</code>和<code>http://www.example.com/%41</code>是不相等的URI。</p><p>hashCode()方法与相等性是一致的。<strong>相等的URI有相同的散列码</strong>,不相等的URI不太可能有相同的散列码。</p><p><strong>URI实现了 Comparable</strong>,因此URI可以排序。基于各个部分的字符串比较,按以下列顺序进行排序:</p><ul><li>如果模式不同就比较模式,不考虑大小写。</li><li>否则,如果模式相同,一般认为层次URI小于有相同模式的不透明URI。</li><li>如果两个URI都是不透明URI,则根据模式特定部分对它们排序。</li><li>如果模式和不透明的模式特有部分都相等,就根据片段比较URI。</li><li>如果两个URI都是层次URI,则根据它们的授权机构部分排序,授权机构本身依次根据用户信息、主机和端口排序。主机比较不区分大小写</li><li>如果模式和授权机构都相等,就使用路径来区分。</li><li>如果路径也相等,就比较查询字符串。</li><li>如果查询字符串相等,就比较片段。</li></ul><p>除了与URI自身比较外,URI不能与其他任何类型比较。将URI与任何其他对象比较都会导致ClassCastException异常。</p><h2 id="字符串表示"><a href="#字符串表示" class="headerlink" title="字符串表示"></a>字符串表示</h2><p>有两个方法可以将URI对象转换为字符串: toString()和 toASCIIString()。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toASCIIString</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p></p><p><strong>toString()方法返回URI的未编码( unencoded)的字符串形式</strong>(也就是说,类似<code>è</code>和<code>\</code>的字符不用百分号转义)。因此,<strong>调用这个方法的结果不能保证是一个语法正确的URI</strong>,尽管实际上它是一个语法正确的IRI。<strong>这种形式有时对于向人们显示很有用(注:就是方便阅读),不过通常并不用于获取数据</strong>。</p><p><strong>toASCIIString()方法返回URI的编码( encoded)的字符串形式</strong>。类似<code>è</code>和<code>\</code>的字符总是会完成百分号转义,无论最初是否已转义。<strong>大多数时候都应当使用这种URI字符串形式尽管 toString()返回的形式对人而言更容易阅读</strong>,但有可能会复制粘贴到不希望接收到无效UR的地方(而 <strong>toString()返回的有可能是无效的URI</strong>)。<strong><code>toAsCIIString()总是返回语法正确的URI</code></strong>。</p><h2 id="x-www-form-urlencoded"><a href="#x-www-form-urlencoded" class="headerlink" title="x-www-form-urlencoded"></a>x-www-form-urlencoded</h2><p>Web设计人员面对的挑战之一是要处理不同操作系统之间的区别。这些不同会导致URL的问题。例如,有些操作系统允许文件中有空格,而有些不允许。大多数操作系统不反对文件名中出现#号,但在URL中#号表示文件名的结束,后面是片段标识符。其他特殊字符、非字母数字字符等在URL中或另一个操作系统上有特殊的意义,这也会产生类似的问题。另外,<strong>发明web时 Unicode还没有完全普及</strong>,所以并不是所有系统都能处理“<code>è</code>”和“本”之类的字符。为了解决这些问题,<strong>URL中使用的字符必须来自ASCII的个固定的子集,确切地讲,包括：</strong></p><ul><li>大写字母A-Z。</li><li>小写字母a-z。</li><li>数字0-9。</li><li>标点符号字符<ul><li><code>-</code></li><li><code>_</code></li><li><code>.</code></li><li><code>!</code></li><li><code>~</code></li><li><code>*</code></li><li><code>&#39;</code></li><li><code>,</code></li></ul></li></ul><p>字符:<code>/&amp;?@#;$+=和%</code>也可以使用,但只用于特定的用途。如果这些字符出现在路径或查询字符串中,它们以及所有其他字符都应当编码。</p><p>编码方式非常简单。<strong>除了ASCII数字、字母和前面指定的标点符号以外,所有其他字符都要转换为字节,每个字节要写为百分号后面加两个十六进制数字</strong>。空格是一种特殊情况,因为它太普遍了。除了编码为%20,空格可以编码为加号(+)。加号本身编码为%2B。<code>/#=&amp;</code>和<code>?</code>字符用在名字中时应当编码,但作为URL各部分之间的分隔符时不用编码。</p><p>URL类不自动编码或解码。可以使用无效的ASCII字符和非ASCII字符以及(或)百分号转义字符来构造URL对象。由 getPath()和 toExternalForm()等方法输出时,这样的字符和转义字符不会自动编码或解码。要由你负责确保在用来构造URL对象的字符串中对所有这些字符正确地编码。</p><p>幸运的是,Java提供了 URLEncoder和 URLDecoder类,可以对这种格式的字符串编解码。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/&#39;448e8023&#39;/">URI类</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第5章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>相等性和比较</title>
      <link href="/blog/20afcbfd/"/>
      <url>/blog/20afcbfd/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:20 GMT+0800 (中国标准时间) --><p>URL类包含通常的 equals()和 hashCode()方法。这些方法的行为与你预想的一样。<strong>当且仅当两个URL都指向相同主机、端口和路径上的相同资源,而且有相同的片段标识符和查询字符串,才认为这两个URL是相等的</strong>。不过,这里有一个惊喜。实际上 <strong>equals()方法会尝试用DNS解析主机,来判断两个主机是否相同</strong>,如可以判断<code>http://www.ibiblio.org</code>和<code>http://ibiblio.org/</code>是一样的。</p><hr><p>警告:这说明,URL上的 equals()可能是一个阻塞的I/O操作!出于这个原因,应当避免将URL存储在依赖 equals()的数据结构中,如java.util.HashMap。更好的选择是 <code>java.net.URI</code>,可以在必要时将URI与URL来回转换。</p><hr><p>另一方面,<strong>equals()还不够深入,不会具体比较两个URL标识的资源</strong>。例如,<code>http://www.oreilly.com/</code>不等于<code>http://www.oreilly.com/index.html</code>;另外<code>http://www.oreilly.com:80</code>也不等于<code>http://www.oreilly.com</code>。</p><p>示例5-5为<code>http://www.ibiblio.org/</code>和<code>http://ibiblio.org/</code>创建URL对象,并用equals()方法指出它们是否相等。<br>示例5-5:<code>http://www.ibiblio.org</code>和<code>http://ibiblio.org</code>相等吗?<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URLEquality</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            URL www = <span class="keyword">new</span> URL (<span class="string">"http://www.ibiblio.org/"</span>);</span><br><span class="line">            URL ibiblio = <span class="keyword">new</span> URL(<span class="string">"http://ibiblio.org/"</span>);</span><br><span class="line">            <span class="keyword">if</span> (ibiblio.equals(www)) </span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(ibiblio + <span class="string">" is the same as "</span> + www);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(ibiblio + <span class="string">" is not the same as "</span> + www);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException ex) &#123;</span><br><span class="line">            System.err.println(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行这个程序时,会发现:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ibiblio.org/ is the same as http://www.ibiblio.org/</span><br></pre></td></tr></table></figure><p></p><p>URL没有实现 Comparable。</p><p>URL类还有一个 sameFile()方法,可以检查两个URL是否指向相同的资源:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> same <span class="title">File</span><span class="params">(URL other)</span></span></span><br></pre></td></tr></table></figure><p></p><p>这个比较与 equals()基本上相同。这里也包括DNS查询,不过<strong>sameFile()不考虑片段标识符</strong>。比较<code>http://www.oreilly.com/index.html#p1</code>和<code>http://www.oreilly.com/index.html#q2</code>时, sameFile()返回true,而 equals()会返回 false。<br>下面的代码段使用 sameFile()比较两个URL:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">URL u1=<span class="keyword">new</span> URL(<span class="string">"http://www.ncsa.uiuc.edu/HTMLPrimer.html#GS"</span>);</span><br><span class="line">URL u2= <span class="keyword">new</span> URL(<span class="string">"http://www.ncsa.uiuc.edu/HTMLPrimer.html#HD"</span>);</span><br><span class="line"><span class="keyword">if</span>(u1.sameFile(u2))</span><br><span class="line">&#123;</span><br><span class="line">    System.out.prinln(u1+<span class="string">" is the same file as \n"</span>+u2);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.prinln(u1+<span class="string">" is not the same file as \n"</span>+u2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>输出如下:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://www.ncsa.uiuc.edu/HTMLPrimer.html#GS is the same file as</span><br><span class="line">http://www.ncsa.uiuc.edu/HTMLPrimer.html#HD</span><br></pre></td></tr></table></figure><p></p><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>URL有3个方法可以<strong>将一个URL实例转换为另外一种形式</strong>,分别是 toString()、toExternalForm()和 toURI()。</p><p>与所有好的类一样, java.net.URL有一个toString()方法。toString()生成的 String总是绝对URL,如<code>http://www.cafeaulait.org/javatutorial.html</code>。显式调用toString()并不常见。显示(打印)语句会隐式调用 toString()。除了显示(打印)语句以外,使用toExternalForm()更合适:</p><h3 id="public-String-toExternal"><a href="#public-String-toExternal" class="headerlink" title="public String toExternal();"></a>public String toExternal();</h3><p>toExternalForm()方法将一个URL对象转换为一个字符串,可以在HTML链接或Web浏览器的打开URL对话框中使用。<br>toExternalForm()方法返回表示这个URL的一个人可读的 String。它等同于 tostring()方法。事实上, toString()所做的就是返回 toExternalform()。</p><p>最后, toURI()方法将URL对象转换为对应的URI对象:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> URI <span class="title">toURI</span><span class="params">()</span> <span class="keyword">throws</span> URISyntaxException</span></span><br></pre></td></tr></table></figure><p></p><p>稍后将讨论URI类。在这里,你要了解的要点是URI类提供了比URL类更精确、更符合规范的行为。<strong>对于像绝对化和编码等操作,在选择时应当首选URI类</strong>。<strong>如果需要把URL存储在一个散列表或其他数据结构中,也应当首选URI类,因为它的equals()方法不会阻塞</strong>。<code>URL类应当主要用于从服务器下载内容</code>。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/20afcbfd/">相等性和比较</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第5章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>分解URL</title>
      <link href="/blog/7ee2319/"/>
      <url>/blog/7ee2319/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:20 GMT+0800 (中国标准时间) --><p>URL由以下5部分组成:</p><ul><li>模式,也称为协议。</li><li>授权机构。</li><li>路径。</li><li>片段标识符,也称为段或ref</li><li>查询字符串。</li></ul><p>例如,在URL <code>http://www.ibiblio.org/javafaq/books/jnp/index.html?isbn=1565922069#toc</code>中,模式是http,授权机构是<a href="http://www.ibiblio.org,路径是javafaq/books/jnp/index.html,片段标识符是toc,查询字符串是isbn=1565922069。不过,并非所有URL都有所有这些部分。例如,URL" target="_blank" rel="noopener">www.ibiblio.org,路径是javafaq/books/jnp/index.html,片段标识符是toc,查询字符串是isbn=1565922069。不过,并非所有URL都有所有这些部分。例如,URL</a> <code>http://www.fags.org/rfcs/rfc3986.html</code>只有模式、授权机构和路径,而没有片段标识符和查询字符串。</p><p>授权机构可以进一步划分为用户信息、主机和端口。例如,在URL <code>http://admin@www.blackstar.com:8080/</code>中,授权机构是<a href="mailto:`admin@www.blackstar.com" target="_blank" rel="noopener">`admin@www.blackstar.com</a>:8080`,包含用户信息admin、主机<a href="http://www.blackstar.com和端口8080。" target="_blank" rel="noopener">www.blackstar.com和端口8080。</a></p><p>9个公共方法提供了URL这些部分的只读访问: getFile(),getHost()、getPort()、 getProtocol()、 getRef()、 getQuery()、 getPath()、 getUserInfo()和getAuthority()。</p><h3 id="public-String-getProtocol"><a href="#public-String-getProtocol" class="headerlink" title="public String getProtocol()"></a>public String getProtocol()</h3><p><strong>getProtocol()方法返回一个String,其中包含URL的模式</strong>(如”http”,”https”或”file”)。例如,下面的代码段会打印https:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URL u=<span class="keyword">new</span> URL(<span class="string">"https://xkcd.com/727/"</span>);</span><br><span class="line">System.out.prinln(u.getProtocol());</span><br></pre></td></tr></table></figure><p></p><h3 id="public-String-getHost"><a href="#public-String-getHost" class="headerlink" title="public String getHost()"></a>public String getHost()</h3><p>getHost()方法返回一个 String,其中包含URL的主机名。例如,下面的代码段会打印xkcd.com<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URL u=<span class="keyword">new</span> URL(<span class="string">"https://xkcd.com/727/"</span>);</span><br><span class="line">System.out.println(u.getHost());</span><br></pre></td></tr></table></figure><p></p><h3 id="public-int-getPort"><a href="#public-int-getPort" class="headerlink" title="public int getPort()"></a>public int getPort()</h3><p>getport()方法将URL中指定的端口号作为一个int返回。如果URL中没有指定端口getPort()返回-1,表示这个URL没有显式指定端口,将使用该协议的默认端口。例如,如果URL是<code>http://www.userfriendly.org/</code>,getPort()会返回-1;如果URL是<code>http://ewwuserfriendly.org:80/</code>, getport()会返回80。下面的代码将显示端口号为-1,因为URL中没有指定端口:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URL u=<span class="keyword">new</span> URL(<span class="string">"http://www.ncsa.illinois.edu/AboutUs/"</span>);</span><br><span class="line">System.out.println(<span class="string">"The port part of"</span>+u+<span class="string">"is"</span>+u.getPort());</span><br></pre></td></tr></table></figure><p></p><h3 id="public-int-getDefaultPort"><a href="#public-int-getDefaultPort" class="headerlink" title="public int getDefaultPort()"></a>public int getDefaultPort()</h3><p>genFile()方法返回一个 String,其中包含<strong>URL的路径部分</strong>;要记住,Java不会把URL分解为单独的路径和文件部分。从主机名后的第一个斜线(/)一直到开始片段标识符的号之前的字符,都被认为是文件部分。例如:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URL page= <span class="keyword">this</span>.getDocumentBase();</span><br><span class="line">System.out.println(<span class="string">"This page's path is"</span>+page.getFile());</span><br></pre></td></tr></table></figure><p></p><p>如果URL没有文件部分,Java会把文件设置为空串。</p><h3 id="public-String-getPath"><a href="#public-String-getPath" class="headerlink" title="public String getPath()"></a>public String getPath()</h3><p>getPath()方法几乎是 genFile()的同义词。也就是说,它会返回一个 String,其中包含URL的路径和文件部分。但是与 getFile()不同,它返回的 String中不包括查询字符串,只有路径。</p><hr><p>警告:注意,并不像你想象的那样, getPath()方法不只是返回目录路径, genTile()也不只是返回文件名。 <strong>getPath()和 getFile()都返回完整的路径和文件名。唯一的区别是 genFile()还返回查询字符串,而 getPath()不返回这一部分。</strong></p><hr><h3 id="public-String-getRef"><a href="#public-String-getRef" class="headerlink" title="public String getRef()"></a>public String getRef()</h3><p>getRef()方法返回URL的片段标识符部分。如果URL没有片段标识符,则这个方法返回null在下面的代码中, getRef()返回字符串 xtocidl902914:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URL u= <span class="keyword">new</span> URL(<span class="string">"http://www.ibiblio.org/javafaq/javafaq.html#xtocid1902914"</span>);</span><br><span class="line">System.out.println(<span class="string">"The fragment ID of "</span>+u+<span class="string">" is "</span>+ u.getRef()));</span><br></pre></td></tr></table></figure><p></p><h3 id="public-String-getQuery"><a href="#public-String-getQuery" class="headerlink" title="public String getQuery()"></a>public String getQuery()</h3><p>getQuery()方法<strong>返回URL的查询字符串</strong>。如果URL没有查询字符串,则这个方法返回null。在下面的代码中, getQuery()返回字符串 <code>category= Piano</code>:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URL u= <span class="keyword">new</span> URL(<span class="string">"http://www.ibiblio.org/nywc/compositions.phtml?category=piano"</span>)</span><br><span class="line">System.out.println(<span class="string">"The query string of "</span>+u+<span class="string">" is "</span>+ u.getQuery ();</span><br></pre></td></tr></table></figure><p></p><h3 id="public-String-getUserInfo"><a href="#public-String-getUserInfo" class="headerlink" title="public String getUserInfo()"></a>public String getUserInfo()</h3><p><strong>有些URL包括用户名,有时甚至会有口令信息。这些信息位于模式之后,而且在主机之前,用一个@符号将用户信息与主机分开</strong>。例如,在URL <code>http://elharo@java.oreilly.com/</code>中,用户信息是<code>elharo</code>。有些URL还在用户信息中包括口令。例如,在URL <code>ftp://mp3:secret@ftp.example.com/c%3a/stuff/mp3/</code>中,用户信息是mp3:secret。不过,大<strong>多数情况下,在URL中包括口令存在安全风险</strong>。如果URL没有任何用户信息getUserInfo()就返回null。</p><p>mailto URL的行为可能与你想象的不一样。在类似 mailto:<a href="mailto:elharo@ibiblio.org" target="_blank" rel="noopener">elharo@ibiblio.org</a>的URL中,”<a href="mailto:elharo@ibiblio.org" target="_blank" rel="noopener">elharo@ibiblio.org</a>“是路径,而不是用户信息和主机。这是因为,这个URL指定了消息的远程接收者,而不是发送消息的用户名和主机。</p><h3 id="public-String-getAuthority"><a href="#public-String-getAuthority" class="headerlink" title="public String getAuthority()"></a>public String getAuthority()</h3><p>在URL的模式和路径之间,你会发现授权机构。URI的这一部分指示了解析资源的授权机构。<strong>在大多数情况下,授权机构包括用户信息、主机和端口</strong>例如,在 URL <code>ftp://mp3:mp3@138.247.121.61:21000/c%3a/</code>中,授权机构是<code>mp3:mp3@138.247.121.61:21000</code>,其中，用户信息是<code>mp3:mp3</code>,主机是<code>138.247.121.61</code>,端口是<code>21000</code>不过,并不是所有URL都有这几部分。例如,在URL <code>http://conferences.oreilly.com/java/speakers/</code>中,授权机构只有主机名conferences.oreilly.com.getAuthority()方法会以URL中的形式返回授权机构,可能有用户信息和端口,也可能没有。</p><p>示例5-4使用这些方法把命令行中输入的URL解析为各个组成部分。</p><h3 id="示例5-4-URL的组成部分"><a href="#示例5-4-URL的组成部分" class="headerlink" title="示例5-4:URL的组成部分"></a>示例5-4:URL的组成部分</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URLSplitter</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                URL u = <span class="keyword">new</span> URL(args[i]);</span><br><span class="line">                System.out.println(<span class="string">"The URL is "</span> + u);</span><br><span class="line">                <span class="comment">//模式(协议)</span></span><br><span class="line">                System.out.println(<span class="string">"The scheme is "</span> + u.getProtocol());</span><br><span class="line">                <span class="comment">//用户信息</span></span><br><span class="line">                System.out.println(<span class="string">"The user info is "</span> + u.getUserInfo());</span><br><span class="line">                <span class="comment">//主机</span></span><br><span class="line">                String host = u.getHost();</span><br><span class="line">                <span class="keyword">if</span> (host != <span class="keyword">null</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> atSign = host.indexOf(<span class="string">'@'</span>);</span><br><span class="line">                    <span class="keyword">if</span> (atSign != -<span class="number">1</span>) host = host.substring(atSign+<span class="number">1</span>);</span><br><span class="line">                    System.out.println(<span class="string">"The host is "</span> + host);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"The host is null."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//端口号</span></span><br><span class="line">                System.out.println(<span class="string">"The port is "</span> + u.getPort());</span><br><span class="line">                <span class="comment">//路径</span></span><br><span class="line">                System.out.println(<span class="string">"The path is "</span> + u.getPath());</span><br><span class="line">                <span class="comment">//片段(锚点)</span></span><br><span class="line">                System.out.println(<span class="string">"The ref is "</span> + u.getRef());</span><br><span class="line">                <span class="comment">//查询信息</span></span><br><span class="line">                System.out.println(<span class="string">"The query string is "</span> + u.getQuery());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (MalformedURLException ex) &#123;</span><br><span class="line">                System.err.println(args[i] + <span class="string">" is not a URL I understand."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="ftp://mp3:mp3@138.247.121.61:21000/c%3a/" target="_blank" rel="noopener">ftp://mp3:mp3@138.247.121.61:21000/c%3a/</a><br><a href="http://www.oreilly.com" target="_blank" rel="noopener">http://www.oreilly.com</a><br><a href="http://www.ibiblio.org/nywc/compositions.phtml?category=Piano" target="_blank" rel="noopener">http://www.ibiblio.org/nywc/compositions.phtml?category=Piano</a><br><a href="http://admin@www.blackstar.com8080/" target="_blank" rel="noopener">http://admin@www.blackstar.com8080/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&gt;java URLSplitter \</span><br><span class="line">&gt;ftp://mp3:mp3@138.247.121.61:21000/c%3a/ \</span><br><span class="line">&gt;http://www.oreilly.com \</span><br><span class="line">&gt;http://www.ibiblio.org/nywc/compositions.phtml?category=Piano \</span><br><span class="line">&gt;http://admin@www.blackstar.com8080/ \</span><br><span class="line"></span><br><span class="line">The URL is ftp://mp3:mp3@138.247.121.61:21000/c%3a/</span><br><span class="line">The scheme is ftp</span><br><span class="line">The user info is mp3:mp3</span><br><span class="line">The host is 138.247.121.61</span><br><span class="line">The port is 21000</span><br><span class="line">The path is /c%3a/</span><br><span class="line">The ref is null</span><br><span class="line">The query string is null</span><br><span class="line"></span><br><span class="line">The URL is http://www.oreilly.com</span><br><span class="line">The scheme is http</span><br><span class="line">The user info is null</span><br><span class="line">The host is www.oreilly.com</span><br><span class="line">The port is -1</span><br><span class="line">The path is </span><br><span class="line">The ref is null</span><br><span class="line">The query string is null</span><br><span class="line"></span><br><span class="line">The URL is http://www.ibiblio.org/nywc/compositions.phtml?category=Piano</span><br><span class="line">The scheme is http</span><br><span class="line">The user info is null</span><br><span class="line">The host is www.ibiblio.org</span><br><span class="line">The port is -1</span><br><span class="line">The path is /nywc/compositions.phtml</span><br><span class="line">The ref is null</span><br><span class="line">The query string is category=Piano</span><br><span class="line"></span><br><span class="line">The URL is http://admin@www.blackstar.com8080/</span><br><span class="line">The scheme is http</span><br><span class="line">The user info is admin</span><br><span class="line">The host is www.blackstar.com8080</span><br><span class="line">The port is -1</span><br><span class="line">The path is /</span><br><span class="line">The ref is null</span><br><span class="line">The query string is null</span><br></pre></td></tr></table></figure><p>本文链接: <a href="https://www.lansheng.net.cn/blog/7ee2319/">分解URL</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第5章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>相对URL</title>
      <link href="/blog/903a0cbc/"/>
      <url>/blog/903a0cbc/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:20 GMT+0800 (中国标准时间) --><p>摘要:</p><ul><li>相对URL</li><li>URL类</li></ul><a id="more"></a><h2 id="相对URL"><a href="#相对URL" class="headerlink" title="相对URL"></a>相对URL</h2><p>URL可以告诉Web浏览器一个文档的大量信息:</p><ul><li>用于获取此文档的协议,</li><li>文档所在的主机,</li><li>以及文档在该主机上的路径。</li></ul><p>大多数信息可能与该文档中引用的其他URL相同。因此,<strong>并不要求完整地指定每一个URL,URL可以<code>继承其父文档</code>(即这个URL所在的文档)<code>的协议</code>、<code>主机名</code>和<code>路径</code></strong>。<strong>如果继承了父文档的部分信息,这些不完整的URL称为相对URL( relative URL)</strong>。相反,<strong>完整指定的URL称为绝对URL( absolute URL)</strong>。在相对URL中,可以认为缺少的各个部分都与所在文档的URL中对应的部分相同。例如,假设在浏览<code>http://www.ibiblio.org/javafag/javatutorial.html</code>时单击这个超链接:<br><code>&lt;a href=&quot;javafaq.html&quot;&gt;</code></p><p>浏览器从<code>http://ww.ibiblio.org/javafag/javatutorial.html</code>末尾截去<code>javatutorial.html</code>,得到<code>http://ww.ibiblio.org/javafag/</code>然后将<code>javafaq.html</code>附加到<code>http://www.ibiblio.org/javafaq/</code>末尾,得到<code>http://www.ibiblio.org/javafaq/javafaq.html</code>。最后加载这个文档。</p><p><strong>如果相对链接以“/”开头,那么它相对于文档根目录,而不是相对于当前文件</strong>。因此如果浏览hp:/ ww. ibiblio. orgljavafaqljavatutorial.hm时单击下面的链接:<br><code>&lt;a href=&quot;/projects/ipv6/&quot;&gt;</code><br>浏览器会从<code>http://ww.ibiblio.org/javafag/javatutorial.html</code>末尾去掉<code>/javafag/javatutorial.html</code>,得到<code>http://ww.ibiblio.org</code>然后将<code>/projects/ipv6/</code>附加到<code>http://ww.ibiblio.org</code>末尾,得到<code>http://ww.ibiblio.org/projects/ipv6/</code>。最后加载这个文档。</p><p><strong>相对URL有很多优点</strong>。首先可以减少录入,不过这一点并不太重要。更重要的是,<strong>相对URL允许用多种协议来提供一个文档树:例如,HTTP和FTP。HTTP可能用于直接浏览,FTP可以用于镜像网站</strong>。最重要的一点是,<strong><code>相对URL允许将整个文档树从一个网站移动或复制到另一个网站,而不会破坏所有的内部链接</code></strong>。</p><h2 id="URL类"><a href="#URL类" class="headerlink" title="URL类"></a>URL类</h2><p><strong>java.net.URL类是对统一资源定位符</strong>(如<code>http://www.lolcats.com/</code>或<code>ftp://ftp.redhat,com/pub/</code>)<strong>的抽象</strong>。它扩展了java.lang.Object,<strong>是一个<code>final类</code>,<code>不能对其派生子类</code></strong>。<strong>它不依赖于继承来配置不同类型URL的实例,而<code>使用了策略( strategy)设计模式</code></strong>。<strong>协议处理器就是策略</strong>,URL类构成上下文,通过它来选择不同的策略。</p><p>虽然把URL存储为字符串会很简单,但将URL作为对象考虑会很有帮助,这个<strong>URL对象的字段包括<code>模式</code>(也就是<code>协议</code>)、<code>主机名</code>、<code>端口</code>、<code>路径</code>、<code>查询字符串</code>和<code>片段标识符</code>(也称为ref),每个字段可以单独设置</strong>。实际上,java.net.URL类正是这样组织的,虽然不同版本Java之间在细节上稍有差别。</p><p><strong>URL是不可变的。构造一个URL对象后,其字段不再改变</strong>。这有一个副作用:可以保证它们是“<strong>线程安全</strong>”的。</p><h3 id="创建新的URL"><a href="#创建新的URL" class="headerlink" title="创建新的URL"></a>创建新的URL</h3><p>与第4章的 InetAddress对象不同,你可以构造 java.net.URL的实例。不同构造函数所需的信息有所不同:</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>URL(String spec)</code></td><td style="text-align:left">根据 String 表示形式创建 URL 对象。</td></tr><tr><td style="text-align:left"><code>URL(String protocol, String host, int port, String file)</code></td><td style="text-align:left">根据指定 protocol、host、port 号和 file 创建 URL 对象。</td></tr><tr><td style="text-align:left"><code>URL(String protocol, String host, int port, String file, URLStreamHandler handler)</code></td><td style="text-align:left">根据指定的 protocol、host、port 号、file 和 handler 创建 URL 对象。</td></tr><tr><td style="text-align:left"><code>URL(String protocol, String host, String file)</code></td><td style="text-align:left">根据指定的 protocol 名称、host 名称和 file 名称创建 URL。</td></tr><tr><td style="text-align:left"><code>URL(URL context, String spec)</code></td><td style="text-align:left">通过在指定的上下文中对给定的 spec 进行解析创建 URL。</td></tr><tr><td style="text-align:left"><code>URL(URL context, String spec, URLStreamHandler handler)</code></td><td style="text-align:left">通过在指定的上下文中用指定的处理程序对给定的 spec 进行解析来创建 URL。</td></tr></tbody></table><p>使用哪个构造函数取决于你有哪些信息以及信息的形式。如果试图为一个不支持的协议创建URL对象,或者如果URL的语法不正确,所有这些构造函数都会抛出一个<code>MalformedURLException</code>异常。</p><p>支持哪些协议取决于具体实现。<strong>所有虚拟机都支持的协议只有http和file</strong>,而且后者名声很不好。如今Java还支持https、jar和ftp。一些虚拟机还支持 mailto和 gopher,以及一些定制协议如doc、 netdoc、 systemresouce和Java在内部使用的 verbatim。</p><hr><p>提示:如果某个VM不支持你需要的协议,可以为该模式安装一个协议处理器( protocolhandler),使URL类支持这个协议。在实际中,<strong>这种方法带来的麻烦远甚于它带来的好处</strong>。<strong>最好使用一个库,提供专门支持该协议的一个定制API</strong>。</p><hr><p>除了验证能否识别URL模式外,Java不会对它构造的URL完成任何正确性检查。<strong>程序员要负责确保所创建的URL是合法的</strong>。例如,Java不会检查 Http URL中的主机名中是否包含空格,或者查询字符串是否是x-www-form-URL-encoded。它不检查 mailto URL是否真正包含一个电子邮件地址。<strong>你完全可以为不存在的主机创建URL,或者可以为尽管存在但不允许连接的主机创建URL</strong>。</p><h3 id="从字符串构造URL"><a href="#从字符串构造URL" class="headerlink" title="从字符串构造URL"></a>从字符串构造URL</h3><p>最简单的URL构造函数只接受一个字符串形式的绝对URL作为唯一的参数:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">URL</span><span class="params">(String url)</span> <span class="keyword">throws</span> MalformedURLException</span></span><br></pre></td></tr></table></figure><p></p><p>与所有构造函数一样,这个函数只能在new操作符后调用,另外同样类似于所有其他URL构造函数,它可能会抛出MalformedURLException异常。下面的代码根据一个 String构造一个URL对象,并捕获可能抛出的异常:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    URL u=<span class="keyword">new</span> URL(<span class="string">"http://www.audubon.org/"</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(MalformedURLException ex)</span><br><span class="line">&#123;</span><br><span class="line">    System.err.println(ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>示例5-1是一个很简单的程序,用来确定一个虛拟机支持哪些协议。它尝试为所有15种协议分别构造一个URL对象,这包括8种标准协议,不同 Java API的3种定制协议和Java在内部使用的4种协议(无相关文档)。如果构造函数成功,则说明这个协议得到支持。否则,抛出一个MalformedURLException异常,由此可知虚拟机不支持这个协议。</p><h4 id="示例5-1-虚拟机支持哪些协议"><a href="#示例5-1-虚拟机支持哪些协议" class="headerlink" title="示例5-1:虚拟机支持哪些协议?"></a>示例5-1:虚拟机支持哪些协议?</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolTester</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="comment">//      hypertext transfer protocol</span></span><br><span class="line">        testProtocol(<span class="string">"http://www.adc.org"</span>);<span class="comment">//超文本传输协议</span></span><br><span class="line"><span class="comment">//      secure http 安全http协议</span></span><br><span class="line">        testProtocol(<span class="string">"https://www.amazon.com/exec/obidos/order2/"</span>);</span><br><span class="line"><span class="comment">//      file transfer protocol 文件传输协议</span></span><br><span class="line">        testProtocol(<span class="string">"ftp://ibiblio.org/pub/languages/java/javafaq/"</span>);</span><br><span class="line"><span class="comment">//      Simple Mail Transfer Protocol 简单邮件协议</span></span><br><span class="line">        testProtocol(<span class="string">"mailto:elharo@ibiblio.org"</span>);</span><br><span class="line"><span class="comment">//      telnet </span></span><br><span class="line">        testProtocol(<span class="string">"telnet://dibner.poly.edu/"</span>);</span><br><span class="line"><span class="comment">//      local file access</span></span><br><span class="line">        testProtocol(<span class="string">"file:///etc/passwd"</span>);</span><br><span class="line"><span class="comment">//      gopher</span></span><br><span class="line">        testProtocol(<span class="string">"gopher://gopher.anc.org.za/"</span>);</span><br><span class="line"><span class="comment">//      Lightweight Directory Access Protocol 轻量组目录访问协议</span></span><br><span class="line">        testProtocol(</span><br><span class="line">        <span class="string">"ldap://ldap.itd.umich.edu/o=University%20of%20Michigan,c=US?postalAddress"</span>);</span><br><span class="line"><span class="comment">//      JAR</span></span><br><span class="line">        testProtocol(</span><br><span class="line">        <span class="string">"jar:http://cafeaulait.org/books/javaio/ioexamples/javaio.jar!"</span></span><br><span class="line">        + <span class="string">"/com/macfaq/io/StreamCopier.class"</span>);</span><br><span class="line"><span class="comment">//      NFS,Network File System 网络文件系统</span></span><br><span class="line">        testProtocol(<span class="string">"nfs://utopia.poly.edu/usr/tmp/"</span>);</span><br><span class="line"><span class="comment">//      a custom protocol for JDBC JDCB的定制协议</span></span><br><span class="line">        testProtocol(<span class="string">"jdbc:mysql://luna.ibiblio.org:3306/NEWS"</span>);</span><br><span class="line">        <span class="comment">//远程方法调用的定制协议</span></span><br><span class="line"><span class="comment">//      rmi, a custom protocol for remote method invocation</span></span><br><span class="line">        testProtocol(<span class="string">"rmi://ibiblio.org/RenderEngine"</span>);</span><br><span class="line"><span class="comment">//      custom protocols for HotJava HotJava的定制协议</span></span><br><span class="line">        testProtocol(<span class="string">"doc:/UsersGuide/release.html"</span>);</span><br><span class="line">        testProtocol(<span class="string">"netdoc:/UsersGuide/release.html"</span>);</span><br><span class="line">        testProtocol(<span class="string">"systemresource://www.adc.org/+/index.html"</span>);</span><br><span class="line">        testProtocol(<span class="string">"verbatim:http://www.adc.org/"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testProtocol</span><span class="params">(String url)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            URL u = <span class="keyword">new</span> URL(url);</span><br><span class="line">            System.out.println(u.getProtocol() + <span class="string">" is supported"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException ex) &#123;</span><br><span class="line">            String protocol = url.substring(<span class="number">0</span>, url.indexOf(<span class="string">':'</span>));<span class="comment">//获取协议名称</span></span><br><span class="line">            System.out.println(protocol + <span class="string">" is not supported"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的结果取决于运行这个程序的虚拟机。以下是 Mac Os X上Java7的结果:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">http is supported</span><br><span class="line">https is supported</span><br><span class="line">ftp is supported</span><br><span class="line">mailto is supported </span><br><span class="line">telnet is not supported</span><br><span class="line">file is supported</span><br><span class="line">gopher is not supported</span><br><span class="line">ldap is not supported</span><br><span class="line">jar is supported</span><br><span class="line">nfs is not supported</span><br><span class="line">jdbc is not supported</span><br><span class="line">rmi is not supported</span><br><span class="line">doc is not supported</span><br><span class="line">netdoc is supported</span><br><span class="line">systemresource is not supported</span><br><span class="line">verbatim is not supported</span><br></pre></td></tr></table></figure><p></p><p>这里显示不支持RMI和JDBC,这实际上不太正确。事实上,JDK的确支持这些协议。不过,这两个协议分别通过 java.rmi和java.sql包来支持,而无法跟其他支持协议一样可以通过URL来访问(但是我实在不明白,如果Sun不想通过Java处理URL的复杂机制来与RM和JDBC交互,为什么还要为RM和JDBC参数包裹上URL的外衣)。<br>其他Java7虚拟机会显示类似的结果。并非来自 Oracle代码基的虚拟机所支持的协议可能有些不同。例如Android的DalvikVM只支持http,https,file,ftp和jar协议。</p><h2 id="由组成部分构造URL"><a href="#由组成部分构造URL" class="headerlink" title="由组成部分构造URL"></a>由组成部分构造URL</h2><p>还可以通过指定协议、主机名和文件来构建一个URL:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">URL</span><span class="params">(String protocol, String hostname, String file)</span><span class="keyword">throws</span> MalformedURLException</span></span><br></pre></td></tr></table></figure><p></p><p>这个构造函数将端口设置为<code>-1</code>,所以会<code>使用该协议的默认端口</code>。<strong>file参数<code>应当以斜线开头</code>,包括路径、文件名和可选的片段标识符</strong>。有可能会忘记最前面的斜线,这是一个很常见的错误,而且这个错误不容易发现。与所有URL构造函数一样,它可能会抛出MalformedURLException异常。例如:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    URL u=<span class="keyword">new</span> URL(<span class="string">"http"</span>,<span class="string">"www.eff.org"</span>,<span class="string">"/blueribbon.html#intro"</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(MalformedURLException ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"should't happen; all VMs recognize http"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这会创建一个URL对象,指向<code>http://www.eff.org/blueribbon.html#intro</code>,并使用HTTP的默认端口(端口80)。文件规范包括指定锚的一个引用。如果虚拟机不支持HTTP,这个代码会捕获可能抛出的异常。不过,这在实际中不会发生。</p><p>在很少见的一些情况下,默认端口不正确时,下一个构造函数允许用一个int显式指定端口。其他参数都是一样的。例如,下面的代码段会创建一个指向<code>http://fourier.dur.ac.uk:8000/~dma3mjh/jsci</code>的URL对象,这里显式地指定了端口8000：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    URL u=<span class="keyword">new</span> URL(<span class="string">"http"</span>,<span class="string">"fourier.dur.ac.uk"</span>,<span class="number">8000</span>,<span class="string">"/~dma3mjhh/jsci/"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(MalformedURLException ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"should't happen; all VMs recognize http"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="构造相对URL"><a href="#构造相对URL" class="headerlink" title="构造相对URL"></a>构造相对URL</h2><p>这个构造函数根据相对URL和基础URL构建一个绝对URL:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">URL</span><span class="params">(URL base, String relative)</span> <span class="keyword">throws</span> MalformedURLException</span></span><br></pre></td></tr></table></figure><p></p><p>例如,你可能正在解析HTML文档<code>http://www.ibiblio.org/javafaq/index.html</code>,并遇到一个名为 <code>mailinglists.html</code>的文件链接,但没有进一步的限定信息。这时,可以用包含该链接的文档的URL来提供缺少的信息。这个构造函数会计算出新的URL为<code>http://www.ibiblio.org/javafaq/mailinglists.html</code>。例如:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    URL u1=<span class="keyword">new</span> URL(<span class="string">"http://www.ibiblio.org/javafaq/index.html"</span>);</span><br><span class="line">    URL u2=<span class="keyword">new</span> URL(u1,<span class="string">"mailinglists.html"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(MalformedURLException ex)</span><br><span class="line">&#123;</span><br><span class="line">    System.err.println(ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>将文件名从u1的路径中去除,追加新文件名 <code>mailinglists.html</code>得到u2</strong>。<strong>如果希望循环处理位于同一个目录下的一组文件,这个构造函数特别有用</strong>。可以为第一个文件创建一个URL,然后使用这个初始URL,通过替代文件名来创建其他文件的URL对象。</p><h2 id="其他URL对象来源"><a href="#其他URL对象来源" class="headerlink" title="其他URL对象来源"></a>其他URL对象来源</h2><p>除了这里讨论的构造函数,Java类库中的其他一些方法也返回URL对象。在 applet中,getDocumentBase()会返回包含这个 applet的页面的URL, getCodeBase()会返回 applet.class件的URL。<strong>java.io.File类有一个 toURL()方法,它返回与指定文件匹配的fie URL</strong>。这个方法所返回URL的具体格式与平台相关。例如,在 Windows上,它可能返回类似<code>file:/D:/JAVA/JNP4/05/ToURLTest.javal</code>的URL。在 Linux和其他UNX上,可能会看到<code>file:/home/elharo/books/JNP4/05/ToURLTest.java</code>。实际上, <strong>file URL非常依赖于平台和程序。 Java file URL通常不能与用于web浏览器和其他程序使用的URL互换,甚至不能与不同平台上运行的Java程序互换</strong>。</p><p>类加载器不仅用于加载类,也能加载资源,如图片和音频文件。静态方法<code>ClassLoader.getSystemResource(String name)</code>返回一个URL,通过它可以读取一个资源。ClassLoader.getSystemResources(string name)方法返回一个 Enumeration,其中包含一个URL列表,通过这些URL可以读取指定的资源。最后,实例方法getResource(String name)会在所引用类加载器使用的路径中搜索指定资源的URL。这些方法返回的URL可能是 file URL、 Http URL或其他模式。资源的完全路径是用包限定的Java名,这里要用斜线而不是点,例如/com/macfaq/sounds/swale.au或com/macauimages/headshot.jpg。Java虚拟机会尝试在类路径中査找所请求的资源,很可能在一个JAR归档文件中。</p><p>类库中还有其他一些方法可以返回URL对象,但大多数是简单的获取方法,只返回一个你可能已经知道的URL,因为一开始就是用它来构造这个对象,例如java.swing.JEditorPane的 getPage()方法和 java.net.URLConnection的 getURL()方法。</p><h2 id="从URL获取数据"><a href="#从URL获取数据" class="headerlink" title="从URL获取数据"></a>从URL获取数据</h2><p>仅仅有URL并不太让人兴奋。大家关心的是URL所指向的文档中包含的数据。URL类有几个方法可以从URL获取数据:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">openStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> URLConnection <span class="title">openConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> URLConnection <span class="title">openConnection</span><span class="params">(Proxy proxy)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getContent</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getContent</span><span class="params">(Class[] classes)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure><p></p><p>这些方法中,最基本也是最常用的是 openStream(),它会返回一个 InputStream,可以从这个流读取数据。如果需要更多地控制下载过程,应当调用 openConnection(),这会提供一个可以配置的 URLConnection,再由它得到一个 InputStream。我们将在第7章讨论这个方法。最后,可以用 getContent()向URL请求其内容,这会提供一个更完整的对象,如 String或 Image。同样的,它也会给出一个 InputStream。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> InputStream open <span class="title">Stream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure><p><strong>openStream()方法连接到URL所引用的资源,在客户端和服务器之间完成必要的握手,<code>返回一个 InputStream,可以由此读取数据</code></strong>。<strong>从这个InputStream获得的数据是URL引用的原始内容</strong>(即未经解释的内容): 如果读取 ASCII文本文件则为ASCII;如果读取HTML文件则为原始HTML,如果读取图像文件则为二进制图片数据等。它不包括任何HTTP首部或者与协议有关的任何其他信息。可以像读取任何其他Inputstream样读取这个 Inputstream。例如:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    URL u=<span class="keyword">new</span> URL(<span class="string">"http://www.lolcats.com"</span>);</span><br><span class="line">    InputStream in=u.openStream();</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">while</span>((c=in.read())!=-<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.write(c);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(IOException ex)</span><br><span class="line">&#123;</span><br><span class="line">    System.err.println(ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这段代码捕获IOException异常,它还会捕获URL构造函数可能抛出的MalformedURLException异常,因为 MalformedURLException是 IOExceptionl的子类。</p><p>与大多数网络流一样,要想可靠地关闭流,需要下点工夫。在Java6及之前版本中,我们使用了<strong>释放模式</strong>:在try块外声明<strong>流变量</strong>,并将它设置为null,然后在 finally块中,如果流变量非nul,则将它关闭。例如:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">InputStream in=<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    URL u=<span class="keyword">new</span> URL(<span class="string">"http://www.lolcats.com"</span>);</span><br><span class="line">    in =u.openStream();</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">while</span>((c=in.read())!=-<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.write(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(IOEception ex)</span><br><span class="line">&#123;</span><br><span class="line">    System.err.prinln(ex);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(in!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            in.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException ex)&#123;</span><br><span class="line">        <span class="comment">//忽略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>Java7更为简洁,可以使用一个嵌套的try-with- resources语句语句:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    URL u=<span class="keyword">new</span> URL(<span class="string">"http://www.lolcats.com"</span>);</span><br><span class="line">    <span class="comment">//try-with- resources语句</span></span><br><span class="line">    <span class="keyword">try</span>(InputStream in=u.openStream();)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">while</span>((c=in.read())!=-<span class="number">1</span>) System.out.write(c);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException ex)</span><br><span class="line">    &#123;</span><br><span class="line">        System.err.println(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例5-2从命令行读取一个URL,从这个URL打开一个 Inputstream,将得到的 Inputstream串链到使用默认编码方式的 InputStreamReader,然后使用InputStreamReader的read()方法从文件读取连续的字符,将各个字符显示在 System.out上。也就是说,如果URL引用一个HTML文件,它会显示位于这个URL的原始数据:程序的输出将是原始HTML。</p><p>示例5-2:下载一个Web页面<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SourceViewer</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            InputStream in = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line"><span class="comment">//              Open the URL for reading</span></span><br><span class="line">                URL u = <span class="keyword">new</span> URL(args[<span class="number">0</span>]);</span><br><span class="line">                in = u.openStream();<span class="comment">//取得InputStream</span></span><br><span class="line"><span class="comment">//              buffer the input to increase performance</span></span><br><span class="line">                in = <span class="keyword">new</span> BufferedInputStream(in);<span class="comment">//使用缓冲的输入流</span></span><br><span class="line"><span class="comment">//              chain the InputStream to a Reader</span></span><br><span class="line">                Reader r = <span class="keyword">new</span> InputStreamReader(in);<span class="comment">//包装读取流</span></span><br><span class="line">                <span class="keyword">int</span> c;</span><br><span class="line">                <span class="keyword">while</span> ((c = r.read()) != -<span class="number">1</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.print((<span class="keyword">char</span>) c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (MalformedURLException ex) &#123;</span><br><span class="line">                System.err.println(args[<span class="number">0</span>] + <span class="string">" is not a parseable URL"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                System.err.println(ex);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (in != <span class="keyword">null</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        in.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">//                      ignore</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>下面是Sourceviewer下载<code>https://www.oreilly.com</code>时输出的前几行:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;O&apos;Reilly Media - Technology and Business Training&lt;/title&gt;</span><br><span class="line">&lt;meta name=&quot;description&quot; content=&quot;Gain technology and business knowledge and hone your skills with learning resources created and curated by O&apos;Reilly&apos;s experts: live online training, video, books, conferences, our platform has content from 200+ of the world鈥檚 best publishers.&quot; /&gt;</span><br><span class="line">&lt;meta name=&quot;date&quot; content=&quot;2018-09-18&quot; /&gt;</span><br><span class="line">&lt;meta name=&quot;search_date&quot; content=&quot;2018-06-28&quot; /&gt;</span><br><span class="line">&lt;meta name=&quot;search-title&quot; content=&quot;O&apos;Reilly Media - Technology and Business Training&quot; /&gt;</span><br><span class="line">&lt;meta name=&quot;pagename&quot; content=&quot;O&apos;Reilly Media - Technology and Business Training&quot; /&gt;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p></p><p>这个Web页面中还有很多行;如果想查看,可以在你的Web浏览器中自行查看。这个程序最不可靠的部分是,它轻率地假定URL指向文本,而这不一定正确。它很可能指向GIF或JPEG图像、MP3声音文件或者其他内容。即使确实解析为文本,文档编码方式也可能与客户端系统的默认编码方式不同。远程主机和本地客户端可能采用不同的默认字符集。一般来讲,如果页面使用了与ASCII完全不同的字符集,HTML会在首部包括一个META标记,指示所使用的字符集。例如,下面的META标记指示了中文的Big-5编码方式:<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=big5"</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>XML文档则可能有一个XML声明:<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="Big5"?&gt;</span><br></pre></td></tr></table></figure><p></p><p>实际上,除了解析文件,查找类似这样的首部,并没有一种简单的方法可以得到这个信息,而且即使采用这种方法,也存在局限性。许多用拉丁字母手工编码的HTML文件没有这样的META标记。由于 Windows、Mac和大多数UNIX对128到255的字符解释都稍有不同,所以除了创建这些文档的平台外,在其他平台上将无法正确地解释这些文档中的扩展字符。</p><p>更添乱的是,实际文档前面的HTTP首部可能还有自己的编码信息,这可能与文档本身声明的编码完全不同。不能使用URL类读取这个首部,但可以利用 openConnection()方法返回的 URLConnection对象来读取。<strong>编码方式的检测和声明是Web体系结构中比较棘手的问题之一</strong>。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> URLConnection <span class="title">openConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOEXception</span></span><br></pre></td></tr></table></figure><p></p><p>openConnection()方法为指定的URL打开一个socket,并返回一个 URLConnection对象。<strong>URLConnection表示一个网络资源的打开的连接</strong>。如果调用失败,则 openConnection()会抛出一个 IOEXception异常。例如:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    URL u=<span class="keyword">new</span> URL(<span class="string">"https://news.ycombinator.com/"</span>);</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        URLConnection uc=u.openConnection();</span><br><span class="line">        InputStream in=uc.getInputStream();</span><br><span class="line">        <span class="comment">//从连接读取...</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException ex)</span><br><span class="line">    &#123;</span><br><span class="line">        System.err.prinln(ex);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(MalformedURLException ex)</span><br><span class="line">    &#123;</span><br><span class="line">        System.err.prinln(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>如果希望与服务器直接通信,应当使用这个方法。通过 URLConnection,你可以访问服务器发送的所有数据:除了原始的文档本身外(如HTML、纯文本、二进制图像数据),还可以访问这个协议指定的所有元数据。例如,如果模式是HTTP或HttPS,URLConnection允许你访问HTTP首部以及原始HTML。除了从URL读取,URLConnection还允许你向URL写入数据,例如,向一个 mailto URL发送电子邮件,或者提交表单数据。 URLConnection是第7章将介绍的主要内容。</p><p>这个方法有一个重载版本,可以指定通过哪个代理服务器传递连接:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> URLConnection <span class="title">openConnection</span><span class="params">(Proxy proxy)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure><p></p><p>这会覆盖用平常socksProxyhost,socksProxyPort,http.proxyHost,http.proxyPort,http.nonProxyhosts和类似系统属性设置的任何代理服务器。如果协议处理器不支持代理,这个参数将被忽略,如果可能将直接建立连接。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">getcontent</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure><p></p><p>getContent()方法是下载URL引用数据的第三种方法。 getContent()方法获取由URL引用的数据,尝试由它建立某种类型的对象。<strong>如果URL指示某种文本(如ASCI或HTML文件),返回的对象通常是某种 Inputstream</strong>。<strong>如果URL指示一个图像(如GIF或JPEG文件), getContent()通常返回一个java.awt. ImageProducer</strong>。这两个不同的类有一个共同点,它们本身并不是数据对象,而是一种途径,程序可以利用它们构造数据对象:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">URL u=<span class="keyword">new</span> URL(<span class="string">"http://mesola.obspm.fr/"</span>);</span><br><span class="line">Object o=u.getContent();</span><br><span class="line"><span class="comment">//将Object强制转换为适当的类型。</span></span><br><span class="line"><span class="comment">//处理这个Object...</span></span><br></pre></td></tr></table></figure><p></p><p>getContent()的做法是,在从服务器获取的数据首部中查找 Content-type字段。如果服务器没有使用MIME首部,或者发送了一个不熟悉的 Content-type, getContent()会返回某种 Inputstream,可以通过它读取数据。如果无法获取这个对象,就会抛出一个IOException异常,如示例5-3所示。</p><h4 id="示例5-3-下载一个对象"><a href="#示例5-3-下载一个对象" class="headerlink" title="示例5-3:下载一个对象"></a>示例5-3:下载一个对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContentGetter</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>  (args.length &gt; <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">//          Open the URL for reading</span></span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                URL u = <span class="keyword">new</span> URL(args[<span class="number">0</span>]);</span><br><span class="line">                Object o = u.getContent();</span><br><span class="line">                System.out.println(<span class="string">"I got a "</span> + o.getClass().getName());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (MalformedURLException ex) &#123;</span><br><span class="line">                System.err.println(args[<span class="number">0</span>] + <span class="string">" is not a parseable URL"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                System.err.println(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是尝试获得<a href="http://www.oreilly.com内容时的结果" target="_blank" rel="noopener">http://www.oreilly.com内容时的结果</a>:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;java ContentGetter http://www.oreilly.com</span><br><span class="line">I got a sun.net.www.protocol.http.HttpURLConnection$HttpInputStream</span><br></pre></td></tr></table></figure><p></p><p>具体的类可能因为Java的版本不同而有所区别(较早版本中是io.PushbackInputStream或sun.net.<a href="http://www.http.KeepAliveStream),不过至少应当种形式的InputStream。" target="_blank" rel="noopener">www.http.KeepAliveStream),不过至少应当种形式的InputStream。</a><br>下面是尝试加载图像时的结果:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;java ContentGetter https://avatar.csdn.net/C/B/8/1_qq_21808961.jpg?1537341372</span><br><span class="line">I got a sun.awt.image.URLImageSource</span><br></pre></td></tr></table></figure><p></p><p>下面是尝试用 getcontent()加载一个 Java applet时的结果:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%java Contentgetter http://www.cafeaulait.org/relativeuRltest.class</span><br><span class="line">&lt;/userinput&gt;</span><br><span class="line">I got a sun.net.www.protocol.http.HttpURLConnection$HttpInputStream&lt;/programlisting&gt;</span><br></pre></td></tr></table></figure><p></p><p>(注：我的电脑上上面跑的结果是不对的，上面的URL失效了吧，但是没必要深入的看结果，了解功能就行了。)<br>下面是当尝试用 getContent()加载一个音频文件时的结果:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;java ContentGetter https://music.163.com/song?id=421137682</span><br><span class="line">I got a sun.net.www.protocol.http.HttpURLConnection$HttpInputStream</span><br></pre></td></tr></table></figure><p></p><p>最后的结果最不常见,因为这就像Java核心API访问一个表示声音文件的类。它不只是用来加载声音数据的接口。</p><p>这个例子显示出使用 <strong>getContent()最大的问题:很难预测将获得哪种对象</strong>。可能得到某种 Inputstream或 ImageProducer,或者可能是 AudioClip,<strong>用 instanceof操作符很容易检查。这个信息对于读取文本文件或显示一个图像应该足够了</strong>。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final Object getContent(Class[] classes) throws IOException</span><br></pre></td></tr></table></figure><p></p><p>URL的内容处理器可以提供一个资源的不同视图。 getContent()方法的这个重载版本允许你选择希望将内容作为哪个类返回。这个方法尝试以第一种可用的格式返回URL的内容。例如,如果首选将HTML文件作为一个 String返回,而第二个选择是 Reader,第三个选择是 Inputstream,可以编写以下代码：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">URL u=<span class="keyword">new</span> URL(<span class="string">"http://www.nmu.org"</span>);</span><br><span class="line">Class&lt;?&gt;[] types =<span class="keyword">new</span> Class[<span class="number">3</span>];</span><br><span class="line">types[<span class="number">0</span>]=String.class;</span><br><span class="line">types[<span class="number">1</span>]=Reader.class;</span><br><span class="line">types[<span class="number">2</span>]=InputStream.class;</span><br><span class="line">Object obj=u.getContent(types);</span><br></pre></td></tr></table></figure><p></p><p>如果内容处理器知道如何返回资源的一个字符串表示,它就会返回一个 String。如果它不知道如何返回资源的字符串表示,则返回 Reader。倘若它也不知道如何将资源表示为一个读取器,那么它将返回 Inputstream。必须用 instanceof检查返回的对象的类型。例如:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(o <span class="keyword">instanceof</span> String)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.prinln(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">esle <span class="title">if</span><span class="params">(o <span class="keyword">instanceof</span> Reader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    Reader r=(Reader)o;</span><br><span class="line">    <span class="keyword">while</span>((c=r.read())!=-<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print((<span class="keyword">char</span>) c);</span><br><span class="line">    &#125;</span><br><span class="line">    r.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(o <span class="keyword">instanceof</span> InputStream)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    InputStream in=(InputStream) o;</span><br><span class="line">    <span class="keyword">while</span>((c=in.read())!=-<span class="number">1</span>)System.out.write(c);</span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">"Error:unexpected type "</span>+o.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/903a0cbc/">相对URL</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第5章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>第五章 URL和URI</title>
      <link href="/blog/487e88c6/"/>
      <url>/blog/487e88c6/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:20 GMT+0800 (中国标准时间) --><p>第4章中,你学习了如何通过主机名和IP地址确定主机在 Internet的地址。这一章我们将提高力度,进一步学习<strong>如何确定资源的地址</strong>,任何给定主机上可能会有任意多个资源。</p><p><strong>HTML是一个超文本( hypertext)标记语言</strong>,因为<strong>它提供了一种方法,可以指定URL标识的其他文档的链接</strong>。<strong>URL可以唯一地标识一个资源在 Internet上的位置。URL是最常见的URI,即统一资源标识符( Uniform Resource Identifier)</strong>。<code>URI可以由资源的网络位置来标识资源(如URL),也可以由资源的名字、编号或其他特性来标识</code>。</p><h2 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h2><p><strong>统一资源标识符( Uniform Resource Identifier,URI)</strong>是采用一种特定语法标识一个资源的字符串。所标识的资源可能是服务器上的一个文件。不过,也可能是一个邮件地址新闻消息、图书、人名、 Internet主机、 Oracle的最新股价或者任何其他内容。</p><p>资源是由URI标识的内容。<strong>URI则是标识一个资源的字符串</strong>。没错,这里构成了一个环。<strong>不要花太多时间去考虑资源是什么</strong>或者不是什么,<strong>因为你根本不会看到资源</strong>。<strong>从服务器接收到的只是资源的一种字节表示</strong>。不过<strong>一个资源可能有多种不同的表示</strong>。例如,<a href="https://www.un.org/en/documents/udhr/标识了人权宣言" target="_blank" rel="noopener">https://www.un.org/en/documents/udhr/标识了人权宣言</a>( Universal Declaration of HumanRights),不过这个宣言还有纯文本、XML、PDF和其他格式的表示。另外,这个资源还有英语、法语、阿拉伯语和很多其他语言的表示。</p><p>其中有些表示本身就是资源。例如,<a href="https://www.un.org/en/documents/udhr/特别标识了英语版本的人权宣言。" target="_blank" rel="noopener">https://www.un.org/en/documents/udhr/特别标识了英语版本的人权宣言。</a></p><hr><p>提示:好的Web体系结构的重要原则之一就是要充分使用URI。如果有人想要得到某个资源的地址,或者想要指示某个资源,可以提供一个URI(实际上是URL)。如果一个资源是另个资源的一部分,或是其他资源的一个集合,或者是另一个资源在某个特定时刻的状态,它也完全可以有自己的URI。例如,在一个邮件服务中,每个用户、接收到的每个消息发送的每个消息、收件箱的每个过滤视图、每个联系人、每个过滤规则,以及用户可能查看的每一个页面都要有一个唯一的URI。尽管按层次构建的URI是一些很晦涩的字符串,不过实际中可以用人可读的子结构来设计。例如,<a href="https://mail.example.com/可能是一个特定的邮件服务器,http://mail.example.com/johndoe可能是这个服务器上John" target="_blank" rel="noopener">https://mail.example.com/可能是一个特定的邮件服务器,http://mail.example.com/johndoe可能是这个服务器上John</a> Doe的邮箱<a href="http://mail.example.com/johndoe?messageID=162977.l361" target="_blank" rel="noopener">http://mail.example.com/johndoe?messageID=162977.l361</a> .JavaMail.nobody%40meetup.com则是这个邮箱中的一个特定的消息。</p><hr><p>URI的语法由一个模式和一个模式特定部分组成,模式和模式特定部分用一个冒号分隔,如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模式:模式特定部分</span><br></pre></td></tr></table></figure><h3 id="模式特定部分的语法"><a href="#模式特定部分的语法" class="headerlink" title="模式特定部分的语法"></a>模式特定部分的语法</h3><p>模式特定部分的语法取决于所用的模式。当前的模式包括:</p><ul><li>data<ul><li>链接中直接包含的Base64编码数据,参见RFC2397。</li></ul></li><li>file<ul><li>本地磁盘上的文件</li></ul></li><li>ftp<ul><li>FTP服务器。</li></ul></li><li>http<ul><li>使用超文本传输协议的国际互联网服务器</li></ul></li><li>mailto<ul><li>电子邮件地址。</li></ul></li><li>magnet<ul><li>可以通过对等网络(如 BitTorrent)下载的资源</li></ul></li><li>teInet<ul><li>与基于 Telnet的服务的连接。</li></ul></li><li>urn<ul><li>统一资源名( Uniform Resource Name,URN)。</li></ul></li></ul><p>此外,Java还大量使用了一些非标准的定制模式,如rmi、jar、jndi和doc,来实现各种不同用途。</p><p>URI中的模式特定部分并没有特定的语法。不过,很多都采用一种层次结构形式,如:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//authority/path?query</span><br></pre></td></tr></table></figure><p></p><p>这个URI的 authority部分指定了负责解析该URl其余部分的授权机构(authority)。例如。</p><p>URI <code>http://www.ietf.org/rfc/rfc3986.txt</code>的</p><ul><li>模式为<code>http</code>,</li><li>授权机构为<code>www.ietf.org</code>,</li><li>另外路径为<code>/rfc/rfc3986.txt</code>(包括前面的斜线)。</li></ul><p>这表示位于<a href="http://www.ietf.org的服务器负责将路径/rfc/rfc3986.txt映射到一个资源。这个URI没有查询部分。" target="_blank" rel="noopener">www.ietf.org的服务器负责将路径/rfc/rfc3986.txt映射到一个资源。这个URI没有查询部分。</a></p><p>URI <code>http://www.powells.com/cgi-bin/biblio?inkey=62-1565928709-0</code>的</p><ul><li>模式为http</li><li>授权机构为<a href="http://www.powells.com" target="_blank" rel="noopener">www.powells.com</a></li><li>路径为/cgi-bin/biblio,</li><li>另外查询为 inkey=62-1565928709-0。</li></ul><p>URI urn:isbn:156592870</p><ul><li>模式为un,</li><li>但模式特定部分没有采用层次结构的 authority/path?query形式</li></ul><p>尽管当前大多数的URI例子都使用 Internet主机作为授权机构,不过未来的模式可能不是这样。但是,如果授权机构是 Internet主机,那么还可以提供可选的用户名和端口,使授权机构更为特定。例如,</p><p>URL <code>ftp://mp3:mp3@ci43198-a.ashville.nc.home.com:33/VanHanen-Jump.mp3</code>的</p><ul><li>授权机构是<code>mp3:mp3@ci43198-a.ashville.nc.home.com:33/</code>。这个授权机构有<ul><li>用户名mp3、</li><li>口令mp3、</li><li>主机ci43198-a.ashville.nc.home.com和端口33。</li></ul></li><li>它的模式是ftp,</li><li>路径是/VanHanen-Jump.mp3(在大多数情况下,在URI中包含口令是一个很大的安全漏洞,除非像这里一样,你确实想让全世界所有人都知道口令)。</li></ul><p><strong>路径是授权机构用来确定所标识资源的字符串</strong>。不同的授权机构可能会把相同的路径解释为指向不同的资源。例如,授权机构是<code>www.landoverbaptist.org</code> 时,路径<code>/index.html</code>可能表示某个资源,而授权机构是<code>www.churchofsatan.com</code>时,路径<code>/index.html</code>则可能表示完全不同的一个资源。<strong>路径可以是分层的</strong>,在这种情况下,各个部分之间用斜线分隔。“.”和“.”操作符用于在这个层次结构中导航。这是从UNIX操作系统的路径名语法继承而来的(web和URL都是在UNIX下发明的)。它们可以很方便地映射到存储在一个 UNIX Web服务器上的文件系统。不过,不能保证任何特定路径的所有部分都能实际对应到特定文件系统的文件或目录。例如,在URI <code>http://www.amazon.com/exec/obidos/ISBN%3D565924851/cafeaulait002-377705-3043449</code>中,这个层次结构的所有部分只是用来从数据库提取信息，并不存储在文件系统中。<code>ISBN%3D565924851</code>根据ISBN号从数据库选择某本书, <code>cafeaulaitA</code>指定如果由此链接完成一次交易谁将获得推荐费,而<code>002-3777605-3043449</code>是一个会话密钥,用来跟踪访问者在网站中所走过的路径。</p><p>有些URI并不分层,至少在文件系统意义上是如此。例如, <code>snews://secnews.netscape.com/netscape.devs-java</code>的路径为/netscape.devs-java。虽然由 netscape和devs-java之间的“.”指示新闻组名存在层次性,但这并未编码为URI的一部分。</p><p>模式部分由小写字母、数字和加号、点及连号符组成。典型URI的其他三部分(授权机构、路径和查询)分别由ASCII<strong>字母数字符号</strong>组成(即字母A-Z、a-z和数字0-9)。此外,还可以使用<strong>标点符号</strong><code>-</code>,<code>_</code>,<code>.</code>,<code>!</code>和<code>~</code>。<strong>定界符</strong>(如<code>/</code>,<code>?</code>,<code>&amp;</code>和<code>=</code>)可以有其预定义的用途。所有其他字符,包括非ASCI字母数字(如和乙),应当用百分号(%)转义,其后是该字符按UTF-8编码的十六进制码,<strong>另外一些定界符实际上没有用作为定界符,那么也需要这样转义</strong>。例如在UTF-8中,<code>a</code>是2字节<code>0xC3 0xA1</code>,所以要编码为<code>%c3%a1</code>。汉字“木”的 Unicode码点为<code>0x6728</code>。在UTF-8中,这会编码为3字节<code>E6</code>,<code>9C</code>和<code>A8</code>。因此,它在URI中编码为<code>%E6%9C%A8</code>。</p><p>如果你没有像这样将非ASCII字符编码为十六进制码,而是<strong>将它们(非ASCII)直接包含在URI中</strong>,那么你得到的不是一个URI,而是<code>IRI</code>(<code>国际化资源标识符</code>, Internationalized resourceIdentifier)。<strong>IRI更容易录入,也更容易读,但是很多软件和协议只接受和支持URI</strong>。</p><p>除非用于特定URL中的模式特定部分,否则诸如“/”和“@”等标点符号也必须编码,<code>要用百分号转义</code>。例如,URI <code>http://www.cafeaulait.org/books/javaio2/</code>中的斜线不需要编码为%2F,因为它们是按http URI模式所指定的方式分隔这个层次结构。不过,如果个文件名包括“<code>/</code>”字符,例如,如果为了与这本书的书名更为一致,将最后一个目录命名为 Java I/O而不是 javaio2,那么URI就必须写为<code>http://www.cafeaulait.org/ books/Java%20I%2FO/</code>。对于UNIX或 Windows用户而言,实际上并没有看上去那么牵强。Mac文件名经常包括一个斜线。许多平台上的文件名通常都包含需要编码的字符,包括@,$,+,=等。当然,一般情况下URL并非由文件名得来。</p><h2 id="URLs"><a href="#URLs" class="headerlink" title="URLs"></a>URLs</h2><p><strong>URL是一个URI,<code>除了标识一个资源,还会为资源提供一个特定的网络位置</code>,客户端可以用它来获取这个资源的一个表示。与之不同,<code>通用的URI可以告诉你一个资源是什么,但是无法告诉你它在哪里,以及如何得到这个资源</code></strong>。在实际世界中,这就像书名《哈里波特与死亡圣器》与这本书在图书馆的具体位置“312室第28行第7个书架”之间的区别。在Java中,这就类似于 java.net.URI类(只标识资源)与 java.net.URL类(既能标识资源,又能获取资源)之间的差别。</p><p>URL中的网络位置通常包括<code>用来访问服务器的协议</code>(如FTP、HTTP)、<code>服务器的主机名或IP地址</code>,<code>以及文件在该服务器上的路径</code>。典型的URL类似于<code>http://www.ibiblio.org/javafag/javatutorial.html</code>。它指示服务器<code>www.ibiblio.org</code>的Javafaq目录下有一个名为<code>javatutorial.html</code>的文件,这个文件可以通过HTTP访问。</p><h2 id="URL的语法"><a href="#URL的语法" class="headerlink" title="URL的语法"></a>URL的语法</h2><p>URL的语法为:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protocol://userInfo@host:port/path?query#fragment</span><br></pre></td></tr></table></figure><p></p><h3 id="协议-protocol"><a href="#协议-protocol" class="headerlink" title="协议(protocol)"></a>协议(protocol)</h3><p>这里的协议( protocol)是对URI中模式( scheme)的另一种叫法( URI RFC中使用“模式”。Java文档中使用“协议”)。在URL中,协议部分可以是file,ftp,http,https,magnet,telnet或其他各种字符串(但不包括urn)。</p><h3 id="主机-host"><a href="#主机-host" class="headerlink" title="主机(host)"></a>主机(host)</h3><p>URL的主机(host)部分是提供所需资源的服务器的名字。这可以是一个主机名,如<code>www.oreilly.com</code>或<code>utopia.poly.edu</code>,也可以是服务器的IP地址,如204.148.40.9或128.238.3.21。</p><h3 id="用户信息-userInfo"><a href="#用户信息-userInfo" class="headerlink" title="用户信息(userInfo)"></a>用户信息(userInfo)</h3><p>用户信息( userInfo)部分是服务器的登录信息(可选)。如果有这一部分,其中包含一个用户名,极少见的情况下还会包含一个口令。</p><h3 id="端口号-port"><a href="#端口号-port" class="headerlink" title="端口号(port)"></a>端口号(port)</h3><p>端口(port)号也是可选的。如果服务在其默认端口运行(HTTP服务器的默认端口是80),就不需要这个部分。</p><p>用户信息、主机和端口合在一起构成权威机构(authority)。</p><h3 id="路径-path"><a href="#路径-path" class="headerlink" title="路径(path)"></a>路径(path)</h3><p>路径(path)指向指定服务器上的一个特定目录。路径通常看上去类似一个文件系统路径,如/forum/ index.php。它可能确实映射到服务器上的一个文件系统,不过也有可能并不映射到一个文件系统。<strong>如果确实映射到一个文件系统,路径则相对于服务器的文档根目录,而不一定相对于服务器上文件系统的根目录</strong>。一般来讲,向公众开放的服务器不会将其整个文件系统展示给客户端,而是只展示指定目录中的内容。这个目录称为<strong>文档根目录</strong>,所有路径和文件名都相对于这个目录。因此,在UNIX服务器上,公众可用的所有文件可能位于/var/public/html,<strong>但是对于某个从远程机器连接的人来说,这个目录就好像是文件系统的根目录一样</strong>。</p><h3 id="查询-query-字符串"><a href="#查询-query-字符串" class="headerlink" title="查询(query)字符串"></a>查询(query)字符串</h3><p>查询(query)字符串向服务器提供附加参数。一般只在http URL中使用,其中包含表单数据,作为输入提供给在这个服务器上运行的程序。</p><h3 id="片段-fragment"><a href="#片段-fragment" class="headerlink" title="片段( fragment)"></a>片段( fragment)</h3><p>最后<strong>,片段( fragment)指向远程资源的某个特定部分。如果远程资源是HTML,那么这个片段标识符将指定该HTML文档中的一个锚( anchor)</strong>。如果远程资源是XML,那么这个片段标识符是一个 X Pointer。有些文献将URL的片段部分称为“段”( section),Java文档则莫名其妙地把片段标识符称为“Ref”。<strong>片段标识符目标在HTML文档中用id属性创建</strong>,如:<br><code>&lt;h3 id=&quot;xtocid1902914&quot;&gt;Comments&lt;/h3&gt;</code></p><p>这个标记<code>标识文档中的某个点</code>。为了引用这个点,URL不仅要包括文档的文件名,还要包括片段标识符,与URL的其余部分用#隔开:<br><code>http://www.cafeaulait.org/javafaq.html#xtocid1902914</code></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/487e88c6/">第五章 URL和URI</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第5章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>一些有用的程序</title>
      <link href="/blog/8ffd9f6b/"/>
      <url>/blog/8ffd9f6b/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><p>现在你已经了解了java.net.InetAddress类的有关知识。只使用这个类中的工具就能编写一些相当有用的程序。这里将看到两个例子:一个可以检查地址是否是一个已知的垃圾邮件发送者,另一个可以通过离线处理日志文件来提升web服务器的性能。</p><h2 id="SpamCheck"><a href="#SpamCheck" class="headerlink" title="SpamCheck"></a>SpamCheck</h2><p>很多服务会监视垃圾邮件发送者(spammer),并通知客户端试图与之连接的主机是否是一个已知的垃圾邮件发送者。这些实时黑洞列表(real-time blackhole lists,RBL)需要非常快地对查询做出响应,而且要处理相当大的工作负载。可能会有数千个甚至上百万个主机反复查询,查看试图建立连接的一个IP地址是否是一个已知的垃圾邮件发送者。</p><p>这个问题的性质要求响应必须很快,理想情况下,还应该可以缓存。另外,负载应当分布到多个服务器上,最好是位于世界各地的不同服务器。看起来可以使用Web服务器SOAP、UDP、定制协议或者其他某种机制来实现,不过实际上只使用DNS就能巧妙地实现这个服务。</p><p>要查看一个IP地址是否是一个已知的垃圾邮件发送者,可以逆置这个地址的字节,增加黑洞服务的域,然后查找这个地址。如果找到这个地址,说明它是一个垃圾邮件发送者。如果没有找到,就说明它不是。例如,如果你想向sbl.spamhaus.org询问207.8.34.17是否是一个垃圾邮件发送者,就要查找主机名17.34.87.207 sbl.spamhaus.org(需要说明,尽管这里包含数字部分,不过这是一个主机名ASCII字符串,而不是一个点分四段IP地址)。</p><p>如果DNS査询成功(更确切地讲,如果它返回地址127.0.0.2),那么这个主机就是一个已知的垃圾邮件发送者。如果查找失败,也就是说,它抛出一个UnknownHostException,说明这个地址不是一个垃圾邮件发送者。示例4-9实现了这个检查。</p><p>示例4-9: SpamCheck<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpamCheck</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BLACKHOLE = <span class="string">"sbl.spamhaus.org"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String arg: args) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (isSpammer(arg)) </span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(arg + <span class="string">" is a known spammer."</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(arg + <span class="string">" appears legitimate."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSpammer</span><span class="params">(String arg)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            InetAddress address = InetAddress.getByName(arg);</span><br><span class="line">            <span class="keyword">byte</span>[] quad = address.getAddress();</span><br><span class="line">            String query = BLACKHOLE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">byte</span> octet : quad) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> unsignedByte = octet &lt; <span class="number">0</span> ? octet + <span class="number">256</span> : octet;</span><br><span class="line">                query = unsignedByte + <span class="string">"."</span> + query;</span><br><span class="line">            &#125;</span><br><span class="line">            InetAddress.getByName(query);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>以下给出一些示例输出:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;java SpamCheck 207.34.56.23 125.12.32.4 130.130.130.130</span><br><span class="line">207.34.56.23 appears legitimate.</span><br><span class="line">125.12.32.4 appears legitimate.</span><br><span class="line">130.130.130.130 appears legitimate.</span><br></pre></td></tr></table></figure><p></p><p>如果使用这个技术,要注意掌握黑洞列表策略和地址的变化。出于很明显的原因,黑洞服务器经常成为DDOS和其他攻击的目标,所以如果黑洞服务器改变了地址,或者停止响应任何查询,你不能因此阻塞所有通信。<br>另外还要注意,不同的黑洞列表采用的协议可能稍有差别。例如,有些黑洞列表返回的垃圾邮件IP是1270.0.l而不是127.0.0.2。</p><h2 id="处理Web服务器日志文件"><a href="#处理Web服务器日志文件" class="headerlink" title="处理Web服务器日志文件"></a>处理Web服务器日志文件</h2><p>web服务器日志会跟踪记录访问Web网站的主机。默认情况下,日志会报告连接服务器的网站的IP地址。不过,通常可以从网站的名字而不是其IP地址获得更多信息。大多数web服务器有一个选项,可以存储主机名而不是IP地址,不过这可能会影响性能,因为每次访问时服务器都需要做一个DNS请求。如果先记录IP地址,稍后在服务器不太忙时再转换为主机名,或者甚至干脆在另外一个机器上完成转换,这样效率会更高。示例4-10给出了一个名为 Weblog的程序,它读取Web服务器日志文件,显示各行时将IP地址转换为主机名。</p><p>大多数web服务器都对常见的日志文件格式进行了标准化。常见日志文件格式中的一行般如下:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">205.160.186.76 unknown - [17/Jun/2013:22:53:58 -0500] &quot;Get /bgs/greenbg.gif Http 1.0&quot; 200 50</span><br></pre></td></tr></table></figure><p></p><p>这一行指示位于IP地址205.160.186.76的Web浏览器在2013年6月17日下午11:53(58秒)访问这个Web服务器上的文件/ bgs/greenbg.gif。文件已找到(响应码200),向浏览器成功地传输了50字节数据。</p><p>第一个域是IP地址,或者如果启用了DNS解析,则是要建立连接的主机名。接下来是一个空格。因此,对我们来说,解析日志文件很简单,第一个空格之前的都是IP地址,其后的内容不需要改变。</p><p>点分四段格式IP地址使用java.net.InetAddress的常用方法转换为主机名。示例4-10展示了这些代码。</p><p>示例4-10:处理Web服务器日志文件<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Weblog</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (FileInputStream fin =  <span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]);</span><br><span class="line">        Reader in = <span class="keyword">new</span> InputStreamReader(fin);</span><br><span class="line">        BufferedReader bin = <span class="keyword">new</span> BufferedReader(in);) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (String entry = bin.readLine();entry != <span class="keyword">null</span>;entry = bin.readLine()) </span><br><span class="line">            &#123;</span><br><span class="line"><span class="comment">//              separate out the IP address</span></span><br><span class="line">                <span class="keyword">int</span> index = entry.indexOf(<span class="string">' '</span>);</span><br><span class="line">                String ip = entry.substring(<span class="number">0</span>, index);<span class="comment">//第一个空格之前的是IP地址</span></span><br><span class="line">                String theRest = entry.substring(index);<span class="comment">//剩下的部分</span></span><br><span class="line"><span class="comment">//              Ask DNS for the hostname and print it out</span></span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//使用IP地址创建InetAddress对象</span></span><br><span class="line">                    InetAddress address = InetAddress.getByName(ip);</span><br><span class="line">                    <span class="comment">//输出主机名，和其他记录。</span></span><br><span class="line">                    System.out.println(address.getHostName() + theRest);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnknownHostException ex) &#123;</span><br><span class="line">                    System.err.println(entry);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Exception: "</span> + ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>要处理的文件名作为命令行上的第一个参数传递给Weblog。从这个文件打开一个FileInputstream fin,并将一个 InputstreamReader串链至fin。这个 InputstreamReader通过串链到 BufferedReader类的一个实例进行缓冲。文件在一个for循环中逐行处理。</p><p>每次循环时都会把一行放入 String变量 entry。然后 entry被分解成两个子串:ip以及theRest,ip包含第一个空格之前的所有内容, therest是第一个空格之后到字符串末尾的全部内容。第一个空格的位置由 entry. indexof(“ “)确定。子串ip使用 getByName()转换为一个 InetAddress对象。然后 getHostName()查询主机名。最后,在 System.out上显示主机名以及这一行的所有其他内容( therest)。输出可以通过标准输出重定向的方式,发送到新文件中。</p><p>Weblog比你预想的更高效。大多数Web浏览器会对提供的每个网页生成多个日志文件项,因为不只是页面本身有一个日志项,页面中的每个图片也分别对应有一个日志项。很多访问者访问网站时会请求多个页面。<strong>DNS查找成本很高</strong>,如果每个网站每次出现在日志文件中时都要查找,这样做并不合适。 <strong>Inetaddress类会缓存请求过的地址。如果再次请求相同的地址,它可以从缓存中获取,这比从DNS获取要快得多</strong>。</p><p>尽管如此,这个程序肯定还可以更快。在我最初的测试中,每个日志项花费的时间大于1秒(具体的数字取决于网络连接的速度、本地和远程DNS服务器的速度,以及程序运时的网络拥塞状况)。<strong>这个程序耗费了大量时间等待DNS返回请求,在此期间什么也不做。显然,这正是多线程设计所要解决的问题。可以由一个主线程读取日志文件,将各个日志项传递给其他线程进行处理。</strong></p><p>这里绝对需要一个<code>线程池</code>。经过几天之后,即使是低吞吐量的web服务器也会生成包含数百万行的日志文件。如果试图为每一项生成一个新的线程来处理这样一个日志文件,即使是最强大的虚拟机也会很快吃不消,特别是主线程读取文件项的速度要比各个线程解析域名并结束的速度快得多。因此,很有必要重用线程。线程数目存储在一个可调整的参数 numberOfThreads中,所以可以调整这个参数来满足VM和网络栈的需要(同时发起太多DNS请求也会出现问题)。</p><p>现在程序分为两个类。第一个类 LookupTask如示例4-11所示,这是一个Callable类,它会解析一个日志文件项,查找一个地址,并把这个地址替换为相应的主机名。看上去好像没有太多工作,并不需要占用太多CPU,确实如此。不过,由于这里涉及网络连接,而且多个不同的DNS服务器之间可能还有一系列网络连接构成一个层次结构,所以有大量闲置时间,可以由其他线程更好地加以利用。</p><p>示例4-11: LookupTask</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LookupTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String line;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LookupTask</span><span class="params">(String line)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.line = line;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">//          separate out the IP address</span></span><br><span class="line">            <span class="keyword">int</span> index = line.indexOf(<span class="string">' '</span>);</span><br><span class="line">            String address = line.substring(<span class="number">0</span>, index); <span class="comment">//空格之前的是IP地址</span></span><br><span class="line">            String theRest = line.substring(index);<span class="comment">//剩下的部分</span></span><br><span class="line">            String hostname = InetAddress.getByName(address).getHostName();<span class="comment">//获取主机名</span></span><br><span class="line">            <span class="keyword">return</span> hostname + <span class="string">" "</span> + theRest;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">return</span> line;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个类PooledWeblog如示例4-12所示,其中包含main()方法,它会读取文件,并为每行创建一个 LookupTask。各个任务提交给一个executor,它可以并行和串行运行多个(不过不是全部)任务。</p><p>submit()方法返回的Future连同原来的行存储在一个队列中(以防异步线程中出错)。由一个循环从这个队列中读取值,并显示这些值。这样可以保持日志文件原来的顺序。</p><p>示例4-12: PooledWebLog<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Requires Java 7 for try-with-resources and multi-catch</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledWeblog</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NUM_THREADS = <span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(NUM_THREADS);</span><br><span class="line">        Queue&lt;LogEntry&gt; results = <span class="keyword">new</span> LinkedList&lt;LogEntry&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> (BufferedReader in = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">        <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]), <span class="string">"UTF-8"</span>));</span><br><span class="line">        )&#123;</span><br><span class="line">            <span class="keyword">for</span> (String entry = in.readLine(); entry != <span class="keyword">null</span>; entry = in.readLine()) </span><br><span class="line">            &#123;</span><br><span class="line">                LookupTask task = <span class="keyword">new</span> LookupTask(entry);</span><br><span class="line">                Future&lt;String&gt; future = executor.submit(task);</span><br><span class="line">                LogEntry result = <span class="keyword">new</span> LogEntry(entry, future);</span><br><span class="line">                results.add(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Start printing the results. This blocks each time a result isn't ready.</span></span><br><span class="line">        <span class="keyword">for</span> (LogEntry result : results) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(result.future.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException ex) &#123;</span><br><span class="line">                System.out.println(result.original);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        executor.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LogEntry</span> </span></span><br><span class="line"><span class="class">        </span>&#123;</span><br><span class="line">            String original;</span><br><span class="line">            Future&lt;String&gt; future;</span><br><span class="line">            LogEntry(String original, Future&lt;String&gt; future) &#123;</span><br><span class="line">            <span class="keyword">this</span>.original = original;</span><br><span class="line">            <span class="keyword">this</span>.future = future;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>使用这样的线程允许并行地处理同一个日志文件,从而节省大量时间。在我不太科学的测试中,多线程版本比串行版本快10到50倍。但是我们的技术编辑在另一个系统上运行同样的测试,只看到4倍的速度提升。不过无论如何,这仍是一个不小的进步。</p><p>这个设计还有一个缺点。与为每一个日志文件项生成一个线程相比,尽管Callable任务队列更为高效,但是日志文件可能很庞大,所以这个程序仍会占用大量内存。为避免这点,可以把输出放在一个单独的线程中,它与输入线程共享同一个队列。由于解析输入的同时可以处理和显示之前的日志文件项,所以队列不会膨胀得过大。但是这又会带来另一个问题。你需要一个单独的信号指示输出已经完成,因为空队列已经不足以证明任务已经完成。最容易的方法是统计输入行数,确保它与输出行数一致。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/8ffd9f6b/">一些有用的程序</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第4章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>NetworkInterface类</title>
      <link href="/blog/9dcd7732/"/>
      <url>/blog/9dcd7732/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><p><strong>NetworkInterface类表示一个本地IP地址</strong>。这可以是一个物理接口,如额外的以太网卡(常见于防火墙和路由器),也可以是一个虚拟接口,与机器的其他IP地址绑定到同个物理硬件。 NetworkInterface类提供了一些方法可以枚举所有本地地址(而不考虑接口),并由它们创建 InetAddress对象,然后这些 InetAddress对象可用于创建 socket、服务器 socket等。</p><h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><p>由于 NetworkInterface对象表示物理硬件和虚拟地址,所以不能任意构造。与 Inetaddress类一样,有一些静态工厂方法可以返回与某个网络接口关联的NetworkInterface对象。可以通过IP地址、名字或枚举来请求一个 NetworkInterface。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NetworkInterface <span class="title">getByName</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">                                  <span class="keyword">throws</span> SocketException <span class="comment">//搜索具有指定名称的网络接口。</span></span></span><br></pre></td></tr></table></figure><p></p><p>getByName()方法返回一个 NetworkInterface对象,表示有指定名字的网络接口。如果没有这样一个接口,就返回null。如果在査找相关网络接口时底层网络栈遇到问题,会抛出一个 SocketException异常,不过这种情况不太可能发生。</p><p>名字的格式与平台有关。在典型的UNIX系统上,以太网接口名的形式为eth0、eth1等。本地回送地址的名字可能类似于“1o”。在 Windows上,名字是类似“CE31”和“ELX100”的字符串,取自这个特定网络接口的厂商名和硬件模型名。例如,下面的代码段尝试找到UNIX系统上的主以太网接口:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    NetworkInterface ni= NetworkInterface.getByName (<span class="string">"etho"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ni == <span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        System.err.println(<span class="string">"No such interface: etho"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(SocketException ex)</span><br><span class="line">&#123;</span><br><span class="line">    System.<span class="function">err <span class="title">println</span><span class="params">(<span class="string">"Could not list sockets."</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NetworkInterface <span class="title">getByInetAddress</span><span class="params">(InetAddress addr)</span> <span class="keyword">throws</span> SocketException</span></span><br><span class="line"><span class="function">        一个便捷方法，搜索绑定了指定 Internet 协议 <span class="params">(IP)</span> 地址的网络接口。</span></span><br></pre></td></tr></table></figure><p><strong>getByInetAddress()方法返回一个 NetworkInterface对象,表示与指定IP地址绑定的网络接口。如果本地主机上没有网络接口与这个IP地址绑定,就返回null</strong>。如果发生错误,就抛出一个 SocketException异常。例如,下面的代码段会找到本地回送地址的网络接口:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    InetAddress local= <span class="function">InetAddress <span class="title">getByName</span> <span class="params">(<span class="string">"127.0.0.1"</span>)</span></span>;</span><br><span class="line">    NetworkInterface ni=NetworkInterface.getByInetAddress(local);</span><br><span class="line">    <span class="keyword">if</span>(ni == <span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        System.err.println(<span class="string">"Thats weirlocal loopback address. "</span> )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(SocketException ex)</span><br><span class="line">&#123;</span><br><span class="line">    System.err.printIn(<span class="string">"Could not list network interfaces. "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(UnknownHostException ex)</span><br><span class="line">&#123;</span><br><span class="line">    System.err.println (<span class="string">"That's weird. Could not lookup 127.0.0.1."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Enumeration&lt;NetworkInterface&gt; <span class="title">getNetworkInterfaces</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                                                          <span class="keyword">throws</span> SocketException返回此机器上的所有接口</span></span><br></pre></td></tr></table></figure><p>getNetworkInterfaces()方法返回一个java.util.Enumeration,这会列出本地主机上的所有网络接口。示例4-8是一个简单的程序,会列出本地主机上的所有网络接口:</p><h3 id="示例4-8-列出所有网络接口的程序"><a href="#示例4-8-列出所有网络接口的程序" class="headerlink" title="示例4-8:列出所有网络接口的程序"></a>示例4-8:列出所有网络接口的程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceLister</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SocketException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Enumeration&lt;NetworkInterface&gt; interfaces = NetworkInterface.getNetworkInterfaces();</span><br><span class="line">        <span class="keyword">while</span> (interfaces.hasMoreElements()) </span><br><span class="line">        &#123;</span><br><span class="line">            NetworkInterface ni = interfaces.nextElement();</span><br><span class="line">            System.out.println(ni);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是在IBiblio登录服务器上运行这个程序的结果:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name:eth1(eth1) index: 3 addresses:</span><br><span class="line">/192.168.210.122</span><br><span class="line">name:eth0(eth0) index: 2 addresses</span><br><span class="line">/152.2.210.122;</span><br><span class="line">name: lo (lo) index: 1 addresses:</span><br><span class="line">/127.0.0.1;</span><br></pre></td></tr></table></figure><p></p><p>你会看到这台主机有两个单独的以太网卡及本地回送地址。索引为2的以太网卡(eth)的IP地址是152.2.210.122,索引为3的以太网卡的IP地址是192.168210.122。与往常一样,回送地址(lo)为127.0.0.1。</p><h2 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h2><p>有了 NetworkInterface对象,就可以查询其IP地址和名字。这几乎是这些对象所能完成的唯一操作。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Enumeration&lt;InetAddress&gt; <span class="title">getInetAddresses</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        一个便捷方法，返回一个具有绑定到此网络接口全部或部分 InetAddress 的 Enumeration</span></span><br></pre></td></tr></table></figure><p></p><p>一个网络接口可以绑定多个IP地址。现在这种情况不太常见,但确实是存在的。getInetAddresses()方法返回一个java.util.Enumeration,其中对于与这个接口绑定的每一个IP地址都包含一个 InetAddress。例如,下面的代码段列出etho接口的所有IP地址:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NetworkInterface etho= NetworkInterrface.getByName(<span class="string">"etho"</span>);</span><br><span class="line">Enumeration addresses=etho.getInetAddresses();</span><br><span class="line"><span class="keyword">while</span>(addresses.hasMoreElements())</span><br><span class="line">&#123;</span><br><span class="line">    System. out. println(addresses.nextElement());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;<span class="comment">//获取此网络接口的名称。</span></span><br></pre></td></tr></table></figure><p>getName()方法返回某个特定 NetworkInterface对象的名,如eth0或lo。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDisplayName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//获取此网络接口的显示名称。显示名称是描述网络设备的可读字符串</span></span><br></pre></td></tr></table></figure><p>getDisplayName()方法声称可以返回特定 NetworkInterface的一个更友好的名字,类似于“ Ethernet Card0”。不过,根据我在UNx上的测试,它总是返回与 getName()同样的结果。在 Windows上,可以看到稍微友好一些的名字,如“ Local Area Connection”或Local Area Connection2”。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/9dcd7732/">NetworkInterface类</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第4章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>工厂方法</title>
      <link href="/blog/a778ad08/"/>
      <url>/blog/a778ad08/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:20 GMT+0800 (中国标准时间) --><p>本文链接: <a href="https://www.lansheng.net.cn/blog/a778ad08/">工厂方法</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第4章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Inet4Address和Inet6Address</title>
      <link href="/blog/86b74042/"/>
      <url>/blog/86b74042/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><p>Java使用了两个类Inet4Address和Inet6Address,来区分IPv4地址和IPv6地址:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Inet4Address</span> <span class="keyword">extends</span> <span class="title">InetAddress</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">final</span> <span class="title">class</span> <span class="title">Inet6Address</span> <span class="keyword">extends</span> <span class="title">InetAddress</span></span></span><br></pre></td></tr></table></figure><p></p><p>大多数情况下,你确实不必考虑一个地址是IPv4还是IPv6地址。因为在Java程序所在的应用层,完全不需要了解低层的细节(<strong>即使确实需要知道是IPv4还是IPv6,只需检查 netAddress()返回的字节数组的大小,如果是4个字节，就是IPv4,如果是16字节，那就是IPv6,这比使用 instanceof来测试地址是哪一个子类要快得多</strong>)。<strong>Inet4Address覆盖了InetAddress的几个方法,但没有以任何公共方式改变其行为</strong>。Inet6Address也类似,但加入了超类中未出现的一个新方法, isIPv4CompatibleAddress():<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIPv4CompatibleAddress</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p></p><p>当且仅当地址实际上是填充在IPv6“容器”中的一个IPv4地址时,这个方法返回true,这意味着只有最后的4字节(最后四个字节对应IPv4地址)不是0。<strong>也就是说,地址的形式为0:0:0:0:0:0:0:xxxx。如果是这样,可以从 getBytes()返回的数组中提取最后4字节,用这个数据创建一个Inet4Address</strong>。不过,很少需要这样做。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/86b74042/">Inet4Address和Inet6Address</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第4章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>测试可达性</title>
      <link href="/blog/24e1a183/"/>
      <url>/blog/24e1a183/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><p><strong>InetAddress类有两个 isReachable()方法,可以测试一个特定节点对当前主机是否可达(也就是说,能否建立一个网络连接)</strong>。连接可能由于很多原因而阻塞,包括防火墙代理服务器、行为失常的路由器和断开的线缆等,或者只是因为试图连接时远程主机没有开机。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReachable</span><span class="params">(<span class="keyword">int</span> timeout)</span></span></span><br><span class="line"><span class="function">                    <span class="keyword">throws</span> IOException <span class="comment">//测试是否可以达到该地址</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReachable</span><span class="params">(NetworkInterface netif,<span class="keyword">int</span> ttl,<span class="keyword">int</span> timeout)</span></span></span><br><span class="line"><span class="function">                    <span class="keyword">throws</span> IOException <span class="comment">//测试是否可以达到该地址。</span></span></span><br></pre></td></tr></table></figure><p></p><p><strong>这些方法尝试使用 traceroute(更确切地讲,就是 ICMP echo请求)查看指定地址是否可达。如果主机在 timeout毫秒内响应,则方法返回true;否则返回 false</strong>。如果出现网络错误则抛出 IOException异常。第二个方法还允许指定从哪个本地网络接口建立连接,以及“生存时间”(连接被丢弃前尝试的最大网络跳数)。</p><h2 id="Object方法"><a href="#Object方法" class="headerlink" title="Object方法"></a>Object方法</h2><p>与其他各个类一样,java.net.InetAddress继承自java.lang.Object。因此,它可以访问Object类的所有方法。它覆盖了3个方法来提供更特殊的行为:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p></p><p><strong>如果一个对象本身是 InetAddress类的实例,而且与一个 InetAddress对象有相同的IP地址,只有此时才会与该 InetAddress对象相等,<code>并不要求这两个对象有相同的主机名</code></strong>。因此,<a href="http://www.ibiblio.org的InetAddress对象等于www.cafeaulait.org的InetAddress对象,因为这两个主机名指向相同的IP地址。示例4-7为www.ibiblio.org和helios.biblia.org创建InetAddress对象,然后指出它们是否为同一台机器。" target="_blank" rel="noopener">www.ibiblio.org的InetAddress对象等于www.cafeaulait.org的InetAddress对象,因为这两个主机名指向相同的IP地址。示例4-7为www.ibiblio.org和helios.biblia.org创建InetAddress对象,然后指出它们是否为同一台机器。</a></p><h4 id="示例4-7-www-ibiblioorg和helios-ibiblio-org相同吗"><a href="#示例4-7-www-ibiblioorg和helios-ibiblio-org相同吗" class="headerlink" title="示例4-7:www.ibiblioorg和helios.ibiblio.org相同吗?"></a>示例4-7:<a href="http://www.ibiblioorg和helios.ibiblio.org相同吗" target="_blank" rel="noopener">www.ibiblioorg和helios.ibiblio.org相同吗</a>?</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IBiblioAliases</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String args[])</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//使用域名实例化InetAddress对象</span></span><br><span class="line">            InetAddress ibiblio = InetAddress.getByName(<span class="string">"www.ibiblio.org"</span>);</span><br><span class="line">            InetAddress helios = InetAddress.getByName(<span class="string">"helios.ibiblio.org"</span>);</span><br><span class="line">            <span class="comment">//判断两个对象是否相等(如果IP地址相等则两个对象相等)</span></span><br><span class="line">            <span class="keyword">if</span> (ibiblio.equals(helios)) </span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println</span><br><span class="line">                (<span class="string">"www.ibiblio.org is the same as helios.ibiblio.org"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println</span><br><span class="line">                (<span class="string">"www.ibiblio.org is not the same as helios.ibiblio.org"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException ex) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Host lookup failed."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这个程序时会发现:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.ibiblio.org is the same as helios.ibiblio.org</span><br></pre></td></tr></table></figure><p></p><hr><p>其实我电脑上运行的结果是两个不相同。可能已经改了域名和IP地址的映射关系。不过不要紧，就大致了解equals()方法是根据IP地址来判断就行了。</p><hr><p>hashCode()方法与 equals()方法一致。<strong> hashCode()方法返回的int<code>只根据IP地址来计算</code>它不考虑主机名</strong>。<code>如果两个 InetAddress对象有相同的地址,就会有相同的散列码</code>,即使它们的主机名有所不同。</p><p>与所有好的类一样,java.net.InetAddress有一个 toString()方法,可以返回对象的简单文本表示。示例4-1到示例4-2在将InetAddress)对象传递给 System.out.println()时都隐式调用了这个方法。如你所见,由 toString()生成的字符串有如下形式:<br><strong>主机名/点分四段地址</strong><br><strong>不是所有 InetAddress都有主机名。如果没有</strong>,在Java1.3及以前版本中就替换为点分四段式地址。在<strong>Java1.4及以后版本中,主机名设置为空字符串</strong>。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/24e1a183/">测试可达性</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第4章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>地址类型</title>
      <link href="/blog/6c3ef939/"/>
      <url>/blog/6c3ef939/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><p><strong>有些IP地址和地址模式有特殊的含义</strong>。例如,前面提到127.0.0.1是本地回送地址。<br><strong>224.0.0.0到239.255.255.255范围内的IPv4地址是<code>组播地址</code>,可以同时发送到多个订购的主机</strong>。Java提供了10个方法来测试 InetAddress对象是否符合其中某个标准:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnyLocalAddress</span><span class="params">()</span></span>;<span class="comment">//检查 InetAddress 是否是通配符地址的实用例行程序。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLoopbackAddress</span><span class="params">()</span></span>;<span class="comment">//检查 InetAddress 是否是回送地址的实用例行程序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLinkLocalAddress</span><span class="params">()</span></span>;<span class="comment">//检查 InetAddress 是否是链接本地地址的实用例行程序。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSiteLocalAddress</span><span class="params">()</span></span>;<span class="comment">//检查 InetAddress 是否是站点本地地址的实用例行程序。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMulticastAddress</span><span class="params">()</span></span>;<span class="comment">//检查 InetAddress 是否是 IP 多播地址的实用例行程序。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMCGlobal</span><span class="params">()</span></span>;<span class="comment">//检查多播地址是否具有全局域的实用例行程序。 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMCNodeLocal</span><span class="params">()</span></span>;<span class="comment">//检查多播地址是否具有节点范围的实用例行程序。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMCLinkLocal</span><span class="params">()</span></span>;<span class="comment">//检查多播地址是否具有链接范围的实用例行程序。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMCSiteLocal</span><span class="params">()</span></span>;<span class="comment">//检查多播地址是否具有站点范围的实用例行程序。 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMCOrgLocal</span><span class="params">()</span></span>;<span class="comment">//检查多播地址是否具有组织范围的实用例行程序。</span></span><br></pre></td></tr></table></figure><p></p><h3 id="通配地址"><a href="#通配地址" class="headerlink" title="通配地址"></a>通配地址</h3><p><strong>如果地址是<code>通配地址( wildcard address)</code>, isAnyLocalAddress()方法返回true,否则返回 false。通配地址可以匹配本地系统中的任何地址</strong>。如果系统有多个网络接口(如一个系统有多个以太网卡,或者系统有一个以太网卡和一个802.11WiFi接口),这会很重要。<strong>在IPv4中,通配地址是0.0.0.0</strong>。<strong>在IPV6中通配地址是<code>0:0:0:0:0:0:0:0</code>(又写作<code>::</code>)</strong>。</p><h3 id="回送地址"><a href="#回送地址" class="headerlink" title="回送地址"></a>回送地址</h3><p><strong>如果地址是<code>回送地址( loopback address)</code>, isLoopbackAddress()方法返回true,否则返回 false</strong>。<strong>回送地址直接在IP层连接同一台计算机,而不使用任何物理硬件。因此,通过连接回送地址,可以绕过可能有bug或不存在的以太网、PPP和其他驱动程序进行测试</strong>,这有助于隔离问题。连接回送地址与从系统中连接同一个系统的正常IP地址有所不同。<strong>在IPv4中,回送地址是127.0.0.1。在IPv6中,这个回送地址是0:0:0:0:0:0:0:1(又写作<code>::1</code>)</strong></p><h3 id="IPv6本地链接地址"><a href="#IPv6本地链接地址" class="headerlink" title="IPv6本地链接地址"></a>IPv6本地链接地址</h3><p><strong>如果地址是一个IPv6本地链接地址, isLinkLocalAddress()方法返回true,否则返回false</strong>。IPv6本地链接地址可以用于帮助IPv6网络实现自配置,与IPv4网络上的DHCP非常相似,但没有必要使用服务器。路由器不会把发送给本地链接地址的包转发到本地子网以外。<strong>所有本地链接地址都以8字节FE80:000:0000开头。后8字节用本地地址填充</strong>,这个地址通常从以太网卡生产商分配的以太网MAC地址复制。</p><h3 id="IPv6本地网站地址"><a href="#IPv6本地网站地址" class="headerlink" title="IPv6本地网站地址"></a>IPv6本地网站地址</h3><p><strong>如果地址是一个IPv6本地网站地址, isSiteLocalAddress()方法返回true,否则返回false</strong>。本地网站地址与本地链接地址相似,不过本地网站地址可以由路由器在网站或校园内转发,但不应转发到网站以外。<strong>本地网站地址以8字节FEC0:0000:00000开头</strong>。<strong>后8字节用本地地址填充</strong>,这个地址通常从以太网卡生产商分配的以太网MAC地址复制。</p><h3 id="组播地址"><a href="#组播地址" class="headerlink" title="组播地址"></a>组播地址</h3><p><strong>如果地址是一个组播地址, isMulticastAddress()方法返回true,否则返回 false</strong>。组播会将内容广播给所有预订的计算机,而不是某一台计算机。<strong>在IPv4中,组播地址都在224.0.0.0到239.255.255.255范围内。在IPv6中,组播地址都以字节FF开头</strong>。第13章将讨论组播。</p><h3 id="全球组播地址"><a href="#全球组播地址" class="headerlink" title="全球组播地址"></a>全球组播地址</h3><p><strong>如果地址是全球组播地址, isMCGlobal()方法返回tue,否则返回 false</strong>。全球组播地址可能在世界范围内都有订购者。所有组播地址都以FF开头。<strong>在IPv6中,全球组播地址以FF0E或FF1E开头,这取决于这个组播地址是已知的永久分配地址还是一个临时地址</strong>。<strong>在IPv4中,所有组播地址都是全球范围的,至少对这个方法而言是这样</strong>。在第13章你将看到,<strong>IPv4使用生存时间(TTL)值而不是地址来控制范围</strong>。</p><h3 id="网站范围组播地址"><a href="#网站范围组播地址" class="headerlink" title="网站范围组播地址"></a>网站范围组播地址</h3><p><strong>如果地址是一个网站范围组播地址, isMCSiteLocal()方法返回true,否则返回 false</strong>。<strong>发送到网站范围地址的包只会在本地网站内传输</strong>。网站组播地址以FF05或FF15开头,这取决于这个组播地址是已知的永久分配地址还是一个临时地址。</p><h3 id="子网范围组播地址"><a href="#子网范围组播地址" class="headerlink" title="子网范围组播地址"></a>子网范围组播地址</h3><p><strong>如果地址是一个子网范围组播地址, isMCLinklocal()方法返回true,否则返回 false</strong>。发送到子网组播地址的包只会在自己的子网内传输。子网组播地址以FF02或FF12开头,这取决于这个组播地址是已知的永久分配地址还是一个临时地址。</p><h3 id="本地接口组播地址"><a href="#本地接口组播地址" class="headerlink" title="本地接口组播地址"></a>本地接口组播地址</h3><p><strong>如果地址是一个本地接口组播地址, isMCNodeLocal()方法返回true,否则返回 false</strong>。<strong>发送到本地接口地址的包不能发送到</strong>最初的<strong>网络接口以外</strong>,即使是相同节点上的不同网络接口也不行。这主要用于网络调试和测试。本地接口组播地址以2字节FF01或FF11开头,这取决于这个组播地址是已知的永久分配地址还是一个临时地址。</p><hr><p>提示:这个方法的名与当前的术语不太一致。IPv6协议的早期草案称这种地址为“本地节点”地址,因而方法名为“ isMCNodeLocal”。实际上,在将这个方法增加到JDK之前,IPNG工作组就已经修改了这个方法名,不过很遗憾,Sun没有及时拿到备忘录</p><hr><p>示例4-6是一个简单的程序,这里使用这10个方法来测试从命令行输入的一个地址的性质。<br>示例4-6:测试IP地址的性质</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IPCharacteristics</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            InetAddress address = InetAddress.getByName(args[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span> (address.isAnyLocalAddress()) </span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(address + <span class="string">" is a wildcard address."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (address.isLoopbackAddress()) </span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(address + <span class="string">" is loopback address."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (address.isLinkLocalAddress()) </span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(address + <span class="string">" is a link-local address."</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (address.isSiteLocalAddress()) &#123;</span><br><span class="line">                System.out.println(address + <span class="string">" is a site-local address."</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(address + <span class="string">" is a global address."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (address.isMulticastAddress()) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (address.isMCGlobal()) </span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(address + <span class="string">" is a global multicast address."</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (address.isMCOrgLocal()) &#123;</span><br><span class="line">                    System.out.println(address</span><br><span class="line">                    + <span class="string">" is an organization wide multicast address."</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (address.isMCSiteLocal()) &#123;</span><br><span class="line">                    System.out.println(address + <span class="string">" is a site wide multicast</span></span><br><span class="line"><span class="string">                    address."</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (address.isMCLinkLocal()) &#123;</span><br><span class="line">                    System.out.println(address + <span class="string">" is a subnet wide multicast</span></span><br><span class="line"><span class="string">                    address."</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (address.isMCNodeLocal()) &#123;</span><br><span class="line">                    System.out.println(address</span><br><span class="line">                    + <span class="string">" is an interface-local multicast address."</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(address + <span class="string">" is an unknown multicast</span></span><br><span class="line"><span class="string">                    address type."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(address + <span class="string">" is a unicast address."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException ex) &#123;</span><br><span class="line">            System.err.println(<span class="string">"Could not resolve "</span> + args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个IPv4和IPv6地址的输出:<br>略，回去再跑。写注释，修改程序。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/6c3ef939/">地址类型</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第4章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>InetAddress类</title>
      <link href="/blog/f9eb76d8/"/>
      <url>/blog/f9eb76d8/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><p><strong>java.net.InetAddress类是Java对IP地址(包括IPv4和IPv6)的高层表示</strong>。大多数其他网络类都要用到这个类,包括Socket,ServerSocket、URL、 DatagramSocket、DatagramPacket等。<strong>一般地讲,它包括一个主机名和一个P地址</strong>。</p><h2 id="创建新的-I-InetAddress对象"><a href="#创建新的-I-InetAddress对象" class="headerlink" title="创建新的 I InetAddress对象"></a>创建新的 I InetAddress对象</h2><p><strong>InetAddress类没有公共构造函数</strong>。实际上, InetAddress有一些静态工厂方法,可以连接到DNS服务器来解析主机名。最常用的是 InetAddress.getByName()。例如,可以如下查找<a href="http://www.oreilly.com" target="_blank" rel="noopener">www.oreilly.com</a>:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InetAddress address=InetAddress.getByName(<span class="string">"www.Oreilly.com"</span>);</span><br></pre></td></tr></table></figure><p></p><p>这个方法并不只是设置 InetAddress类中的一个私有 String字段。实际上它会建立与本地DNS服务器的一个连接,来查找名字和数字地址(如果你之前查找过这个主机,这个信息可能会在本地缓存,如果是这样,就不需要再建立网络连接)。如果DNS服务器找不到这个地址,这个方法会抛出一个 UnknownHostException异常,这是 IOEXception的一个子类。</p><p>示例4-1展示了一个完整的程序,它为<a href="http://www.oreilly.com创建一个InetAddress对象,这里包括所有必要的导入和异常处理。" target="_blank" rel="noopener">www.oreilly.com创建一个InetAddress对象,这里包括所有必要的导入和异常处理。</a><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OReillyByName</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            InetAddress address = InetAddress.getByName(<span class="string">"www.oreilly.com"</span>);</span><br><span class="line">            System.out.println(address);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException ex) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Could not find www.oreilly.com"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>结果如下:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.oreilly.com/23.193.119.31</span><br></pre></td></tr></table></figure><p></p><p>还可以按IP地址反向查找。例如,如果希望得到地址208.201.239.100的主机名,可以向InetAddress.getByName()传入一个点分四段地址:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InetAddress address = InetAddress.getByName(&quot;208.201.239.100&quot;);</span><br><span class="line">System.out.println(address.getHostName());</span><br></pre></td></tr></table></figure><p></p><p><strong>如果你查找的地址没有相应的主机名, getHostName()就会返回你提供的点分四段地址</strong>。</p><p>之前我提到过<a href="http://www.oreilly.com实际上有两个地址。getHostName()返回哪一个地址是不确定的。如果出于某种原因你需要得到一个主机的所有地址,可以调用getAllByName(),它会返回一个数组" target="_blank" rel="noopener">www.oreilly.com实际上有两个地址。getHostName()返回哪一个地址是不确定的。如果出于某种原因你需要得到一个主机的所有地址,可以调用getAllByName(),它会返回一个数组</a>:</p><p>InetAddress[] addresses=InetAddress.getAllByName(“<a href="http://www.oreilly.com&quot;)" target="_blank" rel="noopener">www.oreilly.com&quot;)</a>;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> </span><br><span class="line">&#123;</span><br><span class="line">    InetAddress[] addresses=InetAddress.getAllByName(<span class="string">"www.oreilly.com"</span>);</span><br><span class="line">    <span class="keyword">for</span> (InetAddress inetAddress : addresses)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(inetAddress);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (UnknownHostException ex) &#123;</span><br><span class="line">    System.out.println(<span class="string">"Could not find www.oreilly.com"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后, getLocalHost()方法会为运行这个代码的主机返回一个 InetAddress对象:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InetAddress me=InetAddress.getLocalHost();</span><br></pre></td></tr></table></figure><p></p><p>这个方法尝试连接DNS来得到一个真正的主机名和IP地址,如“ elharo.laptop.corp.com”和“192.1.254.68”;不过如果失败,它就会返回回送地址,即主机名“localhost”和点分四段地址“127.0.0.1”。</p><p>示例4-2显示了运行这个代码的机器的地址。</p><p>示例4-2:查找本地机器的地址<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAddress</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//获取本机地址</span></span><br><span class="line">            InetAddress address = InetAddress.getLocalHost();</span><br><span class="line">            System.out.println(address);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException ex) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Could not find this computer's address."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>输出如下(我是在titan.oit.unc.edu上运行这个程序),这个每个人的输出效果不一样。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">titan.oit.unc.edu/152.46.7.122</span><br></pre></td></tr></table></figure><p></p><p>你可能会看到完全限定名如titan.oit.unc.edu,也可能会看到部分名如titan,这取决于本地DSN服务器为本地域中的主机返回什么结果。如果没有连接到 Internet,系统也没有固定IP地址或域名,可能会看到域名为 localhost,IP地址为1270.0.1。<br>创建地址:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InetAddress <span class="title">getByAddress</span><span class="params">(<span class="keyword">byte</span>[] addr)</span> <span class="keyword">throws</span> UnknownHostException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InetAddress <span class="title">getByAddress</span><span class="params">(String hostname,<span class="keyword">byte</span>[] addr)</span> <span class="keyword">throws</span> UnknowHostException</span></span><br></pre></td></tr></table></figure><p></p><p>第一个 Inetaddress.getByAddress()工厂方法用一个IP地址(而没有主机名)创建一个 InetAddress对象。第二个 InetAddress.getByAddress()方法使用一个IP地址和个主机名创建 Inetaddress对象。例如,下面这个代码段会为107.23.216.196创建一个InetAddress：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] address=&#123;<span class="number">107</span>,<span class="number">23</span>,(<span class="keyword">byte</span>)<span class="number">216</span>,(<span class="keyword">byte</span>)<span class="number">196</span>&#125;;</span><br><span class="line">InetAddress lessWrong=InetAddress.getByAddress(address);</span><br><span class="line">InetAddress lessWrongWithname=InetAddress.getByAddress(<span class="string">"lesswrong.com"</span>,address);</span><br></pre></td></tr></table></figure><p></p><p>需要说明,它必须把两个大数字转换为字节。</p><p>与其他工厂方法不同,这两个方法不能保证这个主机一定存在,或者主机名能正确地映射到IP地址。只有当作为 address参数传入的字节数组大小不合法时(不是4字节,也不是16字节),这两个方法才会抛出一个 UnknownHostException异常。<strong>如果域名服务器不可用,或者可能有不正确的信息,这会很有用</strong>。例如,我的主干网中所有计算机、打印机或路由器都没有注册任何DNS服务器。因为我记不住为哪些系统分配了哪些地址,所以我写了一个简单的程序,尝试依次连接所有254个可能的本地地址,来看哪些地址是活动的(这样花费的时间是把所有地址写在一张纸上所需时间的10倍)。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p><strong>由于DNS查找的开销可能相当大</strong>(如果请求需要经过多个中间服务器,或者尝试解析个不可达的主机,这大约需要几秒的时间),<strong>所以 InetAddress类会缓存查找的结果。<code>一旦得到一个给定主机的地址,就不会再次查找</code>,即使你为同一个主机创建一个新的InetAddress对象,也不会再次查找地址</strong>。只要在程序运行期间IP地址没有改变,这就没有问题。</p><p>负面结果(即主机未找到错误)稍有些问题。有可能刚开始尝试解析一个主机时失败,但随后再次尝试时解析会成功,这种情况并不少见。由于从远程DNS服务器发来的信息还在传输中,第一次尝试超时。然后这个地址到达本地服务器,所以下一次请求时可用。出于这个原因,<strong>Java对于不成功的DNS查询只缓存10秒</strong>。</p><p>这些时间可以用系统属性 networkaddress.cache.ttl和 networkaddress.cache.negative,ttl来控制。其中<strong>第一个属性 networkaddress.cache.ttl指定了成功的DNS查找结果在Java缓存中保留的时间(秒数</strong>), <strong>networkaddress.cache.negative.ttl指定了不成功的查找结果缓存的时间(秒数)</strong>。<strong>在这些时限内,再次尝试查找相同的主机会返回相同的值</strong>。这两个属性如果设为-1则表示“永不过期“</p><p>除了在 InetAddress类中的本地缓存,本地主机、本地域名服务器和 Internet上其他地方的DNS服务器也会缓存各种査询的结果。对此,Java没有提供有关的控制方法。因此,在 <strong>Internet上传播IP地址改变的信息可能要花费几个小时</strong>。在此期间,你的程序可能会遇到各种异常,包括 UnknownHostException、 NoRouteToHostException和ConnectException异常,这取决于对DNS所做的改变。</p><h2 id="按IP地址查找"><a href="#按IP地址查找" class="headerlink" title="按IP地址查找"></a>按IP地址查找</h2><p><strong>调用 getByName()并提供一个IP地址串作为参数时,会为所请求的IP地址创建一个InetAddress对象,<code>而不检查DNS</code></strong>。这说明,<strong>可能会为实际上不存在也无法连接的主机创建 InetAddress对象</strong>。<strong>由包含<code>IP地址的字符串</code>来创建 InetAddress对象时,<code>这个对象的主机名初始设置为这个IP地址字符串</code></strong>。<strong>只有当请求主机名时(显式地通过 getHostName()请求),才会真正完成主机名的DNS查找</strong>。从点分四段地址<code>208.201.239.37</code>确定<a href="http://www.oreilly.com时就采用了这种方式。**如果请求主机名并最终完成了一个DNS查找,但是指定IP地址的主机无法找到,那么主机名会保持为最初的点分四段字符串**。不过,**不会抛出" target="_blank" rel="noopener">www.oreilly.com时就采用了这种方式。**如果请求主机名并最终完成了一个DNS查找,但是指定IP地址的主机无法找到,那么主机名会保持为最初的点分四段字符串**。不过,**不会抛出</a> UnknownHostException异常**。</p><p><strong>主机名要比IP地址稳定得多</strong>。<strong>有些服务多年以来一直使用同一个主机名,但IP地址更换了很多次</strong>。如果要在使用主机名(如<a href="http://www.oreilly.com)或使用IP地址(如208.201.239.37)之间做出选择,一定要选择主机名。**只有当主机名不可用时才使用IP地址**。" target="_blank" rel="noopener">www.oreilly.com)或使用IP地址(如208.201.239.37)之间做出选择,一定要选择主机名。**只有当主机名不可用时才使用IP地址**。</a></p><h2 id="安全性问题"><a href="#安全性问题" class="headerlink" title="安全性问题"></a>安全性问题</h2><p><strong>从主机名创建一个新的 InetAddress对象被认为是一个潜在的不安全操作,因为这需要一个DNS查找</strong>。<strong>在默认安全管理器控制下的不可信applet只允许获得它的<code>初始主机(其代码基)</code>的IP地址</strong>,这可能是本地主机。不允许不可信代码由任何其他主机名创建 InetAddress对象。不论代码使用 InetAddress.getByName()方法，InetAddress.getAllByName()方法、 InetAddress.getLocalHost()方法,还是其他方法,都是如此。不可信代码可以由字符串形式的IP地址构造 InetAddress对象,但不会为这样的地址完成DNS查找。</p><p>由于禁止与代码基(本地主机)之外的主机建立网络连接,不可信的代码不允许对第三方主机完成任意的DNS查找。任意的DNS查找会打开一个隐藏的通道,通过它,程序可以与第三方主机对话。例如,假设一个从<a href="http://www.bigisp.com下载的applet希望将消息“macfaq.dialup.cloud9.net" target="_blank" rel="noopener">www.bigisp.com下载的applet希望将消息“macfaq.dialup.cloud9.net</a> is vulnerable”发送给 crackersinc.com。它只需要请求 macfaq.dialup.cloud9.net is.vuInerable.crackersinc.com的DNS信息。为了解析这个主机名,这个applet会联系本地DNS服务器。本地DNS服务器会联系位于 crackersinc.com的DNS服务器。尽管这些主机不存在,但黑客可以查看 crackersinc.com的DNS错误日志来获取这个消息。如果再结合压缩、纠错、加密,以及将电子邮件消息发送给一个第四方网站的定制DNS服务器,这个机制还可以复杂得多,但这个版本已经足以证明上述观点。<strong>由于任意DNS查找会泄漏信息,所以要禁止任意的DNS查找</strong>。</p><p><strong>不可信代码允许调用 InetAddress.getLocalHost()</strong>。不过,在这种环境下,getLocalHost()总是返回主机名 localhost/127.0.0.1。禁止applet找出真正的主机名和地址的原因在于,运行 applet的计算机可能故意隐藏在防火墙的后面。在这种情况下applet不应作为通道来获得Web服务器还没有的信息。</p><p>与所有安全性检查一样,禁止DNS解析可以对可信代码放宽要求。要测试一个主机能否解析,所用的特定 SecurityManager方法是 checkConnect():<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkConnect</span><span class="params">(String hostname, <span class="keyword">int</span> port)</span></span></span><br></pre></td></tr></table></figure><p></p><p>当port参数为-1时,这个方法检查能否调用DNS解析指定的 hostname。(如果port参数大于-1,这个方法检査是否允许在指定端口对指定主机建立连接)。 hostname参数可以是主机名(如<a href="http://www.oreilly.com),也可以是点分四段IP地址(如208.201.239.37),或者还可以是十六进制IPv6地址如FEDC:DC:0:7076:10。" target="_blank" rel="noopener">www.oreilly.com),也可以是点分四段IP地址(如208.201.239.37),或者还可以是十六进制IPv6地址如FEDC:DC:0:7076:10。</a></p><h2 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h2><p>InetAddress包含4个获取方法,可以将主机名作为字符串返回,将IP地址返回为字符串和字节数组:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getHostName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCanonicalHostName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span>[] <span class="title">getAddress</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getHostAddress</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p></p><p>没有对应的 setHostName()和 setAddress()方法,这说明 <strong>java.net之外的包无法在后台改变 InetAddress对象的字段。这使得 InetAddress不可变,因此是线程安全的</strong>。</p><p>getHostName()方法返回一个 String,其中包含主机的名字,以及这个 InetAddress对象表示的IP地址。如果这台机器没有主机名或者安全管理器阻止确定主机名,就会返回点分四段格式的数字IP地址。例如:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InetAddress machine= InetAddress.getLocalHost();</span><br><span class="line">String localhost=machine.getHostName();</span><br></pre></td></tr></table></figure><p></p><p>getCanonicalHostName()方法也类似,不过在与DNS联系方面更积极一些。<strong>getHostName()只是在不知道主机名时才会联系DNS,而 getcanonicalHostName()知道主机名时也会联系DNS,可能会替换原来缓存的主机名</strong>。例如:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InetAddress machine= InetAddress.getLocalHost();</span><br><span class="line">String localhost= machine.getCanonicalHostName();</span><br></pre></td></tr></table></figure><p></p><p><strong>如果开始只有一个占分四段IP地址而没有主机名, getCanonicalHostName()方法尤其有用</strong>。示例4-3首先使用 InetAddress.getByName(),然后对得到的对象应用getcanonicalHostName(),可以把点分四段地址208.201.239.37转换为一个主机名。</p><h3 id="示例4-3-给定地址-找出主机名"><a href="#示例4-3-给定地址-找出主机名" class="headerlink" title="示例4-3:给定地址,找出主机名"></a>示例4-3:给定地址,找出主机名</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseTest</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        InetAddress ia = InetAddress.getByName(<span class="string">"208.201.239.100"</span>);</span><br><span class="line">        System.out.println(ia.getCanonicalHostName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getHostAddress()方法返回一个字符串,其中包含点分四段格式的IP地址。示例4-4使用这个方法按通常的<strong>格式显示本地机器的IP地址</strong>。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAddress</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            InetAddress address = InetAddress.getLocalHost();</span><br><span class="line">            String dottedQuad=me.getHostAddress();</span><br><span class="line">            System.out.prinln(<span class="string">"My address is "</span>+dottedQuad)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException ex) &#123;</span><br><span class="line">            System.out.println(<span class="string">"I'm sorry. I don't know my own address."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>结果如下:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">My address is 192.168.73.1</span><br></pre></td></tr></table></figure><p></p><p>当然,具体的输出依赖于运行程序的机器。</p><p><strong>如果希望知道一台机器的IP地址(很少这样做),可以使用 getAddress()方法</strong>,它会以网络字节顺序将IP地址作为一个字节数组返回。最高字节(即地址的点分四段形式中的第一字节)是数组的第一字节,即数组的元素0。如果要考虑到IPv6地址,不要对这个数组的长度做任何假定。如果需要知道这个数组的长度,可以使用数组的length字段:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InetAddress me= InetAddress.getLocalHost();</span><br><span class="line"><span class="keyword">byte</span>[] address=me.getAddress();</span><br></pre></td></tr></table></figure><p></p><p>返回的字节是无符号的,这会带来一个问题。<strong>与C不同,Java没有无符号字节这种基本数据类型。值大于127的字节会当作负数</strong>。因此,如果要对 getAddress()返回的字节做任何处理,需要将字节提升为int,并做适当的调整。下面给出一种做法:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> unsignedByte =signedByte &lt;<span class="number">0</span> ? signedByte+<span class="number">256</span> : signedByte;</span><br></pre></td></tr></table></figure><p></p><p>这里, signedByte可能为正也可能为负。<strong>条件操作符?测试 signedBy是否为负。如果为负,则为 signedBy加上256使其成为正数。否则保持不变</strong>。 signedByte会在完成加法操作之前自动提升为int,所以不存在这种回绕( wraparound)问题。<br><strong>之所以要查看IP地址的原始字节,一个原因是想要确定地址的类型</strong>。<strong>测试 getAddress()所返回数组的字节数可以确定处理的是IPv4还是IPv6地址</strong>,如示例4-5所示。</p><h3 id="示例4-5-确定地址是IV4还是Iv6"><a href="#示例4-5-确定地址是IV4还是Iv6" class="headerlink" title="示例4-5:确定地址是IV4还是Iv6"></a>示例4-5:确定地址是IV4还是Iv6</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddressTests</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getVersion</span><span class="params">(InetAddress ia)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] address = ia.getAddress();</span><br><span class="line">        <span class="keyword">if</span> (address.length == <span class="number">4</span>) <span class="keyword">return</span> <span class="number">4</span>;<span class="comment">//如果是4个字节的IP地址，那就是IPv4地址。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (address.length == <span class="number">16</span>) <span class="keyword">return</span> <span class="number">6</span>;<span class="comment">//如果是16个字节的IP地址，那就是IPv6地址。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文链接: <a href="https://www.lansheng.net.cn/blog/f9eb76d8/">InetAddress类</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第4章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>第4章Internet地址</title>
      <link href="/blog/f384e578/"/>
      <url>/blog/f384e578/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>连接到 Interne的设备称为<code>节点(node)</code>。计算机节点称为<code>主机(host)</code>。每个节点或主机都由至少一个唯一的数来标识,这称为<code>Internet地址或IP地址</code>。目前大多<code>数IP地址是四字节长</code>,这被称作<code>IPv4地址</code>。不过,一小部分<code>IP地址是16字节长</code>(而且这种地址的数量正在增加),这被称作<code>IPv6地址`</code>(4和6指 Internet协议的版本,不是地址中的字节数`)。</strong>IPv4和IPv6地址都是字节的有序序列,和数组一样。它们不是数,它们的顺序也不具有任何可预测或有用的意义。</p><p><strong>IPv4地址一般写为<code>四个无符号字节</code>,<code>每字节范围从0到255</code>,<code>最高字节在前</code></strong>。为方便人们查看,各字节用点号分隔。例如, login.ibiblio.org的地址是152.19.134.132。这称为点分四段( dotted quad)格式(也叫点分十进制)。</p><p><strong>IPv6地址通常写为冒号分隔的8个区块,每个区块是4个十六进制数字</strong>。例如,写这本书时,<code>www.hamiltonweather.tk</code>的地址是<strong>2400:cb00:2048:<code>0001</code>:<code>0000</code>:<code>0000</code>:6ca2:c665</strong>。<code>前导的0不需要写出</code>。因此,<a href="http://www.hamiltonweather.tk的地址可以写为**2400:cb00:2048:`1`:`0`:`0`:6ca2:c665**。**两个冒号表示多个0区块,但每个地址中双冒号至多出现一次**。例如,**2001:4860:4860:`0000:0000:0000:0000`:8888**可以写为紧缩的**2001:4860:4860`::`8888**。**在IPv6和IPv4的混合网络中,`IPv6地址的最后4字节有时写为IPv4的点分四段地址`。**例如,**FEDC:BA98:70654:3210:FEDC:BA98:`7654:3210`**可以写为**FEDC:BA98:7654:3210:FEDC:BA98:`18.84.50.16`**。" target="_blank" rel="noopener">www.hamiltonweather.tk的地址可以写为**2400:cb00:2048:`1`:`0`:`0`:6ca2:c665**。**两个冒号表示多个0区块,但每个地址中双冒号至多出现一次**。例如,**2001:4860:4860:`0000:0000:0000:0000`:8888**可以写为紧缩的**2001:4860:4860`::`8888**。**在IPv6和IPv4的混合网络中,`IPv6地址的最后4字节有时写为IPv4的点分四段地址`。**例如,**FEDC:BA98:70654:3210:FEDC:BA98:`7654:3210`**可以写为**FEDC:BA98:7654:3210:FEDC:BA98:`18.84.50.16`**。</a></p><p>IP地址对于计算机来说很不错,但对人来说是个问题,人们很难记忆长的数字。在20世纪50年代,G.A.Miller发现大多数人可以记住每个数中大约7个数字,有些人可以记住多达9个,而另外一些人只能记住5个。有关的更多信息参见《 Psychological Review》卷63第81-97页上的《 The Magic Number Seven, Plus or Minus two: Some Limits on Our Capacity for Processing Information》这就是为什么电话号码被分成多个部分,每个部分包括3或4个数字,另外还有一个3个数字的区号。很明显,<strong>IP地址多达12个十进制数字已经超出了大多数人的记忆能力</strong>。我能记住大概两个IP地址,前提是我每天都用它们,而且这两个地址处于同一个子网内。</p><p><strong>为避免到处携带记满IP地址的通讯录, Internet的设计者发明了域名系统( Domain NameSystem,DNS)</strong>。DNS将人们可以记忆的主机名(如 login.ibiblio.org)与计算机可以记忆的IP地址(如152.19.134.132)关联在一起。<strong>服务器通常至少有一个主机名。客户端往往有一个主机名,但也可能没有,特别是有些客户端的IP地址会在启动时动态指定</strong>。</p><hr><p>提示:通俗地讲,人们通常使用“Internet地址”表示一个主机名(或者甚至是电子邮件地址,或者完全URL)。在关于网络编程的书中,准确区分地址和主机名非常重要。<strong>在本书中,地址总是数字IP地址,而不是人类可读的主机名</strong>。</p><hr><p><strong>有些机器有多个名</strong>。例如,<a href="http://www.beand.com和xom.nu实际上是同一台Linux主机。名www.beand.com实际上指示一个web网站而不是一个特定的机器。**在过去,当这个web网站从一台机器移到另一台机器时,这个名字将重新指派给这台新机器,使它永远指向网站的当前服务器。通过这种方法,就不会因为网站迁移到一个新主机而要更新Web上的URL**。一些常见的名字如www和news通常就是提供这些服务的机器的别名。例如,new.sspeakeasy.net是我的ISP的新闻服务器的别名。由于服务器可能随着时间而改变,别名可能跟着服务转移。" target="_blank" rel="noopener">www.beand.com和xom.nu实际上是同一台Linux主机。名www.beand.com实际上指示一个web网站而不是一个特定的机器。**在过去,当这个web网站从一台机器移到另一台机器时,这个名字将重新指派给这台新机器,使它永远指向网站的当前服务器。通过这种方法,就不会因为网站迁移到一个新主机而要更新Web上的URL**。一些常见的名字如www和news通常就是提供这些服务的机器的别名。例如,new.sspeakeasy.net是我的ISP的新闻服务器的别名。由于服务器可能随着时间而改变,别名可能跟着服务转移。</a></p><p><strong>有时,一个名会映射到多个IP地址,这时就要由DNS服务器负责随机选择一台机器来响应各个请求。这个特性在业务流量非常大的web网站经常使用,它将负载分摊到多个系统上</strong>。例如,<a href="http://www.oreilly.com实际上是两台机器,一台位于208.201.239.100,一台位于208.201.239.101。" target="_blank" rel="noopener">www.oreilly.com实际上是两台机器,一台位于208.201.239.100,一台位于208.201.239.101。</a></p><p>每台连接到 Internet的计算机都应当能访问一个称为域名服务器( domain name server)的机器,它通常是一个运行特殊DNS软件的UNIX主机,这种软件了解不同主机名和IP地址之间的映射。大多数域名服务器只知道其本地网络上主机的地址,以及其他网站中些域名服务器的地址。<strong>如果客户端请求本地域之外一个机器的地址,本地域名服务器就会询问远程位置的域名服务器,再将答案转发给请求者</strong>。</p><p>大多数情况下,可以使用主机名,而让DNS处理向IP地址的转换。只要能连接到一个域名服务器,就不需要担心在你的机器、本地域名服务器和 Internet其余部分之间传递主机名和地址的有关细节。不过,你至少要能访问一个域名服务器才能使用本章和本书其余大部分的例子。这些程序在独立计算机上无法运行。你的机器必须连接到 Internet。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/f384e578/">第4章Internet地址</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第4章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java网络编程第4版 线程池和Executor</title>
      <link href="/blog/e9b810a3/"/>
      <url>/blog/e9b810a3/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><p><strong>向程序添加多个线程会极大地提升性能,尤其是I/O受限的程序,如大多数网络程序</strong>。不过,线程自身也存在开销。<strong>启动一个线程时,以及线程撤销后进行清理时,都需要虛拟机做大量工作</strong>,尤其是生成数百个线程的程序,即使对中低吞吐量的网络服务器而言,这种情况也很常见。即使线程能很快结束,这也会加重垃圾回收器或VM其他部分的负担而影响性能,就好像每分钟分配几千个任何其他类型的对象。更重要的是,<strong>在运行线程之间切换也会带来开销</strong>。<strong>如果线程自然阻塞(例如等待网络数据),那么没有什么真正的影响,但如果线程是CPU受限的,倘若能避免线程间的大量切换,整个任务可能会更快地结束</strong>。最后,也是最重要的,<strong>虽然线程有助于更高效地利用计算机有限的CPU资源,但所能提供的资源毕竟是有限的。一旦已经生成足够多的线程来使用计算机所有可用的空闲时间,那么再生成更多线程只会将MIPS和内存浪费在线程管理上。</strong></p><p>将各个任务作为一个 Sunnah1e对象提交给这个线程池,你就会得到一个 Futurexte利用java.uti1, concurrent中的 Executors类,可以非常容易地建立线程池。只需可以用来检查任务的进度。下面来看一个例子。假设你希望使用一个 java.uti1,zipGZIPOutputstream对当前目录中的每一个文件完成gzip压缩。这是一个过滤器流,会压缩它写的所有数据</p><p><strong>利用Java.util.concurrent中的Executors类,可以非常容易地建立线程池</strong>。只需要将各个任务作为一个 Runnable对象提交给这个线程池,你就会得到一个 Future对象,可以用来检查任务的进度。下面来看一个例子。假设你希望使用一个 java.util.zipGZIPOutputStream对当前目录中的每一个文件完成gzip压缩。这是一个过滤器流,会压缩它写的所有数据。</p><p>一方面,这是一个有大量IO的操作,因为所有文件都必须进行读/写。另一方面,数据压缩是一个“CPU密集”度很高的操作,所以你不希望同时运行太多线程。这是使用线程池的大好机会。每个客户端线程将压缩文件,同时主程序将确定要压缩哪个文件。在这个例子中,主程序的速度很可能会远远超过压缩线程,因为它要做的所有工作就是列出目录中的文件。因此,毫无疑问,首先要填充线程池,然后启动池中压缩文件的线程。不过,为了让这个示例尽可能具有地一般性,我们将让主程序与压缩线程并行运行。</p><p>示例3-13显示了 GZipRunnable类。它包含一个字段来标识要压缩的文件。run()方法会压缩这个文件并返回。<br>示例3-13: GZipRunnable类<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GZipRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> File input;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GZipRunnable</span><span class="params">(File input)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.input = input;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="comment">//      don't      compress      an      already      compressed      file</span></span><br><span class="line">        <span class="keyword">if</span> (!input.getName().endsWith(<span class="string">".gz"</span>)) </span><br><span class="line">        &#123;</span><br><span class="line">            File output = <span class="keyword">new</span> File(input.getParent(), input.getName() + <span class="string">".gz"</span>);</span><br><span class="line">            <span class="keyword">if</span> (!output.exists()) </span><br><span class="line">            &#123; <span class="comment">// Don't overwrite an existing file</span></span><br><span class="line">                <span class="keyword">try</span> ( <span class="comment">// with resources; requires Java 7</span></span><br><span class="line">                InputStream in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(input));</span><br><span class="line">                OutputStream out = <span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">                        <span class="keyword">new</span> GZIPOutputStream(</span><br><span class="line">                                <span class="keyword">new</span> FileOutputStream(output)));</span><br><span class="line">                ) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> b;</span><br><span class="line">                    <span class="comment">//标准读写方法</span></span><br><span class="line">                    <span class="keyword">while</span> ((b = in.read()) != -<span class="number">1</span>) out.write(b);</span><br><span class="line">                    out.flush();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                    System.err.println(ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>注意 GZipRunnable中可以使用Java7的try- with-resources语句。输入和输出流都在try块的最前面声明,并在try块的末尾自动关闭。</p><p>还要注意输入和输出的缓冲。这对于I/O有限的应用的性能非常重要,在网络程序中尤其重要。<strong>最坏情况下,缓冲对性能没有影响,但在最好情况下,会让执行速度提高一个数量级</strong>。</p><p>示例3-14是主程序。它构造了线程池,线程数固定为4,并迭代处理命令行中列出的所有文件和目录。这些文件以及这些目录中的文件将用来构建一个 GZipRunnable。这个runnable提交到线程池,最终由这4个线程之一处理。<br>示例3-14: GZipThread用户接口类<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GZipAllFiles</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">4</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class="line">        <span class="keyword">for</span> (String filename : args) </span><br><span class="line">        &#123;</span><br><span class="line">            File f = <span class="keyword">new</span> File(filename);</span><br><span class="line">            <span class="keyword">if</span> (f.exists()) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (f.isDirectory()) </span><br><span class="line">                &#123;</span><br><span class="line">                    File[] files = f.listFiles();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; files.length; i++) </span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!files[i].isDirectory()) </span><br><span class="line">                        &#123; <span class="comment">// don't recurse directories</span></span><br><span class="line">                            Runnable task = <span class="keyword">new</span> GZipRunnable(files[i]);</span><br><span class="line">                            pool.submit(task);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Runnable task = <span class="keyword">new</span> GZipRunnable(f);</span><br><span class="line">                    pool.submit(task);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>一旦将所有文件增加到这个池,就可以调用<strong>pool.shutdown()</strong>。这有可能在还有工作要完成的情况下发生。这个方法不会中止等待的工作。它只是<strong>通知线程池再没有更多任务需要增加到它的内部队列,而且一旦完成所有等待的工作,就应当关闭</strong>。</p><p>你要写的网络程序可能有大量线程,对于这些网络程序来说,很少像这样关闭,因为它有一个确定的终点:即所有文件都得到处理时。大多数网络服务器会无限继续,直到通过一个管理界面将其关闭。在这些情况下,你可能希望调用 <strong>shutdownNow(),中止当前处理中的任务,并忽略所有等待的任务</strong>。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/e9b810a3/">java网络编程第4版 线程池和Executor</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第3章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java截图文字识别升级</title>
      <link href="/blog/77feedee/"/>
      <url>/blog/77feedee/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>之前已经完成了程序的开发，也加入了热键，不过每次截图(ctrl+alt+w)都要手动的去点击文字识别按钮，显然有点浪费时间。<br>需求，添加文字识别快捷键(alt+B(BaiduOCR的简称))</p><p>实现，支持快捷键即可。</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>让工具栏在截图窗口消失的时候，显示在屏幕左上角，避免挡住屏幕影响阅读。<br>在构造函数中传入工具栏窗口的引用tools，然后嗲用tools.setLocation(0,0)。即可，本来我想着放在右边的，但是放右边的话不好计算坐标，索性就放右上角。<br>添加构造函数:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BaiduOCR</span><span class="params">(String path, ScreenShotWindow screenShotWindow,</span></span></span><br><span class="line"><span class="function"><span class="params">JButton baiduOCRButton, ToolsWindow tools)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.path = path;</span><br><span class="line"><span class="keyword">this</span>.screenShotWindow = screenShotWindow;</span><br><span class="line"><span class="keyword">this</span>.baiduOCRButton = baiduOCRButton;</span><br><span class="line"><span class="keyword">this</span>.tools = tools;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>run()方法中加入：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tools != <span class="keyword">null</span>)</span><br><span class="line">tools.setLocation(<span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p></p><h2 id="升级2"><a href="#升级2" class="headerlink" title="升级2"></a>升级2</h2><p>有时候误操作的时候，我必须得截图一下才能进行其他操作。<br>我希望在误操作的时候可以退出截图。比如按下esc按键。<br>按下alt+e让截图窗口隐藏</p><p>修改好了，我现在该代码都没注意改</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/77feedee/">Java截图文字识别升级</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> java_GUI </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java网络编程第4版 线程调度</title>
      <link href="/blog/a6b44b1a/"/>
      <url>/blog/a6b44b1a/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><p>当多个线程同时运行时(更正确的说法是,<code>当多个线程可以同时运行时</code>),<strong>必须考虑线程调度问题</strong>。你需要确保所有重要的线程至少要得到一些时间来运行,更重要的线程要得到更多的时间。此外,你希望保证线程以合理的顺序执行。如果Web服务器有10个排队的请求,每个请求都需要5s进行处理,你不会希望串行地处理它们。</p><p>如果这样做,第一个请求将在5秒内结東,而第二个将需要10秒,第三个需要15秒,依此类推,直到最后一个请求,它必须等待将近1分钟才能得到服务。到那时,用户很可能已经去浏览其他网页了。通过并行地运行线程,就能够在总共仅仅10秒内处理完所有10个请求。这种策略之所以可行,这是因为在为一个典型的web请求提供服务时,会有大量的空闲时间,在这段时间内线程只是在等待网络跟上CPU的速度,虚拟机的线程调度器完全可以将这段时间用于其他线程。不过,CPU受限的线程(而不是在网络程序中更常见的I受限线程)可能永远不会达到这种程度,如果CPU受限,线程往往更多地忙于处理,而不是等待更多的输入。这样的线程可能占用所有可用的CPU资源,使得所有其他线程处于“饥饿”状态。仔细考虑一下就可以避免这个问题。事实上,<code>与同步不当或死锁相比避免“饥饿”问题要容易得多</code>。</p><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>不是所有线程创建时都是均等的。<strong>每个线程都有一个优先级,指定为一个从0到10的整数</strong>。当多个线程可以运行时,虚拟机通常只运行最高优先级的线程,但这并不是一个严格的规则。<strong>在Java中,10是最高优先级,0是最低优先级。默认优先级为5,除非特意指定其他设置,否则你的线程都将具有这个默认优先级(5)</strong>。</p><hr><p>警告:这与UNIX区分进程优先级的一般方式刚好相反,<code>UINX中,进程的优先级数越大,进程获得的CPU时间就越少</code>。</p><hr><p>以下三个优先级(1,5和10)通常指定为三个命名常量</p><ul><li>Thread. MIN_PRIORITY(1)</li><li>Thread.NORM_PRIORITY(5)</li><li>Thread.MAX_PRIORITY(10)</li></ul><hr><p>警告:并不是所有操作系统都支持这11个不同的优先级。例如, Windows只有7个优先级。<code>在 Windows上,优先级1和2、3和4、6和7以及8和9会做同样的处理</code>(也就是说,优先级为9的线程并不会抢占优先级为8的线程)。</p><hr><p>有时你希望给一个线程更多的时间。与用户交互的线程应当获得非常高的优先级,这样就能感觉到响应非常快。另一方面,<code>在后台完成计算的线程应当获得低优先级</code>。<code>很快结束的任务应当有高优先级</code>。<code>将花费很长时间的任务应当有低优先级</code>,这样就不会妨碍其他任务。线程的优先级可以使用 setPriority()方法来改变:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span></span></span><br></pre></td></tr></table></figure><p></p><p>如果试图超出最大优先级,或者设置为一个非正的优先级,这些将抛出一个<code>IllegalArgumentException</code>异常。<br>例如,在示例3-11中,你可能希望完成计算的线程比生成这个线程的主程序有更高的优先级。这很容易做到,只需要修改 calculateDigest()方法,将生成的各个线程的优先级设置为8:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateDigest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListCallbackDigest cb= <span class="keyword">new</span> ListCallbackDigest(filename)</span><br><span class="line">    cb. addDigestListener(<span class="keyword">this</span>);</span><br><span class="line">    Thread t= <span class="keyword">new</span> Thread(cb);</span><br><span class="line">    t.setPriority (<span class="number">8</span>);</span><br><span class="line">    t.start:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>不过,一般情况下要尽量避免对线程使用太高的优先级,因为这要冒一定的风险,可能使其他低优先级线程遭受“饥饿”之苦。</p><h2 id="抢占"><a href="#抢占" class="headerlink" title="抢占"></a>抢占</h2><p>毎个虚拟机都有一个线程调度器,确定在给定时刻运行哪个线程。<code>主要有两种线程调度:抢占式( preemptive)和协作式( cooperative)</code>。<br>抢占式线程调度器确定一个线程正常地轮到其CPU时间时,会暂停这个线程,将CPU控制权交给另外的线程。<br><strong>协作式线程调度器</strong>在将CPU控制权交给其他线程前,<strong>会等待正在运行的线程<code>自己暂停</code></strong>。<code>与使用抢占式线程调度的虛拟机相比,使用协作式线程调度器的虚拟机更容易使线程陷入“饥饿”</code>,因为一个高优先级的非协作线程会独占整个CPU。<br>所有Java虚拟机都确保在不同优先级之间使用抢占式线程调度。也就是说,当一个低优先级线程正在运行,而一个高优先级线程准备运行时,<strong>虚拟机会或早或晚(可能很早)暂停这个低优先级线程,让高优先级线程运行。高优先级线程就抢占( preempt)了低优先级线程</strong>。</p><p><strong>如果多个相同优先级的线程准备运行</strong>,这种情况比较棘手。<strong>抢占式线程调度器偶尔会暂停其中一个线程,让下一个线程得到一些CPU时间</strong>。不过,<strong>协作式线程调度器</strong>不会这样。它<strong>将<code>等待正在运行的线程明确放弃控制</code>或者运行到最后停止(到达停止点)</strong>。倘若正在运行的线程永远也不放弃控制权,而且永远不会到达停止点,<strong>如果没有更高优先级线程抢占这个正在运行的线程,那么其他所有线程都会陷入“饥饿”状态</strong>。这很不好。重要的一点是,要确保所有线程自身定期地暂停,这样其他线程才可以有运行的机会</p><hr><p>警告:<strong>如果在一个使用抢占式线程调度的虚拟机上开发,饥饿问题可能很难发现</strong>。即使你的机上没有出现问题,这并不表示这个问题不会在<strong>客户的机器上出现(如果他们的虚拟机使用协作式线程调度</strong>)。<strong>目前大多数虚拟机都使用抢占式线程调度,但有些较早的虚拟机仍采用协作式调度,另外在一些特定用途的Java虚拟机(如面向嵌入式环境的虚拟机)中也可能会遇到协作式调度</strong></p><hr><p>为了能让其他线程有机会运行,一个线程有10种方式可以暂停或者指示它准备暂停。这包括:</p><ul><li>可以对I/O阻塞。</li><li>可以对同步对象阻塞。</li><li>可以放弃。</li><li>可以休眠。</li><li>可以连接另一个线程。</li><li>可以等待一个对象可以结束。</li><li>可以被更高优先级线程抢占。</li><li>可以被挂起。</li><li>可以停止。</li></ul><p>要检查你编写的每一个run()方法,确保这些条件之一会以合理的频率出现。<strong>最后两种可能性(挂起，停止)已经废弃不用,因为它们可能会让对象处于不一致的状态</strong>,所以我们来看能够让线程成为虚拟机中协作的一员的其他8种方法。</p><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p>任何时候线程必须停下来等待它没有的资源时,就会发生阻塞。要让网络程序中的线程自动放弃CPU控制权,最常见的方式是对IO阻塞。由于CPU比网络和磁盘快得多,网络程序经常会在等待数据从网络到达或向网络发送数据时阻塞。即使只阻塞几毫秒,这点时间也足够其他线程用来完成重要的任务。</p><p>线程在进入一个同步方法或代码块时也会阻塞。<strong><code>如果这个线程没有</code>所同步对象的<code>锁</code>,<code>而其他线程拥有这个锁,这个线程就会暂停,直到锁被释放为止</code></strong>。如果这个锁永远也不释放,那么这个线程会永久停止。<br>(注:线程执行同步方法或同步块的时候，要么得到锁而执行，要么得不到锁而等待(阻塞))</p><p><strong>不论是对I/O阻塞还是对锁阻塞,线程都不会释放自己已经拥有的锁(一个或多个)</strong>。对于I/O阻塞,这不是个大问题,因为无非有两种情况:最后I/O终将不再阻塞而线程将继续执行;或者将抛出个 IOException异常,然后线程退出这个同步块或方法,并释放它的锁。不过,<strong>如果个线程由于没有得到一个锁而阻塞,将永远不会放弃它自已已经持有的锁</strong>。<strong><code>如果一个线程等待第二个线程拥有的锁,而第二个线程等待第一个线程拥有的锁,就会导致死锁。</code></strong></p><h2 id="放弃"><a href="#放弃" class="headerlink" title="放弃"></a>放弃</h2><p>要让线程放弃控制权,第二种方式是显式地放弃。为此线程可以通过调用Thread.yield()静态方法来做到。这将通知虚拟机,如果有另一个线程A准备运行,可以运行该线程A。有些虚拟机(特别是在实时操作系统上)会忽略这个提示。</p><hr><p>参考:<a href="https://www.cnblogs.com/java-spring/p/8309931.html" target="_blank" rel="noopener">https://www.cnblogs.com/java-spring/p/8309931.html</a><br>注:<br><strong>Java线程中的Thread.yield( )方法</strong>，译为<strong>线程让步</strong>。顾名思义，<strong>就是说当一个线程使用了这个方法之后，它就会把自己CPU执行的时间让掉，让自己或者其它的线程运行，注意<code>是让自己或者其他线程运行</code></strong>，并不是单纯的让给其他线程。<br>yield()的作用是让步。它能让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到“运行状态”继续运行！</p><p>举个例子：<br>一帮小朋友在排队上公交车，轮到Yield的时候，他突然说：我不想先上去了，咱们大家来竞赛上公交车。然后所有人就一块冲向公交车，有可能是其他人先上车了，也有可能是Yield先上车了。<br>但是线程是有优先级的，优先级越高的人，就一定能第一个上车吗？这是不一定的，优先级高的人仅仅只是第一个上车的概率大了一点而已，最终第一个上车的，也有可能是优先级最低的人。并且所谓的优先级执行，是在大量执行次数中才能体现出来的。</p><hr><p>在放弃之前,线程应当确保它或与它关联的 Runnable对象处于一致状态,可以由其他对象使用。<strong>放弃并不会释放这个线程拥有的锁。因此,在理想情况下,在线程放弃时不应当做任何同步</strong>。一个线程放弃时,如果等待运行的其他线程都是因为需要这个线程所拥有的同步资源而阻塞,那么这些线程将不能运行。实际上,控制权将回到唯一可以运行的线程,即刚刚放弃的这个线程,这很大程度上失去了放弃的意义。</p><p>在实际中让线程放弃非常简单。如果线程的run()方法只包含一个无限循环,那么只要在循环的末尾加一个 Thread, yield()调用。例如:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//完成线程的工作...</span></span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>这会使其他有<code>相同优先级的线程</code>有机会运行</strong>。</p><p>如果每次循环迭代都要花费很多时间,你可能希望在代码的其余部分散布更多的Thread, yield()调用。在没有必要放弃的情况下,这种防范措施效果不甚明显。</p><h3 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a>休眠</h3><p>休眠是更有力的放弃方式。<strong>放弃只是表示线程愿意暂停,让其他有相同优先级的线程有机会运行</strong>,<strong>而进入休眠的线程有所不同,不管有没有其他线程准备运行,休眠线程都会暂停</strong>。<code>这样一来,不只是其他有相同优先级的线程得到机会,还会给较低优先级的线程一个运行的机会</code>。不过,<strong>进入休眠的线程仍然拥有它已经获得的所有锁。因此,其他需要相同锁的线程会阻塞,即使CPU可用</strong>。所以<code>要避免在同步方法或块内让线程休眠</code>。</p><p>通过调用以下两个重载的 Thread.sleep()静态方法之一,线程可以进入休眠。第一个方法接受要休眠的毫秒数作为参数。第二个接受毫秒数和毫微秒数。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> milliseconds)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> milliseconds, <span class="keyword">int</span> nanoseconds)</span><span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure><p></p><p>虽然多数现代计算机时钟至少有接近毫秒级的精确度,但精确度达到毫微秒级的极少。<strong>不能保证在任何虛拟机上都能将实际的休眠时间控制在毫微秒甚至毫秒级</strong>。如果本地硬件不支持这个精度,休眠时间将舍入为可测量的最接近的值。例如:下面的run()方法尝试每5分钟加载一个页面,如果失败,就向web管理员发emai提醒这个问题:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        (<span class="keyword">if</span>(!getpage(<span class="string">"http://www.ibiblio.org/"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            mailError(<span class="string">"webmaster@ibiblio.org"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">             Thread. sleep(<span class="number">30000</span>);<span class="comment">//300,000毫秒=5分钟</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(InterruptedException ex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>线程不能绝对保证一定会休眠所期望的那么长时间。有时,在请求唤醒呼叫之后过段时间线程才会真正唤醒,因为VM正在忙于做其他事情。也可能时间还没有到,但有其他线程完成了一些操作而唤醒了休眠的线程。一般情况下,这是通过调用休眠线程的interrupt()方法来实现的。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p></p><p>有些情况下<strong>线程与 Thread对象之间的区别很重要</strong>,这里就是如此。<strong>一个线程在休眠,并不意味着其他醒着的线程不能处理这个线程相应的 Thread对象(通过它的方法和字段)</strong>。具体地,<strong><code>另一个线程</code>可以调用<code>休眠</code>Thread对象的 interrupt()方法,这会让休眠中的线程得到一个 InterruptedException异常。在此之后,这个休眠中的线程会被唤醒并正常执行</strong>,至少在再次进入休眠之前会正常执行。在前面的例子中,使用了一个InterruptedException来结束一个线程,否则这个线程会永远运行下去。抛出InterruptedException时,就会打破无限循环,run()方法结束,相应地线程将会停止。<code>用户选择菜单中的Exit或指示希望程序退出时,用户界面线程会调用这个线程的interrupt()方法</code>。(是这样的吗，我表示怀疑)</p><hr><p>警告:如果一个线程对一个I/O操作(如读或写)阻塞,中断这个线程的效果很大程度上依赖于具体的平台。通常这将是一个什么都不做的操作。也就是说,线程继续阻塞。在 Solaris上,read()或 write()方法可能抛出一个 InterruptedIOException这是 IOException的一个子类。不过,其他平台上通常不会这样,而且在 Solaris上这也不适用于所有流类。<strong>如果你的程序体系结构需要可中断的I/O,就应当认真考虑使用第11章讨论的非阻塞IO,而不是流</strong>。<strong>与流不同,缓冲区和通道都明确设计为支持读写/写阻塞时中断</strong>。</p><hr><h2 id="连接线程"><a href="#连接线程" class="headerlink" title="连接线程"></a>连接线程</h2><p>一个线程可能需要另一个线程的结果,这是很常见的。例如,web浏览器在一个线程中加载HTML页面,它可能要生成一个单独的线程来获取页面中嵌入的各个图片。如果IMG元素没有指定 HEIGHT和 WIDTH属性,主线程在结束页面的显示之前,可能必须等待所有图片加载完毕。<strong>Java提供了三个join()方法,允许一个线程在继续执行前等待另一个线程结束</strong>。这些方法是:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> milliseconds)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> milliseconds, <span class="keyword">int</span> nanoseconds)</span><span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure><p></p><p><strong>第一种方法无限等待被连接( joined)的线程结束</strong>。后面两个方法会<strong>等待指定的一段时间,然后会继续执行,即使被连接的线程还没有结束</strong>。与 sleep方法一样,不能保证毫微秒级的精度。</p><p><strong>连接线程(即<code>调用join()方法的线程</code>)<code>等待被连接的线程</code></strong>(也就是说,调用的是这个线程的join()方法)结束。例如,考虑下面这段代码。我们希望找到一个随机 double数组中的最小数、最大数和中间数。用有序数组能更快地完成。我们生成一个新线程对数组排序,然后连接到这个线程等待它的结果。只有当它结束时,才会读取所需的值。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span>[] array= <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">10000</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    array[i]= Math.random();</span><br><span class="line">&#125;</span><br><span class="line">SortThread t= <span class="keyword">new</span> SortThread(array);</span><br><span class="line">t.start();</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    t.join();<span class="comment">//当前线程等待排序线程t结束,当前线程停止执行，等到排序线程t结束后再执行。</span></span><br><span class="line">    System.out.println(<span class="string">"Minimum:"</span>+array[<span class="number">0</span>]);</span><br><span class="line">    System.out.println(<span class="string">"Median:"</span>+array[array.length/<span class="number">2</span>])</span><br><span class="line">    System.out.println(<span class="string">"Maximum:"</span>+array[array.length-<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(InterruptedException ex)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>前面第1行到第4行先执行,用随机数填充数组。然后第5行创建一个新的 SortThread。第6行启动这个线程对数组排序。在找到数组的最小数、中间数和最大数之前,需要等待排序线程结束。因此,第8行将当前线程连接到排序线程。至此,执行这些代码的线程会停止执行。它会等待排序线程结束执行。直到排序线程结束运行并撤销之后,第9行到第11行才会获取最小、中间和最大值。</p><p>连接到(注:或者说<code>等待</code>)<code>另一个线程的线程可以被中断</code>,如果有其他线程调用正在等待线程的interrupt()方法,它就会像休眠线程一样被中断。线程将这个调用作为一个 InterruptedException异常。此后,它会从捕获这个异常的 catch块开始正常执行。在前面的例子中,<strong>如果线程被中断,它将跳过最小值、中间值和最大值的计算,因为如果排序线程在结束前被中断,这些值是不可用的</strong>。(注:我觉得这里没有因果关系，异常处理机制就是这么运作的)</p><p>可以使用join()修复示例3-4。示例3-4的问题是,main()方法的速度会超过生成结果的线程(即main()方法要使用的结果)。通过在使用各个线程的结果前连接各个线程(注:说的那么绕，就是主线程等待计算线程计算完毕，因为主线程要使用计算的结果),就能容易地解决这个问题。如示例3-12所示。</p><h3 id="示例3-12-通过连接生成所需结果的线程-避免竞态条件"><a href="#示例3-12-通过连接生成所需结果的线程-避免竞态条件" class="headerlink" title="示例3-12:通过连接生成所需结果的线程,避免竞态条件"></a>示例3-12:通过连接生成所需结果的线程,避免竞态条件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.xml.bind.DatatypeConverter;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDigestUserInterface</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ReturnDigest[] digestThreads = <span class="keyword">new</span> ReturnDigest[args.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) </span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">//          Calculate          the          digest</span></span><br><span class="line">            digestThreads[i] = <span class="keyword">new</span> ReturnDigest(args[i]);</span><br><span class="line">            digestThreads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                digestThreads[i].join();<span class="comment">//主线程等待计算线程结束</span></span><br><span class="line"><span class="comment">//              Now              print              the              result</span></span><br><span class="line">                StringBuffer result = <span class="keyword">new</span> StringBuffer(args[i]);</span><br><span class="line">                result.append(<span class="string">": "</span>);</span><br><span class="line">                <span class="keyword">byte</span>[] digest = digestThreads[i].getDigest();</span><br><span class="line">                result.append(DatatypeConverter.printHexBinary(digest));</span><br><span class="line">                System.out.println(result);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                System.err.println(<span class="string">"Thread Interrupted before completion"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于示例3-12以启动线程同样的顺序连接这些线程,这样修复也有一个副作用,它会按构造线程所用的参数的顺序显示输出,而不是按线程结束的顺序。这种修改不会让程序变慢,但有时<strong>如果你希望线程一旦结束就获得结果,而不是等待其他无关线程先结束</strong>,这可能会是个问题。</p><hr><p>提示:如今,连接线程可能没有Java5之前那么重要。具体来讲,很多原来需要join()的设计现在用 <a href="https://www.cnblogs.com/fengsehng/p/6048610.html" target="_blank" rel="noopener">Executor</a>和 <a href="https://www.cnblogs.com/cz123/p/7693064.html" target="_blank" rel="noopener">Future</a>可以更容易地实现。</p><hr><h2 id="等待一个对象"><a href="#等待一个对象" class="headerlink" title="等待一个对象"></a>等待一个对象</h2><p>线程可以等待(wait)一个它锁定的对象。在等待时,它会释放这个对象的锁并暂停,直到它得到其他线程的通知。另一个线程以某种方式修改这个对象,通知等待对象的线程,然后继续执行。这与连接线程不同,并不要求等待线程和通知线程在另一个线程继续前必须结束。<code>等待会暂停执行,直到一个对象或资源达到某种状态。连接也会暂停执行,不过是直到一个线程结束</code>(注:等待与连接的区别)。</p><p>在暂停线程的方法中,等待一个对象的做法并不太出名。这是因为它不涉及 Thread类的任何方法。实际上,要等待某个特定的对象,希望暂停的线程首先必须使用synchronized获得这个对象的锁,然后调用这个对象的三个重载wait()方法之一:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> milliseconds)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> milliseconds, <span class="keyword">int</span> nanoseconds)</span><span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure><p></p><p>这些方法不在 Thread类中,而是在java.lang.Object类中。因此,可以在任何类的任何对象上调用这些方法。调用其中一个方法时,调用它的线程会释放所等待的对象的锁(但不会释放它拥有的其他对象的锁),并进入休眠。线程会保持休眠,直到发生以下3种情况之一:</p><ul><li>时间到期</li><li>线程被中断</li><li>对象得到通知</li></ul><p><strong>超时时间</strong>( timeout)与sleep()和join()方法中的超时时间相同,<strong>即线程经过指定的段时间后(在本地硬件时钟的精度范围内)会唤醒</strong>。当时间到期时,线程会从紧挨着 wait()调用之后的语句继续执行。不过,如果线程不能立即重新获得所等待的对象的锁,它可能仍要阻塞一段时间。</p><p>中断( Interruption)与 sleep()和join()的工作方式相同:其他线程调用这个线程的interrupt()方法。这将导致一个 InterruptedException异常,并在捕获这个异常的catch块内继续执行。不过,在抛出异常前线程要重新获得所等待对象的锁,<strong>所以调用interrupt()方法后,该线程可能仍要阻塞一段时间</strong>。</p><p>第三种可能的方法是通知( notification),这是一个新方法。在其他线程在这个线程所等待的对象上调用 notify()或 notifyll()方法时,就会发生通知。这两个方法都在java.lang.Object类中:</p><ul><li>public final void notify()</li><li>public final void notifyAll()</li></ul><p>这两个方法都必须在线程所等待的对象上调用,而不是在 Thread本身调用。在通知一个对象之前,线程必须首先使用同步方法或块获得这个对象的锁。<strong>notify()基本上随机地从等待这个对象的线程列表中选择一个线程,并将它唤醒。notifyAll()方法会唤醒等待指定对象的每一个线程</strong>。</p><p>一旦等待线程得到通知,它就试图重新获得所等待对象的锁。如果成功,就会从紧接着wait()调用之后的语句继续执行。如果失败,它就会对这个对象阻塞,直到可以得到锁,然后继续执行紧接着wait()调用之后的语句。<br>例如,假设一个线程(JarThread)正在从网络连接中读取一个JAR归档文件。这个归档文件中第一项是清单文件。另一个线程可能对这个清单文件的内容感兴趣,即使归档文件的其余部分尚不可用。对清单文件感兴趣的线程(另一个线程)会创建一个定制的ManifestFile对象,将这个ManifestFile对象的引用传递给将要读取JAR归档文件的线程(JarThread),并等待这个读取JAR归档文件的线程。读取归档文件的线程(JarThread)首先用流中的项填写ManifestFile,然后通知ManifestFile,再继续读取JAR归档文件的其余部分。当阅读器线程通知ManifestFile时,另一个线程会被唤醒,它将按其计划处理现在已经完全准备就绪的ManifestFile对象。第一个线程的工作方式如下:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//另一个线程(最对清单文件感兴趣的线程)</span></span><br><span class="line">ManifestFile m= <span class="keyword">new</span> ManifestFile();<span class="comment">//创建定制的ManifestFile对象</span></span><br><span class="line">JarThread t= <span class="keyword">new</span> JarThread (m, in);<span class="comment">//传递引用给JarThread线程</span></span><br><span class="line"><span class="comment">//获取清单文件的锁</span></span><br><span class="line"><span class="keyword">synchronized</span>(m)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取清单文件的锁后</span></span><br><span class="line">    t.start();  <span class="comment">//启动JarThread线程，Jar线程将读取清单文件到ManifestFile对象中</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        m.wait();<span class="comment">//放弃当前的锁,等待。等待别人唤醒</span></span><br><span class="line">        <span class="comment">//处理JarThread线程处理好的清单文件...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(InterruptedException ex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//处理异常...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>JarThread类工作如下:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清单文件的引用</span></span><br><span class="line">Manifestfile theManifest;</span><br><span class="line">Inputstream in;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JarThread</span><span class="params">( Manifest m, Inputstream in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    theManifest=m;</span><br><span class="line">    <span class="keyword">this</span>.in=in;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取清单文件的锁</span></span><br><span class="line">    <span class="keyword">synchronized</span>(theManifest)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取到锁后</span></span><br><span class="line">        <span class="comment">//从流in读入清单文件...</span></span><br><span class="line">        <span class="comment">//读入清单文件完毕后,唤醒在清单文件对象theManifest(也就是对象m)上等待的线程</span></span><br><span class="line">        theManifest.notify()</span><br><span class="line">        <span class="comment">//读取流的其余部分...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>当多个线程希望等待同一个对象时,等待(<code>wait()</code>)和通知(<code>notifiy()</code>)会更为常用</strong>。例如,一个线程可能在读取一个Web服务器日志文件,文件中每一行包含要处理的一项。读取时每一行放在个 java.util.List中。多个线程在添加项时会等待这个List来处理这些项。每次添加一项时,会使用 notifyll()方法通知等待线程。<strong>如果有多个线程在等待这个对象,首选notifyll()</strong>,因为没有办法选择要通知哪个线程。<strong>当等待一个对象的所有线程得到通知时,这些线程都会被唤醒,并试图获得这个对象的锁。不过,只有一个线程能立即成功。得到锁的这个线程将继续执行。其余线程会阻塞,直到第一个线程释放这个锁</strong>。如果多个线程等待同一个对象,那么轮到最后一个线程获得这个对象的锁并继续执行时,可能已经过去了相当长的时间。在这段时间内,这个线程等待的对象完全有可能再次置于不可接受的状态。因此,一般要将wait()调用放在检查当前对象状态的循环中。不要假定因为线程得到了通知,对象(锁)现在就处于正确的状态。要保证对象进入正确的状态(解锁状态)之后,再也不会进入不正确(锁定状态?)的状态,如果无法保证这一点,就要显式地进行检查。例如,下面显示了等待日志文件项的客户端线程:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理列表</span></span><br><span class="line"><span class="keyword">private</span> List&lt;string&gt; entries;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processEntry</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">synchronized</span>(entries) <span class="comment">//必须对等待的对象同步</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(entries.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//在当前列表上等待</span></span><br><span class="line">            entries.wait();</span><br><span class="line">            <span class="comment">//停止等待,因为 entries.size()变为非0,</span></span><br><span class="line">            <span class="comment">//但是我们不知道它仍然是非0,</span></span><br><span class="line">            <span class="comment">//所以再次通过循环检查它现在的状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(InterruptedException ex)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">//如果被中断，则检查最后一项已经处理过，所以返回</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String entry=entries.remove(entries.size()-<span class="number">1</span>);</span><br><span class="line">        /处理这一项</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>下面给出的代码会读取日志文件,并将项添加到列表中:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readLogFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        String entry=log.getNextEntry();</span><br><span class="line">        <span class="keyword">if</span>(entry==<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//没有更多项要添加到列表,</span></span><br><span class="line">            <span class="comment">//所以中断所有仍在等待的线程。</span></span><br><span class="line">            <span class="comment">//否则它们将永远等待下去</span></span><br><span class="line">            <span class="keyword">for</span> (Thread thread:threads)</span><br><span class="line">            &#123;</span><br><span class="line">                thread. interrupt();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span>(entries)</span><br><span class="line">        &#123;</span><br><span class="line">            entries.add(<span class="number">0</span>,entry);</span><br><span class="line">            entries.notifyAll();唤醒所以在entries(锁)上等待的线程()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>注解:我这里看的有点懵逼啊,不是很懂上面代码要干嘛。算了我先往下看。</p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>线程要以合理的方式放弃CPU控制权,最后一种方法是结束( finishing)。<strong>当run()方法返回时,线程将撤销,其他线程可以接管CPU</strong>。在网络应用程序中,包装一个阻塞操作的线程往往会这样做,例如从服务器下载一个文件,这样应用程序的其他部分就不会被阻塞。</p><p>另一方面,如果run()方法太简单,总是很快就结束,而不会阻塞,那就存在一个很实际的问题:到底有没有必要生成一个线程。<strong>虚拟机在建立和撤销线程时会有很大的开销。如果线程会在极短的时间内结束,那么使用一次简单的方法调用而不是单独的线程可能会结束得更快</strong>。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/a6b44b1a/">java网络编程第4版 线程调度</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第3章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>我的截图百度文字识别工具</title>
      <link href="/blog/3640dbe/"/>
      <url>/blog/3640dbe/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>经过一番编码，终于达到我的效果了。先记录一下代码吧。</p><h2 id="程序入口类-ScreenShotOCR"><a href="#程序入口类-ScreenShotOCR" class="headerlink" title="程序入口类:ScreenShotOCR"></a>程序入口类:ScreenShotOCR</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> release.ocr.baidu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.AWTException;</span><br><span class="line"><span class="keyword">import</span> java.awt.EventQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScreenShotOCR</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> ScreenShotWindow ssw;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">startScreenShotWindow();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 回调函数，使得当前窗口不可见。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">notVisible</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ssw.setVisible(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">visiable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ssw.setVisible(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startScreenShotWindow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">EventQueue.invokeLater(<span class="keyword">new</span> Runnable()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">ssw = <span class="keyword">new</span> ScreenShotWindow();</span><br><span class="line">ssw.setVisible(<span class="keyword">true</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (AWTException e)</span><br><span class="line">&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实上面的main中的代码不用独立提取出来作为一个函数。</p><h1 id="矩形截图窗口ScreenShotWindow"><a href="#矩形截图窗口ScreenShotWindow" class="headerlink" title="矩形截图窗口ScreenShotWindow"></a>矩形截图窗口ScreenShotWindow</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> release.ocr.baidu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.AWTException;</span><br><span class="line"><span class="keyword">import</span> java.awt.Color;</span><br><span class="line"><span class="keyword">import</span> java.awt.Dimension;</span><br><span class="line"><span class="keyword">import</span> java.awt.Graphics;</span><br><span class="line"><span class="keyword">import</span> java.awt.Image;</span><br><span class="line"><span class="keyword">import</span> java.awt.Rectangle;</span><br><span class="line"><span class="keyword">import</span> java.awt.Robot;</span><br><span class="line"><span class="keyword">import</span> java.awt.Toolkit;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.MouseAdapter;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.MouseEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.MouseMotionAdapter;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.RescaleOp;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JButton;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFileChooser;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JWindow;</span><br><span class="line"><span class="keyword">import</span> javax.swing.filechooser.FileNameExtensionFilter;</span><br><span class="line"><span class="keyword">import</span> javax.swing.filechooser.FileSystemView;</span><br><span class="line"><span class="keyword">import</span> com.melloware.jintellitype.HotkeyListener;</span><br><span class="line"><span class="keyword">import</span> com.melloware.jintellitype.JIntellitype;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 截图矩形窗口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScreenShotWindow</span> <span class="keyword">extends</span> <span class="title">JWindow</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> orgx, orgy, endx, endy;</span><br><span class="line"><span class="keyword">private</span> BufferedImage image = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> BufferedImage tempImage = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> BufferedImage saveImage = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> ToolsWindow tools = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 热键相关设置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"><span class="comment">// 定义热键标识，用于在设置多个热键时，在事件处理中区分用户按下的热键</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FUNC_KEY_MARK = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXIT_KEY_MARK = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScreenShotWindow</span><span class="params">()</span> <span class="keyword">throws</span> AWTException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">createScreenCapture();</span><br><span class="line"><span class="comment">// 设置鼠标监听事件</span></span><br><span class="line"><span class="keyword">this</span>.addMouseListener(<span class="keyword">new</span> MouseAdapter()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 鼠标按下</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mousePressed</span><span class="params">(MouseEvent e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 鼠标按下时，表明截屏开始，记录结束点坐标，并隐藏操作窗口</span></span><br><span class="line">orgx = e.getX();</span><br><span class="line">orgy = e.getY();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tools != <span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 截图的时候隐藏窗口</span></span><br><span class="line">tools.setVisible(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 鼠标松开</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseReleased</span><span class="params">(MouseEvent e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 鼠标松开时，说明截屏结束，显示操作窗口</span></span><br><span class="line"><span class="keyword">if</span> (tools == <span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">tools = <span class="keyword">new</span> ToolsWindow(ScreenShotWindow.<span class="keyword">this</span>, e.getX(),</span><br><span class="line">e.getY());</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">tools.setVisible(<span class="keyword">false</span>);</span><br><span class="line">tools.setLocation(e.getX(), e.getY());</span><br><span class="line">&#125;</span><br><span class="line">tools.setVisible(<span class="keyword">true</span>);</span><br><span class="line">tools.toFront();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标移动和拖动监听事件处理函数</span></span><br><span class="line"><span class="keyword">this</span>.addMouseMotionListener(<span class="keyword">new</span> MouseMotionAdapter()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseDragged</span><span class="params">(MouseEvent e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 鼠标拖动时，记录坐标并重绘窗口</span></span><br><span class="line">endx = e.getX();</span><br><span class="line">endy = e.getY();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 临时图像，用于缓冲屏幕区域放置屏幕闪烁</span></span><br><span class="line">Image tempImage2 = createImage(ScreenShotWindow.<span class="keyword">this</span>.getWidth(),</span><br><span class="line">ScreenShotWindow.<span class="keyword">this</span>.getHeight());</span><br><span class="line">Graphics g = tempImage2.getGraphics();</span><br><span class="line">g.drawImage(tempImage, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">int</span> x = Math.min(orgx, endx);</span><br><span class="line"><span class="keyword">int</span> y = Math.min(orgy, endy);</span><br><span class="line"><span class="keyword">int</span> width = Math.abs(endx - orgx) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> height = Math.abs(endy - orgy) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 加上1防止width或height0</span></span><br><span class="line"><span class="comment">//设置截屏矩形边框的颜色</span></span><br><span class="line">g.setColor(Color.RED);</span><br><span class="line">g.drawRect(x - <span class="number">1</span>, y - <span class="number">1</span>, width + <span class="number">1</span>, height + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 减1加1都了防止图片矩形框覆盖掉</span></span><br><span class="line">saveImage = image.getSubimage(x, y, width, height);</span><br><span class="line">g.drawImage(saveImage, x, y, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">ScreenShotWindow.<span class="keyword">this</span>.getGraphics().drawImage(tempImage2, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">ScreenShotWindow.<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第2步：注册热键，第一个参数表示该热键的标识，第二个参数表示组合键，如果没有则为0，第三个参数为定义的主要热键</span></span><br><span class="line">JIntellitype.getInstance().registerHotKey(FUNC_KEY_MARK,</span><br><span class="line">JIntellitype.MOD_ALT, (<span class="keyword">int</span>) <span class="string">'W'</span>);</span><br><span class="line">JIntellitype.getInstance().registerHotKey(EXIT_KEY_MARK,</span><br><span class="line">JIntellitype.MOD_ALT, (<span class="keyword">int</span>) <span class="string">'Q'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第3步：添加热键监听器JIntellitype</span></span><br><span class="line">JIntellitype.getInstance().addHotKeyListener(<span class="keyword">new</span> HotkeyListener()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onHotKey</span><span class="params">(<span class="keyword">int</span> markCode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (markCode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 按下alt+w快捷键表示再次截屏</span></span><br><span class="line"><span class="keyword">case</span> FUNC_KEY_MARK :</span><br><span class="line"><span class="comment">// showMessage();</span></span><br><span class="line"><span class="comment">//ScreenShotOCR.visiable();</span></span><br><span class="line"><span class="comment">//再次截屏时,隐藏工具窗口</span></span><br><span class="line"><span class="keyword">if</span>(tools!=<span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">tools.setVisible(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重新截屏</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">createScreenCapture();</span><br><span class="line">&#125; <span class="keyword">catch</span> (AWTException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示窗口</span></span><br><span class="line">ScreenShotOCR.visiable();</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// alt+q快捷键表示退出程序</span></span><br><span class="line"><span class="keyword">case</span> EXIT_KEY_MARK :</span><br><span class="line">System.exit(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">// 构造函数结束</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 截取当前整个屏幕，并设置到图片字段image中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> AWTException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createScreenCapture</span><span class="params">()</span> <span class="keyword">throws</span> AWTException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 获取屏幕尺寸</span></span><br><span class="line">Dimension d = Toolkit.getDefaultToolkit().getScreenSize();</span><br><span class="line"><span class="comment">// 设置窗口显示大小</span></span><br><span class="line"><span class="keyword">this</span>.setBounds(<span class="number">0</span>, <span class="number">0</span>, d.width, d.height);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 截取整个屏幕</span></span><br><span class="line">Robot robot = <span class="keyword">new</span> Robot();</span><br><span class="line">image = robot</span><br><span class="line">.createScreenCapture(<span class="keyword">new</span> Rectangle(<span class="number">0</span>, <span class="number">0</span>, d.width, d.height));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他函数</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(Graphics g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">RescaleOp ro = <span class="keyword">new</span> RescaleOp(<span class="number">0.8f</span>, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">tempImage = ro.filter(image, <span class="keyword">null</span>);</span><br><span class="line">g.drawImage(tempImage, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 保存图像到文件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveImage</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">JFileChooser jfc = <span class="keyword">new</span> JFileChooser();</span><br><span class="line">jfc.setDialogTitle(<span class="string">"保存"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件过滤器，用户过滤可选择文件</span></span><br><span class="line">FileNameExtensionFilter filter = <span class="keyword">new</span> FileNameExtensionFilter(<span class="string">"PNG"</span>,</span><br><span class="line"><span class="string">"png"</span>);</span><br><span class="line">jfc.setFileFilter(filter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个默认文件（此文件会生成到桌面上）</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyymmddHHmmss"</span>);</span><br><span class="line">String fileName = sdf.format(<span class="keyword">new</span> Date());</span><br><span class="line">File filePath = FileSystemView.getFileSystemView().getHomeDirectory();</span><br><span class="line">File defaultFile = <span class="keyword">new</span> File(</span><br><span class="line">filePath + File.separator + fileName + <span class="string">".png"</span>);</span><br><span class="line">jfc.setSelectedFile(defaultFile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> flag = jfc.showSaveDialog(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> (flag == JFileChooser.APPROVE_OPTION)</span><br><span class="line">&#123;</span><br><span class="line">File file = jfc.getSelectedFile();</span><br><span class="line">String path = file.getPath();</span><br><span class="line"><span class="comment">// 检查文件后缀，放置用户忘记输入后缀或者输入不正确的后缀</span></span><br><span class="line"><span class="keyword">if</span> (!(path.endsWith(<span class="string">".png"</span>) || path.endsWith(<span class="string">".PNG"</span>)))</span><br><span class="line">&#123;</span><br><span class="line">path += <span class="string">".png"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line">ImageIO.write(saveImage, <span class="string">"png"</span>, <span class="keyword">new</span> File(path));</span><br><span class="line">System.exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用百度识图,传入按钮的引用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">baiduOCR</span><span class="params">(JButton baiduOCRButton)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line">ImageIO.write(saveImage, <span class="string">"png"</span>, <span class="keyword">new</span> File(<span class="string">"1.png"</span>));</span><br><span class="line"><span class="comment">//传入图片,当前窗口的引用，文字识别按钮的引用(改变颜色)</span></span><br><span class="line">Thread baiduOCR = <span class="keyword">new</span> Thread(</span><br><span class="line"><span class="keyword">new</span> BaiduOCR(<span class="string">"1.png"</span>, <span class="keyword">this</span>, baiduOCRButton));</span><br><span class="line">baiduOCR.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Exit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">System.exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面注册了快捷键(热键)，按下alt+w会重新截取屏幕，按下alt+q会退出程序。</p><h2 id="操作栏ToolsWindow"><a href="#操作栏ToolsWindow" class="headerlink" title="操作栏ToolsWindow"></a>操作栏ToolsWindow</h2><p>这个操作窗口会在截图结束的时候显示<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> release.ocr.baidu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.BorderLayout;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JButton;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JToolBar;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JWindow;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 操作窗口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToolsWindow</span> <span class="keyword">extends</span> <span class="title">JWindow</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">private</span> ScreenShotWindow parent;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ToolsWindow</span><span class="params">(ScreenShotWindow parent, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.parent = parent;</span><br><span class="line"><span class="keyword">this</span>.init();</span><br><span class="line"><span class="keyword">this</span>.setLocation(x, y);</span><br><span class="line"><span class="keyword">this</span>.pack();</span><br><span class="line"><span class="keyword">this</span>.setVisible(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.setLayout(<span class="keyword">new</span> BorderLayout());</span><br><span class="line">JToolBar toolBar = <span class="keyword">new</span> JToolBar(<span class="string">"Java 截图"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存按钮</span></span><br><span class="line">JButton saveButton = <span class="keyword">new</span> JButton(<span class="string">"保存"</span>);</span><br><span class="line">saveButton.addActionListener(<span class="keyword">new</span> ActionListener()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 保存截图</span></span><br><span class="line">parent.saveImage();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e1)</span><br><span class="line">&#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">toolBar.add(saveButton);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 百度识图按钮</span></span><br><span class="line">JButton baiduOCRButton = <span class="keyword">new</span> JButton(<span class="string">"文字识别"</span>);</span><br><span class="line">baiduOCRButton.addActionListener(<span class="keyword">new</span> ActionListener()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 保存截图</span></span><br><span class="line">parent.baiduOCR(baiduOCRButton);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e1)</span><br><span class="line">&#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">toolBar.add(baiduOCRButton);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭按钮</span></span><br><span class="line">JButton closeButton = <span class="keyword">new</span> JButton(<span class="string">"退出"</span>);</span><br><span class="line">closeButton.addActionListener(<span class="keyword">new</span> ActionListener()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">System.exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">toolBar.add(closeButton);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.add(toolBar, BorderLayout.NORTH);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="百度文字识别类-BaiduOCR"><a href="#百度文字识别类-BaiduOCR" class="headerlink" title="百度文字识别类:BaiduOCR"></a>百度文字识别类:BaiduOCR</h2><ul><li>APP_ID</li><li>API_KEY</li><li>SECRET_KEY<br>这三个要到百度文字网页去获取，注册，然后创建文字识别应用。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> release.ocr.baidu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.Color;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JButton;</span><br><span class="line"><span class="keyword">import</span> org.json.JSONObject;</span><br><span class="line"><span class="keyword">import</span> com.baidu.aip.ocr.AipOcr;</span><br><span class="line"><span class="keyword">import</span> clipboard.util.SysClipboardUtil;</span><br><span class="line"><span class="keyword">import</span> net.sf.json.JSONArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaiduOCR</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="comment">// 设置APPID/AK/SK</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String APP_ID = <span class="string">"你的APP_ID"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String API_KEY = <span class="string">"你的API_KEY"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SECRET_KEY = <span class="string">"你的SECRET_KEY"</span>;</span><br><span class="line"><span class="comment">//窗体引用</span></span><br><span class="line">ScreenShotWindow screenShotWindow;</span><br><span class="line"><span class="comment">//设置按钮颜色</span></span><br><span class="line">JButton baiduOCRButton;</span><br><span class="line"><span class="comment">//文件路径</span></span><br><span class="line">String path;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BaiduOCR</span><span class="params">(String path,ScreenShotWindow screenShotWindow,JButton baiduOCRButton)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.path=path;</span><br><span class="line"><span class="keyword">this</span>.screenShotWindow=screenShotWindow;</span><br><span class="line"><span class="keyword">this</span>.baiduOCRButton=baiduOCRButton;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//设置按钮颜色，表示开始处理</span></span><br><span class="line">baiduOCRButton.setBackground(Color.pink);</span><br><span class="line"><span class="comment">//让窗体不可见</span></span><br><span class="line">ScreenShotOCR.notVisible();</span><br><span class="line"><span class="comment">//调用百度文字识别接口</span></span><br><span class="line">baiduOCR(path);</span><br><span class="line"><span class="comment">//再次调用,改变窗体的显示。让用户知道处理结束了。</span></span><br><span class="line"><span class="comment">//ScreenShotOCR.visiable();</span></span><br><span class="line"><span class="comment">//回调函数，执行完毕后关闭程序</span></span><br><span class="line"><span class="comment">//ScreenShotWindow.Exit();</span></span><br><span class="line"><span class="comment">//改变按钮颜色，表示处理结束</span></span><br><span class="line">baiduOCRButton.setBackground(Color.WHITE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**   </span></span><br><span class="line"><span class="comment"> * 调用百度文字识别</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">baiduOCR</span><span class="params">(String path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 初始化一个AipOcr</span></span><br><span class="line">AipOcr client = <span class="keyword">new</span> AipOcr(APP_ID, API_KEY, SECRET_KEY);</span><br><span class="line"><span class="comment">// 可选：设置网络连接参数</span></span><br><span class="line">client.setConnectionTimeoutInMillis(<span class="number">2000</span>);</span><br><span class="line">client.setSocketTimeoutInMillis(<span class="number">60000</span>);</span><br><span class="line"><span class="comment">// 调用接口</span></span><br><span class="line">JSONObject res = client.basicGeneral(path,</span><br><span class="line"><span class="keyword">new</span> HashMap&lt;String, String&gt;());</span><br><span class="line">String text = res.toString(<span class="number">2</span>);</span><br><span class="line">HashMap&lt;String, Object&gt; resMap = (HashMap&lt;String, Object&gt;) res.toMap();</span><br><span class="line"><span class="comment">// 第二种：</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; it = resMap.entrySet().iterator();</span><br><span class="line"><span class="comment">// 缓冲，用来存储识别结果</span></span><br><span class="line">StringBuilder sbBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">Map.Entry&lt;String, Object&gt; entry;</span><br><span class="line"><span class="keyword">while</span> (it.hasNext())</span><br><span class="line">&#123;</span><br><span class="line">entry = it.next();</span><br><span class="line"><span class="keyword">if</span> (entry.getKey().equals(<span class="string">"words_result"</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 获取词组</span></span><br><span class="line">JSONArray jsonArray = JSONArray.fromObject(entry.getValue());</span><br><span class="line">System.out.println(jsonArray.toString());</span><br><span class="line"><span class="keyword">for</span> (Object object : jsonArray)</span><br><span class="line">&#123;</span><br><span class="line">sbBuilder.append(object.toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">String words = sbBuilder.toString();</span><br><span class="line">words = words.replaceAll(<span class="string">"(?:(?:\\\"\\&#125;)?\\&#123;\\\"words\\\":\\\"|\\\"\\&#125;)"</span>, <span class="string">""</span>);</span><br><span class="line">SysClipboardUtil.setSysClipboardText(words);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>本文链接: <a href="https://www.lansheng.net.cn/blog/3640dbe/">我的截图百度文字识别工具</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 我的软件 </category>
          
          <category> 百度文字识别 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java网络编程第4版 死锁</title>
      <link href="/blog/83a775f/"/>
      <url>/blog/83a775f/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><p><strong>同步会导致另一个可能的问题:死锁( deadlock)</strong>。<strong>如果两个线程需要独占访问同样的资源集,而每个线程分别有这些资源的不同子集的锁,就会发生死锁。</strong>如果两个线程都不愿意放弃已经拥有的资源,就会进入无限停止状态。在一般意义上讲,这不完全是挂起,因为从操作系统角度看,程序仍然是活动的,行为也是正常的,但对于用户而言。这与挂起没有什么区别。</p><p>再来看图书馆的例子,在下面这种情况下会发生死锁:Jack和Jill都要撰写关于托马斯·杰斐逊的学期论文,他们都需要两本书《 Thomas Jefferson and Sally Hemings: An AmericanControversy)和《Sally Hemings and Thomas Jefferson: History, Memory and CivicCulture》<code>。如果Jill经借到了第一本,而Jack借到了第二本,倘若他们都不愿意放弃已经借到的书,那么都将无法完成论文。最终截止日期到了,他们都得到一个F。这就是死锁问题。</code>(注:这真是一个有趣的问题)</p><p>更糟糕的是,死锁可能是偶发性的bug,很难检测。死锁通常取决于不可预知的时间问题。大多数情况下,Jack或Jill会首先到达图书馆,把两本书都借到。这种情况下,先拿到书的人撰写好论文,再归还这两本书,然后另一个人拿到书并撰写论文。只有在极少情况下他们会同时到达,每人拿到其中一本书。100次里有99次,或者1000次里有999次,程序都能完全正常地运行。只有在极少情况下会毫无征兆地挂起。当然,<strong>如果一个多线程服务器每分钟处理成百上千个请求,即使每百万个请求才发生一次问题,也会迅速地让服务器挂起。</strong></p><p><strong>要防止死锁,最重要的技术是避免不必要的同步</strong>。<strong>如果有其他方法可以确保线程安全,比如<code>让对象不可变或保存对象的一个局部副本</code>,<code>就最好使用那种方法(而不是同步</code>)</strong>。<strong><code>同步应当是确保线程安全的最后一道防线</code>。<code>如果确实需要同步,要保持同步块尽可能小</code>,而且尽量不要一次同步多个对象</strong>。但这可能很困难,因为你的代码会调用Java类库的很多方法,这些方法可能会在你不知情的情况下同步一些对象。因此,实际同步的对象可能比你预想的要多得多。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/83a775f/">java网络编程第4版 死锁</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第3章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java设置全局热键——第三方包jintellitype实现</title>
      <link href="/blog/f91e74b/"/>
      <url>/blog/f91e74b/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>Java原生API并不支持为应用程序设置全局热键。要实现全局热键，需要用JNI方式实现，这就涉及到编写C/C++代码，这对于大多数不熟悉C/C++的javaer来说，有点困难。不过幸好，国外有人已经实现了，发布成第三方java包，借此，我们可以很方便的设置全局热键而不用编写任何C/C++代码。</p><p>jintellitype由两部分组成，一部分是java写的jintellityp的jar文件，另一部分是C/C++写的已编译好的dll文件，有两个dll文件，分别是32位和64位系统的。在我使用jintellitype的过程中，把jintellitype的jar文件Build进项目后，不知道dll文件放哪，我试着运行，根据错误提示，原来需要把dll文件放到项目com.melloware.jintellitype包下。建议同时把两个dll文件都加进去，这样，你的程序就可以同时兼容32位和64位系统，而你不需要任何额外的处理。</p><h2 id="使用jintellitype的步骤"><a href="#使用jintellitype的步骤" class="headerlink" title="使用jintellitype的步骤"></a>使用jintellitype的步骤</h2><p>所以，使用jintellitype的步骤为：</p><ul><li>下载jintellitype，解压压缩包。<ul><li>JIntellitype官方下载：<a href="http://melloware.com" target="_blank" rel="noopener">http://melloware.com</a><ul><li>在官网首页中找到<code>JIntellitype</code>，然后点进去(需要科学上网)。</li><li>在Downloads页面中下载最新的版本(<a href="https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/jintellitype/jintellitype-1.3.9-dist.zip" target="_blank" rel="noopener">https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/jintellitype/jintellitype-1.3.9-dist.zip</a>)。</li><li>下载后解压就行了。</li></ul></li><li>下载地址2：<a href="http://mvnrepository.com/artifact/com.melloware/jintellitype/1.3.9" target="_blank" rel="noopener">http://mvnrepository.com/artifact/com.melloware/jintellitype/1.3.9</a>。这个网站可以下载到jar包，好像没能下载到<code>JIntellitype.dll</code>和<code>JIntellitype64.dll</code>,还是使用上面的方法吧。</li></ul></li><li>在你的Java项目中新建一个包(package)：com.melloware.jintellitype</li><li>把解压到的两个dll文件(<code>JIntellitype.dll</code>和<code>JIntellitype64.dll</code>)放到你的Java项目中的com.melloware.jintellitype中</li><li>Eclipse中的Buildpath中引入jintellitype.jar<br>完成上面的步骤后就可以使用热键来控制程序了。</li></ul><a id="more"></a><p>实例：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.Insets;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JButton;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JOptionPane;</span><br><span class="line"><span class="keyword">import</span> com.melloware.jintellitype.HotkeyListener;</span><br><span class="line"><span class="keyword">import</span> com.melloware.jintellitype.JIntellitype;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用JIntellitype实现全局热键设置</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Jeby Sun</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobleHotKeyDemo</span> <span class="keyword">extends</span> <span class="title">JFrame</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义热键标识，用于在设置多个热键时，在事件处理中区分用户按下的热键</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FUNC_KEY_MARK = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXIT_KEY_MARK = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">JButton msgBtn;</span><br><span class="line">JButton exitBtn;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">GlobleHotKeyDemo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.setTitle(<span class="string">"全局热键设置"</span>);</span><br><span class="line"><span class="keyword">this</span>.setBounds(<span class="number">100</span>, <span class="number">100</span>, <span class="number">600</span>, <span class="number">400</span>);</span><br><span class="line"><span class="keyword">this</span>.setLayout(<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">this</span>.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">msgBtn = <span class="keyword">new</span> JButton(<span class="string">"弹出框（Alt+S）"</span>);</span><br><span class="line"><span class="comment">// 设置按钮边距</span></span><br><span class="line">msgBtn.setMargin(<span class="keyword">new</span> Insets(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">msgBtn.setFocusable(<span class="keyword">false</span>);</span><br><span class="line">msgBtn.setBounds(<span class="number">20</span>, <span class="number">20</span>, <span class="number">120</span>, <span class="number">30</span>);</span><br><span class="line">msgBtn.addActionListener(<span class="keyword">new</span> ActionListener()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">showMessage();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">this</span>.add(msgBtn);</span><br><span class="line"></span><br><span class="line">exitBtn = <span class="keyword">new</span> JButton(<span class="string">"退出（Alt+Q）"</span>);</span><br><span class="line">exitBtn.setMargin(<span class="keyword">new</span> Insets(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">exitBtn.setFocusable(<span class="keyword">false</span>);</span><br><span class="line">exitBtn.setBounds(<span class="number">160</span>, <span class="number">20</span>, <span class="number">120</span>, <span class="number">30</span>);</span><br><span class="line">exitBtn.addActionListener(<span class="keyword">new</span> ActionListener()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">System.exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">this</span>.add(exitBtn);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一步：注册热键，第一个参数表示该热键的标识，第二个参数表示组合键，如果没有则为0，第三个参数为定义的主要热键</span></span><br><span class="line">JIntellitype.getInstance().registerHotKey(FUNC_KEY_MARK,</span><br><span class="line">JIntellitype.MOD_ALT, (<span class="keyword">int</span>) <span class="string">'S'</span>);</span><br><span class="line">JIntellitype.getInstance().registerHotKey(EXIT_KEY_MARK,</span><br><span class="line">JIntellitype.MOD_ALT, (<span class="keyword">int</span>) <span class="string">'Q'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步：添加热键监听器</span></span><br><span class="line">JIntellitype.getInstance().addHotKeyListener(<span class="keyword">new</span> HotkeyListener()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onHotKey</span><span class="params">(<span class="keyword">int</span> markCode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (markCode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> FUNC_KEY_MARK :</span><br><span class="line">showMessage();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EXIT_KEY_MARK :</span><br><span class="line">System.exit(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.setVisible(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">JOptionPane.showMessageDialog(<span class="keyword">null</span>, <span class="string">"就算把窗口最小化，按快捷键Alt+S也可以弹出提示框哦！"</span>,</span><br><span class="line"><span class="string">"弹出框标题"</span>, JOptionPane.INFORMATION_MESSAGE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">new</span> GlobleHotKeyDemo();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>其实，jintellitype的使用非常简单，就3个步骤：<br>第一步：添加jar包和dll文件；<br>第二步：注册热键；<br>第三步：添加热键监听器，实现接口的方法；<br>参考：<a href="https://www.cnblogs.com/jebysun/p/3969363.html" target="_blank" rel="noopener">https://www.cnblogs.com/jebysun/p/3969363.html</a></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/f91e74b/">Java设置全局热键——第三方包jintellitype实现</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> java_GUI </category>
          
          <category> 全局热键 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java网络编程第4版 同步的替代方式</title>
      <link href="/blog/8076ac29/"/>
      <url>/blog/8076ac29/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><p>对于由线程调度引起的不一致的行为,同步并不总是这个问题最好的解决方案。还有很多技术可以完全避免使用同步。<code>第一个方法是,在可能的情况下,要使用局部变量而不是字段</code>。<code>局部变量不存在同步问题</code>。每次进入一个方法时,虚拟机将为这个方法创建一组全新的局部变量。这些变量在方法外部是不可见的,而且方法退出时将被撤销。因此,<code>一个局部变量不可能由两个不同的线程共享。每个线程都有自己单独的一组局部变量</code>。</p><p><strong>基本类型的方法参数也可以在单独的线程中安全地修改</strong>,因为<code>Java按值而不是按引用来传递参数</code>。以此推断,像Math,sqrt()等纯函数只取0个或多个基本类型参数,完成一些计算,并返回一个值,而<code>不与任何类的字段交互,这些函数自然就是线程安全的</code>。这些方法通常声明为静态方法或者应当声明为静态方法。</p><p>对象类型的方法参数有些麻烦,<code>因为按值传递的实际参数是对象的引用</code>。例如,假设将个数组的引用传入sort()方法。当这个方法对数组排序时,<code>没有办法阻止同样拥有这个数组引用的其他线程修改数组中的值</code>。<br><code>String参数是安全的,因为它们是不可变( immutable)的</code>(也就是说,<code>一旦创建了一个String对象,它就不能被任何线程修改</code>)。<strong>不可变对象永远也不会改变状态</strong>。其字段的值只在构造函数运行时设置一次,其后就不会再改变。 StringBuffer参数是不安全的,因为它们并不是不可变的,在创建后还可以修改。</p><p><strong>构造函数一般不需要担心线程安全问题</strong>。<code>在构造函数返回前,没有线程有这个对象的引用,所以不可能有两个线程都有这个对象的引用</code>(最有可能的问题是构造函数依赖于另一个线程中的另一个对象,这个对象可能在构造函数运行时改变,但这种情况并不常见。另外,如果构造函数以某种方式把它正在创建的对象的引用传递给一个不同的线程,也有可能出现问题,但这种情况也不常见)。</p><p>你可以在自己的类中利用不可变性。要使一个类做到线程安全,这往往是最简单的方法,通常会比确定哪些方法或代码段要进行同步容易得多。<code>要使一个对象不可变,只要将其所有字段声明为 private(私有)和 final(最终),而且不要编写任何可能改变它们的方法</code>。核心Java库中的很多类都是不可变的(如 java.lang.String、java.lang.Integer、java.lang.Double等)。这使得这些类在某些方面用处不大,但的确能让它们有更强的线程安全性。</p><p>第三种技术是<strong>将非线程安全的类用<code>作为线程安全的类的一个私有字段</code></strong>。<strong>只要包含类只以线程安全的方式访问这个非安全类,而且只要永远不让这个私有字段的引用泄漏到另一个对象中,那么这个类就是安全的</strong>。这个技术的一个例子就是Web服务器可能使用非同步的 LogFile类,但是<code>为每个单独的线程提供它自己单独的日志</code>,这样各个线程之间就不会有共享的资源。</p><p>有些情况下,你可以使用 java.util.concurrent.atomic包中特意设计为<strong><code>保证线程安全</code>但<code>可变的类</code></strong>。具体来讲,可以<code>不使用int而使用 AtomicInteger</code>。不使用long而使用 AtomicLong。不使用 boolean而使用 AtomicBoolean。不使用int[]而使用AtomicIntegerArray。<code>不使用引用变量,而是把对象存储在一个 AtomicReference中</code>,不过需要说明,这<code>不会让对象本身也是线程安全的,只是该引用变量的获取和设置是线程安全的</code>。如果可以利用现代CPU上快速的机器级线程安全指令,这些类可能比其相应基本类型的同步访问快得多。</p><p><strong>对于映射和列表等集合,可以使用java.util.Collections的方法把它们<code>包装在一个线程安全的版本</code>中</strong>。例如,如果有一个集合foo,可以用 Collections.synchronizedSet(foo)得到这个集合的一个线程安全视图。如果有一个列表foo,可以使用Collections.synchronizedList(foo)来得到它的线程安全视图。对于映射,需要调用Collections.synchronizedMap(foo)等。为了能正常工作,在此之后必须只使用Collections.synchronizedSet/List/Map返回的视图。如果偶尔访问了原来的底层数据结构,那么不论是原来的数据结构还是同步视图都无法做到线程安全。</p><p>不管怎样,要认识到这只是单个的原子方法调用。<strong>如果需要作为一个原子连续地完成两个操作,中间不能有中断,就需要同步</strong>。因此,举例来说,即使一个列表通过Collections.synchronizedList()同步,如果希望迭代处理这个列表,仍然需要对它同步,因为这可能涉及很多连续的原子操作。尽管每个方法调用确实是原子的,可以保证安全,但是如果没有明确的同步,这个操作序列并不一定安全。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/8076ac29/">java网络编程第4版 同步的替代方式</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第3章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java网络编程第4版 同步方法</title>
      <link href="/blog/ea28a41c/"/>
      <url>/blog/ea28a41c/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><p>由于对对象本身同步整个方法体是很常见的,所以Java为此提供了一个快捷方式。可以通过向方法声明添加 synchronized修饰符,对当前对象(this引用)同步整个方法。例如：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writeEntry</span><span class="params">(String message)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Date d=<span class="keyword">new</span> Date();</span><br><span class="line">    out.write(d.toString());</span><br><span class="line">    out.write(<span class="string">'\t'</span>);</span><br><span class="line">    out.write(message);</span><br><span class="line">    out.write(<span class="string">"\r\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>对于同步问题,仅仅向所有方法添加 synchronized修饰符并不是一劳永逸的解决方案</strong>。首先,它使得很多VM的性能严重下降(不过在这方面更多最新的VM已经大为改进),<code>可能会使代码速度降低</code>三分之一或者更多。<code>其次,它大大增加了死锁的可能性</code>。第三,也是最重要的,<strong>并不总是对象本身需要防止同时修改或访问,<code>如果只是对该方法所属类的实例进行同步,可能并不能保护真正需要保护的对象</code></strong>。例如,在这个例子中,我们真正要避兔的是两个线程同时写入out。如果其他类有与 LogFile完全无关的out的引用,这些写入就会失败。不过在这个例子中,同步LogFile对象就足够了,因为out是一个私有实例变量。由于不会提供这个对象的引用,除非通过 LogFile类,否则其他对象没有办法调用这个对象。因此,在这里同步 LogFile对象与同步out有同样的效果。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/ea28a41c/">java网络编程第4版 同步方法</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第3章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java网络编程第4版 同步块</title>
      <link href="/blog/3c8d711/"/>
      <url>/blog/3c8d711/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><p>为了指示这5行代码应当一起执行,要把它们包围在一个synchronized块中,它会对System.out对象同步,如下所示:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(System.out)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.print(input+<span class="string">": "</span>);</span><br><span class="line">    System.out.print(DatatypeConverter.printHexBinary(digest));</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>一旦线程开始打印这些值,所有其他线程在打印它们的值之前就必须停止,需要等待这个线程结束。<strong>同步要求在同一个对象上同步的所有代码要串行地运行,而不能并行运行</strong>。例如,如果另一个不同的类和不同进程中的代码恰好也对System.out同步,那么它也不能与这个代码块并行运行。不过,对不同对象同步的代码或者根本不同步的代码仍可以与这个代码并行运行。即使它使用了 System. out也可以这么做。<strong>Java没有提供任何方法来阻止其他线程使用共享资源。它只能防止对同一个对象同步的其他线程使用这个共享资源</strong>。</p><hr><p>提示:事实上, Printstream类在内部要求大多数方法都对 Printstream对象同步(如这个例子中的 System.out)。换句话说,<code>调用System.out.println()的其他各个线程都会对System.out同步</code>,而且必须等待这个代码结束。从这个方面来看, Printstream很独特。大多数其他Outputstream子类都不会自行同步。</p><hr><p><strong>只要有多个线程共享资源,都必须考虑同步</strong>。这些线程可能是相同 Thread子类的实例,或者使用了相同的 Runnable类,也可能是完全不同的类的实例。<strong>关键在于这些线程所共享的资源,而不是这些线程是哪个类。<code>只有当两个线程都拥有相同对象的引用时,同步才成为问题</code></strong>。在前面的例子中,问题就在于多个线程都访问同一个 Printstream对象System.out。在这种情况下,导致冲突的是一个静态类变量。不过,实例对象也会有问题。</p><p>例如,假设你的Web服务器保存了一个日志文件。这个日志文件可能用示例3-11中的类来表示。这个类本身不使用多线程。不过,<strong>如果web服务器<code>使用多线程处理入站连接,那么每个线程都需要访问相同的日志文件</code>,因而会访问相同的 LogFile对象</strong>。</p><h3 id="示例3-11-LogFile"><a href="#示例3-11-LogFile" class="headerlink" title="示例3-11: LogFile"></a>示例3-11: LogFile</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogFile</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Writer out;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogFile</span><span class="params">(File f)</span> <span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(f);</span><br><span class="line">        <span class="keyword">this</span>.out = <span class="keyword">new</span> BufferedWriter(fw);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeEntry</span><span class="params">(String message)</span> <span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Date d = <span class="keyword">new</span> Date();</span><br><span class="line">        out.write(d.toString());</span><br><span class="line">        out.write(<span class="string">'\t'</span>);</span><br><span class="line">        out.write(message);</span><br><span class="line">        out.write(<span class="string">"\r\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个类中, writeEntry()方法获得当前日期和时间,然后使用四个单独的out.write()调用写入底层文件。<strong>如果两个或多个线程都有同一个 LogFile对象的引用,而且一个线程在写数据的过程中被另一个线程打断,这就会出现问题</strong>。一个线程可能写入了日期和个tab(制表符),然后下一个线程可能写入三个完整的记录。然后,第一个线程再写入消息、回车和换行。<code>解决这个问题的方法还是同步</code>。不过,在这个例子中,要对哪个对象同步呢?对此有两个很好的选择。第一种选择是对 Writer对象out同步。例如:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeEntry</span><span class="params">(String message)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    synchroized(out)</span><br><span class="line">    &#123;</span><br><span class="line">        Date d=<span class="keyword">new</span> Date();</span><br><span class="line">        out.write(d.toString());</span><br><span class="line">        out.write(<span class="string">'\t'</span>);</span><br><span class="line">        out.write(message);</span><br><span class="line">        out.writer(<span class="string">"\r\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这样就能正常工作了,这是因为所有使用这个 LogFile对象的线程也会使用属于这个LogFile的同一个out对象。out是私有的,这并没有关系。虽然它会由其他线程和对象使用,但只会在 LogFile类中引用。此外,虽然在这里是对out对象同步,但需要保护不被中断的是writeEntry()方法。 <code>Writer类都有自己的内部同步,这会防止一个线程中断另一个线程中的 write()方法</code>(对于输入和输出流则并非如此<code>,只有 Printstream有所例外。写一个输出流时有可能被另一个线程中断</code>)。每个 Writer都有一个lock字段,指示书写器要对所写的哪个对象同步。<br>第二种可能性是对 LogFile对象本身同步。这很简单,只要用到this关键词。例如:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeEntry</span><span class="params">(String message)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Date d=<span class="keyword">new</span> Date();</span><br><span class="line">        out.write(d.toString());</span><br><span class="line">        out.write(<span class="string">'\t'</span>);</span><br><span class="line">        out.write(message);</span><br><span class="line">        out.write(<span class="string">"\r\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/3c8d711/">java网络编程第4版 同步块</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第3章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java网络编程第4版 同步</title>
      <link href="/blog/83389788/"/>
      <url>/blog/83389788/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><p>我的书架上堆满了书,包括很多一样的书,过时的书,以及10年里我从没看过、可能将来也不会再看的书。这些年来,为了购置这些书,花了我上万美元,甚至更多。不过,离我的公寓两个街区就有一个中心布鲁克林公共图书馆,那里的书架上也堆满了书。100多年来,这个图书馆为其收藏花费了上百万美元。但区别在于它的书由布鲁克林的居民所共享,因此这些书有很高的利用率。所收藏的大多数书一年会使用很多次。虽然公共图书馆在买书和存书方面比我花的钱多很多,<strong>但图书馆阅读每页书的成本却比我的个人书架要低很多。这正是共享资源的优点。</strong></p><p>当然,共享资源也有缺点。如果我需要图书馆的一本书,我必须走到图书馆,还要在书架上寻找我需要的书。我必须排队办手续拿到这本书,或者我只能在图书馆看这本书而不能带回家。有时候,别人已经借走了这本书,我就必须填写预约单,申请这本书归还时能为我保留。另外我不能在书边上写笔记,不能对段落做标记,也不能撕下几页粘在我的公告牌上(唔,也许我可以这样做,但是如果这样做了,就会大大地降低这本书对于将来其他借阅者的用处:如果图书馆抓到了我,我可能会失去借阅资格)。<strong>从图书馆借书而不是自己买一本,在时间和方便性上会有很大的损失,但能够节约钱和存储空间</strong>。</p><p><strong>线程就像是图书馆的借阅者</strong>,它从一个中心资源池中借阅。<strong>线程通过共享内存、文件句柄、 socket和其他资源使得程序更高效</strong>。<code>只要两个线程不同时使用相同的资源,多线程的程序就比多进程程序高效得多</code>,在多进程程序中,每个进程都要为各个资源维护自己的副本。<code>多线程程序的缺点是,如果两个线程同时访问同一个资源,其中一个就必须等待另一个结東。</code>如果其中一个没有等待,资源就可能被破坏。</p><p>让我们看一个特定的例子。考虑示例3-1和示例3-2中的run()方法。如前所述,这个方法把结果建立为一个String,然后使用一个 System.out.println()调用将这个 String在控制台打印出来。输出如下<br><img src="http://pefsyzdwh.bkt.clouddn.com/18-9-13/67781906.jpg" alt=""><br>四个线程并行地运行,生成了这个输出。<strong>每个线程向控制台写入一行。写入这些行的顺序是不可预见的,因为线程的调度不可预知</strong>,但每一行会作为一个整体写入。不过,假如使用这个run()方法的另一个版本,不是将中间结果存储在 String变量 result中,而是当这些中间结果可用时就直接显示在控制台上:</p><p>不同文件的摘要都混在了一起!无法区分哪个数字属于哪个摘要。很明显,这是个很大的问题。</p><p>出现这种混乱的原因在于, <strong>System.out由4个不同的线程共享</strong>。<strong>如果一个线程通过多个System.out.print()语句向控制台写输出,有可能它还没有完成所有写入,就有另一个线程插进来,开始写它的输出。</strong>哪个线程会抢先于其他线程,这个具体顺序无法确定每次运行这个程序时,你都可能会看到稍有不同的输出。</p><p>需要有一种办法能够<strong>指定一个共享资源只能由一个线程独占访问来执行一个特定的语句序列</strong>。在这个例子中,共享资源是 System.out,需要独占访问的语句是:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.print(input+<span class="string">": "</span>);</span><br><span class="line">System.out.print(DatatypeConverter.printHexBinary(digest));</span><br><span class="line">System.out.println();</span><br></pre></td></tr></table></figure><p></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/&#39;83389788&#39;/">java网络编程第4版 同步</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第3章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java网络编程第4版 Future,Callable和Executor</title>
      <link href="/blog/8f04ec78/"/>
      <url>/blog/8f04ec78/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><p>Java5引入了多线程编程的一个新方法,通过隐藏细节可以更容易地处理回调。不再是直接创建一个线程,你要创建一个 Executorservice,它会根据需要为你创建线程。可以向 ExecutorService提交Ca11able任务,对于每个Ca11ab1e任务,会分别得到一个Future。之后可以向 Future请求得到任务的结果。如果结果已经准备就绪,就会立即得到这个结果。如果还没有准备好,轮询线程会阻塞,直到结果准备就绪。这种做法的好处是,你可以创建很多不同的线程,然后按你需要的顺序得到你需要的答案。</p><p>例如,假设你要找出一个很大的数字数组中的最大值。如果采用最原始的方法实现,需要的时间为O(n),其中n是数组中的元素个数。不过,如果可以将这个工作分解到多个线程,每个线程分别在一个单独的内核上运行,这样就会快得多。为了便于说明,下面假设需要两个线程。</p><p>Callable接口定义了一个call()方法,它可以返回任意的类型。示例3-9是一个Callable,它会采用最明显的方式查找数组的一个分段中的最大值。</p><h3 id="示例3-9-FindMaxTask"><a href="#示例3-9-FindMaxTask" class="headerlink" title="示例3-9: FindMaxTask"></a>示例3-9: FindMaxTask</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FindMaxTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">    FindMaxTask(<span class="keyword">int</span>[] data, <span class="keyword">int</span> start, <span class="keyword">int</span> end) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//记录最大值</span></span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//记录下最大的值</span></span><br><span class="line">            <span class="keyword">if</span> (data[i] &gt; max) max = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管可以直接调用call()方法,但这并不是它的本来目的。实际上,你要把Callable对象提交给一个 Executor,它会为每个Callable对象创建一个线程( Executor还可以使用其他策略,例如,它可以使用一个线程按顺序调用这些 callable,不过对于这个问题来说,每个 callable分别对应一个线程是一个很好的策略)。如示例3-10所示。</p><h3 id="示例3-10-MultithreadedMaxFinder"><a href="#示例3-10-MultithreadedMaxFinder" class="headerlink" title="示例3-10: MultithreadedMaxFinder"></a>示例3-10: MultithreadedMaxFinder</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultithreadedMaxFinder</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span>[] data)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data.length == <span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> data[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//      split      the      job      into      2      pieces</span></span><br><span class="line">        FindMaxTask task1 = <span class="keyword">new</span> FindMaxTask(data, <span class="number">0</span>, data.length/<span class="number">2</span>);</span><br><span class="line">        FindMaxTask task2 = <span class="keyword">new</span> FindMaxTask(data, data.length/<span class="number">2</span>, data.length);</span><br><span class="line"><span class="comment">//      spawn      2      threads</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        Future&lt;Integer&gt; future1 = service.submit(task1);</span><br><span class="line">        Future&lt;Integer&gt; future2 = service.submit(task2);</span><br><span class="line">        <span class="keyword">return</span> Math.max(future1.get(), future2.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会同时搜索这两个子数组,所以对于合适的硬件和规模很大的输入,这个程序运行的速度几乎可以达到原来的两倍。不仅如此,与先找出数组前一半的最大值再找出数组后一半的最大值的做法相比,这个代码几乎同样简单和直接,而不用担心线程或异步性。不过,这里有一个重要的区别。在示例3-10的最后一个语句中,调用 future1.get()时,这个方法会阻塞,等待第一个 FindMaxTask完成。只有当第一个 FindMaxTask完成时,才会调用 future2.get()。也有可能第二个线程已经结束,在这种情况下,结果值会直接返回,但是如果第二个线程还没有结束,同样的,也会等待这个线程完成。<code>一旦两个线程都结束,将比较它们的结果,并返回最大值</code>。(思想就是，用了两个线程来实现，第一个线程)</p><p>Future是一种非常方便的做法,可以<strong>启动多个线程来处理一个问题的不同部分,然后等待它们全部都结束之后再继续</strong>。 executor和 executor服务允许你用不同的策略将任务分配给不同的线程。这个例子只使用了两个线程,不过完全可以使用更多的线程,并重用这些线程来完成多个任务。只要你能把任务分解到适当独立的部分, Executor就可以隐藏异步性的很多细节。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/8f04ec78/">java网络编程第4版 Future,Callable和Executor</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第3章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>通过JIntellitype给Java程序注册系统热键</title>
      <link href="/blog/9d991fe9/"/>
      <url>/blog/9d991fe9/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>参考:<a href="https://blog.csdn.net/iteye_11213/article/details/81886200" target="_blank" rel="noopener">https://blog.csdn.net/iteye_11213/article/details/81886200</a></p><p>JIntellitype提供了简单的调用方法去注册系统热键。操作简单，示例明确，下载后阅读一下readme.txt文档，就可以使用了。</p><p>使用时首先要定义一个实现了HotkeyListener接口的类，实现其onHotKey(int)方法，这个方法接收一个数字，作为标志</p><p>然后就可以使用JIntellitype.getInstance().registerHotKey(int,int,int)方法注册需要的热键了，其中第一个参数将是触发时传递个onHotKey方法的参数，所以两者要保持统一，第二个参数为ctrl、alt、shift等的组合结果，第三个一般为组合键的字母。<br>示例代码：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.iflysse.swing;</span><br><span class="line"><span class="keyword">import</span> com.melloware.jintellitype.HotkeyListener;</span><br><span class="line"><span class="keyword">import</span> com.melloware.jintellitype.JIntellitype;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> ZYWANG</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HotkeyTest</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//注册一个ctrl+alt+a的热键</span></span><br><span class="line">        JIntellitype.getInstance().registerHotKey(<span class="number">100</span>, JIntellitype.MOD_CONTROL+JIntellitype.MOD_ALT, (<span class="keyword">int</span>)<span class="string">'T'</span>);</span><br><span class="line">        <span class="comment">//添加热键监听器</span></span><br><span class="line">        JIntellitype.getInstance().addHotKeyListener(<span class="keyword">new</span> HotkeyListener() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onHotKey</span><span class="params">(<span class="keyword">int</span> arg0)</span> </span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                System.out.println(arg0);<span class="comment">//打印参数</span></span><br><span class="line">                <span class="comment">//JIntellitype.getInstance().unregisterHotKey(arg0);//用于移除热键注册的方法</span></span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread.sleep(<span class="number">10000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>JIntellitype下载地址：<a href="http://melloware.com/download/" target="_blank" rel="noopener">http://melloware.com/download/</a> （打开页面，找到JIntellitype）<br>下载地址：<a href="https://code.google.com/archive/p/jintellitype/downloads" target="_blank" rel="noopener">https://code.google.com/archive/p/jintellitype/downloads</a>,注意需要科学上网。<br>附件中提供了一个jintellitype-1.3.4-dist版本备用</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/9d991fe9/">通过JIntellitype给Java程序注册系统热键</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> java_GUI </category>
          
          <category> 全局热键 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java网络编程第4版 回调</title>
      <link href="/blog/2907fd66/"/>
      <url>/blog/2907fd66/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><p>事实上,还有一种更简单有效的方法来解决这个问题。有了这个方法,我们完全可以淘汰前面的做法,不必通过无限循环来重复地轮询每个 ReturnDigest对象来查看是否结東。这个方法的技巧在于,<strong>不是在主程序中重复地询问每个 ReturnDigest线程是否结束</strong>(就像一个五岁小孩在长途汽车旅行中反复地问“我们到了吗?”这真的很烦人),<strong>而是让线程告诉主程序它何时结束</strong>。<code>这是通过调用主类(即启动这个线程的类)中的一个方法来做到的</code>。这被称为<code>回调( callback)</code>,因为<code>线程在完成时反过来调用其创建者</code>。这样一来,主程序就可以在等待线程结束期间休息,而不会占用运行线程的时间。<br>当线程的run()方法接近结束时,要做的最后一件事情就是基于结果<code>调用主程序中的一个已知方法</code>。不是由主程序询问每个线程来寻求答案,而是<code>由每个线程告知主程序答案</code>。例如,示例3-5展示了一个与前面示例很相似的CallbackDigest类。不过,在run()方法的末尾,对于最初启动这个线程的类,它要将 digest传递给这个类的CallbackDigestUserInterface, receiveDigest()静态方法。</p><h3 id="示例3-5-CallbackDigest"><a href="#示例3-5-CallbackDigest" class="headerlink" title="示例3-5: CallbackDigest"></a>示例3-5: CallbackDigest</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallbackDigest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String filename;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallbackDigest</span><span class="params">(String filename)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filename = filename;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            FileInputStream in = <span class="keyword">new</span> FileInputStream(filename);</span><br><span class="line">            MessageDigest sha = MessageDigest.getInstance(<span class="string">"SHA-256"</span>);</span><br><span class="line">            DigestInputStream din = <span class="keyword">new</span> DigestInputStream(in, sha);</span><br><span class="line">            <span class="keyword">while</span> (din.read() != -<span class="number">1</span>) ; <span class="comment">// read entire file</span></span><br><span class="line">            din.close();</span><br><span class="line">            <span class="keyword">byte</span>[] digest = sha.digest();</span><br><span class="line">            CallbackDigestUserInterface.receiveDigest(digest, filename);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            System.err.println(ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException ex) &#123;</span><br><span class="line">            System.err.println(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例3-6中所示的CallbackDigestUserInterface类提供了main()方法。不过,与这个程序的其他变体中的main()方法不同,这个方法只是为命令行中指定的文件启动线程。它不会具体读取、显示或对计算结果完成其他的操作。这些功能由一个单独的方法receiveDigest()来处理。<code>receiveDigest()不在main()方法中调用</code>,沿着main()方法的控制流所能到达的任何方法也不会调用这个 receiveDigest()方法。<code>实际上,它由每个线程单独调用</code>。也就是说, <code>receiveDigest()在摘要线程中运行,而不是在执行主线程中运行。</code></p><h3 id="示例3-6-CallbackDigestUserInterface"><a href="#示例3-6-CallbackDigestUserInterface" class="headerlink" title="示例3-6: CallbackDigestUserInterface"></a>示例3-6: CallbackDigestUserInterface</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.xml.bind.*; <span class="comment">// for DatatypeConverter; requires Java 6 or JAXB 1.0</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallbackDigestUserInterface</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">receiveDigest</span><span class="params">(<span class="keyword">byte</span>[] digest, String name)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder(name);</span><br><span class="line">        result.append(<span class="string">": "</span>);</span><br><span class="line">        result.append(DatatypeConverter.printHexBinary(digest));</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String filename : args) </span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">//          Calculate          the          digest</span></span><br><span class="line">            CallbackDigest cb = <span class="keyword">new</span> CallbackDigest(filename);</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(cb);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例3-5和示例3-6<code>使用静态方法完成回调</code>,这样CallpackDigest只需要知道CallbackDigestUserInterface中要调用的方法名。不过,<code>回调实例方法也不会太难(而且回调实例方法更为常见)</code>。这种情况下,进行<code>回调的类必须有其回调对象的一个引用</code>。<code>通常情况下,这个引用通过线程构造函数的参数来提供</code>。<strong>当run()方法接近结束时,要做的最后一件事情就是调用回调对象的实例方法来传递结果</strong>。例如,示例3-7展示了一个与前面很类似的CallbackDigest类。不过,这一次它有一个额外的字段,这是个名为callback的 InstanceCallbackDigestUserInterface对象。在run()方法的末尾,digest被传递给 callback的 receiveDigest()方法。 InstanceCallbackDigestUserInterface对象本身<code>在构造函数中设置</code>。</p><h3 id="示例3-7-InstanceCallbackDigest"><a href="#示例3-7-InstanceCallbackDigest" class="headerlink" title="示例3-7: InstanceCallbackDigest"></a>示例3-7: InstanceCallbackDigest</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceCallbackDigest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String filename;</span><br><span class="line">    <span class="comment">//用于回调的引用</span></span><br><span class="line">    <span class="keyword">private</span> InstanceCallbackDigestUserInterface callback;</span><br><span class="line">    <span class="comment">//从构造函数中传入主线程的引用，这样当前线程就可以使用该引用调用主线程的实例方法(实例回调)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InstanceCallbackDigest</span><span class="params">(String filename,InstanceCallbackDigestUserInterface callback)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filename = filename;</span><br><span class="line">        <span class="keyword">this</span>.callback = callback;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//其他处理方法，不用管它干什么的，了解思想就行了</span></span><br><span class="line">            FileInputStream in = <span class="keyword">new</span> FileInputStream(filename);</span><br><span class="line">            MessageDigest sha = MessageDigest.getInstance(<span class="string">"SHA-256"</span>);</span><br><span class="line">            DigestInputStream din = <span class="keyword">new</span> DigestInputStream(in, sha);</span><br><span class="line">            <span class="keyword">while</span> (din.read() != -<span class="number">1</span>) ;  <span class="comment">// read entire file</span></span><br><span class="line">            din.close();</span><br><span class="line">            <span class="keyword">byte</span>[] digest = sha.digest();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过传入的引用，回到主线程的方法。</span></span><br><span class="line">            callback.receiveDigest(digest);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | NoSuchAlgorithmException ex) &#123;</span><br><span class="line">            System.err.println(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例3-8中的 InstanceCallbackDigestUserInterface类有main()方法和 receiveDigest()方法,用于处理传入的摘要。示例3-8只是显示摘要,但功能更强的类还可以完成其他操作,如将摘要存储在一个字段中,用它启动另一个线程,或者对它完成进一步的计算。<br>示例3-8: InstanceCallbackDigestUserInterface<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.xml.bind.*; <span class="comment">// for DatatypeConverter; requires Java 6 or JAXB 1.0</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceCallbackDigestUserInterface</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String filename;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] digest;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InstanceCallbackDigestUserInterface</span><span class="params">(String filename)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filename = filename;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateDigest</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//创建，从线程，传入当前主类的实例(this)</span></span><br><span class="line">        InstanceCallbackDigest cb = <span class="keyword">new</span> InstanceCallbackDigest(filename, <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//启动从线程</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(cb);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提供给从线程回调的方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">receiveDigest</span><span class="params">(<span class="keyword">byte</span>[] digest)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.digest = digest;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String result = filename + <span class="string">": "</span>;</span><br><span class="line">        <span class="keyword">if</span> (digest != <span class="keyword">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            result += DatatypeConverter.printHexBinary(digest);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result += <span class="string">"digest not available"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String filename : args) </span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">//          Calculate          the          digest</span></span><br><span class="line">            InstanceCallbackDigestUserInterface d</span><br><span class="line">            = <span class="keyword">new</span> InstanceCallbackDigestUserInterface(filename);</span><br><span class="line">            d.calculateDigest();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>使用实例方法代替静态方法进行回调要复杂一些,但有很多优点</strong>。首先,主类(这个例子中主类是 InstanceCallbackDigestUserInterface)的各个实例只映射至一个文件,可以自然地跟踪记录这个文件的信息,而不需要额外的数据结构。此外,这个实例在必要时可以很容易地重新计算某个特定文件的摘要。实际上,经证明这种机制有更大的灵活性。但是也有一个警告。注意这里新增了启动线程的 calculateDigest()方法。从逻辑上考虑,你可能认为这属于构造函数。不过,<strong>在构造函数中启动线程很危险,特别是线程将回调原来的对象时</strong>。这里有一个竞态条件,可能会在构造函数结束而且对象完全初始化之前允许新线程进行回调。在这里不太可能,因为启动新线程是构造函数做的最后件事。不过,至少理论上是有可能的。因此,<code>万无一失的做法是避免在构造函数中启动线程</code>。</p><p><strong>相比于轮询机制,回调机制的第一个优点是不会浪费那么多CPU周期</strong>。但<code>更重要的优点是回调更灵活</code>,可以处理涉及更多线程、对象和类的更复杂的情况。例如,如果有多个对象对线程的计算结果感兴趣,那么线程可以保存一个要回调的对象列表。特定的对象可以通过调用 Thread或 Runnable类的一个方法把自己添加到这个列表中来完成注册,表示自己对计算结果很感兴趣。如果有多个类的实例对结果感兴趣,可以定义一个新的interface(接口),所有这些类都要实现这个新接口。这个 interface(接口)将声明回调方法。</p><p>如果你对此有种似曾相识的感觉,可能是因为你以前见过这种机制。这正是在 SwingAWT和 Java bean中处理事件的方法。AWT在程序之外的一个单独的线程中运行。组件和bean通过回调在特定接口(如 ActionListener和 PropertyChangeListener)中声明的方法来通知事件的发生。监听者对象使用 Component类中的方法(如 addActionListener()和 addPropertyChangeListener()来完成注册,表示对特定组件触发的事件感兴趣。<br>在组件内部,已注册的监听者存储在由 java.awt.AWTEventMulticaster构成的一个链表中。这种机制有一个更一般的名字:<code>观察者(Observer)设计模式</code>。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/2907fd66/">java网络编程第4版 回调</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第3章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java图形界面编程</title>
      <link href="/blog/795fc6f9/"/>
      <url>/blog/795fc6f9/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>参考：<a href="https://wenku.baidu.com/view/b0b3ae2aa5e9856a5612609f.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/b0b3ae2aa5e9856a5612609f.html</a><br>图形用户界面( Graphical User Interface)简称GUI,提供了一种更加直观、友好的与用户进行交互的方式。利用Java语言进行图形用户界面操作主要由java.awt和 java.swing两个包来完成。其中,<code>AWT包是图形用户界面处理的基本工具包, Swing包在AWT包的基础上进行了升级、扩展,具有更加强大的图形界面开发功能</code>。本章在了解AWT包功能的基础上,重点讲解 Swing的功能。<br><a id="more"></a></p><h2 id="AWT简介"><a href="#AWT简介" class="headerlink" title="AWT简介"></a>AWT简介</h2><p>Java1.0的出现带来了<code>抽象窗口工具箱(AWT)</code>。设计目标是希望构建一个通用的GUI,使得利用它编写的程序能够运行在所有的平台上,以实现Sun公司提出的口号“一次编写,随处运行”。 Java AWT中包含了许多类来支持GUI设计。AWT由Java的 Java.awt包提供,该包中有许多用来设计GU的组件类,如按钮、菜单、列表、文本框等组件类;同时还包含窗口、面板等容器类。AWT的具体层次结构如图16.1所示。<br><img src="http://pefsyzdwh.bkt.clouddn.com/18-9-12/77483434.jpg" alt=""></p><p>Java提供了一系列AWT软件包,其中主要的包及包的描述如图16.2所示。<br><img src="http://pefsyzdwh.bkt.clouddn.com/18-9-12/21263787.jpg" alt=""></p><ul><li><p>java.awt包:是AWT的核心包，包含用于创建用户界面和绘制图形图像的所有类</p></li><li><p>java.awt包：</p><ul><li>AWT的核心包,包含用于创建用户界面和绘制图形图像的所有类</li></ul></li><li>java.awt.color包：<ul><li>提供定义颜色及其空间</li></ul></li><li>java.awt.datatransfer包：<ul><li>提供在应用程序之间和在应用程序内部传输数据的接口和类</li></ul></li><li>java.awt.event包:<ul><li>提供处理由AWT组件所激发的各类事件的接口和类</li></ul></li><li>java.awt.font包:<ul><li>提供各种字体,包括类及接口</li></ul></li><li>java.awt.image包:<ul><li>用于图像处理,提供创建和修改图像的各种类</li></ul></li><li>java.awt.print包:<ul><li>2D图像的API包,为通用的打印API提供类和接口<br>java.awt包提供了基本的Java程序的GUI设计工具。主要包括<code>组件、容器和布局管理器</code>三个概念,其具体描述如下所示。</li></ul></li></ul><h3 id="GUI设计工具组件"><a href="#GUI设计工具组件" class="headerlink" title="GUI设计工具组件"></a>GUI设计工具组件</h3><ul><li>组件Component)：图形用户界面的最基本组成部分是组件,组件是<code>一个可以以图形化的方式显示在屏幕上并能与用户进行交互的对象</code>,例如个按钮,一个标签等</li><li>容器( Container)：是Component(组件)的子类,容器本身是一个组件具有组件的所有性质,但是其<code>主要功能是容纳其他组件和容器</code></li><li>布局管理器(LayoutManager): 每个容器都有一个布局管理器,使用<strong>布局管理器可以对容器中的某个组件进行定位或判断其大小尺寸</strong>等</li></ul><h2 id="Swing简介"><a href="#Swing简介" class="headerlink" title="Swing简介"></a>Swing简介</h2><p>Swing是Java基础类库( Java Foundation Classes)中有关图形界面的类库。 <code>Swing扩展自AWT</code>。例如JFrame扩展自 Frame, JButton扩展自Component等。<code>基本上AWT中的每种控件都能在Swing中找到替代品</code>,比如AWT中的Button对应于 Swing中的 JButton,AWT中的 TextField对应于 Swing中的 JTextField等。</p><p>Swing包是JFC(Java Foundation Classes)的一部分,它由许多包组成,这些包的名称及描述如表16.1所示。<br><img src="http://pefsyzdwh.bkt.clouddn.com/18-9-12/64122628.jpg" alt=""></p><h2 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h2><p>窗口( JFrame)、面板( JPanel)和对话框(J)是Swing中提供用来创建表示图形用户界面的类。该类的对象将被当作容器使用,所有的 Swing组件都必须被添加到容器中,才能被显示出来。</p><h3 id="JFrame类"><a href="#JFrame类" class="headerlink" title="JFrame类"></a>JFrame类</h3><p>Jframe是一个窗口容器组件,可以被显示在用户桌面上,同时也是一个框架,在其中,可以添加需要的其他的Swing组件。 <strong>Jframe是少数几个不<code>是通过绘制的方式显示的Swing组件</code></strong>。 Jframe类的构造方法如下所示</p><ul><li>public JFrame(String title)<ul><li>构造一个初始状态是不可见的、有指定标题的JFrame对象。参数 title指明了 JFrame对象的标题</li></ul></li></ul><p>Jframe类中还提供了一些与窗口有关的方法。其主要方法与方法描述如表16.2所示。<br><img src="http://pefsyzdwh.bkt.clouddn.com/18-9-12/64122628.jpg" alt=""></p><h2 id="JDialog类"><a href="#JDialog类" class="headerlink" title="JDialog类"></a>JDialog类</h2><p>JDialog是一个用来<strong>创建对话框的类</strong>,是 Dialog类的子类。创建的 <strong>JDialog对象可以用来向用户返回信息,接收用户的输入,实现与用户的交互</strong>。</p><h3 id="JDialog与Jframe的区别"><a href="#JDialog与Jframe的区别" class="headerlink" title="JDialog与Jframe的区别"></a>JDialog与Jframe的区别</h3><p>JDialog对象需要依赖于其他的对话框(比如 Jframe)而存在,当它所依赖的对话框关闭或最小化的时候,该对话框也随之关闭或最小化。</p><p>JDialog类创建对话框对象的构造方法如图16.7所示。</p><ul><li>Dialog(JFrame frame,String s)<ul><li>创建一个对话框对象,初始状态为不可见。参数s用来设置对话框的名字</li></ul></li><li>Dialog(frame frame, String s, boolean b)<ul><li>创建一个对话框对象。参数s用来设置对话框的名字,参数b用来决定该对话框的模式</li></ul></li></ul><p>JDialog类中的主要方法及方法描述如表16.3所示。<br><img src="http://pefsyzdwh.bkt.clouddn.com/18-9-12/6477777.jpg" alt=""></p><h2 id="JPanel类"><a href="#JPanel类" class="headerlink" title="JPanel类"></a>JPanel类</h2><p>在得到了 JFrame的内容面板后我们就可以直接将其他的 Swing组件放在其中,或者直接在上面描绘图画或文字,但是习惯上一般不会这么做。<strong>通常会将这些图画或文字信息描绘在名为JPanel的容器上,然后再将 JPanel实例放在内容面板上。这样可以使得面板上的布局更合理</strong>。JPanel通常只作为纯粹的容器来使用,它不能像框架、窗口或者对话框那样独立存在。 JPanel的构造方法如下所示。</p><ul><li>JPanel()<ul><li>构造一个使用默认的布局管理器创建的面板</li></ul></li><li>JPanel(LayoutManager layout)<ul><li>构造一个使用指定布局管理器的面板</li></ul></li></ul><h2 id="Swing常用基本组件"><a href="#Swing常用基本组件" class="headerlink" title="Swing常用基本组件"></a>Swing常用基本组件</h2><p>创建图形用户界面GUI,就是为了让计算机程序更好的和用户交互。 Java Swing提供了二十多种不同的用户界面组件。<strong>所有的Swng组件都是从javax.swing.Jcomponent类中派生而来的,从而继承了组件所特有的属性和方法</strong>。</p><h3 id="常用组件的共性操作"><a href="#常用组件的共性操作" class="headerlink" title="常用组件的共性操作"></a>常用组件的共性操作</h3><p>Swing类库中的组件都继承自 javax.swing.JComponent,因此都具有 JComponent的操作,包括<code>设置背景色</code>,<code>设置前景色</code>、<code>设置字体</code>以及<code>设置是否禁用</code>等。表16.4中是 JComponent中常用的方法及方法描述。<br><img src="http://pefsyzdwh.bkt.clouddn.com/18-9-12/27250573.jpg" alt=""></p><h3 id="按钮-JButton"><a href="#按钮-JButton" class="headerlink" title="按钮( JButton)"></a>按钮( JButton)</h3><p>按钮是用户界面中常用的组件。用户使用 Swing按钮可以显示图像,将整个按钮设置为窗口默认图标,来处理鼠标在按钮上的事件。java.swing包中提供了标准的按压式按钮( JButton)。同时提供了选择式按钮:多选择( JCheckBox)、单选择( JRadioButton)等。我们在这里先来讲解 JButton的知识JButton的构造方法如图16.1所示。</p><ul><li>public JButton ()方法<ul><li>用于创建不带有设置文本或图标的按钮</li></ul></li><li>public JButton(Icon icon)方法<ul><li>用于创建一个带图标的按钮</li></ul></li><li>public JButton(String text)方法<ul><li>用于创建一个带文本的按钮</li></ul></li><li>public JButton(Action a)方法<ul><li>用于创建一个按钮,其属性从所提供的 Action中获取</li></ul></li></ul><h3 id="文本框-JTextField-与密码输入框-JPasswordField"><a href="#文本框-JTextField-与密码输入框-JPasswordField" class="headerlink" title="文本框( JTextField)与密码输入框( JPasswordField)"></a>文本框( JTextField)与密码输入框( JPasswordField)</h3><p><strong>文本框( JTextField)</strong>也是一种常见的组件<strong>,用于处理一行文本</strong>(中间没有回车符)。 JTextField是JTextComponent的子类。密码输入框是 JTextField的个子类。 JTextField和 PasswordField的构造函数形式和常用方法完全一样。这里只列出 JTextField的构造函数,如下所示。</p><ul><li>JTextField()<ul><li>构造一个空文本域</li></ul></li><li>JTextField(String text)<ul><li>构造一个显示指定字符串的文本域</li></ul></li><li>JTextField(int columns)<ul><li>构造一个显示指定列数的空文本域</li></ul></li><li>JTextField(String text,int columns)<ul><li>构造一个具有显示指定字符串,指定列数的文本域<h3 id="文本域-JTextArea"><a href="#文本域-JTextArea" class="headerlink" title="文本域( JTextArea)"></a>文本域( JTextArea)</h3>文本域( JTextArea)也是一种常用组件,<strong>用于处理多行文本</strong>。 JTextArea同 JTextField一样,都是JTextcomponent的子类,因此它们的很多操作都类似,我们不再赘述。 JTextArea的构造函数如下所示：</li></ul></li><li>JTextArea</li><li>构造一个空文本区</li><li>JTextArea(String text)<ul><li>构造一个显示指定字符串的文本区</li></ul></li><li>JTextArea(int columns)<ul><li>构造一个显示指定列数的空文本区</li></ul></li><li>JTextArea(String text, int columns)<ul><li>构造一个具有显示指定字符串,指定列数的文本区</li></ul></li></ul><h3 id="标签-JLabel"><a href="#标签-JLabel" class="headerlink" title="标签( JLabel)"></a>标签( JLabel)</h3><p>标签( JLabel)用来显示一段文本,常用在 JTextField或者 JTextArea前面,提示用户要填写什么样的信息。JLabel用于显示文字,也可以同时显示文字和图标,一般不用于接收鼠标键盘的动作。 JLabel的构造方法如下所示。</p><ul><li>public JLabel (String text)</li><li>使用左对齐字符串来构造一个标签</li><li>public JLabel (Icon icon)<ul><li>使用左对齐图标来构造一个标签</li></ul></li><li>public JLabel (String text, int align)<ul><li>构造一个显示指定列数的空文本区</li></ul></li><li>public JLabel(String text, Icon icon, int align)<ul><li>构造一个具有显示指定字符串,指定列数的文本区</li></ul></li></ul><p>先搬运到这里,后面再看看。看了这么多还是没能达到我想要的结果:设置一个截图的软件，然后自动调用百度识图获取JSON数据，并去除识别的文字，复制到剪贴板中。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/795fc6f9/">Java图形界面编程</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> java_GUI </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java截图</title>
      <link href="/blog/14ec9002/"/>
      <url>/blog/14ec9002/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>源码：<a href="https://www.cnblogs.com/feitianshaoxai/p/6560110.html" target="_blank" rel="noopener">https://www.cnblogs.com/feitianshaoxai/p/6560110.html</a></p><p>上面代码实现了截图的操作，我要在上面的代码中加入自动保存然后调用百度识图的操作。具体可以模仿上面的保存函数</p><p>加入的百度文字识图按钮：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 百度识图按钮</span></span><br><span class="line">JButton baiduOCRButton = <span class="keyword">new</span> JButton(<span class="string">"百度文字识别"</span>);</span><br><span class="line">baiduOCRButton.addActionListener(<span class="keyword">new</span> ActionListener()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 保存截图</span></span><br><span class="line">parent.baiduOCR();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e1)</span><br><span class="line">&#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">toolBar.add(baiduOCRButton);</span><br></pre></td></tr></table></figure><p></p><p>实现算法：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用百度识图</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">baiduOCR</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line">ImageIO.write(saveImage, <span class="string">"png"</span>, <span class="keyword">new</span> File(<span class="string">"1.png"</span>));</span><br><span class="line">Thread baiduOCR=<span class="keyword">new</span> Thread(<span class="keyword">new</span> BaiduOCR(<span class="string">"1.png"</span>,<span class="keyword">this</span>));</span><br><span class="line">baiduOCR.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>说明：直接把截图保存在工程路径下的“1.png”文件中。然后启动一个<code>baiduOCR</code>线程来处理这个图片：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> release.ocr.baidu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> org.json.JSONObject;</span><br><span class="line"><span class="keyword">import</span> com.baidu.aip.ocr.AipOcr;</span><br><span class="line"><span class="keyword">import</span> clipboard.util.SysClipboardUtil;</span><br><span class="line"><span class="keyword">import</span> net.sf.json.JSONArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaiduOCR</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="comment">// 设置APPID/AK/SK</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String APP_ID = <span class="string">"你的百度APP_ID"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String API_KEY = <span class="string">"你的百度API_KEY"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SECRET_KEY = <span class="string">"你的百度SECRET_KEY"</span>;</span><br><span class="line"><span class="comment">//窗体引用,用于使得窗体不可见</span></span><br><span class="line">ScreenShotWindow screenShotWindow;</span><br><span class="line"><span class="comment">//文件路径,我们识别的就是这个图片</span></span><br><span class="line">String path;</span><br><span class="line">       <span class="comment">//通过构造函数传入参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BaiduOCR</span><span class="params">(String path,ScreenShotWindow screenShotWindow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.path=path;</span><br><span class="line"><span class="keyword">this</span>.screenShotWindow=screenShotWindow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//让窗体不可见，以便用户可以进行其他操作</span></span><br><span class="line">ScreenShotOCR.notVisiabl();</span><br><span class="line"><span class="comment">//调用百度文字识别接口</span></span><br><span class="line">baiduOCR(path);</span><br><span class="line"><span class="comment">//回调函数，执行完毕后关闭程序</span></span><br><span class="line">ScreenShotWindow.Exit();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**   </span></span><br><span class="line"><span class="comment"> * 调用百度文字识别</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">baiduOCR</span><span class="params">(String path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 初始化一个AipOcr</span></span><br><span class="line">AipOcr client = <span class="keyword">new</span> AipOcr(APP_ID, API_KEY, SECRET_KEY);</span><br><span class="line"><span class="comment">// 可选：设置网络连接参数</span></span><br><span class="line">client.setConnectionTimeoutInMillis(<span class="number">2000</span>);</span><br><span class="line">client.setSocketTimeoutInMillis(<span class="number">60000</span>);</span><br><span class="line"><span class="comment">// 调用接口取得识别的结果：JSON数据</span></span><br><span class="line">JSONObject res = client.basicGeneral(path,</span><br><span class="line"><span class="keyword">new</span> HashMap&lt;String, String&gt;());</span><br><span class="line">String text = res.toString(<span class="number">2</span>);</span><br><span class="line">            <span class="comment">//从JSON数据中取出翻译的结果</span></span><br><span class="line">            <span class="comment">//转为HashMap</span></span><br><span class="line">HashMap&lt;String, Object&gt; resMap = (HashMap&lt;String, Object&gt;) res.toMap();</span><br><span class="line"><span class="comment">// 迭代器</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; it = resMap.entrySet().iterator();</span><br><span class="line"><span class="comment">// 缓冲，用来存储识别结果</span></span><br><span class="line">StringBuilder sbBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">Map.Entry&lt;String, Object&gt; entry;</span><br><span class="line">            <span class="comment">//遍历Map集合</span></span><br><span class="line"><span class="keyword">while</span> (it.hasNext())</span><br><span class="line">&#123;</span><br><span class="line">entry = it.next();</span><br><span class="line">                    <span class="comment">//找到翻译结果组</span></span><br><span class="line"><span class="keyword">if</span> (entry.getKey().equals(<span class="string">"words_result"</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 获取词组</span></span><br><span class="line">JSONArray jsonArray = JSONArray.fromObject(entry.getValue());</span><br><span class="line">System.out.println(jsonArray.toString());</span><br><span class="line"><span class="keyword">for</span> (Object object : jsonArray)</span><br><span class="line">&#123;</span><br><span class="line">sbBuilder.append(object.toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//获取识别结果</span></span><br><span class="line">String words = sbBuilder.toString();</span><br><span class="line">            <span class="comment">//使用正则表达式删除无用信息，只留下翻译的结果</span></span><br><span class="line">words = words.replaceAll(<span class="string">"(?:(?:\\\"\\&#125;)?\\&#123;\\\"words\\\":\\\"|\\\"\\&#125;)"</span>, <span class="string">""</span>);</span><br><span class="line">SysClipboardUtil.setSysClipboardText(words);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="完整的代码"><a href="#完整的代码" class="headerlink" title="完整的代码"></a>完整的代码</h2><h3 id="ScreenShotOCR类"><a href="#ScreenShotOCR类" class="headerlink" title="ScreenShotOCR类"></a>ScreenShotOCR类</h3><p>ScreenShotOCR类实现截图的功能，窗体的显示。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> release.ocr.baidu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.AWTException;</span><br><span class="line"><span class="keyword">import</span> java.awt.BorderLayout;</span><br><span class="line"><span class="keyword">import</span> java.awt.Color;</span><br><span class="line"><span class="keyword">import</span> java.awt.Dimension;</span><br><span class="line"><span class="keyword">import</span> java.awt.EventQueue;</span><br><span class="line"><span class="keyword">import</span> java.awt.Graphics;</span><br><span class="line"><span class="keyword">import</span> java.awt.Image;</span><br><span class="line"><span class="keyword">import</span> java.awt.Rectangle;</span><br><span class="line"><span class="keyword">import</span> java.awt.Robot;</span><br><span class="line"><span class="keyword">import</span> java.awt.Toolkit;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.MouseAdapter;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.MouseEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.MouseMotionAdapter;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.RescaleOp;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JButton;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFileChooser;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JToolBar;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JWindow;</span><br><span class="line"><span class="keyword">import</span> javax.swing.filechooser.FileNameExtensionFilter;</span><br><span class="line"><span class="keyword">import</span> javax.swing.filechooser.FileSystemView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScreenShotOCR</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> ScreenShotWindow ssw;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">EventQueue.invokeLater(<span class="keyword">new</span> Runnable()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">ssw = <span class="keyword">new</span> ScreenShotWindow();</span><br><span class="line">ssw.setVisible(<span class="keyword">true</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (AWTException e)</span><br><span class="line">&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 回调函数，使得当前窗口不可见。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">notVisiabl</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ssw.setVisible(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 截图矩形窗口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScreenShotWindow</span> <span class="keyword">extends</span> <span class="title">JWindow</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> orgx, orgy, endx, endy;</span><br><span class="line"><span class="keyword">private</span> BufferedImage image = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> BufferedImage tempImage = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> BufferedImage saveImage = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ToolsWindow tools = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScreenShotWindow</span><span class="params">()</span> <span class="keyword">throws</span> AWTException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 获取屏幕尺寸</span></span><br><span class="line">Dimension d = Toolkit.getDefaultToolkit().getScreenSize();</span><br><span class="line"><span class="comment">// 设置窗口显示大小</span></span><br><span class="line"><span class="keyword">this</span>.setBounds(<span class="number">0</span>, <span class="number">0</span>, d.width, d.height);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 截取整个屏幕</span></span><br><span class="line">Robot robot = <span class="keyword">new</span> Robot();</span><br><span class="line">image = robot</span><br><span class="line">.createScreenCapture(<span class="keyword">new</span> Rectangle(<span class="number">0</span>, <span class="number">0</span>, d.width, d.height));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置鼠标监听事件</span></span><br><span class="line"><span class="keyword">this</span>.addMouseListener(<span class="keyword">new</span> MouseAdapter()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 鼠标按下</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mousePressed</span><span class="params">(MouseEvent e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 鼠标松开时记录结束点坐标，并隐藏操作窗口</span></span><br><span class="line">orgx = e.getX();</span><br><span class="line">orgy = e.getY();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tools != <span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">tools.setVisible(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseReleased</span><span class="params">(MouseEvent e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 鼠标松开时，显示操作窗口</span></span><br><span class="line"><span class="keyword">if</span> (tools == <span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">tools = <span class="keyword">new</span> ToolsWindow(ScreenShotWindow.<span class="keyword">this</span>, e.getX(),</span><br><span class="line">e.getY());</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">tools.setLocation(e.getX(), e.getY());</span><br><span class="line">&#125;</span><br><span class="line">tools.setVisible(<span class="keyword">true</span>);</span><br><span class="line">tools.toFront();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.addMouseMotionListener(<span class="keyword">new</span> MouseMotionAdapter()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseDragged</span><span class="params">(MouseEvent e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 鼠标拖动时，记录坐标并重绘窗口</span></span><br><span class="line">endx = e.getX();</span><br><span class="line">endy = e.getY();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 临时图像，用于缓冲屏幕区域放置屏幕闪烁</span></span><br><span class="line">Image tempImage2 = createImage(ScreenShotWindow.<span class="keyword">this</span>.getWidth(),</span><br><span class="line">ScreenShotWindow.<span class="keyword">this</span>.getHeight());</span><br><span class="line">Graphics g = tempImage2.getGraphics();</span><br><span class="line">g.drawImage(tempImage, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">int</span> x = Math.min(orgx, endx);</span><br><span class="line"><span class="keyword">int</span> y = Math.min(orgy, endy);</span><br><span class="line"><span class="keyword">int</span> width = Math.abs(endx - orgx) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> height = Math.abs(endy - orgy) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 加上1防止width或height0</span></span><br><span class="line">g.setColor(Color.BLUE);</span><br><span class="line">g.drawRect(x - <span class="number">1</span>, y - <span class="number">1</span>, width + <span class="number">1</span>, height + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 减1加1都了防止图片矩形框覆盖掉</span></span><br><span class="line">saveImage = image.getSubimage(x, y, width, height);</span><br><span class="line">g.drawImage(saveImage, x, y, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">ScreenShotWindow.<span class="keyword">this</span>.getGraphics().drawImage(tempImage2, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">ScreenShotWindow.<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(Graphics g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">RescaleOp ro = <span class="keyword">new</span> RescaleOp(<span class="number">0.8f</span>, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">tempImage = ro.filter(image, <span class="keyword">null</span>);</span><br><span class="line">g.drawImage(tempImage, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 保存图像到文件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveImage</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">JFileChooser jfc = <span class="keyword">new</span> JFileChooser();</span><br><span class="line">jfc.setDialogTitle(<span class="string">"保存"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件过滤器，用户过滤可选择文件</span></span><br><span class="line">FileNameExtensionFilter filter = <span class="keyword">new</span> FileNameExtensionFilter(<span class="string">"PNG"</span>,</span><br><span class="line"><span class="string">"png"</span>);</span><br><span class="line">jfc.setFileFilter(filter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个默认文件（此文件会生成到桌面上）</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyymmddHHmmss"</span>);</span><br><span class="line">String fileName = sdf.format(<span class="keyword">new</span> Date());</span><br><span class="line">File filePath = FileSystemView.getFileSystemView().getHomeDirectory();</span><br><span class="line">File defaultFile = <span class="keyword">new</span> File(</span><br><span class="line">filePath + File.separator + fileName + <span class="string">".png"</span>);</span><br><span class="line">jfc.setSelectedFile(defaultFile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> flag = jfc.showSaveDialog(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> (flag == JFileChooser.APPROVE_OPTION)</span><br><span class="line">&#123;</span><br><span class="line">File file = jfc.getSelectedFile();</span><br><span class="line">String path = file.getPath();</span><br><span class="line"><span class="comment">// 检查文件后缀，放置用户忘记输入后缀或者输入不正确的后缀</span></span><br><span class="line"><span class="keyword">if</span> (!(path.endsWith(<span class="string">".png"</span>) || path.endsWith(<span class="string">".PNG"</span>)))</span><br><span class="line">&#123;</span><br><span class="line">path += <span class="string">".png"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line">ImageIO.write(saveImage, <span class="string">"png"</span>, <span class="keyword">new</span> File(path));</span><br><span class="line">System.exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用百度识图</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">baiduOCR</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line">ImageIO.write(saveImage, <span class="string">"png"</span>, <span class="keyword">new</span> File(<span class="string">"1.png"</span>));</span><br><span class="line">Thread baiduOCR = <span class="keyword">new</span> Thread(<span class="keyword">new</span> BaiduOCR(<span class="string">"1.png"</span>, <span class="keyword">this</span>));</span><br><span class="line">baiduOCR.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Exit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">System.exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 操作窗口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToolsWindow</span> <span class="keyword">extends</span> <span class="title">JWindow</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">private</span> ScreenShotWindow parent;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ToolsWindow</span><span class="params">(ScreenShotWindow parent, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.parent = parent;</span><br><span class="line"><span class="keyword">this</span>.init();</span><br><span class="line"><span class="keyword">this</span>.setLocation(x, y);</span><br><span class="line"><span class="keyword">this</span>.pack();</span><br><span class="line"><span class="keyword">this</span>.setVisible(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.setLayout(<span class="keyword">new</span> BorderLayout());</span><br><span class="line">JToolBar toolBar = <span class="keyword">new</span> JToolBar(<span class="string">"Java 截图"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存按钮</span></span><br><span class="line">JButton saveButton = <span class="keyword">new</span> JButton(<span class="string">"保存"</span>);</span><br><span class="line">saveButton.addActionListener(<span class="keyword">new</span> ActionListener()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 保存截图</span></span><br><span class="line">parent.saveImage();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e1)</span><br><span class="line">&#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">toolBar.add(saveButton);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 百度识图按钮</span></span><br><span class="line">JButton baiduOCRButton = <span class="keyword">new</span> JButton(<span class="string">"百度文字识别"</span>);</span><br><span class="line">baiduOCRButton.addActionListener(<span class="keyword">new</span> ActionListener()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 保存截图</span></span><br><span class="line">parent.baiduOCR();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e1)</span><br><span class="line">&#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">toolBar.add(baiduOCRButton);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭按钮</span></span><br><span class="line">JButton closeButton = <span class="keyword">new</span> JButton(<span class="string">"退出"</span>);</span><br><span class="line">closeButton.addActionListener(<span class="keyword">new</span> ActionListener()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">System.exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">toolBar.add(closeButton);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.add(toolBar, BorderLayout.NORTH);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="BaiduOCR类"><a href="#BaiduOCR类" class="headerlink" title="BaiduOCR类"></a>BaiduOCR类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> release.ocr.baidu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> org.json.JSONObject;</span><br><span class="line"><span class="keyword">import</span> com.baidu.aip.ocr.AipOcr;</span><br><span class="line"><span class="keyword">import</span> clipboard.util.SysClipboardUtil;</span><br><span class="line"><span class="keyword">import</span> net.sf.json.JSONArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaiduOCR</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="comment">// 设置APPID/AK/SK</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String APP_ID = <span class="string">"你的BaiduAPP_ID"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String API_KEY = <span class="string">"你的"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SECRET_KEY = <span class="string">"你的"</span>;</span><br><span class="line"><span class="comment">//窗体引用</span></span><br><span class="line">ScreenShotWindow screenShotWindow;</span><br><span class="line"><span class="comment">//文件路径</span></span><br><span class="line">String path;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BaiduOCR</span><span class="params">(String path,ScreenShotWindow screenShotWindow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.path=path;</span><br><span class="line"><span class="keyword">this</span>.screenShotWindow=screenShotWindow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//让窗体不可见</span></span><br><span class="line">ScreenShotOCR.notVisiabl();</span><br><span class="line"><span class="comment">//调用百度文字识别接口</span></span><br><span class="line">baiduOCR(path);</span><br><span class="line"><span class="comment">//回调函数，执行完毕后关闭程序</span></span><br><span class="line">ScreenShotWindow.Exit();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**   </span></span><br><span class="line"><span class="comment"> * 调用百度文字识别</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">baiduOCR</span><span class="params">(String path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 初始化一个AipOcr</span></span><br><span class="line">AipOcr client = <span class="keyword">new</span> AipOcr(APP_ID, API_KEY, SECRET_KEY);</span><br><span class="line"><span class="comment">// 可选：设置网络连接参数</span></span><br><span class="line">client.setConnectionTimeoutInMillis(<span class="number">2000</span>);</span><br><span class="line">client.setSocketTimeoutInMillis(<span class="number">60000</span>);</span><br><span class="line"><span class="comment">// 调用接口</span></span><br><span class="line">JSONObject res = client.basicGeneral(path,</span><br><span class="line"><span class="keyword">new</span> HashMap&lt;String, String&gt;());</span><br><span class="line">String text = res.toString(<span class="number">2</span>);</span><br><span class="line">HashMap&lt;String, Object&gt; resMap = (HashMap&lt;String, Object&gt;) res.toMap();</span><br><span class="line"><span class="comment">// 第二种：</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; it = resMap.entrySet().iterator();</span><br><span class="line"><span class="comment">// 缓冲，用来存储识别结果</span></span><br><span class="line">StringBuilder sbBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">Map.Entry&lt;String, Object&gt; entry;</span><br><span class="line"><span class="keyword">while</span> (it.hasNext())</span><br><span class="line">&#123;</span><br><span class="line">entry = it.next();</span><br><span class="line"><span class="keyword">if</span> (entry.getKey().equals(<span class="string">"words_result"</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 获取词组</span></span><br><span class="line">JSONArray jsonArray = JSONArray.fromObject(entry.getValue());</span><br><span class="line">System.out.println(jsonArray.toString());</span><br><span class="line"><span class="keyword">for</span> (Object object : jsonArray)</span><br><span class="line">&#123;</span><br><span class="line">sbBuilder.append(object.toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">String words = sbBuilder.toString();</span><br><span class="line">words = words.replaceAll(<span class="string">"(?:(?:\\\"\\&#125;)?\\&#123;\\\"words\\\":\\\"|\\\"\\&#125;)"</span>, <span class="string">""</span>);</span><br><span class="line">SysClipboardUtil.setSysClipboardText(words);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文链接: <a href="https://www.lansheng.net.cn/blog/14ec9002/">Java截图</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> java_GUI </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java网络编程第4版 轮询</title>
      <link href="/blog/aa00d27d/"/>
      <url>/blog/aa00d27d/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><p>大多数新手采用的解决方案是,<code>让获取方法返回一个标志值</code>(或者可能抛出一个异常),直到设置了结果字段为止。然后<code>主线程定期询问获取方法,查看是否返回了标志之外的值</code>。这个例子中,这表示要<strong>重复地测试 digest是否为空,只有不为空才使用</strong>。例如:<br><img src="http://pefsyzdwh.bkt.clouddn.com/18-9-12/7022980.jpg" alt=""><br>这个解决方案是可行的。它会以正确的顺序给出正确的答案,而不考虑各个线程的相对运行速度。不过,它做了大量不需要做的工作。更糟糕的是,这个解决方案不能保证一定能工作。在有些虚拟机上,主线程会占用所有可用的时间,而没有给具体的工作线程留出任何时间。主线程太忙于检查工作的完成情况,以至于没有时间来具体完成任务!<code>显然这(轮询)不是一个好方法</code>。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/aa00d27d/">java网络编程第4版 轮询</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第3章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java网络编程第4版 竞态条件</title>
      <link href="/blog/fcc5ac73/"/>
      <url>/blog/fcc5ac73/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><p>一种可能的方法是把 dr.getDigest()调用移到main()方法的后面部分,如下所示:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ReturnDigest[] digests=<span class="keyword">new</span> ReturnDigest[args.length ];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;args.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//计算摘要</span></span><br><span class="line">        digests[i]= <span class="keyword">new</span> ReturnDigest(args[i]);</span><br><span class="line">        digests[i].start();    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>()<span class="keyword">int</span> i=<span class="number">0</span>；i&lt; args.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//现在显示结果</span></span><br><span class="line">        StringBuffer result=<span class="keyword">new</span> StringBuffer(args[i]);</span><br><span class="line">        result. append(<span class="string">":"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] digest = digests[i].getDigest();</span><br><span class="line">        result. append(DatatypeConverter.printHexBinary(digest));</span><br><span class="line">        System.out.printin(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>如果你够幸运,这会正常工作,你将得到期望的输出,如下:<br><img src="http://pefsyzdwh.bkt.clouddn.com/18-9-12/72370729.jpg" alt=""><br>但我要强调一下这里所说的“幸运”。你可能得不到这个输出。事实上,你可能仍会得到一个NullPointerException异常。<strong>这段代码是否能正常工作,完全取决于每个ReturnDigest线程是否在其 getDigest()方法被调用之前结束</strong>。如果第一个for循环太快,在第一个for循环生成的线程结束之前就进入了第二个for循环,那么我们又会回到原点,遭遇同样的问题。更糟糕的是,程序看起来好像被挂起了,没有任何输出,甚至连栈轨迹都没有。</p><p>到底会得到正确的结果还是异常,或者是一个挂起的程序,这取决于很多因素,包括程序生成了多少线程,系统的CPU和磁盘的速度,系统使用多少个CPU,以及Java虚拟机为不同线程分配时间所用的算法。这些称为<code>竞态条件</code>( race condition)。<code>能否得到正确结果依赖于不同线程的相对速度,而你无法控制这一点!</code>我们需要一种更好的方法,以保证在摘要就绪前不会调用 getDigest()。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/fcc5ac73/">java网络编程第4版 竞态条件</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第3章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java网络编程第4版 从线程返回信息</title>
      <link href="/blog/ec5f40b6/"/>
      <url>/blog/ec5f40b6/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><p>习惯了传统单线程过程式模型的程序员在转向多线程环境时,<strong>最难掌握的一点就是如何从线程返回信息**</strong>。从结束的线程获得信息,这是多线程编程中最常被误解的方面之一**。<code>run()方法和 start()方法不返回任何值</code>。例如,假设不只是像示例3-1和示例3-2那样简单地显示SHA-256摘要,摘要线程需要把摘要返回给执行主线程。<code>大多数人的第一个反应就是把结果存储在一个字段中,再提供一个获取方法</code>,如示例3-3和示例3-4所示。示例3-3是一个计算指定文件摘要的 Thread子类。示例3-4是一个简单的命令行用户界面,会接收文件名,并创建线程为这些文件计算摘要。</p><h3 id="示例3-3-使用存取方法返回结果的线程"><a href="#示例3-3-使用存取方法返回结果的线程" class="headerlink" title="示例3-3:使用存取方法返回结果的线程"></a>示例3-3:使用存取方法返回结果的线程</h3><p>ReturnDigest</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnDigest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String filename;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] digest;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReturnDigest</span><span class="params">(String filename)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filename = filename;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            FileInputStream in = <span class="keyword">new</span> FileInputStream(filename);</span><br><span class="line">            MessageDigest sha = MessageDigest.getInstance(<span class="string">"SHA-256"</span>);</span><br><span class="line">            DigestInputStream din = <span class="keyword">new</span> DigestInputStream(in, sha);</span><br><span class="line">            <span class="keyword">while</span> (din.read() != -<span class="number">1</span>) ; <span class="comment">// read entire file</span></span><br><span class="line">            din.close();</span><br><span class="line">            digest = sha.digest();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            System.err.println(ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException ex) &#123;</span><br><span class="line">            System.err.println(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getDigest() </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> digest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="示例3-4-使用存取方法获得线程输出的主程序"><a href="#示例3-4-使用存取方法获得线程输出的主程序" class="headerlink" title="示例3-4:使用存取方法获得线程输出的主程序"></a>示例3-4:使用存取方法获得线程输出的主程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.xml.bind.*; <span class="comment">// for DatatypeConverter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnDigestUserInterface</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String filename : args) </span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">//          Calculate          the          digest</span></span><br><span class="line">            ReturnDigest dr = <span class="keyword">new</span> ReturnDigest(filename);</span><br><span class="line">            dr.start();</span><br><span class="line"><span class="comment">//          Now          print          the          result</span></span><br><span class="line">            StringBuilder result = <span class="keyword">new</span> StringBuilder(filename);</span><br><span class="line">            result.append(<span class="string">": "</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] digest = dr.getDigest();</span><br><span class="line">            result.append(DatatypeConverter.printHexBinary(digest));</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReturnDigest类把计算结果存储在私有字段 digest中,可以通过 getDigest()来访问。ReturnDigestUserInterface中的main()方法循环处理由命令行得到的一个文件列表。它为每个文件启动一个新的 ReturnDigest线程,然后试图使用 getDigest()获取结果。不过,当你运行这个程序时,结果却不像你期望的那样:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D: \JAVA\JNP4\examples \03&gt;java ReturnDigestUserInterface * java</span><br><span class="line">Exception in thread &quot;main&quot; java. lang NullPointerException</span><br><span class="line">    at javax.xml.bind Datatype ConverterImpl printHexBinary</span><br><span class="line">    (DatatypeConverterImpl.java: 358)</span><br><span class="line">    at javax.xml.bind.DatatypeConverter.printHexBinary(DatatypeConverter.java: 560)</span><br><span class="line">    at ReturnDigestUserInterface main(ReturnDigestUserInterface.java: 15)</span><br></pre></td></tr></table></figure><p></p><p>问题在于,主程序会在线程有机会初始化摘要之前就获取并使用摘要。在单线程程序里这个控制流可以正常工作,但在这里不行,因为<code>在单线程程序里,dr.start()只是在同一个线程中调用run()方法</code>,而这里情况有所不同。dr.start()启动的计算可能在main()方法调用dr.getDigest()之前结東,也可能还没有结束。如果没有结束, dr.getDigest()则会返回null,第一次尝试访问 digest时会抛出一个NullPointerException异常。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/ec5f40b6/">java网络编程第4版 从线程返回信息</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第3章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java网络编程第4版 实现 Runnable接口</title>
      <link href="/blog/c680e36f/"/>
      <url>/blog/c680e36f/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><p>要想避免覆盖标准 Thread方法,一种办法就是不要派生 Thread类,而是<code>将希望线程完成的任务编写为 Runnable接口的一个实例</code>。这个接口声明了run()方法,这与 Thread类完全一样:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p></p><p>任何实现这个接口的类都必须提供这个方法,<code>除了这个run()方法外,你可以自由地创建任何其他方法(可以使用你选择的任何方法名),而绝不会无意地妨碍线程的行为</code>。它还允许你将线程的任务放在其他类的子类中,如 Applet或 HttpServleT。<strong>要启动执行 Runnable任务的一个线程,可以把这个 Runnable对象传入 Thread构造函数</strong>。例如:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread t=<span class="keyword">new</span> Thread (my RunnableObject);</span><br><span class="line">t.start;</span><br></pre></td></tr></table></figure><p></p><p>对于大多数通过派生 Thread子类来解决的问题,可以很容易地改为使用 Runnable接口。示例3-2展示了这一点,它将示例3-1改写为使用 Runnable接口,而不是派生 Thread的子类。除了名字的改变外,需要做的唯一修改就是将 extends thread改为 implements Runnable,并在main()方法中把 DigestRunnable对象传递给 Thread构造函数。程序的基本逻辑没有变。</p><p>示例3-2: DigestRunnable<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> javax.xml.bind.*; <span class="comment">// for DatatypeConverter; requires Java 6 or JAXB 1.0</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DigestRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String filename;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DigestRunnable</span><span class="params">(String filename)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filename = filename;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            FileInputStream in = <span class="keyword">new</span> FileInputStream(filename);</span><br><span class="line">            MessageDigest sha = MessageDigest.getInstance(<span class="string">"SHA-256"</span>);</span><br><span class="line">            DigestInputStream din = <span class="keyword">new</span> DigestInputStream(in, sha);</span><br><span class="line">            <span class="keyword">while</span> (din.read() != -<span class="number">1</span>) ;</span><br><span class="line">            din.close();</span><br><span class="line">            <span class="keyword">byte</span>[] digest = sha.digest();</span><br><span class="line">            StringBuilder result = <span class="keyword">new</span> StringBuilder(filename);</span><br><span class="line">            result.append(<span class="string">": "</span>);</span><br><span class="line">            result.append(DatatypeConverter.printHexBinary(digest));</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            System.err.println(ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException ex) &#123;</span><br><span class="line">            System.err.println(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String filename : args) </span><br><span class="line">        &#123;</span><br><span class="line">            DigestRunnable dr = <span class="keyword">new</span> DigestRunnable(filename);</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(dr);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>并不认为实现 Runnab1e接口一定优于扩展 Thread类</strong>,没有强有力的理由支持这一点,<strong>反之亦然</strong>。在一些特殊的情况下,例如本章后面的示例3-14,在每个 Thread对象的构造函数中调用 Thread类的一些实例方法可能很有用。这就需要使用子类。在另外一些特定的情况下,可能需要将run()方法放在某个类中,而这个类要扩展另一个类(如HttpServlet),这种情况下就必须使用 Runnable接口。最后,有些崇尚面向对象的人认为,线程完成的任务实际上不是一种 Thread,因此应当放在一个单独的类或接口.(如Runnable)中,而不应放在 Thread的子类中。我部分同意这种观点,但我不认为这个观点像其声称的那样理由充分。所以,<code>本书中主要使用 Runnable接口,但你也可以使用对你来说最方便的任何方法。</code></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/c680e36f/">java网络编程第4版 实现 Runnable接口</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第3章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>json字符串与java对象互转</title>
      <link href="/blog/12f6a417/"/>
      <url>/blog/12f6a417/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:16 GMT+0800 (中国标准时间) --><p>原文：<a href="https://www.cnblogs.com/wangf-keep/p/6480019.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangf-keep/p/6480019.html</a></p><h1 id="json字符串与java对象互转"><a href="#json字符串与java对象互转" class="headerlink" title="json字符串与java对象互转"></a>json字符串与java对象互转</h1><p>在开发过程中，经常需要和别的系统交换数据，<code>数据交换的格式有XML、JSON等</code>，<code>JSON作为一个轻量级的数据格式比XML效率要高</code>，XML需要很多的标签，这无疑占据了网络流量，JSON在这方面则做的很好，下面先看下JSON的格式，</p><p><strong>JSON可以有两种格式，一种是对象格式的，另一种是数组对象</strong>，<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;name&quot;:&quot;JSON&quot;,&quot;address&quot;:&quot;北京市西城区&quot;,&quot;age&quot;:25&#125;//JSON的对象格式的字符串</span><br><span class="line">[&#123;&quot;name&quot;:&quot;JSON&quot;,&quot;address&quot;:&quot;北京市西城区&quot;,&quot;age&quot;:25&#125;]//数据对象格式</span><br></pre></td></tr></table></figure><p></p><p>从上面的两种格式可以看出对象格式和数组对象格式唯一的不同则是在对象格式的基础上加上了<code>[]</code>，再来看具体的结构，可以看出都是<code>以键值对的形式</code>出现的，<code>中间以英文逗号（,）分隔</code>。</p><p><code>在前端和后端进行数据传输的时候这种格式也是很受欢迎的</code>，后端返回json格式的字符串，前台使用js中的JSON.parse()方法把JSON字符串解析为json对象，然后进行遍历，供前端使用。</p><h2 id="JAVA中JSON和java对象之间的互转-。"><a href="#JAVA中JSON和java对象之间的互转-。" class="headerlink" title="JAVA中JSON和java对象之间的互转 ##。"></a>JAVA中JSON和java对象之间的互转 ##。</h2><p>要想实现JSON和java对象之间的互转，需要借助第三方jar包，这里使用<code>json-lib</code>这个jar包，下载地址为：<a href="https://sourceforge.net/projects/json-lib/" target="_blank" rel="noopener">https://sourceforge.net/projects/json-lib/</a>，json-lib需要commons-beanutils-1.8.0.jar、commons-collections-3.2.1.jar、commons-lang-2.5.jar、commons-logging-1.1.1.jar、<a href="http://maven.ibiblio.org/maven2/net/sf/ezmorph/ezmorph/1.0.6/ezmorph-1.0.6.jar" target="_blank" rel="noopener">ezmorph-1.0.6.jar</a>五个包的支持，可以自行从<a href="https://www.findjar.com/index.x" target="_blank" rel="noopener">网上</a>下载，这里不再贴出下载地址。</p><p><code>json-lib</code>提供了几个类可以完成此功能，例，<code>JSONObject</code>、<code>JSONArray</code>。从类的名字上可以看出J<code>SONObject转化的应该是对象格式的</code>，而<code>JSONArray转化的则应该是数组对象（即，带[]形式）的</code>。<br><a id="more"></a></p><h2 id="一、java普通对象和json字符串的互转"><a href="#一、java普通对象和json字符串的互转" class="headerlink" title="一、java普通对象和json字符串的互转"></a>一、java普通对象和json字符串的互转</h2><pre><code>java对象--&gt;字符串</code></pre><p>java普通对象指的是java中的一个java bean，即一个实体类，如，<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cn.study.day3;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//年龄</span></span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">    <span class="comment">//住址</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String age)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">", address="</span>+ address + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面是我的一个普通的java实体类，看json-lib如何把它转化为字符串形式，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">convertObject</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Student stu=<span class="keyword">new</span> Student();</span><br><span class="line">    stu.setName(<span class="string">"JSON"</span>);</span><br><span class="line">    stu.setAge(<span class="string">"23"</span>);</span><br><span class="line">    stu.setAddress(<span class="string">"北京市西城区"</span>);</span><br><span class="line">    <span class="comment">//1、使用JSONObject</span></span><br><span class="line">    JSONObject json = JSONObject.fromObject(stu);</span><br><span class="line">    <span class="comment">//2、使用JSONArray</span></span><br><span class="line">    JSONArray array=JSONArray.fromObject(stu);</span><br><span class="line">    String strJson=json.toString();</span><br><span class="line">    String strArray=array.toString();</span><br><span class="line">    System.out.println(<span class="string">"strJson:"</span>+strJson);</span><br><span class="line">    System.out.println(<span class="string">"strArray:"</span>+strArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我定义了一个Student的实体类，然后分别使用了<code>JSONObject</code>和<code>JSONArray</code>两种方式转化为JSON字符串，下面看打印的结果:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strJson:&#123;&quot;address&quot;:&quot;北京市西城区&quot;,&quot;age&quot;:&quot;23&quot;,&quot;name&quot;:&quot;JSON&quot;&#125;</span><br><span class="line">strArray:[&#123;&quot;address&quot;:&quot;北京市西城区&quot;,&quot;age&quot;:&quot;23&quot;,&quot;name&quot;:&quot;JSON&quot;&#125;]</span><br></pre></td></tr></table></figure><p></p><p>从结果中可以看出两种方法都可以把java对象转化为JSON字符串，只是转化后的结构不同。</p><h2 id="JSON字符串转为java对象"><a href="#JSON字符串转为java对象" class="headerlink" title="JSON字符串转为java对象"></a>JSON字符串转为java对象</h2><p>上面说明了如何把java对象转化为JSON字符串，下面看如何把JSON字符串格式转化为java对象，</p><p>首先需要定义两种不同格式的字符串，需要使用<code>\</code>对双引号进行转义：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">jsonStrToJava</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义两种不同格式的字符串</span></span><br><span class="line">    String objectStr=<span class="string">"&#123;\"name\":\"JSON\",\"age\":\"24\",\"address\":\"北京市西城区\"&#125;"</span>;</span><br><span class="line">    String arrayStr=<span class="string">"[&#123;\"name\":\"JSON\",\"age\":\"24\",\"address\":\"北京市西城区\"&#125;]"</span>;</span><br><span class="line">    <span class="comment">//1、使用JSONObject</span></span><br><span class="line">    JSONObject jsonObject=JSONObject.fromObject(objectStr);</span><br><span class="line">    Student stu=(Student)JSONObject.toBean(jsonObject, Student.class);</span><br><span class="line">    <span class="comment">//2、使用JSONArray</span></span><br><span class="line">    JSONArray jsonArray=JSONArray.fromObject(arrayStr);</span><br><span class="line">    <span class="comment">//获得jsonArray的第一个元素</span></span><br><span class="line">    Object o=jsonArray.get(<span class="number">0</span>);</span><br><span class="line">    JSONObject jsonObject2=JSONObject.fromObject(o);</span><br><span class="line">    Student stu2=(Student)JSONObject.toBean(jsonObject2, Student.class);</span><br><span class="line">    System.out.println(<span class="string">"stu:"</span>+stu);</span><br><span class="line">    System.out.println(<span class="string">"stu2:"</span>+stu2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>打印结果为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stu:Student [name=JSON, age=24, address=北京市西城区]</span><br><span class="line">stu2:Student [name=JSON, age=24, address=北京市西城区]</span><br></pre></td></tr></table></figure><p></p><p>从上面的代码中可以看出，使用JSONObject可以轻松的把JSON格式的字符串转化为java对象，但是使用JSONArray就没那么容易了，因为它有“[]”符号，所以我们这里在获得了JSONArray的对象之后，取其第一个元素即我们需要的一个student的变形，然后使用JSONObject轻松获得。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/12f6a417/">json字符串与java对象互转</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Json </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>基于java操作的JSON入门教程</title>
      <link href="/blog/4d3e356a/"/>
      <url>/blog/4d3e356a/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:16 GMT+0800 (中国标准时间) --><p>原文：<a href="https://wenku.baidu.com/view/e80d83571711cc7931b7164c.html?from=search" target="_blank" rel="noopener">https://wenku.baidu.com/view/e80d83571711cc7931b7164c.html?from=search</a></p><h1 id="基于java操作的JSON入门教程"><a href="#基于java操作的JSON入门教程" class="headerlink" title="基于java操作的JSON入门教程"></a>基于java操作的JSON入门教程</h1><p>尽管有许多宣传关于XML如何拥有跨平台,跨语言的优势,然而,除非应用于Web Services,否则,在普通的Web应用中,开发者经常为XML的解析伤透了脑筋,无论是服务器端生成或处理XML,还是客户端用 Javascript解析XML,都常常导致复杂的代码,极低的开发效率。实际上,对于大多数Web应用来说,他们根本不需要复杂的XML来传输数据,XML的扩展性很少具有优势,许多AJAX应用甚至直接返回HTML片段来构建动态Web页面。<code>和返回XML并解析它相比,返回HTML片段大大降低了系统的复杂性,但同时缺少了一定的灵活性</code>。<br>现在,<code>JSON为Web应用开发者提供了另一种数据交换格式</code>。让我们来看看JSON到底是什么<code>,同XML或HTML片段相比,JSON提供了更好的简单性和灵活性</code>。</p><p>JSON数据格式解析和XML一样,<code>JSON也是基于纯文本的数据格式</code>。由于<code>JSON天生是为 Javascript准备的</code>,因此,JSON的数据格式非常简单,您可以用JSON传输一个简单的 String, Number,Boolean,也可以传输一个数组,或者一个复杂的Object对象。<br><a id="more"></a></p><h3 id="String-Number和Boolean的表示方式"><a href="#String-Number和Boolean的表示方式" class="headerlink" title="String,Number和Boolean的表示方式"></a>String,Number和Boolean的表示方式</h3><h3 id="String表示方式"><a href="#String表示方式" class="headerlink" title="String表示方式"></a>String表示方式</h3><p>String, Number和 Boolean用JSON表示非常简单。例如,用JSON表示一个简单的String abc其格式为:”abc”</p><p>除了字符<code>&quot;,/</code>和一些控制符(b,f,n,r,t)需要编码外,其他 Unicode字符可以直接输出</p><h3 id="Number表示方式"><a href="#Number表示方式" class="headerlink" title="Number表示方式"></a>Number表示方式</h3><p>一个 Number可以根据整型或浮点数表示如下:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12345(整数)</span><br><span class="line">-3.9e10(浮点数)</span><br></pre></td></tr></table></figure><p></p><p>这与绝大多数编程语言的表示方法一致。</p><h3 id="Boolean表示方式"><a href="#Boolean表示方式" class="headerlink" title="Boolean表示方式"></a>Boolean表示方式</h3><p>Boolean类型表示为tue或 false。此外, Javascript中的null被表示为null,注意true、 false和null都没有双引号,否则将被视为一个 String。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>JSON还可以表示一个<strong><code>数组对象</code>,使用<code>[]</code>包含所有元素,每个元素用逗号分隔,元素可以是任意的 Value,</strong>例如,以下数组包含了一个 String, Number, Boolean和一个null</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;abc&quot;, 12345, false, null]</span><br></pre></td></tr></table></figure><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p><strong>Object对象在JSON中是用<code>{}</code>包含一系列无序的<code>Key-Value(键值对)</code>表示的</strong>,实际上，此处的Object相当于Java中的 Map&lt;String, Object&gt; ，而不是Java的Class。<code>注意Key只能用 String表示</code>。</p><p>例如,一个 Address对象包含如下 Key-value<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">city: Beijing</span><br><span class="line">street: Chaoyang Road</span><br><span class="line">postcode:100025(整数)</span><br></pre></td></tr></table></figure><p></p><p>用JSon表示如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;city&quot;: &quot;Beijing&quot;, &quot;street&quot;: &quot;Chaoyang Road&quot;, &quot;postcode&quot;: 100025&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>其中Value也可以是另一个 Object或者数组</code>,因此,复杂的 Object可以嵌套表示。例如,一个 Person对象包含name和 address对象,可以表示如下:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;name&quot;:&quot;Michael&quot;,&quot;address&quot;:</span><br><span class="line">    &#123;&quot;city&quot; : &quot;Beijing&quot;,&quot;street&quot;:&quot;Chaoyang Road&quot;,&quot;postcode&quot;:100025&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Java-Script处理JSON数据"><a href="#Java-Script处理JSON数据" class="headerlink" title="Java Script处理JSON数据"></a>Java Script处理JSON数据</h2><p>上面介绍了如何用JSON表示数据,接下来,我们还要解决<code>如何在服务器端生成JSON格式的数据以便发送到客户端</code>,以及<code>客户端如何使用Javascript处理JSON格式的数据</code>。</p><p>我们先讨论如何在Web页面中用 Javascript处理JSON数据。我们通过一个简单的Javascript方法就能看到客户端如何将JSON数据表示给用户:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function handleJson()</span><br><span class="line">&#123;</span><br><span class="line"> var j = &#123;</span><br><span class="line">    &quot;name&quot;:&quot;Michael&quot;,&quot;address&quot;:</span><br><span class="line">        &#123;&quot;city&quot; : &quot;Beijing&quot;,&quot;street&quot;:&quot;Chaoyang Road&quot;,&quot;postcode&quot;:100025&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">document.write(j.name);</span><br><span class="line">document.write(j.address.city);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>假定服务器返回的JSON数据是上文的:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;name&quot;:&quot;Michael&quot;,&quot;address&quot;:</span><br><span class="line">    &#123;&quot;city&quot; : &quot;Beijing&quot;,&quot;street&quot;:&quot;Chaoyang Road&quot;,&quot;postcode&quot;:100025&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>只需将其赋值给一个 Javascript变量,就可以立刻使用该变量并更新页面中的信息了</code>,相比XML需要从DOM中读取各种节点而言,JSON的使用非常容易。我们需要做的仅仅是发送一个Ajax请求,然后将服务器返回的JSON数据赋值给一个变量即可。<strong>有许多Ajax框架早已包含了处理JSON数据的能力</strong>,例如 Prototype(一个流行的 Javascript库:<a href="http://prototypejs.org" target="_blank" rel="noopener">http://prototypejs.org</a>)提供了<code>evalJSON()</code>方法,能直接将服务器返回的JSON文本变成一个JavaScript变量：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">new Ajax.Request(&quot;http://url&quot;,&#123;</span><br><span class="line">method:&quot;get&quot;,</span><br><span class="line">onSuccess:function(transport)&#123;</span><br><span class="line">var json=transport.responseText.evalJSON();</span><br><span class="line">//TODO：document.write(json.xxx);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><h2 id="服务器端输出JSON格式数据"><a href="#服务器端输出JSON格式数据" class="headerlink" title="服务器端输出JSON格式数据"></a>服务器端输出JSON格式数据</h2><p>下面我们讨论如何在服务器端输出JSON格式的数据。以Java为例,我们将演示将个Java对象编码为JSON格式的文本。</p><h3 id="Java-String对象转为JSON"><a href="#Java-String对象转为JSON" class="headerlink" title="Java String对象转为JSON"></a>Java String对象转为JSON</h3><p>将 String对象编码为JSON格式时,只需处理好特殊字符即可。另外,必须用双引号(<code>&quot;</code>)而非单引号(<code>&#39;</code>)表示字符串:<br>代码太长了，我懒得抄，略</p><h3 id="Java-Number转为JSON"><a href="#Java-Number转为JSON" class="headerlink" title="Java Number转为JSON"></a>Java Number转为JSON</h3><p>将 Number表示为JSON就容易得多,利用Java的多态,我们可以处理 Integer,Long,Float等多种 Number格式:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static String number2JSON(Number number)</span><br><span class="line">&#123;</span><br><span class="line">    return number.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="Java-Boolean对象转为JSON格式"><a href="#Java-Boolean对象转为JSON格式" class="headerlink" title="Java Boolean对象转为JSON格式"></a>Java Boolean对象转为JSON格式</h3><p>Boolean类型也可以直接通过 toString()方法得到JSON的表示<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static String boolean2JSON(Boolean bool)</span><br><span class="line">&#123;</span><br><span class="line">    return bool.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="Java数组转为JSON格式"><a href="#Java数组转为JSON格式" class="headerlink" title="Java数组转为JSON格式"></a>Java数组转为JSON格式</h3><p>要将数组编码为JSON格式,可以<code>通过循环将每一个元素编码</code>:</p><p>代码长，不抄。</p><h3 id="Map-lt-String-Object-gt-编码为JSON格式"><a href="#Map-lt-String-Object-gt-编码为JSON格式" class="headerlink" title="Map&lt;String, Object&gt;编码为JSON格式"></a>Map&lt;String, Object&gt;编码为JSON格式</h3><p>最后,我们需要将 Map&lt;String, Object&gt;编码为JSON格式,<code>因为 Javascript的 Object实际上对应的是Java的 Map&lt;String, Object&gt;</code>。该方法如下：</p><p>代码略，以后再补上，现在先了解个大的框架。</p><h3 id="统一处理任意的Java对象"><a href="#统一处理任意的Java对象" class="headerlink" title="统一处理任意的Java对象"></a>统一处理任意的Java对象</h3><p>为了统一处理任意的Java对象,我们编写一个入口方法 tolson( Object),能够将任意的Java对象编码为JSON格式:</p><p>懒得敲，略啊，感觉这篇文章也是抄的人家博客的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>JSON已经是 Javascript标准的一部分。目前,主流的浏览器对JSON支持都非常完普。应用JSON我们可以从XML的解析中摆脱出来,对那些应用Ajax的Web2.0网站来说JSON确实是目前最灵活的轻量级方案。</p><h2 id="读后感"><a href="#读后感" class="headerlink" title="读后感"></a>读后感</h2><p>没有找到我想要知道的东西，但是了解了一些JSON的知识。我还是多找找博客看看。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/4d3e356a/">基于java操作的JSON入门教程</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Json </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java调用百度文字识别</title>
      <link href="/blog/29121dfd/"/>
      <url>/blog/29121dfd/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="加入GUI"><a href="#加入GUI" class="headerlink" title="加入GUI"></a>加入GUI</h2><p>加入编写GUI,加入Java截图功能，截图后自动保存，然后调用百度识图API,并将从处理结果中的JSON字符串中，取出识别的数据。</p><h2 id="加入全局热键"><a href="#加入全局热键" class="headerlink" title="加入全局热键"></a>加入全局热键</h2><p>上面已经完成了大致的功能，但是缺点是每次都要调用一次。<br>我不想每次都调用一次程序，而是打开一次程序，后面可以多次截图处理。工作结束后再关掉程序。</p><p>代码：</p><h3 id="ScreenShotOCR程序入口类"><a href="#ScreenShotOCR程序入口类" class="headerlink" title="ScreenShotOCR程序入口类"></a>ScreenShotOCR程序入口类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> release.ocr.baidu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.AWTException;</span><br><span class="line"><span class="keyword">import</span> java.awt.EventQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScreenShotOCR</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> ScreenShotWindow ssw;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">EventQueue.invokeLater(<span class="keyword">new</span> Runnable()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">ssw = <span class="keyword">new</span> ScreenShotWindow();</span><br><span class="line">ssw.setVisible(<span class="keyword">true</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (AWTException e)</span><br><span class="line">&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 回调函数，使得当前窗口不可见。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">notVisible</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ssw.setVisible(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">visiable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ssw.setVisible(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="菜单窗口"><a href="#菜单窗口" class="headerlink" title="菜单窗口"></a>菜单窗口</h3><p>这里不用再次添加按钮，所以这个类不用改变。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> release.ocr.baidu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.BorderLayout;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JButton;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JToolBar;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JWindow;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 操作窗口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToolsWindow</span> <span class="keyword">extends</span> <span class="title">JWindow</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">private</span> ScreenShotWindow parent;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ToolsWindow</span><span class="params">(ScreenShotWindow parent, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.parent = parent;</span><br><span class="line"><span class="keyword">this</span>.init();</span><br><span class="line"><span class="keyword">this</span>.setLocation(x, y);</span><br><span class="line"><span class="keyword">this</span>.pack();</span><br><span class="line"><span class="keyword">this</span>.setVisible(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.setLayout(<span class="keyword">new</span> BorderLayout());</span><br><span class="line">JToolBar toolBar = <span class="keyword">new</span> JToolBar(<span class="string">"Java 截图"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存按钮</span></span><br><span class="line">JButton saveButton = <span class="keyword">new</span> JButton(<span class="string">"保存"</span>);</span><br><span class="line">saveButton.addActionListener(<span class="keyword">new</span> ActionListener()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 保存截图</span></span><br><span class="line">parent.saveImage();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e1)</span><br><span class="line">&#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">toolBar.add(saveButton);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 百度识图按钮</span></span><br><span class="line">JButton baiduOCRButton = <span class="keyword">new</span> JButton(<span class="string">"文字识别"</span>);</span><br><span class="line">baiduOCRButton.addActionListener(<span class="keyword">new</span> ActionListener()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 保存截图</span></span><br><span class="line">parent.baiduOCR();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e1)</span><br><span class="line">&#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">toolBar.add(baiduOCRButton);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭按钮</span></span><br><span class="line">JButton closeButton = <span class="keyword">new</span> JButton(<span class="string">"退出"</span>);</span><br><span class="line">closeButton.addActionListener(<span class="keyword">new</span> ActionListener()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">System.exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">toolBar.add(closeButton);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.add(toolBar, BorderLayout.NORTH);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="ScreenShotWindow截图窗口"><a href="#ScreenShotWindow截图窗口" class="headerlink" title="ScreenShotWindow截图窗口"></a>ScreenShotWindow截图窗口</h3><p>ScreenShotWindow中加入热键相关的代码：</p><ul><li><p>添加字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 热键相关设置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"><span class="comment">// 定义热键标识，用于在设置多个热键时，在事件处理中区分用户按下的热键</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FUNC_KEY_MARK = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXIT_KEY_MARK = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p>ScreenShotWindow构造函数中加入热键事件监听处理函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第2步：注册热键，第一个参数表示该热键的标识，第二个参数表示组合键，如果没有则为0，第三个参数为定义的主要热键</span></span><br><span class="line">JIntellitype.getInstance().registerHotKey(FUNC_KEY_MARK,JIntellitype.MOD_ALT, (<span class="keyword">int</span>) <span class="string">'V'</span>);</span><br><span class="line">JIntellitype.getInstance().registerHotKey(EXIT_KEY_MARK,JIntellitype.MOD_ALT, (<span class="keyword">int</span>) <span class="string">'Q'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第3步：添加热键监听器</span></span><br><span class="line">JIntellitype.getInstance().addHotKeyListener(<span class="keyword">new</span> HotkeyListener()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onHotKey</span><span class="params">(<span class="keyword">int</span> markCode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (markCode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//按下alt+v快捷键表示宝表示打开截图窗口，这样可以开始截图</span></span><br><span class="line"><span class="keyword">case</span> FUNC_KEY_MARK :</span><br><span class="line"><span class="comment">// showMessage();</span></span><br><span class="line">ScreenShotOCR.visiable();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// alt+q快捷键表示退出程序</span></span><br><span class="line"><span class="keyword">case</span> EXIT_KEY_MARK :</span><br><span class="line">System.exit(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> release.ocr.baidu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.AWTException;</span><br><span class="line"><span class="keyword">import</span> java.awt.Color;</span><br><span class="line"><span class="keyword">import</span> java.awt.Dimension;</span><br><span class="line"><span class="keyword">import</span> java.awt.Graphics;</span><br><span class="line"><span class="keyword">import</span> java.awt.Image;</span><br><span class="line"><span class="keyword">import</span> java.awt.Rectangle;</span><br><span class="line"><span class="keyword">import</span> java.awt.Robot;</span><br><span class="line"><span class="keyword">import</span> java.awt.Toolkit;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.MouseAdapter;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.MouseEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.MouseMotionAdapter;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.RescaleOp;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JFileChooser;</span><br><span class="line"><span class="keyword">import</span> javax.swing.JWindow;</span><br><span class="line"><span class="keyword">import</span> javax.swing.filechooser.FileNameExtensionFilter;</span><br><span class="line"><span class="keyword">import</span> javax.swing.filechooser.FileSystemView;</span><br><span class="line"><span class="keyword">import</span> com.melloware.jintellitype.HotkeyListener;</span><br><span class="line"><span class="keyword">import</span> com.melloware.jintellitype.JIntellitype;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 截图矩形窗口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScreenShotWindow</span> <span class="keyword">extends</span> <span class="title">JWindow</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> orgx, orgy, endx, endy;</span><br><span class="line"><span class="keyword">private</span> BufferedImage image = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> BufferedImage tempImage = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> BufferedImage saveImage = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> ToolsWindow tools = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 热键相关设置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"><span class="comment">// 定义热键标识，用于在设置多个热键时，在事件处理中区分用户按下的热键</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FUNC_KEY_MARK = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXIT_KEY_MARK = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScreenShotWindow</span><span class="params">()</span> <span class="keyword">throws</span> AWTException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 获取屏幕尺寸</span></span><br><span class="line">Dimension d = Toolkit.getDefaultToolkit().getScreenSize();</span><br><span class="line"><span class="comment">// 设置窗口显示大小</span></span><br><span class="line"><span class="keyword">this</span>.setBounds(<span class="number">0</span>, <span class="number">0</span>, d.width, d.height);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 截取整个屏幕</span></span><br><span class="line">Robot robot = <span class="keyword">new</span> Robot();</span><br><span class="line">image = robot</span><br><span class="line">.createScreenCapture(<span class="keyword">new</span> Rectangle(<span class="number">0</span>, <span class="number">0</span>, d.width, d.height));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置鼠标监听事件</span></span><br><span class="line"><span class="keyword">this</span>.addMouseListener(<span class="keyword">new</span> MouseAdapter()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 鼠标按下</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mousePressed</span><span class="params">(MouseEvent e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 鼠标松开时记录结束点坐标，并隐藏操作窗口</span></span><br><span class="line">orgx = e.getX();</span><br><span class="line">orgy = e.getY();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tools != <span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">tools.setVisible(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseReleased</span><span class="params">(MouseEvent e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 鼠标松开时，显示操作窗口</span></span><br><span class="line"><span class="keyword">if</span> (tools == <span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">tools = <span class="keyword">new</span> ToolsWindow(ScreenShotWindow.<span class="keyword">this</span>, e.getX(),</span><br><span class="line">e.getY());</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">tools.setLocation(e.getX(), e.getY());</span><br><span class="line">&#125;</span><br><span class="line">tools.setVisible(<span class="keyword">true</span>);</span><br><span class="line">tools.toFront();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 鼠标移动和拖动监听事件处理函数</span></span><br><span class="line"><span class="keyword">this</span>.addMouseMotionListener(<span class="keyword">new</span> MouseMotionAdapter()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseDragged</span><span class="params">(MouseEvent e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 鼠标拖动时，记录坐标并重绘窗口</span></span><br><span class="line">endx = e.getX();</span><br><span class="line">endy = e.getY();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 临时图像，用于缓冲屏幕区域放置屏幕闪烁</span></span><br><span class="line">Image tempImage2 = createImage(ScreenShotWindow.<span class="keyword">this</span>.getWidth(),</span><br><span class="line">ScreenShotWindow.<span class="keyword">this</span>.getHeight());</span><br><span class="line">Graphics g = tempImage2.getGraphics();</span><br><span class="line">g.drawImage(tempImage, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">int</span> x = Math.min(orgx, endx);</span><br><span class="line"><span class="keyword">int</span> y = Math.min(orgy, endy);</span><br><span class="line"><span class="keyword">int</span> width = Math.abs(endx - orgx) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> height = Math.abs(endy - orgy) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 加上1防止width或height0</span></span><br><span class="line">g.setColor(Color.BLUE);</span><br><span class="line">g.drawRect(x - <span class="number">1</span>, y - <span class="number">1</span>, width + <span class="number">1</span>, height + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 减1加1都了防止图片矩形框覆盖掉</span></span><br><span class="line">saveImage = image.getSubimage(x, y, width, height);</span><br><span class="line">g.drawImage(saveImage, x, y, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">ScreenShotWindow.<span class="keyword">this</span>.getGraphics().drawImage(tempImage2, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">ScreenShotWindow.<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第2步：注册热键，第一个参数表示该热键的标识，第二个参数表示组合键，如果没有则为0，第三个参数为定义的主要热键</span></span><br><span class="line"> JIntellitype.getInstance().registerHotKey(FUNC_KEY_MARK,</span><br><span class="line"> JIntellitype.MOD_ALT, (<span class="keyword">int</span>) <span class="string">'V'</span>);</span><br><span class="line">JIntellitype.getInstance().registerHotKey(EXIT_KEY_MARK,</span><br><span class="line">JIntellitype.MOD_ALT, (<span class="keyword">int</span>) <span class="string">'Q'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第3步：添加热键监听器</span></span><br><span class="line">JIntellitype.getInstance().addHotKeyListener(<span class="keyword">new</span> HotkeyListener()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onHotKey</span><span class="params">(<span class="keyword">int</span> markCode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (markCode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//按下alt+v快捷键表示</span></span><br><span class="line"><span class="keyword">case</span> FUNC_KEY_MARK :</span><br><span class="line"><span class="comment">// showMessage();</span></span><br><span class="line">ScreenShotOCR.visiable();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// alt+q快捷键表示退出程序</span></span><br><span class="line"><span class="keyword">case</span> EXIT_KEY_MARK :</span><br><span class="line">System.exit(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(Graphics g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">RescaleOp ro = <span class="keyword">new</span> RescaleOp(<span class="number">0.8f</span>, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">tempImage = ro.filter(image, <span class="keyword">null</span>);</span><br><span class="line">g.drawImage(tempImage, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 保存图像到文件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveImage</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">JFileChooser jfc = <span class="keyword">new</span> JFileChooser();</span><br><span class="line">jfc.setDialogTitle(<span class="string">"保存"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件过滤器，用户过滤可选择文件</span></span><br><span class="line">FileNameExtensionFilter filter = <span class="keyword">new</span> FileNameExtensionFilter(<span class="string">"PNG"</span>,</span><br><span class="line"><span class="string">"png"</span>);</span><br><span class="line">jfc.setFileFilter(filter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个默认文件（此文件会生成到桌面上）</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyymmddHHmmss"</span>);</span><br><span class="line">String fileName = sdf.format(<span class="keyword">new</span> Date());</span><br><span class="line">File filePath = FileSystemView.getFileSystemView().getHomeDirectory();</span><br><span class="line">File defaultFile = <span class="keyword">new</span> File(</span><br><span class="line">filePath + File.separator + fileName + <span class="string">".png"</span>);</span><br><span class="line">jfc.setSelectedFile(defaultFile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> flag = jfc.showSaveDialog(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> (flag == JFileChooser.APPROVE_OPTION)</span><br><span class="line">&#123;</span><br><span class="line">File file = jfc.getSelectedFile();</span><br><span class="line">String path = file.getPath();</span><br><span class="line"><span class="comment">// 检查文件后缀，放置用户忘记输入后缀或者输入不正确的后缀</span></span><br><span class="line"><span class="keyword">if</span> (!(path.endsWith(<span class="string">".png"</span>) || path.endsWith(<span class="string">".PNG"</span>)))</span><br><span class="line">&#123;</span><br><span class="line">path += <span class="string">".png"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line">ImageIO.write(saveImage, <span class="string">"png"</span>, <span class="keyword">new</span> File(path));</span><br><span class="line">System.exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用百度识图</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">baiduOCR</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line">ImageIO.write(saveImage, <span class="string">"png"</span>, <span class="keyword">new</span> File(<span class="string">"1.png"</span>));</span><br><span class="line">Thread baiduOCR = <span class="keyword">new</span> Thread(<span class="keyword">new</span> BaiduOCR(<span class="string">"1.png"</span>, <span class="keyword">this</span>));</span><br><span class="line">baiduOCR.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Exit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">System.exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新的问题，程序不能很好的退出，而且让截图窗口显示的方式并不会重新截图，这样我已经阅读到一页文章了，但是窗口中保存的还是前页的截图，所以，应该重新初始化话截图才对。也就是说是使用线程来做才对。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/29121dfd/">Java调用百度文字识别</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 我的软件 </category>
          
          <category> 百度文字识别 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java网络编程第4版 派生Thread</title>
      <link href="/blog/dd928b3e/"/>
      <url>/blog/dd928b3e/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><p>考虑编写一个程序来计算多个文件的安全散列算法(SHA)摘要。在很大程度上,这是<code>一个受限于IO的程序(也就是说,它的速度会受到从磁盘读取文件所花费时间的限制</code>)。如果将它编写为一个标准的程序,串行地处理这些文件,程序就<code>会花费大量时间等待磁盘驱动器返回数据</code>。这个限制对于网络程序尤其明显:<code>程序运行的速度要比网络提供输入的速度快。因此程序的大量时间都耗费在阻塞中</code>。这些时间本可以被其他线程所用,可以处理其他输入源或者完成不依赖于慢速输入的操作(不是所有多线程程序都有这个特点。有时即使并没有线程有大量空闲时间可以分配给其他线程,起码采用多线程设计程序会更容易,可以将程序分解为多个线程,分别执行独立的操作</p><p>示例3-1是 Thread的子类,它的run()方法将为指定文件计算一个256位的SHA-2消息摘要。为此要用一个 DigestInputStream读取这个文件。这个过滤器流在读取文件时会计算一个加密散列函数。读取结束时,可以从 digest()方法得到这个散列。(<code>这个代码不去了解也罢</code>)</p><p>示例3-1: DigestThread</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> javax.xml.bind.*; <span class="comment">// for DatatypeConverter; requires Java 6 or JAXB 1.0</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DigestThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String filename;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DigestThread</span><span class="params">(String filename)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filename = filename;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            FileInputStream in = <span class="keyword">new</span> FileInputStream(filename);</span><br><span class="line">            MessageDigest sha = MessageDigest.getInstance(<span class="string">"SHA-256"</span>);</span><br><span class="line">            DigestInputStream din = <span class="keyword">new</span> DigestInputStream(in, sha);</span><br><span class="line">            <span class="keyword">while</span> (din.read() != -<span class="number">1</span>) ;</span><br><span class="line">            din.close();</span><br><span class="line">            <span class="keyword">byte</span>[] digest = sha.digest();</span><br><span class="line">            StringBuilder result = <span class="keyword">new</span> StringBuilder(filename);</span><br><span class="line">            result.append(<span class="string">": "</span>);</span><br><span class="line">            result.append(DatatypeConverter.printHexBinary(digest));</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            System.err.println(ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException ex) &#123;</span><br><span class="line">            System.err.println(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String filename : args) </span><br><span class="line">        &#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> DigestThread(filename);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main()方法从命令行中读取文件名,<code>针对每个文件名启动一个新的 DigestThread</code>。这个<code>线程的工作实际上在run()方法中完成</code>。这里,由一个 DigestInputstream读取文件,然后结果摘要以十六进制编码方式显示到 System.out。注意,首先在一个本地StringBuffer变量result中建立线程的整个输出,再用一次方法调用将它显示在控制台上。更明显的一种方法是使用 System.out.print()一次显示一部分,但这里不采取这种方法。其原因稍后讨论。</p><p><strong>由于run()方法的签名是固定的,所以无法向其传递参数或从中返回值</strong>。因此,<strong>需要其他方法向线程传递信息和从中获得信息。**</strong>传递信息最简单的方法是向构造函数传递参数**,这会设置 Thread子类中的字段,如前面所示。</p><p><strong>由于<code>线程的异步特性</code>,初要<code>获得线程的信息并传回最初的调用线程</code>,这会更加困难</strong>。示例3-1回避了这个问题,它没有将任何信息传回调用线程,只是把结果显示在System.out上。不过,大多数情况下,你会希望把信息传递给程序的其他部分。<strong>可以把计算结果存储于一个字段,并提供一个获取方法返回这个字段的值</strong>。但是<code>如何知道这个值的计算什么时候结束呢</code>?这非常棘手,本章后面将更详细地进行讨论</p><hr><p>警告:如果<code>对Thread派生子类,就应当只覆盖run(),而不要覆盖其他方法!</code>Thread类的其他各个方法(如 start()、 interrupt()、join()、 sleep()等)都有非常特定的语义,<code>它们与虚拟机的交互很难在你自己的代码中重新实现</code>。应当覆盖run(),并根据需要提供额外的构造函数和其他方法,但<code>不要替换 Thread的任何其他标准方法</code>。</p><hr><p>本文链接: <a href="https://www.lansheng.net.cn/blog/dd928b3e/">java网络编程第4版 派生Thread</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第3章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java网络编程第4版 运行线程</title>
      <link href="/blog/21c4dfa5/"/>
      <url>/blog/21c4dfa5/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><p><code>为了启动一个新线程在虚拟机中运行,要构造一个 Thread类的一个实例,调用它的start()方法</code>,如下所示:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread t=<span class="keyword">new</span> Thread();</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure><p></p><p>当然,这个线程没什么意思,因为它什么都没有做。<code>要让线程完成一些操作,可以对Thread类派生子类,覆盖其run()方法。或者实现 Runnablef接口,将 Runnable对象传递给Thread构造函数</code>。我<code>一般会选择第二种方法,因为这样可以更清楚地将线程完成的任务与线程本身区分开</code>,但是在本书以及其他地方,你会看到这两种技术都在使用。不论采用哪一种方法,<code>关键都在于run()方法</code>,它的签名( signature)是:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> vold <span class="title">run</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p></p><p><code>你应当把线程要做的所有工作都放在这个run()方法中</code>。这个方法可以调用其他方法;可以构造其他对象;甚至可以生成其他线程。不过,线程要这里启动,并在这里结束。<code>当run()方法完成时,线程也就消失了</code>。事实上,run()对于线程就像main()方法对于非线程化传统程序的作用一样。<code>单线程程序会在main()方法返回时退出。多线程程序会在main()方法以及所有非守护线程( nondaemon thread)都返回时才退出</code>(守护线程完成后台任务,如垃圾回收,它们并不阻止虚拟机退出)。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/21c4dfa5/">java网络编程第4版 运行线程</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第3章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java网络编程第4版 前言</title>
      <link href="/blog/6a990816/"/>
      <url>/blog/6a990816/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:19 GMT+0800 (中国标准时间) --><p>回想网络从前的好日子,大约20世纪90年代初期,我们没有Web,没有HTTP,也没有图形界面浏览器。不过,我们有 Usenet新闻、FTP和命令行接口,这一切是那么让人怀念!但是尽管旧时光很美好,却也存在一些问题。例如,当使用 Kermit通过2400b/s调制解调器从热门的FTP网站下裁几K字节的自由软件时,可能经常会遇到这样的错误消息<br><img src="http://pefsyzdwh.bkt.clouddn.com/18-9-11/87648010.jpg" alt=""><br>事实上,在 Internet只有几百万用户而不是数十亿用户的时候,我们远比现在更容易碰上超负荷的拥塞网站。<code>问题在于,大多数FTP服务器会为每个连接创建(fork)一个新的进程</code>(也就是说,100个并发用户意味着要处理100个额外的进程)。<code>由于进程是相当重量级的,太多进程会很快让服务器吃不消</code>。问题不在于机器不够强大,或者网络速度不够快,而是因为FTP服务器实现得太差。如果不是每个连接都需要一个新的进程,完全可以为更多的并发用户提供服务。</p><p>早期Web服务器也有这个问题,不过这个问题由于<code>HTTP连接的短暂特性</code>而有所掩盖。由于Web页面和嵌入的图片一般很小(至少与通常通过FTP获取的软件包相比要小得多),也由于<code>Web浏览器在获取各个文件后会“挂起”连接</code>,而不是一次保持数分钟或几小时的连接,所以Web用户不会像FTP用户那样对服务器施加太多负担。不过,随着使用量的增长,Web服务器的性能仍会下降。根本问题在于,很容易编写代码将每个入站连接和每个新任务都当作单独的进程来处理(至少在UNIX下是如此),这种解决方案将无法扩展。等到服务器要处理成千上万个同时的连接时,性能就会变得像爬行一样慢了。<br><img src="http://pefsyzdwh.bkt.clouddn.com/18-9-11/87648010.jpg" alt=""><br>这个问题<code>至少有两种解决方案</code>。<code>第一种是重用进程,而不是创建新的进程</code>。<code>服务器启动时,就创建固定数量的进程(比如300个)来处理请求</code>。入站请求将放入一个队列。每个进程从队列中删除一个请求,为这个请求提供服务,然后返回到队列来得到下一个请求。尽管仍有300个单独的进程在运行,但是<code>由于避免了建立和销毁进程的所有开销</code>,现在这300个进程可以完成1000个进程的任务。这个数目是粗略估计的。你的实际情况可能有所出入,尤其是当你的服务器还没有达到一定的处理规模,即还没有遭遇可扩展性问题的时侯,到底能有多少获益并不确定。不过,不论不生成新进程会有什么好处,起码重用旧的进程总会有更好的表现。</p><p>这个问题的<code>第二种解决方案</code>是,<code>使用轻量级的线程来处理连接,而不是重量级的进程</code>。虽然每个单独的进程都有自己的一块内存,<strong>但线程在资源使用上更宽松,因为它们会<code>共享内存</code></strong>。<code>使用线程来代替进程,可以再让你的服务器性能提升三倍</code>。再结合<code>使用可重用线程池</code>(而不是可重用进程池),在同样的硬件和网络连接条件下,服务器的运行可以快9倍多!<code>在服务器硬件上运行多个不同的线程,其影响是相对最小的</code>,因为这些线程都在一个进程中运行。如果并发线程数达到4000至20000时,大多数Java虚拟机可能会由于内存耗尽而无法承受。不过,<code>通过使用线程池而不是为每个连接生成新线程</code>,服务器每分钟就可以用不到100个线程来处理数千个短连接。</p><hr><p>线程的替代方法<code>如果一个应用同时需要数千个持续很长时间的连接</code>(这种应用相当少见),<code>就要考虑异步I/O而不是线程。</code>我们将在第11章介绍这个内容。选择器支持一个线程查询一组 socket,找出哪些 socket t已经准备就绪可以读/写数据,然后顺序地处理这些准备好的 socket。在这种情况下,必须基于通道和缓冲区来设计I/O而不是流。</p><p>由于现代虚拟机和操作系统中线程可以提供很高的性能,而且构建一个基于线程的服务器相对简单,所以开始时总会考虑米用基于线程的设计,直到遇到难以逾越的困难。如果确实遇到麻烦,应该考虑<code>将应用分解到多个冗余的服务器上,而不要完全依仗一个服务器</code>上的3倍性能提升。</p><p>当然,分解又会带来相应的设计问题,特别是在一致性方面,这是单个系统中没有的问题。不过,与利用单个系统相比,不论实现的效率如何,这样确实可以提供更大的可扩展性和冗余性。</p><hr><p>遗憾的是,这种性能的提升并不是没有代价的,它<code>会增加程序的复杂性</code>。特别是多线程服务器(和其他多线程程序)要求程序员解决一些问题,而对于单线程程序而言原本不存在这些问题,<code>尤其是安全性和活动性问题</code>。<code>因为不同的线程共享相同的内存,一个线程完全有可能会破坏另一个线程使用的变量和数据结构</code>。这就类似于如果一个程序在没有内存保护机制的操作系统(如 Windows95)中运行,则有可能会破坏整个系统。因此,不同线程必须非常注意当时使用的资源。<code>一般来讲,每个线程只有在确保资源不会改变或者它有独占访问权的时候才可以使用某个资源</code>。不过,也可能两个线程太过小心，每个线程都在等待对资源的独占访问权,却永远都得不到。这会导致<code>死锁</code>,在这种情况下两个线程都在等待另一个线程所占有的资源。在没有得到另一个线程所保留的资源时,两个线程都不会继续处理,但同时都不愿意放弃已经占有的资源。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/6a990816/">java网络编程第4版 前言</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
          <category> 第3章 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Windows地址格式和Linux地址格式相互转换</title>
      <link href="/blog/99823945/"/>
      <url>/blog/99823945/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ul><li>我想从Windows中的文件资源管理器中复制路径，用java代码转成Linux格式，然后粘贴到git-bash中，这样在git-bash中可以快速的进入这个目录。</li><li>或者从git-bash中复制路径，用java代码转换成Windows格式，这样我可以用文件资源管理器快速的打开这个目录或者文件。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><a id="more"></a><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> linux.path.windows.path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> clipboard.util.SysClipboardUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangePathFormat</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">String path=SysClipboardUtil.getSysClipboardText();</span><br><span class="line">System.out.println(path);</span><br><span class="line"><span class="comment">///d/Blog/bolg5</span></span><br><span class="line"><span class="keyword">if</span>(path.matches(<span class="string">"/[a-zA-Z](?:/.+)*"</span>))</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"Linux地址表示方式:"</span>+path);</span><br><span class="line"><span class="comment">//D:\Blog\bolg5</span></span><br><span class="line">path=path.replaceFirst(<span class="string">"/([a-zA-Z])"</span>, <span class="string">"$1:"</span>);</span><br><span class="line">path=path.replace(<span class="string">"/"</span>, <span class="string">"\\"</span>);</span><br><span class="line">System.out.println(<span class="string">"转为window类型："</span>+path);</span><br><span class="line">SysClipboardUtil.setSysClipboardText(path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//d:\Blog\bolg5</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(path.matches(<span class="string">"[a-zA-Z]:(?:\\\\.+)*"</span>))</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"windows地址表示方式:"</span>+path);</span><br><span class="line">path=path.replaceFirst(<span class="string">"([a-zA-Z]):"</span>, <span class="string">"/$1"</span>);</span><br><span class="line">path=path.replace(<span class="string">"\\"</span>, <span class="string">"/"</span>);</span><br><span class="line">System.out.println(<span class="string">"转为Linux类型："</span>+path);</span><br><span class="line">SysClipboardUtil.setSysClipboardText(path);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p><a href="https://blog.csdn.net/qq_21808961/article/details/80671259" target="_blank" rel="noopener">SysClipboardUtil</a></p><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><ul><li>复制路径</li><li>然后调用上面的代码，程序会判断，如果是Linux格式的路径，就转换为Windows路径格式，如果是Windows路径就转换为Linux路径格式。</li></ul><p>本文链接: <a href="https://www.lansheng.net.cn/blog/&#39;99823945&#39;/">Windows地址格式和Linux地址格式相互转换</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 我的软件 </category>
          
          <category> Windows系统相关工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Math Processing Error</title>
      <link href="/blog/fb569c24/"/>
      <url>/blog/fb569c24/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>最近mathjax渲染LaTex公式时，公式老是变成：<code>[Math Processing Error]</code>。我很无奈。<br>解决方法：<br>打开主题配置文件，找到<code>mathjax</code>下面的<code>cdn:</code>配置项，换一个cdn路径就行了。<br>重新更换cdn之后就可以渲染了。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/fb569c24/">[Math Processing Error]</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> 使用MathJax公式 </category>
          
          <category> 报错 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hexo 写博客时在文章中添加到其他文章的超链接</title>
      <link href="/blog/9575d743/"/>
      <url>/blog/9575d743/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>我希望在文章首部添加一些锚点，这样可以在这篇文章之间跳转，例如从文章首部跳转到文章尾部。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>先在本地服务器打开这篇文章，然后复制锚点的链接，然后去掉站点的地址，使用绝对地址即可。<br><a id="more"></a><br>例如，我现在想跳转到上面的问题描述部分<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:4000/2018/09/03/Hexo搭建博客/写文章/Hexo 写博客跳转到其他页面/#问题描述</span><br></pre></td></tr></table></figure><p></p><p>这里用的是绝对地址，我们需要使用相对地址。去掉上面的<code>localhost:4000</code>就行了，得到相对地址：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[跳转到问题描述](/2018/09/03/Hexo搭建博客/写文章/Hexo 写博客跳转到其他页面/#问题描述)</span><br></pre></td></tr></table></figure><p></p><p>效果如下：<br><a href="/2018/09/03/Hexo搭建博客/写文章/Hexo 写博客跳转到其他页面/#问题描述">跳转到问题描述</a></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/9575d743/">Hexo 写博客时在文章中添加到其他文章的超链接</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> 写文章技巧 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>LaTex牛顿莱布尼兹上下限的问题</title>
      <link href="/blog/161696a3/"/>
      <url>/blog/161696a3/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>正确的写法先是：<code>\left.</code>注意left后面要有点号<code>.</code>然后是其他公式，然后是：<code>\right|</code><br>如下所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$L[t]=L[\int 1(t)dt]=\frac&#123;1&#125;&#123;s&#125;\cdot\frac&#123;1&#125;&#123;s&#125;+\left. \frac&#123;1&#125;&#123;s&#125;t \right|_&#123;t=0&#125;=\frac&#123;1&#125;&#123;s^2&#125;$$</span><br></pre></td></tr></table></figure><p></p><p>效果：<br>$$L[t]=L[\int 1(t)dt]=\frac{1}{s}\cdot\frac{1}{s}+\left. \frac{1}{s}t \right|_{t=0}=\frac{1}{s^2}$$<br>如果没有写点号的话，会显示不正确：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$L[t]=L[\int 1(t)dt]=\frac&#123;1&#125;&#123;s&#125;\cdot\frac&#123;1&#125;&#123;s&#125;+\left \frac&#123;1&#125;&#123;s&#125;t \right|_&#123;t=0&#125;=\frac&#123;1&#125;&#123;s^2&#125;$$</span><br></pre></td></tr></table></figure><p></p><p>效果：<br>$$L[t]=L[\int 1(t)dt]=\frac{1}{s}\cdot\frac{1}{s}+\left \frac{1}{s}t \right|_{t=0}=\frac{1}{s^2}$$</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/161696a3/">LaTex牛顿莱布尼兹上下限的问题</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> 使用MathJax公式 </category>
          
          <category> LaTex语法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>箭头_箭头上下标</title>
      <link href="/blog/9d116ea/"/>
      <url>/blog/9d116ea/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>除了作为上下标之外，箭头还用于表示过程。amsmath的<code>\xleftarrow</code>和<code>\xrightarrow</code>命令可以为箭头增加上下标：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\[ a\xleftarrow&#123;x+y+z&#125; b \]</span><br><span class="line">\[ c\xrightarrow[x&lt;y]&#123;a*b*c&#125;d \]</span><br></pre></td></tr></table></figure><p></p><p>$$<br>a\xleftarrow{x+y+z} b \\<br>c\xrightarrow[x&lt;y]{a*b*c}d<br>$$</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/9d116ea/">箭头_箭头上下标</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> 使用MathJax公式 </category>
          
          <category> LaTex语法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>巨算符--连乘符号</title>
      <link href="/blog/525c11d8/"/>
      <url>/blog/525c11d8/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>连乘符号($\prod$)用:<code>\prod</code>表示</p><h3 id="修改上下标的显示位置"><a href="#修改上下标的显示位置" class="headerlink" title="修改上下标的显示位置"></a>修改上下标的显示位置</h3><p>巨算符的上下标用作其上下限。行间公式中，积分号默认将上下限放在右上角和右下角，求和号默认在上下方；行内公式一律默认在右上角和右下角。可以在巨算符后使用<code>\limits</code>手动令上下限显示在上下方，\nolimits则相反。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In text:</span><br><span class="line">$\sum\limits_&#123;i=1&#125;^n \quad</span><br><span class="line">\int\limits_0^&#123;\frac&#123;\pi&#125;&#123;2&#125;&#125; \quad</span><br><span class="line">\prod\limits_\epsilon $ \\</span><br><span class="line">In display:</span><br><span class="line">\[\sum\nolimits_&#123;i=1&#125;^n \quad</span><br><span class="line">\int\limits_0^&#123;\frac&#123;\pi&#125;&#123;2&#125;&#125; \quad</span><br><span class="line">\prod\nolimits_\epsilon \]</span><br></pre></td></tr></table></figure><p>In text:<br>$\sum\limits_{i=1}^n \quad<br>\int\limits_0^{\frac{\pi}{2}} \quad<br>\prod\limits_\epsilon $ \\<br>In display:<br>$$\sum\nolimits_{i=1}^n \quad<br>\int\limits_0^{\frac{\pi}{2}} \quad<br>\prod\nolimits_\epsilon $$</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/525c11d8/">巨算符–连乘符号</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> 使用MathJax公式 </category>
          
          <category> LaTex语法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>LaTex偏导，条件偏导</title>
      <link href="/blog/bdf1358e/"/>
      <url>/blog/bdf1358e/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>偏导符号$\partial$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\left.\frac&#123;\partial f(x,y)&#125;&#123;\partial x&#125;\right|_&#123;x=0&#125;$</span><br></pre></td></tr></table></figure><p>$\left.\frac{\partial f(x,y)}{\partial x}\right|_{x=0}$</p><p>参考: <a href="https://blog.csdn.net/thither_shore/article/details/52260742" target="_blank" rel="noopener">https://blog.csdn.net/thither_shore/article/details/52260742</a></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/bdf1358e/">LaTex偏导，条件偏导</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> 使用MathJax公式 </category>
          
          <category> LaTex语法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>解决Hexo博客中mathJax LaTex公式手机端无法显示</title>
      <link href="/blog/74c14e83/"/>
      <url>/blog/74c14e83/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>我用手机自带的浏览器，发现加载不出公式，解决方法：换用<code>谷歌浏览器app</code>就行了。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/74c14e83/">解决Hexo博客中mathJax LaTex公式手机端无法显示</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> 使用MathJax公式 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>LaTex牛顿莱布尼茨上下限符号</title>
      <link href="/blog/f24112ad/"/>
      <url>/blog/f24112ad/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\left.\int_&#123;a&#125;^&#123;b&#125;f(x)&#123;\mathrm&#123;d&#125;&#125;x=F(x)\right|_&#123;a&#125;^&#123;b&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>$$<br>\left.\int_{a}^{b}f(x){\mathrm{d}}x=F(x)\right|_{a}^{b}<br>$$</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/f24112ad/">LaTex牛顿莱布尼茨上下限符号</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> 使用MathJax公式 </category>
          
          <category> LaTex语法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>LaTex巨算符--积分号，求和号等</title>
      <link href="/blog/825a3007/"/>
      <url>/blog/825a3007/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>积分号∫(\int)、求和号∑(\sum)等符号称为巨算符。巨算符在行内公式和行间公式的大小和形状有区别。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In text:</span><br><span class="line">$\sum_&#123;i=1&#125;^n \quad</span><br><span class="line">\int_0^&#123;\frac&#123;\pi&#125;&#123;2&#125;&#125; \quad</span><br><span class="line">\oint_0^&#123;\frac&#123;\pi&#125;&#123;2&#125;&#125; \quad</span><br><span class="line">\prod_\epsilon $</span><br><span class="line">In display:</span><br><span class="line">$$\sum_&#123;i=1&#125;^n \quad</span><br><span class="line">\int_0^&#123;\frac&#123;\pi&#125;&#123;2&#125;&#125; \quad</span><br><span class="line">\oint_0^&#123;\frac&#123;\pi&#125;&#123;2&#125;&#125; \quad</span><br><span class="line">\prod_\epsilon $$</span><br></pre></td></tr></table></figure><p></p><p>In text:<br>$\sum_{i=1}^n \quad<br>\int_0^{\frac{\pi}{2}} \quad<br>\oint_0^{\frac{\pi}{2}} \quad<br>\prod_\epsilon$<br>In display:<br>$$\sum_{i=1}^n \quad<br>\int_0^{\frac{\pi}{2}} \quad<br>\oint_0^{\frac{\pi}{2}} \quad<br>\prod_\epsilon $$</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/825a3007/">LaTex巨算符–积分号，求和号等</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> 使用MathJax公式 </category>
          
          <category> LaTex语法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>MathJax LaTex多行公式对齐</title>
      <link href="/blog/c9e3a3a5/"/>
      <url>/blog/c9e3a3a5/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><h2 id="多行公式"><a href="#多行公式" class="headerlink" title="多行公式"></a>多行公式</h2><p>更多的情况是，我们需要罗列一系列公式，并令其按照等号对齐。</p><p>目前最常用的是align环境，它将公式用&amp;隔为两部分并对齐。分隔符通常放在等号左边：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;align&#125;</span><br><span class="line">a &amp; = b + c \\</span><br><span class="line">&amp; = d + e</span><br><span class="line">\end&#123;align&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p></p><p>$$<br>\begin{align}<br>a &amp; = b + c \\<br>&amp; = d + e<br>\end{align}<br>$$</p><p>align环境会给每行公式都编号。我们仍然可以用<code>\notag</code>去掉某行的编号。在以下的例子，为了对齐加号，我们将分隔符放在等号右边，这时需要给等号后添加一对括号{}以产生正常的间距：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;align&#125;</span><br><span class="line">a =&#123;&#125; &amp; b + c \\</span><br><span class="line">=&#123;&#125; &amp; d + e + f + g + h + i+ j + k + l \notag \\</span><br><span class="line">&amp; + m + n + o \\</span><br><span class="line">=&#123;&#125; &amp; p + q + r + s</span><br><span class="line">\end&#123;align&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p></p><p>$$<br>\begin{align}<br>a ={} &amp; b + c \\<br>={} &amp; d + e + f + g + h + i+ j + k + l \notag \\<br>&amp; + m + n + o \\<br>={} &amp; p + q + r + s<br>\end{align}<br>$$</p><p>align还能够对齐多组公式，除等号前的&amp;之外，公式之间也用&amp;分隔：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$$\begin&#123;align&#125;</span><br><span class="line">a &amp;=1  &amp;  b &amp;=2   &amp; c &amp;=3   \\</span><br><span class="line">d &amp;=-1 &amp;  e &amp;=-2  &amp; f &amp;=-5</span><br><span class="line">\end&#123;align&#125;$$</span><br></pre></td></tr></table></figure><p></p><p>$$\begin{align}<br>a &amp;=1 &amp; b &amp;=2 &amp; c &amp;=3 \\<br>d &amp;=-1 &amp; e &amp;=-2 &amp; f &amp;=-5<br>\end{align}$$</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/c9e3a3a5/">MathJax LaTex多行公式对齐</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> 使用MathJax公式 </category>
          
          <category> LaTex语法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hexo部署问题 Hexo -d时 `fatal bad config line 1 in file .gitconfig`</title>
      <link href="/blog/1189ba2d/"/>
      <url>/blog/1189ba2d/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>Hexo -d发布问题：<code>fatal: bad config line 1 in file .git/config</code><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">INFO  Deploying: git</span><br><span class="line">INFO  Clearing .deploy_git folder...</span><br><span class="line">INFO  Copying files from public folder...</span><br><span class="line">INFO  Copying files from extend dirs...</span><br><span class="line">fatal: bad config line 1 in file .git/config</span><br><span class="line">FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br><span class="line">Error: fatal: bad config line 1 in file .git/config</span><br><span class="line"></span><br><span class="line">    at ChildProcess.&lt;anonymous&gt; (D:\Blog\bolg5\node_modules\hexo-util\lib\spawn.js:37:17)</span><br><span class="line">    at emitTwo (events.js:126:13)</span><br><span class="line">    at ChildProcess.emit (events.js:214:7)</span><br><span class="line">    at ChildProcess.cp.emit (D:\Blog\bolg5\node_modules\cross-spawn\lib\enoent.js:40:29)</span><br><span class="line">    at maybeClose (internal/child_process.js:925:16)</span><br><span class="line">    at Process.ChildProcess._handle.onexit (internal/child_process.js:209:5)</span><br></pre></td></tr></table></figure><p></p><a id="more"></a><p>应该是<code>.git/config</code>这个文件有问题。这个文件在哪里呢，就在<code>.deploy_git</code>目录下。所以：<br>解决方法:</p><ul><li>删除hexo站点目录下的<code>.deploy_git</code>目录，然后再输入<code>hexo clean &amp;&amp;hexo g&amp;&amp;hexo d</code>即可发布。</li></ul><p>参考:<a href="https://blog.csdn.net/cijiancao/article/details/80819975" target="_blank" rel="noopener">https://blog.csdn.net/cijiancao/article/details/80819975</a></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/1189ba2d/">Hexo部署问题 Hexo -d时 <code>fatal bad config line 1 in file .gitconfig</code></a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> 遇到问题 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>LaTex符号表图片</title>
      <link href="/blog/42ec57e0/"/>
      <url>/blog/42ec57e0/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><h2 id="文本-数字模式通用符号"><a href="#文本-数字模式通用符号" class="headerlink" title="文本/数字模式通用符号"></a>文本/数字模式通用符号</h2><p><img src="https://ws1.sinaimg.cn/large/005UIe1Rgy1fut84uyriqj30kd06d3z2.jpg" alt=""></p><h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><p><img src="https://ws1.sinaimg.cn/large/005UIe1Rgy1fut84uyriqj30kd06d3z2.jpg" alt=""></p><h2 id="二元关系"><a href="#二元关系" class="headerlink" title="二元关系"></a>二元关系</h2><p><img src="https://ws1.sinaimg.cn/large/005UIe1Rgy1fut8835rt8j30lm0f90us.jpg" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/005UIe1Rgy1fut88s52csj30i90d675l.jpg" alt=""></p><h2 id="巨算子"><a href="#巨算子" class="headerlink" title="巨算子"></a>巨算子</h2><p><img src="![](https://ws1.sinaimg.cn/large/005UIe1Rgy1fut89gsqxcj30ni09tt9w.jpg" alt=""></p><h2 id="数学重音符号"><a href="#数学重音符号" class="headerlink" title="数学重音符号"></a>数学重音符号</h2><p><img src="![](https://ws1.sinaimg.cn/large/005UIe1Rgy1fut8a9k2u4j30l009rgmo.jpg" alt=""></p><h2 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a>箭头</h2><p><img src="![](https://ws1.sinaimg.cn/large/005UIe1Rgy1fut8ch1a28j30du0endhd.jpg" alt=""></p><h2 id="作为重音的箭头符号"><a href="#作为重音的箭头符号" class="headerlink" title="作为重音的箭头符号"></a>作为重音的箭头符号</h2><p><img src="![](https://ws1.sinaimg.cn/large/005UIe1Rgy1fut8dhu8srj30h9055dgf.jpg" alt=""></p><h2 id="定界符"><a href="#定界符" class="headerlink" title="定界符"></a>定界符</h2><p><img src="![](https://ws1.sinaimg.cn/large/005UIe1Rgy1fut8ee9wu3j30g308xjs6.jpg" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/005UIe1Rgy1fut8f4pmh1j30hj06oq3d.jpg" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/005UIe1Rgy1fut8fg00klj30k509zgmt.jpg" alt=""></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/42ec57e0/">LaTex符号表图片</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> 使用MathJax公式 </category>
          
          <category> LaTex语法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>LaTex符号表</title>
      <link href="/blog/2846862b/"/>
      <url>/blog/2846862b/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>后面把这些符号表粘贴进来就行了，后面的那些不需要再看了，保留官方文档的连接，现在只要留个印象。</p><h3 id="表4-4-文本-数学模式通用符号"><a href="#表4-4-文本-数学模式通用符号" class="headerlink" title="表4.4:文本/数学模式通用符号"></a>表4.4:文本/数学模式通用符号</h3><table><thead><tr><th style="text-align:left">文本/数学模式通用符号</th><th style="text-align:left">命令</th></tr></thead><tbody><tr><td style="text-align:left">$\{$</td><td style="text-align:left">\{</td></tr><tr><td style="text-align:left">$\}$</td><td style="text-align:left">\}</td></tr><tr><td style="text-align:left">$ $ $</td><td style="text-align:left"><code>\$</code></td></tr><tr><td style="text-align:left">$\%$</td><td style="text-align:left">\%</td></tr><tr><td style="text-align:left">$\S$</td><td style="text-align:left">\S</td></tr><tr><td style="text-align:left">$\dots$</td><td style="text-align:left">\dots</td></tr></tbody></table><h3 id="表4-5-希腊字母。"><a href="#表4-5-希腊字母。" class="headerlink" title="表4.5:希腊字母。"></a>表4.5:希腊字母。</h3><p>\Alpha，\Beta等希腊字母符号不存在，因为它们和拉丁字母A,B等一模一样；小写字母里也不存在\omicron，直接用o代替。<br><a id="more"></a></p><table><thead><tr><th style="text-align:right">效果</th><th style="text-align:left">命令</th><th style="text-align:right">效果</th><th style="text-align:left">命令</th><th style="text-align:right">效果</th><th style="text-align:left">命令</th><th style="text-align:right">效果</th><th style="text-align:left">命令</th></tr></thead><tbody><tr><td style="text-align:right">$\alpha$</td><td style="text-align:left">\alpha</td><td style="text-align:right">$\theta$</td><td style="text-align:left">\theta</td><td style="text-align:right">$o$</td><td style="text-align:left">o</td><td style="text-align:right">$\upsilon$</td><td style="text-align:left">\upsilon</td></tr><tr><td style="text-align:right">$\beta$</td><td style="text-align:left">\beta</td><td style="text-align:right">$\vartheta$</td><td style="text-align:left">\vartheta</td><td style="text-align:right">$\pi$</td><td style="text-align:left">\pi</td><td style="text-align:right">$\phi$</td><td style="text-align:left">\phi</td></tr><tr><td style="text-align:right">$\gamma$</td><td style="text-align:left">\gamma</td><td style="text-align:right">$\iota$</td><td style="text-align:left">\iota</td><td style="text-align:right">$\varpi$</td><td style="text-align:left">\varpi</td><td style="text-align:right">$\varphi$</td><td style="text-align:left">\varphi</td></tr><tr><td style="text-align:right">$\delta$</td><td style="text-align:left">\delta</td><td style="text-align:right">$\kappa$</td><td style="text-align:left">\kappa</td><td style="text-align:right">$\rho$</td><td style="text-align:left">\rho</td><td style="text-align:right">$\chi$</td><td style="text-align:left">\chi</td></tr><tr><td style="text-align:right">$\epsilon$</td><td style="text-align:left">\epsilon</td><td style="text-align:right">$\lambda$</td><td style="text-align:left">\lambda</td><td style="text-align:right">$\varrho$</td><td style="text-align:left">\varrho</td><td style="text-align:right">$\psi$</td><td style="text-align:left">\psi</td></tr><tr><td style="text-align:right">$\varepsilon$</td><td style="text-align:left">\varepsilon</td><td style="text-align:right">$\mu$</td><td style="text-align:left">\mu</td><td style="text-align:right">$\sigma$</td><td style="text-align:left">\sigma</td><td style="text-align:right">$\omega$</td><td style="text-align:left">\omega</td></tr><tr><td style="text-align:right">$\zeta$</td><td style="text-align:left">\zeta</td><td style="text-align:right">$\nu$</td><td style="text-align:left">\nu</td><td style="text-align:right">$\varsigma$</td><td style="text-align:left">\varsigma</td><td style="text-align:right"></td><td style="text-align:left"></td></tr><tr><td style="text-align:right">$\eta$</td><td style="text-align:left">\eta</td><td style="text-align:right">$\xi$</td><td style="text-align:left">\xi</td><td style="text-align:right">$\tau$</td><td style="text-align:left">\tau</td><td style="text-align:right"></td><td style="text-align:left"></td></tr><tr><td style="text-align:right">$\Gamma$</td><td style="text-align:left">\Gamma</td><td style="text-align:right">$\Lambda$</td><td style="text-align:left">\Lambda</td><td style="text-align:right">$\Sigma$</td><td style="text-align:left">\Sigma</td><td style="text-align:right">$\Psi$</td><td style="text-align:left">\Psi</td></tr><tr><td style="text-align:right">$\Delta$</td><td style="text-align:left">\Delta</td><td style="text-align:right">$\Xi$</td><td style="text-align:left">\Xi</td><td style="text-align:right">$\Upsilon$</td><td style="text-align:left">\Upsilon</td><td style="text-align:right">$\Omega$</td><td style="text-align:left">\Omega</td></tr><tr><td style="text-align:right">$\Theta$</td><td style="text-align:left">\Theta</td><td style="text-align:right">$\Pi$</td><td style="text-align:left">\Pi</td><td style="text-align:right">$\Phi$</td><td style="text-align:left">\Phi</td><td style="text-align:right"></td><td style="text-align:left"></td></tr><tr><td style="text-align:right">$\varGamma$</td><td style="text-align:left">\varGamma</td><td style="text-align:right">$\varLambda$</td><td style="text-align:left">\varLambda</td><td style="text-align:right">$\varSigma$</td><td style="text-align:left">\varSigma</td><td style="text-align:right">$\varPsi$</td><td style="text-align:left">\varPsi</td></tr><tr><td style="text-align:right">$\varDelta$</td><td style="text-align:left">\varDelta</td><td style="text-align:right">$\varXi$</td><td style="text-align:left">\varXi</td><td style="text-align:right">$\varUpsilon$</td><td style="text-align:left">\varUpsilon</td><td style="text-align:right">$\varOmega$</td><td style="text-align:left">\varOmega</td></tr><tr><td style="text-align:right">$\varTheta$</td><td style="text-align:left">\varTheta</td><td style="text-align:right">$\varPi$</td><td style="text-align:left">\varPi</td><td style="text-align:right">$\varPhi$</td><td style="text-align:left">\varPhi</td></tr></tbody></table><h3 id="表4-6-二元关系符。"><a href="#表4-6-二元关系符。" class="headerlink" title="表4.6:二元关系符。"></a>表4.6:二元关系符。</h3><p>有的二元关系符都可以加\not前缀得到相反意义的关系符，例如\not=就得到不等号（同\ne）。</p><table><thead><tr><th style="text-align:right">效果</th><th style="text-align:left">命令</th><th style="text-align:right">效果</th><th style="text-align:left">命令</th><th style="text-align:right">效果</th><th style="text-align:left">命令</th></tr></thead><tbody><tr><td style="text-align:right">$&lt;$</td><td style="text-align:left">&lt;</td><td style="text-align:right">$&gt;$</td><td style="text-align:left">&gt;</td><td style="text-align:right">$=$</td><td style="text-align:left">=</td></tr><tr><td style="text-align:right">$\leq$</td><td style="text-align:left">\leq or \le</td><td style="text-align:right">$\ge$</td><td style="text-align:left">\geq or \ge</td><td style="text-align:right">$\equiv$</td><td style="text-align:left">\equiv</td></tr><tr><td style="text-align:right">$\ll$</td><td style="text-align:left"><code>\ll</code></td><td style="text-align:right">$\gg$</td><td style="text-align:left">\gg</td><td style="text-align:right">$\doteq$</td><td style="text-align:left">\doteq</td></tr><tr><td style="text-align:right">$\prec$</td><td style="text-align:left">\prec</td><td style="text-align:right">$\succ$</td><td style="text-align:left">\succ</td><td style="text-align:right">$\sim$</td><td style="text-align:left">\sim</td></tr><tr><td style="text-align:right">$\preceq$</td><td style="text-align:left">\preceq</td><td style="text-align:right">$\succeq$</td><td style="text-align:left">\succeq</td><td style="text-align:right">$\simeq$</td><td style="text-align:left">\simeq</td></tr><tr><td style="text-align:right">$\subset$</td><td style="text-align:left">\subset</td><td style="text-align:right">$\supset$</td><td style="text-align:left">\supset</td><td style="text-align:right">$\approx$</td><td style="text-align:left">\approx</td></tr><tr><td style="text-align:right">$\subseteq$</td><td style="text-align:left">\subseteq</td><td style="text-align:right">$\supseteq$</td><td style="text-align:left">\supseteq</td><td style="text-align:right">$\cong$</td><td style="text-align:left">\cong</td></tr><tr><td style="text-align:right">$\sqsubset$</td><td style="text-align:left">\sqsubset</td><td style="text-align:right">$\sqsupset$</td><td style="text-align:left">\sqsupset</td><td style="text-align:right"></td></tr></tbody></table><p>太多了，不搬运了，我处理不过来。到时候看官方文档吧。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/2846862b/">LaTex符号表</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> 使用MathJax公式 </category>
          
          <category> LaTex语法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>LaTex数学公式语法</title>
      <link href="/blog/83c2e83a/"/>
      <url>/blog/83c2e83a/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>参考文献：<a href="http://texdoc.net/texmf-dist/doc/latex/lshort-chinese/lshort-zh-cn.pdf" target="_blank" rel="noopener">http://texdoc.net/texmf-dist/doc/latex/lshort-chinese/lshort-zh-cn.pdf</a></p><h2 id="公式排版基础"><a href="#公式排版基础" class="headerlink" title="公式排版基础"></a>公式排版基础</h2><p>数学公式有两种排版方式：其一是文字混排，称为<code>行内公式</code>；其二是单独列为一行排版，称为<code>行间公式</code>。<br>行内公式由一对<code>$</code>包裹：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Add $a$ squared and $b$ Squared to get $c$ Squared .Or,using a more mathmatical approach:$a^2+b^2=c^2$</span><br></pre></td></tr></table></figure><p></p><p>显示效果：<br>Add $a$ squared and $b$ Squared to get $c$ Squared .Or,using a more mathmatical approach:$a^2+b^2=c^2$</p><h2 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h2><a id="more"></a><h3 id="一般符号"><a href="#一般符号" class="headerlink" title="一般符号"></a>一般符号</h3><p>希腊字母符号的名称就是其英文名称，如$\alpha$(\alpha),$\beta$(\beta)等等。<br>大写的希腊字母为首字母大写的命令，如$\Gamma$(\Gamma),$\Delta$(\Delta)等等。<br>无穷大符号为$\infty$(\infty)。</p><p>省略号有$\dots$(\dots)和$cdots$(<code>\cdots</code>)两种形式。他们有各自合适的用途：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$a_1,a_2,\dots,a_n$</span><br><span class="line">$a_1,a_2,\cdots,a_n$</span><br></pre></td></tr></table></figure><p></p><p>显示效果如下：<br>$a_1,a_2,\dots,a_n$<br>$a_1,a_2,\cdots,a_n$</p><p>\ldost和\dots是完全等效的，它们既能用在公式中，也用在文本里作为省略号。<br>除此之外，在矩阵中可能会用到竖排的$\vdots$(\vdots)和斜排的$\ddots$(\ddots)</p><h3 id="指数，上下标和导数"><a href="#指数，上下标和导数" class="headerlink" title="指数，上下标和导数"></a>指数，上下标和导数</h3><p>在LaTex中用<code>^</code>和<code>_</code>表明上下标。<strong>注意上下标的内容(子公式)一般需要用花括号包裹</strong>，否则上下标只对后面的一个符号起作用<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$p^3_&#123;ij&#125; \qquad m_\mathrm&#123;Knuth&#125;\qquad \sum_&#123;K=1&#125;^3 k $</span><br><span class="line">$a^x+y \neq a^&#123;x+y&#125;\\qquad e^(x^2) \neq &#123;e^x&#125;^2$</span><br></pre></td></tr></table></figure><p></p><p>显示效果：</p><p>$p^3_{ij} \qquad m_\mathrm{Knuth}\qquad \sum_{K=1}^3 k $<br>$a^x+y \neq a^{x+y}\qquad e^(x^2) \neq {e^x}^2$</p><p>导数符号<code>‘</code>(’)是一类特殊的上标，可以适当连用表示多阶导数，也可以在其后连用上标：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$f(x)=x^2 \quad f&apos;(x)=2x \quad f&apos;&apos;^&#123;2&#125;=4$</span><br></pre></td></tr></table></figure><p></p><p>显示效果：<br>$f(x)=x^2 \quad f’(x)=2x \quad f’’^{2}=4$</p><h3 id="分式和根式"><a href="#分式和根式" class="headerlink" title="分式和根式"></a>分式和根式</h3><p>分式使用\frac{分子}{分母}来书写。分式的大小在行间公式是正常显示大小，而在行内被极度压缩。amsmath提供了方便的命令\dfrac和\tfrac,令用户能够在行内使用正常大小的行内公式，或是反过来。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">斜分式: $3/8 \qquad $,压缩分式：$\frac&#123;3&#125;&#123;8&#125;\qquad$ ,显示正常大小：$\dfrac&#123;3&#125;&#123;8&#125;$</span><br></pre></td></tr></table></figure><p></p><p>斜分式: $3/8 \qquad $,压缩分式：$\frac{3}{8}\qquad$ ,显示正常大小：$\dfrac{3}{8}$</p><p>一般的根式使用\sqrt{…}表示，表示n此方跟时写成\sqrt[n]{…}<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$\sqrt&#123;x&#125; \Leftrightarrow x^&#123;1/2&#125;</span><br><span class="line">\quad \sqrt[3]&#123;2&#125;</span><br><span class="line">\quad \sqrt&#123;x^&#123;2&#125;+\sqrt&#123;y&#125;&#125;$</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p></p><p>$\sqrt{x} \Leftrightarrow x^{1/2}<br>\quad \sqrt[3]{2}<br>\quad \sqrt{x^{2}+\sqrt{y}}$</p><p>特殊的分式形式，如二项式结构，由amsmath宏包的\binom命令生成：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pascal&apos;s rule is</span><br><span class="line">$$</span><br><span class="line">\binom&#123;n&#125;&#123;k&#125;=\binom&#123;n-1&#125;&#123;k&#125;+\binom&#123;n-1&#125;&#123;k-1&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p></p><p>Pascal’s rule is<br>$$<br>\binom{n}{k}=\binom{n-1}{k}+\binom{n-1}{k-1}<br>$$</p><h3 id="关系符"><a href="#关系符" class="headerlink" title="关系符"></a>关系符</h3><p>LaTex常见的关系符号除了可以直接输入的=,&gt;,&lt;，其他符号用命令输入，常用的有不等于: $\ne$ (\ne),大于等于号: $\ge$ (\ge)和小于等于号:$\le$ (\le),约等于号: $\approx$ (\approx),等价 $\equiv$ (\equiv),正比: $\propto$ (\propto),相似: $\sim$ (\sim)等等。<br>LaTex还提供了自定义二元关系符的命令<code>\stackrel</code>,用于将一个符号叠加在原有的二元关系符之上：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">f_n(x) \stackrel&#123;*&#125;&#123;\approx&#125; 1</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p></p><p>$$<br>f_n(x) \stackrel{*}{\approx} 1<br>$$</p><h3 id="算符"><a href="#算符" class="headerlink" title="算符"></a>算符</h3><p>LaTex中的算符大多数是二元算符，除了直接用键盘可以输入的+，-，*，/外，其他符号用命令输入，常用的符号有乘号：$\times$(\times),除号: $\div$ (\div),点乘: $\cdot$ (\cdot),加减号 $\pm$ (\pm) 或者 $\mp$ (\mp)等等。更多符号命令可参考表4.7以及表4.17</p><h3 id="巨算子"><a href="#巨算子" class="headerlink" title="巨算子"></a>巨算子</h3><p>积分号$\int$(\int),求和号$\sum$(\sum)等符号称为<strong><a href="http://texdoc.net/texmf-dist/doc/latex/lshort-chinese/lshort-zh-cn.pdf#54" target="_blank" rel="noopener">巨算子</a></strong>。巨算子在行内公式和行间公式的大小形状有区别<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在行内显示:$\sum_&#123;i=1&#125;^n \quad</span><br><span class="line">\int_0^&#123;\frac&#123;\pi&#125;&#123;2&#125;&#125; \quad</span><br><span class="line">\oint_0^&#123;\frac&#123;\pi&#125;&#123;2&#125;&#125; \quad</span><br><span class="line">\prod_\epsilon $</span><br><span class="line">在行间显示：</span><br><span class="line">$$\sum_&#123;i=1&#125;^n \quad</span><br><span class="line">\int_0^&#123;\frac&#123;\pi&#125;&#123;2&#125;&#125; \quad</span><br><span class="line">\oint_0^&#123;\frac&#123;\pi&#125;&#123;2&#125;&#125; \quad</span><br><span class="line">\prod_\epsilon $$</span><br></pre></td></tr></table></figure><p></p><p>在行内显示:$\sum_{i=1}^n \quad<br>\int_0^{\frac{\pi}{2}} \quad<br>\oint_0^{\frac{\pi}{2}} \quad<br>\prod_\epsilon $<br>在行间显示：</p><p>$$\sum_{i=1}^n \quad<br>\int_0^{\frac{\pi}{2}} \quad<br>\oint_0^{\frac{\pi}{2}} \quad<br>\prod_\epsilon $$</p><p>巨算符的上下标用作其上下限。行间公式中，积分号默认将上下限放在右上角和右下角，求和号默认在上下方；行内公式一律默认在右上角和右下角。<strong>可以在巨算符后使用\limits手动令上下限显示在上下方</strong>，\nolimits则相反,即不显示在上下方，也就是显示在右上角，右下角。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In text:</span><br><span class="line">$\sum\limits_&#123;i=1&#125;^n \quad</span><br><span class="line">\int\limits_0^&#123;\frac&#123;\pi&#125;&#123;2&#125;&#125; \quad</span><br><span class="line">\prod\limits_\epsilon $ </span><br><span class="line">In display:</span><br><span class="line">$$\sum\nolimits_&#123;i=1&#125;^n \quad</span><br><span class="line">\int\limits_0^&#123;\frac&#123;\pi&#125;&#123;2&#125;&#125; \quad</span><br><span class="line">\prod\nolimits_\epsilon $$</span><br></pre></td></tr></table></figure><p></p><p>In text:<br>$\sum\limits_{i=1}^n \quad<br>\int\limits_0^{\frac{\pi}{2}} \quad<br>\prod\limits_\epsilon $<br>In display:<br>$$\sum\nolimits_{i=1}^n \quad<br>\int\limits_0^{\frac{\pi}{2}} \quad<br>\prod\nolimits_\epsilon $$</p><h3 id="数学重音和上下括号"><a href="#数学重音和上下括号" class="headerlink" title="数学重音和上下括号"></a>数学重音和上下括号</h3><p>数学符号可以像文字一样<strong>加重音</strong>，比如对时间求导的符号$\dot{r}$(\dot{r})、$ddot{r}$(ddot{r})、表示向量的箭头$vec{r}$(vec{r})、表示欧式空间单位向量的$\hat{\mathbf{e}}$(\hat{\mathbf{e}})等，详见表<a href="http://texdoc.net/texmf-dist/doc/latex/lshort-chinese/lshort-zh-cn.pdf#e1" target="_blank" rel="noopener">4.9</a>。使用时要注意重音符号的作用区域，<strong>一般应当对某个符号而不是不符号加下表使用重音：</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$\bar&#123;x_0&#125; \quad \bar&#123;x&#125;_0$\\[5pt]</span><br><span class="line">$\vec&#123;x_0&#125; \quad \vec&#123;x&#125;_0$\\[5pt]</span><br><span class="line">$\hat&#123;\mathbf&#123;e&#125;_x&#125; \quad</span><br><span class="line">\hat&#123;\mathbf&#123;e&#125;&#125;_x$</span><br></pre></td></tr></table></figure><p></p><p>$\bar{x_0} \quad \bar{x}_0$<br>$\vec{x_0} \quad \vec{x}_0$<br>$\hat{\mathbf{e}_x} \quad<br>\hat{\mathbf{e}}_x$</p><p>LATEX也能为多个字符加重音，包括直接画线的\overline和\underline命令（可叠加使用）、宽重音符号\widehat、表示向量的箭头\overrightarrow等。后两者详见表4.9和4.11等。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$0.\overline&#123;3&#125; =</span><br><span class="line">\underline&#123;\underline&#123;1/3&#125;&#125;$</span><br><span class="line">$\hat&#123;XY&#125; \qquad \widehat&#123;XY&#125;$</span><br><span class="line">$\vec&#123;AB&#125; \qquad</span><br><span class="line">\overrightarrow&#123;AB&#125;$</span><br></pre></td></tr></table></figure><p></p><p>$0.\overline{3} =<br>\underline{\underline{1/3}}$<br>$\hat{XY} \qquad \widehat{XY}$<br>$\vec{AB} \qquad<br>\overrightarrow{AB}$</p><p>\overbrace和\underbrace命令用来生成上/下括号，各自可带一个上/下标公式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$\underbrace&#123;\overbrace&#123;a+b+c&#125;^6</span><br><span class="line">\cdot \overbrace&#123;d+e+f&#125;^7&#125;</span><br><span class="line">_\text&#123;meaning of life&#125; = 42$</span><br></pre></td></tr></table></figure><p>$\underbrace{\overbrace{a+b+c}^6<br>\cdot \overbrace{d+e+f}^7}<br>_\text{meaning of life} = 42$</p><h3 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a>箭头</h3><p>除了作为上下标之外，箭头还用于表示过程。amsmath的<code>\xleftarrow</code>和<code>\xrightarrow</code>命令可以为箭头增加上下标：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$$ a\xleftarrow&#123;x+y+z&#125; b $$</span><br><span class="line">$$c\xrightarrow[x&lt;y]&#123;a\*b\*c&#125;d $$</span><br></pre></td></tr></table></figure><p></p><p>$$ a\xleftarrow{x+y+z} b$$<br>$$c\xrightarrow[x&lt;y]{a*b*c}d $$</p><p>注意，这里<code>$$c\xrightarrow[x&lt;y]{a\*b\*c}d $$</code>乘号前面加转义符是让Markdown引擎不解析这两个星号，因为两个连续的星号，markdown会解析成斜体字。</p><h3 id="括号和定界符"><a href="#括号和定界符" class="headerlink" title="括号和定界符"></a>括号和定界符</h3><p>LATEX提供了多种括号和定界符表示公式块的边界。除小括号( )、中括号[ ]之外，其余都是LATEX命令，包括大括号\{ \}。表4.12和4.13给出了更多的括号/定界符命令。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;a,b,c&#125; \neq \&#123;a,b,c\&#125;$</span><br></pre></td></tr></table></figure><p></p><p>${a,b,c} \neq \{a,b,c\}$</p><p>使用\left和\right命令可令括号（定界符）的大小可变，在行间公式中常用。LATEX会自动根据括号内的公式大小决定定界符大小。\left和\right必须成对使用。需要使用单个定界符时，另一个定界符写成\left.或\right.。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\[1 + \left(\frac&#123;1&#125;&#123;1-x^&#123;2&#125;&#125;</span><br><span class="line">\right)^3 \qquad</span><br><span class="line">\left.\frac&#123;\partial f&#125;&#123;\partial t&#125;</span><br><span class="line">\right|_&#123;t=0&#125;\]</span><br></pre></td></tr></table></figure><p></p><p>$$1 + \left(\frac{1}{1-x^{2}}<br>\right)^3 \qquad<br>\left.\frac{\partial f}{\partial t}<br>\right|_{t=0}$$</p><h2 id="多行公式"><a href="#多行公式" class="headerlink" title="多行公式"></a>多行公式</h2><h3 id="长公式折行"><a href="#长公式折行" class="headerlink" title="长公式折行"></a>长公式折行</h3><p>通常来讲应当避免写出超过一行而需要折行的长公式。如果一定要折行的话，优先在等号之前折行，其次在加号、减号之前，再次在乘号、除号之前。其它位置应当避免折行。<br>amsmath宏包的multline环境提供了书写折行长公式的方便环境。它允许用<code>\\\\</code>(markdown中显示:\\\)折行，<strong>将公式编号放在最后一行</strong>。多行公式的<strong>首行左对齐</strong>，<strong>末行右对齐</strong>，<strong>其余行居中</strong>。<br>因为markdown中<code>\</code>是转义符，所以<code>\\</code>才表示一个\\,所以这里要写四个<code>\</code>(<code>\\\\</code>)<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$\begin&#123;multline&#125;</span><br><span class="line">a + b + c + d + e + f+ g + h + i \\</span><br><span class="line">= j + k + l + m + n\\</span><br><span class="line">= o + p + q + r + s\\</span><br><span class="line">= t + u + v + x + z</span><br><span class="line">\end&#123;multline&#125;$</span><br></pre></td></tr></table></figure><p></p><p>$\begin{multline}a + b + c + d + e + f+ g + h + i \\<br>= j + k + l + m + n\\<br>= o + p + q + r + s\\= t + u + v + x + z\end{multline}$</p><p>与表格不同的是，公式的最后一行不写<code>\\</code>，如果写了，反倒会产生一个多余的空行。类似equation*，multline*环境排版不带编号的折行长公式。</p><h3 id="多行公式-1"><a href="#多行公式-1" class="headerlink" title="多行公式"></a>多行公式</h3><p>更多的情况是，我们需要罗列一系列公式，并令其按照等号对齐。读者可能阅读过其它手册或者资料，知道LATEX提供了eqnarray环境。它按照等号左边——等号——等号右边呈三列对齐，但等号周围的空隙过大，加上公式编号等一些bug，目前已不推荐使用</p><p><strong>目前最常用的是align环境，它将公式用&amp;隔为两部分并对齐。分隔符通常放在等号左边：</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;align&#125;</span><br><span class="line">a &amp; = b + c \\</span><br><span class="line">&amp; = d + e</span><br><span class="line">\end&#123;align&#125;</span><br></pre></td></tr></table></figure><p></p><p>$\begin{align}<br>a &amp; = b + c \\<br>&amp; = d + e<br>\end{align}$</p><p><code>align</code>环境会给每行公式都编号。我们仍然可以用<code>\notag</code>去掉某行的编号。在以下的例子，为了对齐加号，我们将分隔符放在等号右边，这时需要给等号后添加一对括号{}以产生正常的间距：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$\begin&#123;align&#125;</span><br><span class="line">a =&#123;&#125; &amp; b + c \\</span><br><span class="line">=&#123;&#125; &amp; d + e + f + g + h + i</span><br><span class="line">+ j + k + l \notag \\</span><br><span class="line">&amp; + m + n + o \\</span><br><span class="line">=&#123;&#125; &amp; p + q + r + s</span><br><span class="line">\end&#123;align&#125;$</span><br></pre></td></tr></table></figure><p></p><p>$\begin{align}<br>a ={} &amp; b + c \\<br>={} &amp; d + e + f + g + h + i+ j + k + l \notag \\<br>&amp; + m + n + o \\<br>={} &amp; p + q + r + s<br>\end{align}$</p><p>align还能够对齐多组公式，除等号前的&amp;之外，公式之间也用&amp;分隔：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$\begin&#123;align&#125;</span><br><span class="line">a &amp;=1  &amp;  b &amp;=2   &amp; c &amp;=3   \\</span><br><span class="line">d &amp;=-1 &amp;  e &amp;=-2  &amp; f &amp;=-5</span><br><span class="line">\end&#123;align&#125;$</span><br></pre></td></tr></table></figure><p></p><p>$\begin{align}<br>a &amp;=1 &amp; b &amp;=2 &amp; c &amp;=3 \\<br>d &amp;=-1 &amp; e &amp;=-2 &amp; f &amp;=-5<br>\end{align}$</p><p>如果我们不需要按等号对齐，只需罗列数个公式，gather将是一个很好用的环境：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$\begin&#123;gather&#125;</span><br><span class="line">a = b + c \\</span><br><span class="line">d = e + f + g \\</span><br><span class="line">h + i = j + k \notag \\</span><br><span class="line">l + m = n</span><br><span class="line">\end&#123;gather&#125;$</span><br></pre></td></tr></table></figure><p></p><p>$\begin{gather}<br>a = b + c \\<br>d = e + f + g \\<br>h + i = j + k \notag \\<br>l + m = n<br>\end{gather}$</p><p>align和gather有对应的不带编号的版本align*和gather*。</p><h3 id="公用编号的多行公式"><a href="#公用编号的多行公式" class="headerlink" title="公用编号的多行公式"></a>公用编号的多行公式</h3><p>另一个常见的需求是将多个公式组在一起公用一个编号，编号位于公式的居中位置。为此，amsmath宏包提供了诸如aligned、gathered等环境，与equation环境套用。以-ed结尾的环境用法与前一节不以-ed结尾的环境用法一一对应。我们仅以aligned举例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$\begin&#123;equation&#125;</span><br><span class="line">\begin&#123;aligned&#125;</span><br><span class="line">a &amp;= b + c \\</span><br><span class="line">d &amp;= e + f + g \\</span><br><span class="line">h + i &amp;= j + k \\</span><br><span class="line">l + m &amp;= n</span><br><span class="line">\end&#123;aligned&#125;</span><br><span class="line">\end&#123;equation&#125;$</span><br></pre></td></tr></table></figure><p></p><p>$\begin{equation}<br>\begin{aligned}<br>a &amp;= b + c \\<br>d &amp;= e + f + g \\<br>h + i &amp;= j + k \\<br>l + m &amp;= n<br>\end{aligned}<br>\end{equation}$</p><p>split环境和aligned环境用法类似，也用于和equation环境套用，区别是split只能将每行的一个公式分两栏，aligned允许每行多个公式多栏。</p><h2 id="数组和矩阵"><a href="#数组和矩阵" class="headerlink" title="数组和矩阵"></a>数组和矩阵</h2><p>为了排版二维数组，LATEX提供了array环境，用法与tabular环境极为类似，也需要定义列格式，并用\\换行。数组可作为一个公式块，在外套用\left、\right等定界符:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$$ \mathbf&#123;X&#125; = \left(</span><br><span class="line">\begin&#123;array&#125;&#123;cccc&#125;</span><br><span class="line">x_&#123;11&#125; &amp; x_&#123;12&#125; &amp; \ldots &amp; x_&#123;1n&#125;\\</span><br><span class="line">x_&#123;21&#125; &amp; x_&#123;22&#125; &amp; \ldots &amp; x_&#123;2n&#125;\\</span><br><span class="line">\vdots &amp; \vdots &amp; \ddots &amp; \vdots\\</span><br><span class="line">x_&#123;n1&#125; &amp; x_&#123;n2&#125; &amp; \ldots &amp; x_&#123;nn&#125;\\</span><br><span class="line">\end&#123;array&#125;</span><br><span class="line">\right) $$</span><br></pre></td></tr></table></figure><p></p><p>还是因为是在markdown文档中<code>\</code>需要转义，所以两个斜杠:<code>\\</code>,在markdown文档中需要使用四个斜杠:<code>\\\\</code>来表示<br>$$ \mathbf{X} = \left(<br>\begin{array}{cccc}<br>x_{11} &amp; x_{12} &amp; \ldots &amp; x_{1n}\\<br>x_{21} &amp; x_{22} &amp; \ldots &amp; x_{2n}\\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots\\<br>x_{n1} &amp; x_{n2} &amp; \ldots &amp; x_{nn}\\<br>\end{array}<br>\right) $$</p><p>值得注意的是，上一节末尾介绍的aligned等环境也可以用定界符包裹。我们还可以利用空的定界符排版出这样的效果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\[ |x| = \left\&#123;</span><br><span class="line">\begin&#123;array&#125;&#123;rl&#125;</span><br><span class="line">-x &amp; \text&#123;if &#125; x &lt; 0,\\</span><br><span class="line">0 &amp; \text&#123;if &#125; x = 0,\\</span><br><span class="line">x &amp; \text&#123;if &#125; x &gt; 0.</span><br><span class="line">\end&#123;array&#125; \right. \]</span><br></pre></td></tr></table></figure><p></p><p>[ |x| = \left\{<br>\begin{array}{rl}<br>-x &amp; \text{if } x &lt; 0,\\<br>0 &amp; \text{if } x = 0,\\<br>x &amp; \text{if } x &gt; 0.<br>\end{array} \right. ]</p><p>我不知道这里为什么显示不正常，可以能不支持把，下面的例子同样也可额完成，衣柜对于分段函数可以写下面的这种形式。</p><h3 id="分段函数"><a href="#分段函数" class="headerlink" title="分段函数"></a>分段函数</h3><p>不过上述例子可以用amsmath提供的cases环境更轻松地完成：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$$ |x| =</span><br><span class="line">\begin&#123;cases&#125;</span><br><span class="line">-x &amp; \text&#123;if &#125; x &lt; 0,\\</span><br><span class="line">0 &amp; \text&#123;if &#125; x = 0,\\</span><br><span class="line">x &amp; \text&#123;if &#125; x &gt; 0.</span><br><span class="line">\end&#123;cases&#125; $$</span><br></pre></td></tr></table></figure><p></p><p>$$ |x| =<br>\begin{cases}<br>-x &amp; \text{if } x &lt; 0,\\<br>0 &amp; \text{if } x = 0,\\<br>x &amp; \text{if } x &gt; 0.<br>\end{cases} $$</p><p>我们当然也可以用array环境排版各种矩阵。amsmath宏包还直接提供了多种排版矩阵的环境，包括不带定界符的matrix，以及带各种定界符的矩阵pmatrix（(）、bmatrix（[）、Bmatrix（{）、vmatrix（）、Vmatrix（）。使用这些环境时，无需给定列格式5：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\[</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line">1 &amp; 2 \\ 3 &amp; 4</span><br><span class="line">\end&#123;matrix&#125; \qquad</span><br><span class="line">\begin&#123;bmatrix&#125;</span><br><span class="line">x_&#123;11&#125; &amp; x_&#123;12&#125; &amp; \ldots &amp; x_&#123;1n&#125;\\</span><br><span class="line">x_&#123;21&#125; &amp; x_&#123;22&#125; &amp; \ldots &amp; x_&#123;2n&#125;\\</span><br><span class="line">\vdots &amp; \vdots &amp; \ddots &amp; \vdots\\</span><br><span class="line">x_&#123;n1&#125; &amp; x_&#123;n2&#125; &amp; \ldots &amp; x_&#123;nn&#125;\\</span><br><span class="line">\end&#123;bmatrix&#125;</span><br><span class="line">\]</span><br></pre></td></tr></table></figure><p>$$<br>\begin{matrix}<br>1 &amp; 2 \\\\ 3 &amp; 4<br>\end{matrix} \qquad<br>\begin{bmatrix}<br>x_{11} &amp; x_{12} &amp; \ldots &amp; x_{1n}\\<br>x_{21} &amp; x_{22} &amp; \ldots &amp; x_{2n}\\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots\\<br>x_{n1} &amp; x_{n2} &amp; \ldots &amp; x_{nn}\\<br>\end{bmatrix}<br>$$</p><p>在矩阵中的元素里排版分式时，一来要用到\dfrac等命令，二来行与行之间有可能紧贴着，这时要用到3.6.6小节的方法来调节间距：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\mathbf&#123;H&#125;=</span><br><span class="line">\begin&#123;bmatrix&#125;</span><br><span class="line">\dfrac&#123;\partial^2 f&#125;&#123;\partial x^2&#125; &amp;</span><br><span class="line">\dfrac&#123;\partial^2 f&#125;</span><br><span class="line">&#123;\partial x \partial y&#125; \\[8pt]</span><br><span class="line">\dfrac&#123;\partial^2 f&#125;</span><br><span class="line">&#123;\partial x \partial y&#125; &amp;</span><br><span class="line">\dfrac&#123;\partial^2 f&#125;&#123;\partial y^2&#125;</span><br><span class="line">\end&#123;bmatrix&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p></p><p>$$<br>\mathbf{H}=<br>\begin{bmatrix}<br>\dfrac{\partial^2 f}{\partial x^2} &amp;<br>\dfrac{\partial^2 f}<br>{\partial x \partial y} \\ [8pt]<br>\dfrac{\partial^2 f}<br>{\partial x \partial y} &amp;<br>\dfrac{\partial^2 f}{\partial y^2}<br>\end{bmatrix}<br>$$</p><h2 id="公式中的间距"><a href="#公式中的间距" class="headerlink" title="公式中的间距"></a>公式中的间距</h2><p>前文提到过，绝大部分时候，数学公式中各元素的间距是根据符号类型自动生成的，需要我们手动调整的情况极少。我们已经认识了两个生成间距的命令<code>\quad</code>和<code>\qquad</code>。在公式中我们还可能用到的间距包括<code>\,</code>、<code>\:</code>、<code>\;</code>以及负间距<code>\!</code>，其中<code>\quad</code>、<code>\qquad</code>和<code>\,</code>在文本和数学环境中可用，后三个命令只用于数学环境。文本中的<code>\␣</code>也能使用在数学公式中。<br>此处应该有图片，但是我的图片好像用不了了</p><p>一个常见的用途是修正积分的被积函数$f(x)$和微元$dx$之间的距离。注意微元里的$d$用的是直立体：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\int_a^b f(x)\mathrm&#123;d&#125;x</span><br><span class="line">\qquad</span><br><span class="line">\int_a^b f(x)\,\mathrm&#123;d&#125;x</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p></p><p>$$<br>\int_a^b f(x)\mathrm{d}x<br>\qquad<br>\int_a^b f(x)\,\mathrm{d}x<br>$$</p><p>另一个用途是生成多重积分号。如果我们直接连写两个\int，之间的间距将会过宽，此时可以使用负间距\!修正之。不过amsmath提供了更方便的多重积分号，如<strong>二重积分<code>\iint</code></strong>、<strong>三重积分<code>\iiint</code></strong>等。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$$\newcommand\diff&#123;\,\mathrm&#123;d&#125;&#125;</span><br><span class="line">\begin&#123;gather\*&#125;</span><br><span class="line">\int\int f(x)g(y)</span><br><span class="line">\diff x \diff y \\</span><br><span class="line">\int\\!\\!\\!\int</span><br><span class="line">f(x)g(y) \diff x \diff y \\</span><br><span class="line">\iint f(x)g(y) \diff x \diff y \\</span><br><span class="line">\iint\quad \iiint\quad \idotsint</span><br><span class="line">\end&#123;gather\*&#125;$$</span><br></pre></td></tr></table></figure><p></p><p>这上面还是有问题的，我在hexo mathjax的marked.js（在./node_modules/marked/lib/中）修改了：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/, </span><br><span class="line">//它取消了该渲染引擎对\,&#123;,&#125;的转义</span><br><span class="line">  escape: /^\\([`*\[\]()#$+\-.!_&gt;])/,</span><br></pre></td></tr></table></figure><p></p><p>取消了<code>\\</code>的转义，但是这了<code>\i</code>还是现实错误，我不知道该怎么弄，所以，上面的代码中使用<code>\\i</code>代替<code>\i</code>。修改源码需谨慎。<br>$$\newcommand\diff{\,\mathrm{d}}<br>\begin{gather*}<br>\int\int f(x)g(y)<br>\diff x \diff y \\<br>\int\!\!\!\int<br>f(x)g(y) \diff x \diff y \\<br>\iint f(x)g(y) \diff x \diff y \\<br>\iint\quad \iiint\quad \idotsint<br>\end{gather*}$$</p><h2 id="数学符号的字体控制"><a href="#数学符号的字体控制" class="headerlink" title="数学符号的字体控制"></a>数学符号的字体控制</h2><h3 id="数学字母字体"><a href="#数学字母字体" class="headerlink" title="数学字母字体"></a>数学字母字体</h3><p>LATEX允许一部分数学符号切换字体，主要是拉丁字母、数字等等。表4.2给出了切换字体的命令。某一些命令需要字体宏包的支持。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$\mathcal&#123;R&#125; \quad \mathfrak&#123;R&#125;</span><br><span class="line">\quad \mathbb&#123;R&#125;$</span><br><span class="line">$$\mathcal&#123;L&#125;</span><br><span class="line">= -\frac&#123;1&#125;&#123;4&#125;F_&#123;\mu\nu&#125;F^&#123;\mu\nu&#125;$$</span><br><span class="line">$\mathfrak&#123;su&#125;(2)$ and</span><br><span class="line">$\mathfrak&#123;so&#125;(3)$ Lie algebr</span><br></pre></td></tr></table></figure><p></p><p>$\mathcal{R} \quad \mathfrak{R}<br>\quad \mathbb{R}$<br>$$\mathcal{L}<br>= -\frac{1}{4}F_{\mu\nu}F^{\mu\nu}$$<br>$\mathfrak{su}(2)$ and<br>$\mathfrak{so}(3)$ Lie algebr</p><h3 id="数学符号的尺寸"><a href="#数学符号的尺寸" class="headerlink" title="数学符号的尺寸"></a>数学符号的尺寸</h3><p>数学符号按照符号排版的位置规定尺寸，从大到小包括行间公式尺寸、行内公式尺寸、上下标尺寸、次级上下标尺寸。除了字号有别之外，行间和行内公式尺寸下的巨算符也使用不一样的大小。LATEX为每个数学尺寸指定了一个切换的命令，见4.3。<br>例如行间公式的分式内，分子分母使用行内公式尺寸，巨算符采用行内尺寸的形式。对比一下分子分母使用\displaystyle命令与否的区别：<br>这里有一个表格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">P = \frac</span><br><span class="line">&#123;\sum_&#123;i=1&#125;^n (x_i- x)(y_i- y)&#125;</span><br><span class="line">&#123;\displaystyle \left[</span><br><span class="line">\sum_&#123;i=1&#125;^n (x_i-x)^2</span><br><span class="line">\sum_&#123;i=1&#125;^n (y_i-y)^2</span><br><span class="line">\right]^&#123;1/2&#125; &#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>$$<br>P = \frac<br>{\sum_{i=1}^n (x_i- x)(y_i- y)}<br>{\displaystyle \left[<br>\sum_{i=1}^n (x_i-x)^2<br>\sum_{i=1}^n (y_i-y)^2<br>\right]^{1/2} }<br>$$</p><h2 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h2><p>后面把这些符号表粘贴进来就行了，后面的那些不需要再看了，保留官方文档的连接，现在只要留个印象。</p><h3 id="表4-4-文本-数学模式通用符号"><a href="#表4-4-文本-数学模式通用符号" class="headerlink" title="表4.4:文本/数学模式通用符号"></a>表4.4:文本/数学模式通用符号</h3><table><thead><tr><th style="text-align:left">文本/数学模式通用符号</th><th style="text-align:left">命令</th></tr></thead><tbody><tr><td style="text-align:left">$\{$</td><td style="text-align:left">\{</td></tr><tr><td style="text-align:left">$\}$</td><td style="text-align:left">\}</td></tr><tr><td style="text-align:left">$$$</td><td style="text-align:left">$</td></tr><tr><td style="text-align:left">$\%$</td><td style="text-align:left">\%</td></tr><tr><td style="text-align:left">$\dag$</td><td style="text-align:left">\dag</td></tr><tr><td style="text-align:left">$\S$</td><td style="text-align:left">\S</td></tr><tr><td style="text-align:left">$\copyright$</td><td style="text-align:left">\copyright</td></tr><tr><td style="text-align:left">$\dots$</td><td style="text-align:left">\dots</td></tr><tr><td style="text-align:left">$\ddag$</td><td style="text-align:left">\ddag</td></tr><tr><td style="text-align:left">$\P$</td><td style="text-align:left">\P</td></tr><tr><td style="text-align:left">$\pounds$</td><td style="text-align:left">\pounds</td></tr></tbody></table><h3 id="表4-5-希腊字母。"><a href="#表4-5-希腊字母。" class="headerlink" title="表4.5:希腊字母。"></a>表4.5:希腊字母。</h3><p>\Alpha，\Beta等希腊字母符号不存在，因为它们和拉丁字母A,B等一模一样；小写字母里也不存在\omicron，直接用o代替。</p><table><thead><tr><th style="text-align:right">效果</th><th style="text-align:left">命令</th><th style="text-align:right">效果</th><th style="text-align:left">命令</th><th style="text-align:right">效果</th><th style="text-align:left">命令</th><th style="text-align:right">效果</th><th style="text-align:left">命令</th></tr></thead><tbody><tr><td style="text-align:right">$\alpha$</td><td style="text-align:left">\alpha</td><td style="text-align:right">$\theta$</td><td style="text-align:left">\theta</td><td style="text-align:right">$o$</td><td style="text-align:left">o</td><td style="text-align:right">$\upsilon$</td><td style="text-align:left">\upsilon</td></tr><tr><td style="text-align:right">$\beta$</td><td style="text-align:left">\beta</td><td style="text-align:right">$\vartheta$</td><td style="text-align:left">\vartheta</td><td style="text-align:right">$\pi$</td><td style="text-align:left">\pi</td><td style="text-align:right">$\phi$</td><td style="text-align:left">\phi</td></tr><tr><td style="text-align:right">$\gamma$</td><td style="text-align:left">\gamma</td><td style="text-align:right">$\iota$</td><td style="text-align:left">\iota</td><td style="text-align:right">$\varpi$</td><td style="text-align:left">\varpi</td><td style="text-align:right">$\varphi$</td><td style="text-align:left">\varphi</td></tr><tr><td style="text-align:right">$\delta$</td><td style="text-align:left">\delta</td><td style="text-align:right">$\kappa$</td><td style="text-align:left">\kappa</td><td style="text-align:right">$\rho$</td><td style="text-align:left">\rho</td><td style="text-align:right">$\chi$</td><td style="text-align:left">\chi</td></tr><tr><td style="text-align:right">$\epsilon$</td><td style="text-align:left">\epsilon</td><td style="text-align:right">$\lambda$</td><td style="text-align:left">\lambda</td><td style="text-align:right">$\varrho$</td><td style="text-align:left">\varrho</td><td style="text-align:right">$\psi$</td><td style="text-align:left">\psi</td></tr><tr><td style="text-align:right">$\varepsilon$</td><td style="text-align:left">\varepsilon</td><td style="text-align:right">$\mu$</td><td style="text-align:left">\mu</td><td style="text-align:right">$\sigma$</td><td style="text-align:left">\sigma</td><td style="text-align:right">$\omega$</td><td style="text-align:left">\omega</td></tr><tr><td style="text-align:right">$\zeta$</td><td style="text-align:left">\zeta</td><td style="text-align:right">$\nu$</td><td style="text-align:left">\nu</td><td style="text-align:right">$\varsigma$</td><td style="text-align:left">\varsigma</td><td style="text-align:right"></td><td style="text-align:left"></td></tr><tr><td style="text-align:right">$\eta$</td><td style="text-align:left">\eta</td><td style="text-align:right">$\xi$</td><td style="text-align:left">\xi</td><td style="text-align:right">$\tau$</td><td style="text-align:left">\tau</td><td style="text-align:right"></td><td style="text-align:left"></td></tr><tr><td style="text-align:right">$\Gamma$</td><td style="text-align:left">\Gamma</td><td style="text-align:right">$\Lambda$</td><td style="text-align:left">\Lambda</td><td style="text-align:right">$\Sigma$</td><td style="text-align:left">\Sigma</td><td style="text-align:right">$\Psi$</td><td style="text-align:left">\Psi</td></tr><tr><td style="text-align:right">$\Delta$</td><td style="text-align:left">\Delta</td><td style="text-align:right">$\Xi$</td><td style="text-align:left">\Xi</td><td style="text-align:right">$\Upsilon$</td><td style="text-align:left">\Upsilon</td><td style="text-align:right">$\Omega$</td><td style="text-align:left">\Omega</td></tr><tr><td style="text-align:right">$\Theta$</td><td style="text-align:left">\Theta</td><td style="text-align:right">$\Pi$</td><td style="text-align:left">\Pi</td><td style="text-align:right">$\Phi$</td><td style="text-align:left">\Phi</td><td style="text-align:right"></td><td style="text-align:left"></td></tr><tr><td style="text-align:right">$\varGamma$</td><td style="text-align:left">\varGamma</td><td style="text-align:right">$\varLambda$</td><td style="text-align:left">\varLambda</td><td style="text-align:right">$\varSigma$</td><td style="text-align:left">\varSigma</td><td style="text-align:right">$\varPsi$</td><td style="text-align:left">\varPsi</td></tr><tr><td style="text-align:right">$\varDelta$</td><td style="text-align:left">\varDelta</td><td style="text-align:right">$\varXi$</td><td style="text-align:left">\varXi</td><td style="text-align:right">$\varUpsilon$</td><td style="text-align:left">\varUpsilon</td><td style="text-align:right">$\varOmega$</td><td style="text-align:left">\varOmega</td></tr><tr><td style="text-align:right">$\varTheta$</td><td style="text-align:left">\varTheta</td><td style="text-align:right">$\varPi$</td><td style="text-align:left">\varPi</td><td style="text-align:right">$\varPhi$</td><td style="text-align:left">\varPhi</td></tr></tbody></table><h3 id="表4-6-二元关系符。"><a href="#表4-6-二元关系符。" class="headerlink" title="表4.6:二元关系符。"></a>表4.6:二元关系符。</h3><p>有的二元关系符都可以加\not前缀得到相反意义的关系符，例如\not=就得到不等号（同\ne）。</p><table><thead><tr><th style="text-align:right">效果</th><th style="text-align:left">命令</th><th style="text-align:right">效果</th><th style="text-align:left">命令</th><th style="text-align:right">效果</th><th style="text-align:left">命令</th></tr></thead><tbody><tr><td style="text-align:right">$&lt;$</td><td style="text-align:left">&lt;</td><td style="text-align:right">$&gt;$</td><td style="text-align:left">&gt;</td><td style="text-align:right">==</td></tr><tr><td style="text-align:right">$\leq$</td><td style="text-align:left">\leq or \le</td><td style="text-align:right">≥\geq or \ge</td><td style="text-align:left">≡</td><td style="text-align:right">\equiv≪\ll≫\gg.=\doteq≺\prec≻\succ∼\sim⪯\preceq⪰\succeq≃\simeq⊂\subset⊃\supset≈\approx⊆\subseteq⊇\supseteq∼=\cong&lt;\sqsubsetℓ=\sqsupsetℓ1\Joinℓ⊑\sqsubseteq⊒\sqsupseteq▷◁\bowtie∈\in∋\ni,\owns∝\propto⊢\vdash⊣\dashv</td><td style="text-align:left">=\models</td><td>\mid∥\parallel⊥\perp⌣\smile⌢\frown≍\asymp::/∈\notin̸=\neqor\ne</td></tr></tbody></table><p>本文链接: <a href="https://www.lansheng.net.cn/blog/83c2e83a/">LaTex数学公式语法</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> 使用MathJax公式 </category>
          
          <category> LaTex语法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>MathJax语法</title>
      <link href="/blog/171023e7/"/>
      <url>/blog/171023e7/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><h2 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h2><p>行内公式是首尾使用一个<code>$</code>包裹起来的公式,显示效果如：<code>$\sum_{i=0}^N \int_{a}^{b}g(t,i)\text{d}t$</code>,显示效果：$\sum_{i=0}^N \int_{a}^{b}g(t,i)\text{d}t$</p><h2 id="行间公式"><a href="#行间公式" class="headerlink" title="行间公式"></a>行间公式</h2><p>行间公式是首尾使用两个<code>$</code>包裹起来的公式，行间公式会另起一行单独显示，并且自动区中对齐。显示效果如<code>$$\sum_{i=0}^N \int_{a}^{b}g(t,i)\text{d}t$$</code>:$$\sum_{i=0}^N \int_{a}^{b}g(t,i)\text{d}t$$</p><p>下面主要使用latex公式</p><h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><table><thead><tr><th style="text-align:left">小写显示效果</th><th style="text-align:left">小写命令</th><th style="text-align:left">大写显示小姑</th><th style="text-align:left">大写命令</th></tr></thead><tbody><tr><td style="text-align:left">$\alpha $</td><td style="text-align:left">\alpha</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">$\beta$</td><td style="text-align:left">\beta</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">$\gamma$</td><td style="text-align:left">\gamma</td><td style="text-align:left">$\Gamma$</td><td style="text-align:left">\Gamma</td></tr><tr><td style="text-align:left">$\delta$</td><td style="text-align:left">\delta</td><td style="text-align:left">$\Delta$</td><td style="text-align:left">\Delta</td></tr><tr><td style="text-align:left">$\epsilon$</td><td style="text-align:left">\epsilon</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">$\zeta$</td><td style="text-align:left">\zeta</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">$\eta$</td><td style="text-align:left">\eta</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">$\theta$</td><td style="text-align:left">\theta</td><td style="text-align:left">$\Theta$</td><td style="text-align:left">\Theta</td></tr><tr><td style="text-align:left">$\iota$</td><td style="text-align:left">\iota</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">$\kappa$</td><td style="text-align:left">\kappa</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">$\lambda$</td><td style="text-align:left">\lambda</td><td style="text-align:left">$\Lambda$</td><td style="text-align:left">\Lambda</td></tr><tr><td style="text-align:left">$\mu$</td><td style="text-align:left">\mu</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">$\nu$</td><td style="text-align:left">\nu</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">$\xi$</td><td style="text-align:left">\xi</td><td style="text-align:left">$\Xi$</td><td style="text-align:left">\Xi</td></tr><tr><td style="text-align:left">$\pi$</td><td style="text-align:left">\pi</td><td style="text-align:left">$\Pi$</td><td style="text-align:left">\Pi</td></tr><tr><td style="text-align:left">$\rho$</td><td style="text-align:left">\rho</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">$\sigma$</td><td style="text-align:left">\sigma</td><td style="text-align:left">$\Sigma$</td><td style="text-align:left">\Sigma</td></tr><tr><td style="text-align:left">$\tau$</td><td style="text-align:left">\tau</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">$\upsilon$</td><td style="text-align:left">\upsilon</td><td style="text-align:left">$\Upsilon$</td><td style="text-align:left">\Upsilon</td></tr><tr><td style="text-align:left">$\phi$</td><td style="text-align:left">\phi</td><td style="text-align:left">$\Phi$</td><td style="text-align:left">\Phi</td></tr><tr><td style="text-align:left">$\chi$</td><td style="text-align:left">\chi</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">$\psi$</td><td style="text-align:left">\psi</td><td style="text-align:left">$\Psi$</td><td style="text-align:left">\Psi</td></tr><tr><td style="text-align:left">$\omega$</td><td style="text-align:left">\omega</td><td style="text-align:left">$\Omega$</td><td style="text-align:left">\Omega</td></tr></tbody></table><ul><li><p>若需要大写希腊字母，将命令首字母大写即可。</p><ul><li>\Gamma呈现为:$\Gamma$</li></ul></li><li><p>若需要斜体希腊字母，将命令前加上var前缀即可。</p><ul><li>\varGamma呈现为:$\varGamma$</li></ul></li></ul><h2 id="字母修饰"><a href="#字母修饰" class="headerlink" title="字母修饰"></a>字母修饰</h2><h3 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h3><ul><li>上标：<code>^</code></li><li>下标：<code>_</code></li></ul><p>例如：<br><code>$C_n^2$</code>呈现为:$C_n^2$</p><h3 id="矢量"><a href="#矢量" class="headerlink" title="矢量"></a>矢量</h3><ul><li><code>\vec a</code>呈现为:$\vec a$</li><li><code>\overrightarrow{xy}</code>呈现为:$\overrightarrow{xy}$</li></ul><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><ul><li>使用{}将具有相同等级的内容扩入其中，成组处理<ul><li>举例：<code>10^{10}</code>呈现为$10^{10}$,而10^10呈现为$10^10$</li></ul></li></ul><h3 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h3><ul><li>小括号<code>$()$</code>呈现为$()$</li><li>中括号<code>$[]$</code>呈现为$[]$</li><li>括号大小：使用<code>\left(</code>或者<code>\right)</code>使符号大小与里面的公式相适应；该语句适用于内部有分数的类型，比如一个分数直接加括号，括号很小不美观。用<code>\left(</code>,<code>\right)</code>括起来就可以把分数包整个包起来，这样比较美观。<ul><li><code>(\frac{x}{y})</code>呈现为:$(\frac{x}{y})$</li><li>而<code>\left(\frac{x}{y}\right)</code>呈现为:$\left(\frac{x}{y}\right)$</li><li><code>(\frac{\frac{x}{y}}{\frac{a}{b}})</code>呈现为:$(\frac{\frac{x}{y}}{\frac{a}{b}})$</li><li><code>\left(\frac{\frac{x}{y}}{\frac{a}{b}}\right)</code>呈现为:$\left(\frac{\frac{x}{y}}{\frac{a}{b}}\right)$</li></ul></li></ul><h3 id="分式与根式"><a href="#分式与根式" class="headerlink" title="分式与根式"></a>分式与根式</h3><ul><li>分式(fractions):<code>\frac{公式1}{公式2}</code>呈现为: $\frac{公式1}{公式2}$</li><li>根式:<code>\sqrt[x]{y}</code>呈现为:$\sqrt[x]{y}$</li></ul><h3 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h3><ul><li><code>\数学符号名</code></li><li>举例：<code>\sin x</code>,<code>\ln x</code>,<code>\max(a,b,x)</code>呈现为：$\sin x$,$\ln x$,$\max(a,b,x)$</li></ul><table><thead><tr><th style="text-align:left">显示</th><th style="text-align:left">命令</th><th style="text-align:left">译名</th></tr></thead><tbody><tr><td style="text-align:left">$\infty$</td><td style="text-align:left">\infty</td><td style="text-align:left">无穷大</td></tr><tr><td style="text-align:left">$\cup$</td><td style="text-align:left">\cup</td><td style="text-align:left">并集</td></tr><tr><td style="text-align:left">$\cap$</td><td style="text-align:left">\cap</td><td style="text-align:left">交集</td></tr><tr><td style="text-align:left">$\subset$</td><td style="text-align:left">\subset</td><td style="text-align:left">子集</td></tr><tr><td style="text-align:left">$\subseteq$</td><td style="text-align:left">\subseteq</td><td style="text-align:left">真子集</td></tr><tr><td style="text-align:left">$\supset$</td><td style="text-align:left">\supset</td><td style="text-align:left">这个符号有点奇怪</td></tr><tr><td style="text-align:left">$\in$</td><td style="text-align:left">\in</td><td style="text-align:left">属于</td></tr><tr><td style="text-align:left">$\notin$</td><td style="text-align:left">\notin</td><td style="text-align:left">不属于</td></tr><tr><td style="text-align:left">$\varnothing$</td><td style="text-align:left">\varnothing</td><td style="text-align:left">空集</td></tr><tr><td style="text-align:left">$\forall$</td><td style="text-align:left">\forall</td><td style="text-align:left">全称量词</td></tr><tr><td style="text-align:left">$\exists$</td><td style="text-align:left">\exists</td><td style="text-align:left">存在量词</td></tr><tr><td style="text-align:left">$\lnot$</td><td style="text-align:left"><code>\lnot</code></td><td style="text-align:left">否定量词</td></tr><tr><td style="text-align:left">$\nabla$</td><td style="text-align:left">\nabla</td><td style="text-align:left">微分算子</td></tr><tr><td style="text-align:left">$\partial$</td><td style="text-align:left">\partial</td><td style="text-align:left">偏微商</td></tr></tbody></table><h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><p>LaTex语法本省会忽略空格的存在</p><h3 id="求和、极限与积分"><a href="#求和、极限与积分" class="headerlink" title="求和、极限与积分"></a>求和、极限与积分</h3><ul><li>求和：<code>\sum</code><ul><li>举例：<code>\sum_{i=1}^n{a_i}</code>呈现为$\sum_{i=1}^n{a_i}$</li></ul></li><li>极限：<code>\lim</code><ul><li>举例:<code>\lim_{x\to 0}</code>呈现为$\lim_{x\to 0}$</li></ul></li><li>积分：<code>\int</code><ul><li>举例：<code>\int_0^\infty{f(x)dx}</code> 呈现为$\int_0^\infty{f(x)dx}$</li></ul></li></ul><p>LaTex中文官方文档:<a href="http://texdoc.net/texmf-dist/doc/latex/lshort-chinese/lshort-zh-cn.pdf" target="_blank" rel="noopener">http://texdoc.net/texmf-dist/doc/latex/lshort-chinese/lshort-zh-cn.pdf</a><br>参考：<a href="https://www.cnblogs.com/purepleasure/p/9019176.html" target="_blank" rel="noopener">https://www.cnblogs.com/purepleasure/p/9019176.html</a><br>参考：<a href="https://www.jianshu.com/p/a0aa94ef8ab2" target="_blank" rel="noopener">https://www.jianshu.com/p/a0aa94ef8ab2</a><br>参考：<a href="https://www.cnblogs.com/purepleasure/p/9019176.html" target="_blank" rel="noopener">https://www.cnblogs.com/purepleasure/p/9019176.html</a></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/&#39;171023e7&#39;/">MathJax语法</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> 使用MathJax公式 </category>
          
          <category> LaTex语法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hexo Next主题中使用MathJax公式步骤</title>
      <link href="/blog/56f6db1d/"/>
      <url>/blog/56f6db1d/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:16 GMT+0800 (中国标准时间) --><p>title: index.html<br>date: 2018-07-05 12:01:30<br>tags:</p><h2 id="mathjax-true"><a href="#mathjax-true" class="headerlink" title="mathjax: true"></a>mathjax: true</h2><p><code>`</code><br>之所以要在文章头里设置开关，是因为考虑只有在用到公式的页面才加载 Mathjax，这样不需要渲染数学公式的页面的访问速度就不会受到影响了。<br><a id="more"></a><br>参考：<a href="https://blog.csdn.net/wgshun616/article/details/81019687" target="_blank" rel="noopener">https://blog.csdn.net/wgshun616/article/details/81019687</a><br>mathjax中文文档：<a href="https://mathjax-chinese-doc.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://mathjax-chinese-doc.readthedocs.io/en/latest/</a></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/56f6db1d/">Hexo Next主题中使用MathJax公式步骤</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java使用BOM判断一个文件是不是UTF-8文件</title>
      <link href="/blog/2fe8061d/"/>
      <url>/blog/2fe8061d/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><p>BOM（byte-order mark）<strong>文件编码头</strong>，即 字节顺序标记.<br><strong>它是插入到以UTF-8、UTF16或UTF-32编码文件开头的特殊标记</strong>，<br><strong>用来标记多字节编码文件的编码类型和字节顺序</strong>（big-endian或little- endian）。<br><strong>一般用来识别文件的编码类型。</strong></p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>在windows系统中，记事本会自动在文件头部加上BOM,也就是加三个字节进行标记，例如对于UTF-8文件，会在文件字节序列前面加上<code>EF BB BF</code>这三个字节。</p><a id="more"></a><p>例如test_utf8.py这个文件用的是utf-8+BOM编码的.<br><img src="https://i.imgur.com/vtWvrjD.png" alt=""><br>现在打开这个文件，然后以16进制的方式查看该文件。<br><img src="https://i.imgur.com/nLTgZnD.png" alt=""><br>可以看到该文件以<code>EF BB BF</code>这三个字节开头，这三个字节表示该文件是UTF-8编码的。<br><code>EF BB BF</code>转成字节表示就是<code>-17,-69,-65</code>.不信来看下面的代码：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.out.print((<span class="keyword">byte</span>)Integer.parseInt(<span class="string">"EF"</span>, <span class="number">16</span>)+<span class="string">","</span>);</span><br><span class="line">    System.out.print((<span class="keyword">byte</span>)Integer.parseInt(<span class="string">"BB"</span>, <span class="number">16</span>)+<span class="string">","</span>);</span><br><span class="line">    System.out.print((<span class="keyword">byte</span>)Integer.parseInt(<span class="string">"BF"</span>, <span class="number">16</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<code>-17,-69,-65</code><br>利用BOM判断一个文件是不是utf-8文件：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 判断是不是utf8编码</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> file 文件名</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 根据文件字节序列的头部的编码信息判断是不是utf8编码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isUTF8File</span><span class="params">(File file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InputStream in = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        in = <span class="keyword">new</span> java.io.FileInputStream(file);</span><br><span class="line"><span class="comment">//      读取3个字节</span></span><br><span class="line">        in.read(b);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e)</span><br><span class="line">    &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line">    &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (in != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                in.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b[<span class="number">0</span>] == -<span class="number">17</span> &amp;&amp; b[<span class="number">1</span>] == -<span class="number">69</span> &amp;&amp; b[<span class="number">2</span>] == -<span class="number">65</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>测试：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    String path = <span class="string">"D:\\学习\\python\\test_utf8.py"</span>;</span><br><span class="line">    File file = <span class="keyword">new</span> File(path);</span><br><span class="line">    System.out.println(file.getAbsolutePath()+<span class="string">"是utf-8编码的文件:"</span>+isUTF8File(file));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\学习\python\test_utf8.py是utf-8编码的文件:true</span><br></pre></td></tr></table></figure><p></p><p>这么做的问题是只能判断带BOM的文件，如果不带BOM那就不好判断了。例如把上面的文件从utf-8+BOM改成utf-8格式，然后保存。<br><img src="https://i.imgur.com/Nj4BWk9.png" alt=""><br>再切换到16进制视图查看：<br><img src="https://i.imgur.com/giSWXga.png" alt=""><br>可以看到不带BOM的utf-8格式的文件不以<code>EF BB BF</code>这三个字节开头，这样来上述的方法就不好使了。<br>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\学习\python\test_utf8.py是utf-8编码的文件:false</span><br></pre></td></tr></table></figure><p></p><p>可以看到我明明是utf-8的文件，但是判断的结果却是false。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/2fe8061d/">Java使用BOM判断一个文件是不是UTF-8文件</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java IO流 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hexo博客显示问题：中文网站名乱码</title>
      <link href="/blog/87aa90c2/"/>
      <url>/blog/87aa90c2/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>这是因为站点配置文件没有使用utf-8编码造成的，所以在<strong>站点配置文件</strong><code>_config.yml</code>中写中文网站名，然后把<strong>站点配置文件</strong>保存为<code>utf-8格式</code>。<br><a id="more"></a><br>例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: 蓝生的博客</span><br><span class="line">subtitle:</span><br><span class="line">description: 记录美好生活</span><br><span class="line">keywords:</span><br><span class="line">author: 蓝生</span><br><span class="line">language: zh_CN</span><br><span class="line">timezone:</span><br></pre></td></tr></table></figure><p></p><p>然后重新启动即可：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><p></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/87aa90c2/">Hexo博客显示问题：中文网站名乱码</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> 遇到问题 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hexo搭建博客2 Hexo安装及部署</title>
      <link href="/blog/48803/"/>
      <url>/blog/48803/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:16 GMT+0800 (中国标准时间) --><p><strong>本文介绍</strong></p><ul><li><a href="https://www.lansheng.net.cn/blog/48803e00/#安装hexo">安装hexo</a><ul><li><a href="https://www.lansheng.net.cn/blog/48803e00/#注意">注意</a></li><li><a href="https://www.lansheng.net.cn/blog/48803e00/#安装成功hexo的输出：">安装成功hexo的输出：</a></li></ul></li><li><a href="https://www.lansheng.net.cn/blog/48803e00/#Hexo命令">Hexo命令</a><ul><li><a href="https://www.lansheng.net.cn/blog/48803e00/#创建站点目录">创建站点目录</a></li><li><a href="https://www.lansheng.net.cn/blog/48803e00/#清楚缓存">清楚缓存</a></li><li><a href="https://www.lansheng.net.cn/blog/48803e00/#生成静态页面">生成静态页面</a></li><li><a href="https://www.lansheng.net.cn/blog/48803e00/#开启本地服务器">开启本地服务器</a></li><li><a href="https://www.lansheng.net.cn/blog/48803e00/#连写形式">连写形式</a></li><li><a href="https://www.lansheng.net.cn/blog/48803e00/#hexo组合命令">hexo组合命令</a></li></ul></li><li><a href="https://www.lansheng.net.cn/blog/48803e00/#将博客部署到Github-Pages上">将博客部署到Github Pages上</a><ul><li><a href="https://www.lansheng.net.cn/blog/48803e00/#安装插件">安装插件</a></li><li><a href="https://www.lansheng.net.cn/blog/48803e00/#修改站点配置文件">修改站点配置文件</a></li></ul></li><li><a href="https://www.lansheng.net.cn/blog/48803e00/#部署hexo">部署hexo</a></li><li><a href="https://www.lansheng.net.cn/blog/48803e00/#参考文章">参考文章</a></li></ul><a id="more"></a><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>在站点目录下，打开git-bash输入下面的指令安装hexo:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli g</span><br></pre></td></tr></table></figure><p></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>安装过程可能比较慢，这跟网络环境有关。如果天没有见到运行效果，请耐心等待。</p><p>我在用<code>git bash</code>安装的时候就半天没反应，这个时候，不小心按下<code>ctrl+c</code>结束了，这样安装没有完整。先删除掉再说：<code>npm uninstall hexo</code>。然后，我默默的打开手机用开个热点。再安装：<code>npm install hexo-cli g</code></p><h3 id="安装成功hexo的输出："><a href="#安装成功hexo的输出：" class="headerlink" title="安装成功hexo的输出："></a>安装成功hexo的输出：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli g</span><br><span class="line">npm WARN saveError ENOENT: no such file or directory, open &apos;D:\Blog\package.json&apos;</span><br><span class="line">npm notice created a lockfile as package-lock.json. You should commit this file.</span><br><span class="line">npm WARN enoent ENOENT: no such file or directory, open &apos;D:\Blog\package.json&apos;</span><br><span class="line">npm WARN Blog No description</span><br><span class="line">npm WARN Blog No repository field.</span><br><span class="line">npm WARN Blog No README data</span><br><span class="line">npm WARN Blog No license field.</span><br><span class="line">npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.4 (node_modules\fsevents):</span><br><span class="line">npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.4: wanted &#123;&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;&#125; (current: &#123;&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;&#125;)</span><br><span class="line"></span><br><span class="line">+ hexo-cli@1.1.0</span><br><span class="line">+ g@2.0.1</span><br><span class="line">added 104 packages in 15.271s</span><br></pre></td></tr></table></figure><p>安装成功之后就可以使用Hexo来建立站点了。</p><h2 id="Hexo命令"><a href="#Hexo命令" class="headerlink" title="Hexo命令"></a>Hexo命令</h2><h3 id="创建站点目录"><a href="#创建站点目录" class="headerlink" title="创建站点目录"></a>创建站点目录</h3><p>安装完成后，根据自己喜好建立目录。如在<code>git-bash</code>中进入<code>/d/Blog/</code>目录下，初始化一个名为<code>blog</code>站点目录，我们以后的所有操作都在这个站点目录下进行。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure><p></p><p>初始化输出：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init blog</span><br><span class="line">INFO  Cloning hexo-starter to D:\Blog\blog</span><br><span class="line">Cloning into &apos;D:\Blog\blog&apos;...</span><br><span class="line">remote: Counting objects: 68, done.</span><br><span class="line">remote: Total 68 (delta 0), reused 0 (delta 0), pack-reused 67</span><br><span class="line">......</span><br><span class="line">&#123;&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;&#125; (current: &#123;&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;&#125;)</span><br><span class="line"></span><br><span class="line">added 396 packages in 33.779s</span><br><span class="line">INFO  Start blogging with Hexo!</span><br></pre></td></tr></table></figure><p></p><p>建立好站点之后，Hexo已经默认给我们创建好一个<code>Hello World</code>页面了。</p><h3 id="清楚缓存"><a href="#清楚缓存" class="headerlink" title="清楚缓存"></a>清楚缓存</h3><p>使用<code>hexo clean</code>可以清除缓存，清除缓存可以让新配置的信息立即生效。</p><h3 id="生成静态页面"><a href="#生成静态页面" class="headerlink" title="生成静态页面"></a>生成静态页面</h3><p>使用<code>hexo generate</code>或简写<code>hexo g</code>命令生成静态页面(html),一般使用简写形式就行了。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p></p><h3 id="开启本地服务器"><a href="#开启本地服务器" class="headerlink" title="开启本地服务器"></a>开启本地服务器</h3><p>输入<code>hexo server</code>或者输入其简写形式<code>hexo s</code>即可开启本地服务器。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p></p><p>然后打开浏览器，输出<code>localhost:4000</code>可以看到效果。</p><h3 id="连写形式"><a href="#连写形式" class="headerlink" title="连写形式"></a>连写形式</h3><p>使用<code>&amp;&amp;</code>作为分隔符可以把多条命令写成一行。例如<code>hexo clean</code>,<code>hexo g</code>,<code>hexo s</code>这三条命令可以写成<code>hexo clean&amp;&amp;hexo g&amp;&amp;hexo s</code>这样的一行的形式。这样可以较少输入命令的次数，<code>git-bash</code>支持按上下键，显示上次执行过的命令。这样我们在调试的时候就可以按一下上键，然后回车执行这三条命令了。</p><h3 id="hexo组合命令"><a href="#hexo组合命令" class="headerlink" title="hexo组合命令"></a>hexo组合命令</h3><p>也可以写成下面的形式：</p><ul><li><p>清除、生成、启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g -s</span><br></pre></td></tr></table></figure></li><li><p>清除、生成、部署</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g -d</span><br></pre></td></tr></table></figure></li></ul><h2 id="将博客部署到Github-Pages上"><a href="#将博客部署到Github-Pages上" class="headerlink" title="将博客部署到Github Pages上"></a>将博客部署到Github Pages上</h2><p>使用<code>hexo s</code>可以在本机上启动服务器(部署在本机)，这种方式适用于调试阶段。部署到Github之后我们可以通过网络来访问。</p><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>hexo要想到githbu pages的要安装hexo-deployer-git这个插件,站点目录下，打开git-bash输入下面的命令进行安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h3 id="修改站点配置文件"><a href="#修改站点配置文件" class="headerlink" title="修改站点配置文件"></a>修改站点配置文件</h3><p>打开<strong>站点根目录</strong>(blog)下的<code>_config.yml</code>文件，这个文件以后称为<strong>站点配置文件</strong>找到下面的<code>deploy:</code>字段 并更改为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/用户名/用户名.github.io.git  #你的仓库地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p></p><p>其中<code>repo</code>字段使github仓库的地址，<code>branch</code>使你想要推送的分支。<br><strong>注意</strong>：冒号后面有一个半角空格。</p><p>以上配置完成后,就可以部署到gitbub上了。</p><h2 id="部署hexo"><a href="#部署hexo" class="headerlink" title="部署hexo"></a>部署hexo</h2><p>输入下面的命令将hexo博客部署到github中：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 清空静态页面</span><br><span class="line">hexo clean</span><br><span class="line"># 生成静态页面</span><br><span class="line">hexo generate</span><br><span class="line"># 部署 </span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p></p><p>相当于执行<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo c &amp;&amp; hexo g -d</span><br></pre></td></tr></table></figure><p></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://blog.csdn.net/xuezhisdc/article/details/53130328" target="_blank" rel="noopener">https://blog.csdn.net/xuezhisdc/article/details/53130328</a></li><li><a href="https://www.cnblogs.com/nuannuan7362/p/6111171.html" target="_blank" rel="noopener">https://www.cnblogs.com/nuannuan7362/p/6111171.html</a></li><li><a href="https://my.oschina.net/ryaneLee/blog/638440" target="_blank" rel="noopener">https://my.oschina.net/ryaneLee/blog/638440</a></li><li><a href="https://www.cnblogs.com/visugar/p/6821777.html" target="_blank" rel="noopener">https://www.cnblogs.com/visugar/p/6821777.html</a></li><li><a href="https://my.oschina.net/ryaneLee/blog/638440" target="_blank" rel="noopener">https://my.oschina.net/ryaneLee/blog/638440</a></li><li><a href="https://www.jianshu.com/p/343934573342" target="_blank" rel="noopener">https://www.jianshu.com/p/343934573342</a></li></ul><p>本文链接: <a href="https://www.lansheng.net.cn/blog/48803e00/">Hexo搭建博客2 Hexo安装及部署</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hexo搭建博客问题2 hexo d命令报错_ERROR Deployer not found_git</title>
      <link href="/blog/8abbc073/"/>
      <url>/blog/8abbc073/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>Hexo搭建博客问题2 hexo d命令报错 ERROR Deployer not found_git.md<br>这是因为插件没有安装好，站点目录下输入<code>npm install --save hexo-deployer-git</code>安装部署插件即可。<br><a id="more"></a></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>我已经在站点配置文件中写入了：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:lanlan2017/lanlan2017.github.io.git  # Github pages地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p></p><p>但是执行，<code>hexo d</code>报错：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR Deployer not found: git</span><br></pre></td></tr></table></figure><p></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>这是因为我还没安装插件，输入下面的插件安装就好了：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure><p></p><p>然后在使用<code>Hexo -d</code>命令就可以推送了。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/8abbc073/">Hexo搭建博客问题2 hexo d命令报错_ERROR Deployer not found_git</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> 遇到问题 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hexo写博客 使用多级分类</title>
      <link href="/blog/d8f66139/"/>
      <url>/blog/d8f66139/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:16 GMT+0800 (中国标准时间) --><p>Hexo原生支持父子分类，只需要在 <code>Front-matter</code>中的分类标记后面写下多个分类就行了。写在后面的分类就在前面分类的子分类，例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">- Diary</span><br><span class="line">- Life</span><br></pre></td></tr></table></figure><p></p><p><strong>会使分类<code>Life</code>成为<code>Diary</code>的子分类，而不是并列分类。</strong>因此，有必要为您的文章选择尽可能准确的分类。<br>hexo中分类和标签的区别如下：<br><a id="more"></a></p><blockquote><p>首先来看官方文档：<a href="https://hexo.io/zh-cn/docs/front-matter.html" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/front-matter.html</a></p><h2 id="分类和标签"><a href="#分类和标签" class="headerlink" title="分类和标签"></a>分类和标签</h2><p>Hexo只对文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：<br>分类具有顺序性和层次性，也就是说分类中 Foo, Bar 不等于 Bar, Foo；<br>而标签没有顺序和层次。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; categories:</span><br><span class="line">&gt; - Diary</span><br><span class="line">&gt; tags:</span><br><span class="line">&gt; - PS3</span><br><span class="line">&gt; - Games</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><h2 id="分类方法的分歧"><a href="#分类方法的分歧" class="headerlink" title="分类方法的分歧"></a>分类方法的分歧</h2><p>如果您有过使用WordPress的经验，就很容易误解Hexo的分类方式。WordPress支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是<strong>Hexo不支持指定多个同级分类</strong>。下面的指定方法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; categories:</span><br><span class="line">&gt; - Diary</span><br><span class="line">&gt; - Life</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p><strong>会使分类<code>Life</code>成为<code>Diary</code>的子分类，而不是并列分类。</strong>因此，有必要为您的文章选择尽可能准确的分类。</p></blockquote><p>本文链接: <a href="https://www.lansheng.net.cn/blog/d8f66139/">Hexo写博客 使用多级分类</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hexo搭建博客4 Next主题优化配置</title>
      <link href="/blog/d7900030/"/>
      <url>/blog/d7900030/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:16 GMT+0800 (中国标准时间) --><p>文本完成：</p><ul><li>不蒜子计数</li><li>修改文章内链接文本样式</li><li>代码块自定义样式</li><li>把文章底部标签中的#号改为图标</li><li>设置网站图标<a id="more"></a><h2 id="访客-amp-访问量"><a href="#访客-amp-访问量" class="headerlink" title="访客&amp;访问量"></a>访客&amp;访问量</h2></li></ul><p>NexT主题中已经集成了不蒜子统计，直接编辑主题配置文件：把enable: 设置为true即可。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 不蒜子计数</span><br><span class="line">busuanzi_count:</span><br><span class="line">  # count values only if the other configs are false</span><br><span class="line">  enable: true</span><br><span class="line">  # custom uv span for the whole site</span><br><span class="line">  site_uv: true</span><br><span class="line">  site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;本站访客数&lt;/i&gt;</span><br><span class="line">  site_uv_footer: 人次</span><br><span class="line">  # custom pv span for the whole site</span><br><span class="line">  site_pv: true</span><br><span class="line">  site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;本站总访问量&lt;/i&gt;</span><br><span class="line">  site_pv_footer: 次</span><br><span class="line">  # custom pv span for one page only</span><br><span class="line">  page_pv: true</span><br><span class="line">  page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;本文总阅读量&lt;/i&gt;</span><br><span class="line">  page_pv_footer: 次</span><br></pre></td></tr></table></figure><p></p><p><code>site_uv_header</code>，<code>site_pv_header</code>，<code>page_pv_header</code>，这几个分别为网站访客数，网站访问量，文章阅读量。你可以在这里写下你的表述。<code>&lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt;</code>表示图标，你可把文字写在标签里，也可以直接使用文字不显示标签也行。<br>开启后的效果：</p><p><img src="https://i.imgur.com/shJosRn.png" alt=""></p><p>可以看到开启后显示访问的用户数，和访问的数量。不过这里，奇怪的是访问数这么多，显然是哪里有问题的。我才刚开始建站，显然不可能有这么多的访问量的。</p><h2 id="修改文章内链接文本样式"><a href="#修改文章内链接文本样式" class="headerlink" title="修改文章内链接文本样式"></a>修改文章内链接文本样式</h2><p>原文：<a href="http://blog.ynxiu.com/2016/hexo-next-theme-optimize.html" target="_blank" rel="noopener">http://blog.ynxiu.com/2016/hexo-next-theme-optimize.html</a><br>next默认的超链接是不带颜色的如下图所示，这里通过修改源码(样式)样式实现。</p><p><img src="https://i.imgur.com/8Bpuooa.png" alt=""></p><p>将链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线。<br>修改文件<code>themes\next\source\css\_common\components\post\post.styl</code> ，<code>添加</code>如下<code>css</code> 样式，：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 文章内链接文本样式</span><br><span class="line">.post-body p a&#123;</span><br><span class="line">  color: #0593d3;</span><br><span class="line">  border-bottom: none;</span><br><span class="line">  border-bottom: 1px solid #0593d3;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    color: #fc6423;</span><br><span class="line">    border-bottom: none;</span><br><span class="line">    border-bottom: 1px solid #fc6423;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择<code>.post-body</code> 是为了不影响标题，选择 <code>p</code> 是为了不影响首页 <code>“阅读全文”</code> 的显示样式。<br>显示效果：<br><img src="https://i.imgur.com/FTZghpg.png" alt=""></p><h2 id="每篇文章末尾统一添加-“本文结束”-标记"><a href="#每篇文章末尾统一添加-“本文结束”-标记" class="headerlink" title="每篇文章末尾统一添加 “本文结束” 标记"></a>每篇文章末尾统一添加 “本文结束” 标记</h2><h3 id="新建-passage-end-tag-swig-文件"><a href="#新建-passage-end-tag-swig-文件" class="headerlink" title="新建 passage-end-tag.swig 文件"></a>新建 <code>passage-end-tag.swig</code> 文件</h3><p>在路径 <code>\themes\next\layout\_macro</code> 中添加 <code>passage-end-tag.swig</code> 文件，其内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;------本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢阅读------&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>好像并没有效果啊，好吧，是我心急了，还没完，继续操作：</p><h3 id="修改-post-swig-文件"><a href="#修改-post-swig-文件" class="headerlink" title="修改 post.swig 文件"></a>修改 post.swig 文件</h3><p>在 \themes\next\layout_macro\post.swig 中， post-body 之后， post-footer 之前添加如下代码（post-footer 之前两个 DIV）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;% if not is_index %&#125;</span><br><span class="line">    &#123;% include &apos;passage-end-tag.swig&apos; %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>我试了，这样并没有效果，还是先算了，别把代码搞崩了，修改代码需谨慎。</p><h3 id="在主题配置文件中添加字段"><a href="#在主题配置文件中添加字段" class="headerlink" title="在主题配置文件中添加字段"></a>在主题配置文件中添加字段</h3><p>在主题配置文件 <code>_config.yml</code>中添加以下字段开启此功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 文章末尾添加“本文结束”标记</span><br><span class="line">passage_end_tag:</span><br><span class="line">  enabled: true</span><br></pre></td></tr></table></figure><p>完成以上设置之后，在每篇文章之后都会添加<strong> “本文结束” 标记</strong>。</p><p>试了没有成功，还是把加进去的删掉比较好</p><h2 id="代码块自定义样式"><a href="#代码块自定义样式" class="headerlink" title="代码块自定义样式"></a>代码块自定义样式</h2><p>Next在默认代码块的颜色是没有的如下如所示，为了让代码块突出显示，可以加入自定义的样式：</p><p><img src="https://i.imgur.com/veMWHRU.png" alt=""></p><p>打开自定义 CSS：<code>\themes\next\source\css\_custom\custom.styl</code> 加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//自定义样式开始</span><br><span class="line">// 代码块自定义样式``内的</span><br><span class="line">code &#123;</span><br><span class="line">    color: #fc6423;</span><br><span class="line">    background: #fbf7f8;</span><br><span class="line">    margin: 2px;</span><br><span class="line">&#125;</span><br><span class="line">// 大代码块的自定义样式</span><br><span class="line">.highlight, pre &#123;</span><br><span class="line">    margin: 5px 0;</span><br><span class="line">    padding: 5px;</span><br><span class="line">    border-radius: 3px;</span><br><span class="line">&#125;</span><br><span class="line">.highlight, code, pre &#123;</span><br><span class="line">    border: 1px solid #d6d6d6;</span><br><span class="line">&#125;</span><br><span class="line">//自定义样式结束</span><br></pre></td></tr></table></figure><p>然后显示效果为：</p><p><img src="https://i.imgur.com/2oCFAoh.png" alt=""></p><p>嗯，这样比较美观一点。</p><hr><p>下面的配置来自文章：<a href="https://blog.csdn.net/qq_32454537/article/details/79482896#t11" target="_blank" rel="noopener">https://blog.csdn.net/qq_32454537/article/details/79482896#t11</a></p><h2 id="添加图标"><a href="#添加图标" class="headerlink" title="添加图标"></a>添加图标</h2><p>到<a href="http://www.bootcss.com/p/font-awesome/" target="_blank" rel="noopener">这个网站</a>中找有一个你喜欢的图标：<br>然后复制下图标的名字，例如：arrow-right(注意不要复制全面 icon-arrow-right，复制后面就行了然后粘贴到图标的配置项就行了)<br><img src="https://i.imgur.com/ARSSG1l.png" alt=""><br>例如，给社交链接添加图标：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/yourname || github</span><br><span class="line">  CSDN: https://blog.csdn.net/qq_21808961 || arrow-right</span><br></pre></td></tr></table></figure><p>显示效果：</p><p><img src="https://i.imgur.com/1Mo1nT6.png" alt=""></p><h2 id="把文章底部标签中的井号改为图标"><a href="#把文章底部标签中的井号改为图标" class="headerlink" title="把文章底部标签中的井号改为图标"></a>把文章底部标签中的井号改为图标</h2><p>去掉文章后面的标签前面的#号。</p><p>修改模板<code>/themes/next/layout/_macro/post.swig</code>，搜索 <code>rel=&quot;tag&quot;&gt;#</code>，将<code>#</code>换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code>这个图标。</p><h2 id="设置网站图标"><a href="#设置网站图标" class="headerlink" title="设置网站图标"></a>设置网站图标</h2><h3 id="首先是生成图标"><a href="#首先是生成图标" class="headerlink" title="首先是生成图标"></a>首先是生成图标</h3><p>到这个网站<a href="http://emblemmatic.org/markmaker/#/designs" target="_blank" rel="noopener">http://emblemmatic.org/markmaker/#/designs</a>(或是其他图标生成网站生成)，输入你想要的名字，例如我输入我的首字母<code>L</code>.然后下载该图标(.png格式)。</p><p><img src="https://i.imgur.com/bEn4vrF.png" alt=""></p><h3 id="转换像素大小"><a href="#转换像素大小" class="headerlink" title="转换像素大小"></a>转换像素大小</h3><p>使用Photoshop打开,把整个图片(或者裁剪下的一部分部分)。转储为web所用的格式,设置像素大小为<code>16*16</code>的和<code>32*32</code>的如下图所示。<br><img src="https://i.imgur.com/rR1W2qM.png" alt=""><br>保存，然后放到站点目录下的<code>source/images</code>目录中即可。</p><p>然后在主题配置文件中配置如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: /images/favicon-16x16-next.png</span><br><span class="line">  medium: /images/favicon-32x32-next.png</span><br><span class="line">  apple_touch_icon: /images/apple-touch-icon-next.png</span><br><span class="line">  safari_pinned_tab: /images/logo.svg</span><br><span class="line">  #android_manifest: /images/manifest.json</span><br><span class="line">  #ms_browserconfig: /images/browserconfig.xml</span><br></pre></td></tr></table></figure><p></p><p><code>safari_pinned_tab</code>这一项需要使用<code>.svg</code>格式，找一个<code>在线png转svg的网站</code>转换一下就行了。命名为<code>logo.svg</code></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/d7900030/">Hexo搭建博客4 Next主题优化配置</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hexo博客问题 RSS地址出错为(yoursite.com)</title>
      <link href="/blog/2c22a8d1/"/>
      <url>/blog/2c22a8d1/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>这是因为你的站点url项没有配置好，因为默认的url配置为<code>https://yoursite.com</code>。</p><h2 id="解决方案，修改站点配置文件中的url字段为你自己的域名"><a href="#解决方案，修改站点配置文件中的url字段为你自己的域名" class="headerlink" title="解决方案，修改站点配置文件中的url字段为你自己的域名"></a>解决方案，修改站点配置文件中的url字段为你自己的域名</h2><a id="more"></a><p>打开<strong>站点配置文件</strong>，地位到url配置项，如下所示，可以看到我的网站地址错误的设置为<code>https://yoursite.com</code><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class="line"># 网站的地址</span><br><span class="line">url: https://yoursite.com/</span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure><p></p><p>把站点配置文件<code>url</code>字段，改为我的域名<code>https://www.lansheng.net.cn/</code>这样就可以了，如下所示。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class="line"># 网站的地址</span><br><span class="line">url: https://www.lansheng.net.cn/</span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure><p></p><p>然后后面就可以使用<code>hexo clean &amp;&amp; hexo g -d</code>进行发布,然后就可正确使用RSS功能了。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/2c22a8d1/">Hexo博客问题 RSS地址出错为(yoursite.com)</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
          <category> 遇到问题 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hexo搭建博客5 Next主题进阶配置</title>
      <link href="/blog/f01200cd/"/>
      <url>/blog/f01200cd/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:16 GMT+0800 (中国标准时间) --><p>摘要：本文将实现：</p><ul><li>实现点击出现爱心效果</li><li>网站底部字数统计</li><li>保留<code>README.md</code>文件</li><li>设置网站的图标Favicon</li><li>实现统计功能</li><li>隐藏网页底部<code>powered By Hexo / 强力驱动</code></li><li>隐藏网页底部<code>主题 – NexT.Gemini v6.4.0</code></li><li>修改字体大小<a id="more"></a></li></ul><h2 id="实现点击出现爱心效果"><a href="#实现点击出现爱心效果" class="headerlink" title="实现点击出现爱心效果"></a>实现点击出现爱心效果</h2><p>原文：<a href="https://blog.csdn.net/qq_33699981/article/details/72716951#t9" target="_blank" rel="noopener">https://blog.csdn.net/qq_33699981/article/details/72716951#t9</a></p><p>实现效果图：<br><img src="https://i.imgur.com/EpUqVjH.gif" alt=""></p><p>具体实现方法：</p><p>在浏览器地址栏输入如下<a href="http://7u2ss1.com1.z0.glb.clouddn.com/love.js" target="_blank" rel="noopener">http://7u2ss1.com1.z0.glb.clouddn.com/love.js</a></p><p>然后将里面的代码copy一下，新建love.js文件并且将代码复制进去，然后保存。将love.js文件放到路径<code>/themes/next/source/js/src</code>里面，然后打开<code>\themes\next\layout\_layout.swig</code>文件,在<strong>末尾</strong>（在前面引用会出现找不到的bug）添加以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 页面点击小红心 --&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>然后刷新浏览器就可看到效果了。</p><h2 id="网站底部字数统计"><a href="#网站底部字数统计" class="headerlink" title="网站底部字数统计"></a>网站底部字数统计</h2><p>实现效果图：</p><p><img src="https://i.imgur.com/ShrEa8j.png" alt=""></p><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>切换到根目录下，然后运行如下代码,安装插件。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure><p></p><h3 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h3><p>然后在<code>/themes/next/layout/_partials/footer.swig</code>文件尾部加上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;theme-info&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="保留README-md文件"><a href="#保留README-md文件" class="headerlink" title="保留README.md文件"></a>保留<code>README.md</code>文件</h2><p>每个项目下一般都有一个 <code>README.md</code> 文件，但是使用 <code>hexo</code> 部署到仓库后，项目下是没有 <code>README.md</code> 文件的。</p><p>在 <code>Hexo</code> 目录下的 <code>source</code> 根目录下添加一个 <code>README.md</code> 文件，修改站点配置文件 <code>_config.yml</code>，将 <code>skip_render</code> 参数的值设置为<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skip_render: README.md</span><br></pre></td></tr></table></figure><p></p><p>保存退出即可。再次使用 <code>hexo d</code> 命令部署博客的时候就不会在渲染 <code>README.md</code> 这个文件了。</p><h2 id="设置网站的图标Favicon"><a href="#设置网站的图标Favicon" class="headerlink" title="设置网站的图标Favicon"></a>设置网站的图标Favicon</h2><p>实现效果图</p><p>具体方法实现</p><p>在<a href="http://www.easyicon.net/" target="_blank" rel="noopener">EasyIcon</a>中找一张（32*32）的ico图标,或者去别的网站下载或者制作，我下载的是这个和很可爱的图标：<a href="https://www.easyicon.net/570008-matte_white_square_icon_animals_animal_panda_sc_icon.html" target="_blank" rel="noopener">https://www.easyicon.net/570008-matte_white_square_icon_animals_animal_panda_sc_icon.html</a></p><p><img src="https://i.imgur.com/PQNW5QZ.png" alt=""></p><p>下载后，用Photoshop调了大小(像素)：</p><p><img src="https://i.imgur.com/gewa12f.png" alt=""></p><p>这里只是为了，记录着良心的图标网站，具体设置方法不细<br>在<strong>主题配置文件</strong>中配置就好了，图标和其他图片一样放在<code>source/images/</code>目录下。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: /images/favicon-16x16-next.png</span><br><span class="line">  medium: /images/favicon-32x32-next.png</span><br><span class="line">  apple_touch_icon: /images/apple-touch-icon-next.png</span><br><span class="line">  safari_pinned_tab: /images/logo.svg</span><br><span class="line">  #android_manifest: /images/manifest.json</span><br></pre></td></tr></table></figure><p></p><h2 id="实现统计功能"><a href="#实现统计功能" class="headerlink" title="实现统计功能"></a>实现统计功能</h2><h3 id="安装插件-1"><a href="#安装插件-1" class="headerlink" title="安装插件"></a>安装插件</h3><p><a href="https://github.com/willin/hexo-wordcount" target="_blank" rel="noopener">https://github.com/willin/hexo-wordcount</a>这个插件已经好久没更新了，<br>而这个插件：<br><a href="https://github.com/theme-next/hexo-symbols-count-time" target="_blank" rel="noopener">https://github.com/theme-next/hexo-symbols-count-time</a><br>最近更新的。而且hexo-symbols-count-time的介绍是</p><blockquote><p>Symbols count and time to read of articles.</p><p>Better than <a href="https://github.com/ierhyna/hexo-reading-time" target="_blank" rel="noopener">hexo-reading-time</a> and faster than <a href="https://github.com/willin/hexo-wordcount" target="_blank" rel="noopener">hexo-worcount</a>. No external dependencies.</p></blockquote><p>所以当然选最快的啦。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure><p></p><p>在主题配置文件中找到symbols_count_time然后配置如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Dependencies: https://github.com/theme-next/hexo-symbols-count-time</span><br><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: true</span><br><span class="line">  item_text_post: true</span><br><span class="line">  item_text_total: false</span><br><span class="line">  awl: 4</span><br><span class="line">  wpm: 275</span><br></pre></td></tr></table></figure><p></p><p>显示效果如下：</p><p><img src="https://i.imgur.com/nULsorT.png" alt=""></p><h2 id="隐藏网页底部powered-By-Hexo-强力驱动"><a href="#隐藏网页底部powered-By-Hexo-强力驱动" class="headerlink" title="隐藏网页底部powered By Hexo / 强力驱动"></a>隐藏网页底部<code>powered By Hexo / 强力驱动</code></h2><p>在主题配置文件中，找到powered键，设置enable为false就行。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">copyright:</span><br><span class="line"># -------------------------------------------------------------</span><br><span class="line">powered:</span><br><span class="line">  # Hexo link (Powered by Hexo).</span><br><span class="line">  enable: false #原本是默认打开的</span><br><span class="line">  # Version info o</span><br></pre></td></tr></table></figure><p></p><h2 id="隐藏网页底部主题-–-NexT-Gemini-v6-4-0"><a href="#隐藏网页底部主题-–-NexT-Gemini-v6-4-0" class="headerlink" title="隐藏网页底部主题 – NexT.Gemini v6.4.0"></a>隐藏网页底部<code>主题 – NexT.Gemini v6.4.0</code></h2><p>在主题配置文件中，找到<code>theme:</code>，设置enable为false就行。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">theme:</span><br><span class="line">  # Theme &amp; scheme info link (Theme - NexT.scheme).</span><br><span class="line">  enable: false #原本是默认打开的 设置为则false隐藏网页底部powered By Hexo / 强力驱动</span><br><span class="line">  # Version info of NexT after scheme info (vX.X.X).</span><br><span class="line">  version: true</span><br></pre></td></tr></table></figure><p></p><p>显示效果：</p><p><img src="https://i.imgur.com/hicNOt1.png" alt=""></p><h2 id="修改字体大小"><a href="#修改字体大小" class="headerlink" title="修改字体大小"></a>修改字体大小</h2><p>打开<code>\themes\next\source\css\ _variables\base.styl</code>文件，将<code>$font-size-base</code>改成<code>16px</code>，如下所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$font-size-base            =16px</span><br></pre></td></tr></table></figure><p></p><p><code>16px</code>我看太大了手机上阅读不方便，留着这个方法，也许哪天我想把字体改小。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/f01200cd/">Hexo搭建博客5 Next主题进阶配置</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>详解Java如何获取文件编码格式</title>
      <link href="/blog/56f38074/"/>
      <url>/blog/56f38074/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p><a href="https://www.jb51.net/article/102705.htm" target="_blank" rel="noopener">本文转自</a><br>这篇文章主要介绍了详解Java如何获取文件编码格式，具有一定的参考价值，感兴趣的小伙伴们可以参考一下。</p><h2 id="Windows中使用BOM判断该文件"><a href="#Windows中使用BOM判断该文件" class="headerlink" title="Windows中使用BOM判断该文件"></a>Windows中使用BOM判断该文件</h2><p><strong>1：简单判断是UTF-8或不是UTF-8</strong>，因为在国内一般除了UTF-8之外就是GBK，所以就设置默认为GBK。</p><p><strong>按照给定的字符集存储文件时，在文件的最开头的三个字节中就有可能存储着编码信息</strong>，所以，<strong>基本的原理就是只要读出文件前三个字节，判定这些字节的值，就可以得知其编码的格式。</strong>其实，，如果这些文本文件在项目内产生，即开发人员可以控制文本的编码格式，只要判定两种如果项目运行的平台就是中文操作系统常见的编码就可以了：GBK和UTF-8。由于中文Windows默认的编码是GBK，所以一般只要判定UTF-8编码格式。</p><p><strong>对于UTF-8编码格式的文本文件，其前3个字节的值就是-17、-69、-65</strong>，所以，判定是否是UTF-8编码格式的代码片段如下：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(path); </span><br><span class="line">InputStream in= <span class="keyword">new</span> java.io.FileInputStream(file); </span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">3</span>]; </span><br><span class="line">in.read(b); </span><br><span class="line">in.close(); </span><br><span class="line"><span class="keyword">if</span> (b[<span class="number">0</span>] == -<span class="number">17</span> &amp;&amp; b[<span class="number">1</span>] == -<span class="number">69</span> &amp;&amp; b[<span class="number">2</span>] == -<span class="number">65</span>) </span><br><span class="line"> System.out.println(file.getName() + <span class="string">"：编码为UTF-8"</span>); </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"> System.out.println(file.getName() + <span class="string">"：可能是GBK，也可能是其他编码"</span>);</span><br></pre></td></tr></table></figure><p>通过这个方法，<strong>只要知道文件头存储的编码信息，可以类似判断文件是否是某一编码格式的文件，不再限于是否是utf-8</strong>，就不在赘述。注意这个方法的局限<strong>：文件头必须有文件存储编码的信息</strong>，对于不规范的文件或被篡改过的就不好办了<br>把上面的方法封装成函数<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 判断是不是utf8编码</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> file 文件名</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 根据文件字节序列的头部的编码信息判断是不是utf8编码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isUTF8File</span><span class="params">(File file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InputStream in = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        in = <span class="keyword">new</span> java.io.FileInputStream(file);</span><br><span class="line"><span class="comment">//      读取3个字节</span></span><br><span class="line">        in.read(b);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e)</span><br><span class="line">    &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line">    &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (in != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                in.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b[<span class="number">0</span>] == -<span class="number">17</span> &amp;&amp; b[<span class="number">1</span>] == -<span class="number">69</span> &amp;&amp; b[<span class="number">2</span>] == -<span class="number">65</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>测试：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    String path = <span class="string">"D:\\学习\\python\\test_utf8.py"</span>;</span><br><span class="line">    File file = <span class="keyword">new</span> File(path);</span><br><span class="line">    System.out.println(file.getAbsolutePath()+<span class="string">"是utf-8编码的文件:"</span>+isUTF8File(file));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这里的test_utf8.py这个文件用的是utf-8编码的，现在打开这个文件，然后以16进制的方式查看该文件。<br><img src="https://i.imgur.com/nLTgZnD.png" alt=""><br>可以看到该文件以<code>EF BB BF</code>这三个字节开头，这三个字节表示该文件是UTF-8编码的。所以我们能通过这样来判断该文件是不是UTF-8编码的。<br><code>EF BB BF</code>转成字节表示就是<code>-17,-69,-65</code>.不信来看下面的代码：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.out.print((<span class="keyword">byte</span>)Integer.parseInt(<span class="string">"EF"</span>, <span class="number">16</span>)+<span class="string">","</span>);</span><br><span class="line">    System.out.print((<span class="keyword">byte</span>)Integer.parseInt(<span class="string">"BB"</span>, <span class="number">16</span>)+<span class="string">","</span>);</span><br><span class="line">    System.out.print((<span class="keyword">byte</span>)Integer.parseInt(<span class="string">"BF"</span>, <span class="number">16</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<code>-17,-69,-65</code></p><h2 id="使用开源项目"><a href="#使用开源项目" class="headerlink" title="使用开源项目"></a>使用开源项目</h2><p>2：若想实现更复杂的文件编码检测，可以使用一个开源项目cpdetector，它所在的网址是：<a href="http://cpdetector.sourceforge.net/。它的类库很小，只有500K左右，cpDetector是基于统计学原理的，不保证完全正确，利用该类库判定文本文件的代码如下：" target="_blank" rel="noopener">http://cpdetector.sourceforge.net/。它的类库很小，只有500K左右，cpDetector是基于统计学原理的，不保证完全正确，利用该类库判定文本文件的代码如下：</a></p><p>读外部文件(先利用cpdetector检测文件的编码格式，然后用检测到的编码方式去读文件):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 利用第三方开源包cpdetector获取文件编码格式 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> path </span></span><br><span class="line"><span class="comment"> *   要判断文件编码格式的源文件的路径 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> huanglei </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2012-7-12 14:05 </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getFileEncode</span><span class="params">(String path)</span> </span>&#123; </span><br><span class="line"> <span class="comment">/* </span></span><br><span class="line"><span class="comment">  * detector是探测器，它把探测任务交给具体的探测实现类的实例完成。 </span></span><br><span class="line"><span class="comment">  * cpDetector内置了一些常用的探测实现类，这些探测实现类的实例可以通过add方法 加进来，如ParsingDetector、 </span></span><br><span class="line"><span class="comment">  * JChardetFacade、ASCIIDetector、UnicodeDetector。 </span></span><br><span class="line"><span class="comment">  * detector按照“谁最先返回非空的探测结果，就以该结果为准”的原则返回探测到的 </span></span><br><span class="line"><span class="comment">  * 字符集编码。使用需要用到三个第三方JAR包：antlr.jar、chardet.jar和cpdetector.jar </span></span><br><span class="line"><span class="comment">  * cpDetector是基于统计学原理的，不保证完全正确。 </span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line"> CodepageDetectorProxy detector = CodepageDetectorProxy.getInstance(); </span><br><span class="line"> <span class="comment">/* </span></span><br><span class="line"><span class="comment">  * ParsingDetector可用于检查HTML、XML等文件或字符流的编码,构造方法中的参数用于 </span></span><br><span class="line"><span class="comment">  * 指示是否显示探测过程的详细信息，为false不显示。 </span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line"> detector.add(<span class="keyword">new</span> ParsingDetector(<span class="keyword">false</span>)); </span><br><span class="line"> <span class="comment">/* </span></span><br><span class="line"><span class="comment">  * JChardetFacade封装了由Mozilla组织提供的JChardet，它可以完成大多数文件的编码 </span></span><br><span class="line"><span class="comment">  * 测定。所以，一般有了这个探测器就可满足大多数项目的要求，如果你还不放心，可以 </span></span><br><span class="line"><span class="comment">  * 再多加几个探测器，比如下面的ASCIIDetector、UnicodeDetector等。 </span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line"> detector.add(JChardetFacade.getInstance());<span class="comment">// 用到antlr.jar、chardet.jar </span></span><br><span class="line"> <span class="comment">// ASCIIDetector用于ASCII编码测定 </span></span><br><span class="line"> detector.add(ASCIIDetector.getInstance()); </span><br><span class="line"> <span class="comment">// UnicodeDetector用于Unicode家族编码的测定 </span></span><br><span class="line"> detector.add(UnicodeDetector.getInstance()); </span><br><span class="line"> java.nio.charset.Charset charset = <span class="keyword">null</span>; </span><br><span class="line"> File f = <span class="keyword">new</span> File(path); </span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line">  charset = detector.detectCodepage(f.toURI().toURL()); </span><br><span class="line"> &#125; <span class="keyword">catch</span> (Exception ex) &#123; </span><br><span class="line">  ex.printStackTrace(); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">if</span> (charset != <span class="keyword">null</span>) </span><br><span class="line">  <span class="keyword">return</span> charset.name(); </span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">String charsetName = getFileEncode(configFilePath); </span><br><span class="line">System.out.println(charsetName); </span><br><span class="line">inputStream = <span class="keyword">new</span> FileInputStream(configFile); </span><br><span class="line">BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream, charsetName));</span><br></pre></td></tr></table></figure><p>读jar包内部资源文件(先利用cpdetector检测jar内部的资源文件的编码格式，然后以检测到的编码方式去读文件)：</p><p>/**</p><ul><li>利用第三方开源包cpdetector获取URL对应的文件编码</li><li></li><li>@param path</li><li>要判断文件编码格式的源文件的URL</li><li>@author huanglei</li><li>@version 2012-7-12 14:05<br><em>/<br>public static String getFileEncode(URL url) {<br>/</em><ul><li>detector是探测器，它把探测任务交给具体的探测实现类的实例完成。</li><li>cpDetector内置了一些常用的探测实现类，这些探测实现类的实例可以通过add方法 加进来，如ParsingDetector、</li><li>JChardetFacade、ASCIIDetector、UnicodeDetector。</li><li>detector按照“谁最先返回非空的探测结果，就以该结果为准”的原则返回探测到的</li><li>字符集编码。使用需要用到三个第三方JAR包：antlr.jar、chardet.jar和cpdetector.jar</li><li>cpDetector是基于统计学原理的，不保证完全正确。<br><em>/<br>CodepageDetectorProxy detector = CodepageDetectorProxy.getInstance();<br>/</em></li><li>ParsingDetector可用于检查HTML、XML等文件或字符流的编码,构造方法中的参数用于</li><li>指示是否显示探测过程的详细信息，为false不显示。<br><em>/<br>detector.add(new ParsingDetector(false));<br>/</em></li><li>JChardetFacade封装了由Mozilla组织提供的JChardet，它可以完成大多数文件的编码</li><li>测定。所以，一般有了这个探测器就可满足大多数项目的要求，如果你还不放心，可以</li><li>再多加几个探测器，比如下面的ASCIIDetector、UnicodeDetector等。<br>*/<br>detector.add(JChardetFacade.getInstance());// 用到antlr.jar、chardet.jar<br>// ASCIIDetector用于ASCII编码测定<br>detector.add(ASCIIDetector.getInstance());<br>// UnicodeDetector用于Unicode家族编码的测定<br>detector.add(UnicodeDetector.getInstance());<br>java.nio.charset.Charset charset = null;<br>try {<br>charset = detector.detectCodepage(url);<br>} catch (Exception ex) {<br>ex.printStackTrace();<br>}<br>if (charset != null)<br>return charset.name();<br>else<br>return null;<br>}</li></ul></li></ul><p>URL url = CreateStationTreeModel.class.getResource(“/resource/“ + “配置文件”);<br>URLConnection urlConnection = url.openConnection();<br>inputStream=urlConnection.getInputStream();<br>String charsetName = getFileEncode(url);<br>System.out.println(charsetName);<br>BufferedReader in = new BufferedReader(new InputStreamReader(inputStream, charsetName));</p><p>3：探测任意输入的文本流的编码，方法是调用其重载形式：</p><p>charset=detector.detectCodepage(待测的文本输入流,测量该流所需的读入字节数);</p><p>上面的字节数由程序员指定，字节数越多，判定越准确，当然时间也花得越长。要注意，字节数的指定不能超过文本流的最大长度。</p><p>4：判定文件编码的具体应用举例：</p><p>属性文件(.properties)是Java程序中的常用文本存储方式，象STRUTS框架就是利用属性文件存储程序中的字符串资源。它的内容如下所示：</p><p>#注释语句</p><p>属性名=属性值</p><p>读入属性文件的一般方法是：</p><p>FileInputStream ios=new FileInputStream(“属性文件名”);<br>Properties prop=new Properties();<br>prop.load(ios);<br>String value=prop.getProperty(“属性名”);<br>ios.close();</p><p>利用java.io.Properties的load方法读入属性文件虽然方便，但如果属性文件中有中文，在读入之后就会发现出现乱码现象。发生这个原因是load方法使用字节流读入文本，在读入后需要将字节流编码成为字符串，而它使用的编码是“iso-8859-1”,这个字符集是ASCII码字符集，不支持中文编码，</p><p>方法一：使用显式的转码：</p><p>String value=prop.getProperty(“属性名”);<br>String encValue=new String(value.getBytes(“iso-8859-1″),”属性文件的实际编码”);</p><p>方法二：象这种属性文件是项目内部的，我们可以控制属性文件的编码格式，比如约定采用Windows内定的GBK，就直接利用”gbk”来转码， 如果约定采用UTF-8，就使用”UTF-8″直接转码。</p><p>方法三：如果想灵活一些，做到自动探测编码，就可利用上面介绍的方法测定属性文件的编码，从而方便开发人员的工作</p><p>补充：可以用下面代码获得Java支持编码集合：</p><p>Charset.availableCharsets().keySet();</p><p>可以用下面的代码获得系统默认编码：</p><p>Charset.defaultCharset();</p><p>以上就是本文的全部内容，希望对大家的学习有所帮助，也希望大家多多支持脚本之家。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/56f38074/">详解Java如何获取文件编码格式</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java IO流 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>utf-8与utf-8+bom的区别</title>
      <link href="/blog/9d9c8d3/"/>
      <url>/blog/9d9c8d3/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p><strong>utf-8与utf-8+bom的区别</strong><br><a href="https://blog.csdn.net/qq_27289001/article/details/76100335" target="_blank" rel="noopener">原文链接</a></p><p>在utf-8编码文件中，BOM写在文件头部，占用三个字节，用来标识该文件属于utf-8编码，现在已经有很多软件识别BOM头，但还是有些不能识别BOM头，比如PHP就不能识别BOM头，这也就是用记事本编辑utf-8编码的PHP文件后，就会报错的原因。<br><strong>在windows环境下，用记事本打开任何一个文本文件，另存为utf-8格式后，这样文件就自动被加上了BOM头信息</strong>。可以很明显的看出，含BOM头的文件多出三个字节 <code>efbbbf</code>。<br><a id="more"></a><br>notepad++会自动添加为带Bom的utf8比较坑爹。带 BOM 的 UTF-8 就是赤裸裸的耍流氓！！！！！！！！！<br>windows总是自做聪明的做一些别人无法理解的事情！！！UTF-8是不需要BOM头的~~~！！<br><a href="https://zhidao.baidu.com/question/1988203804217274627.html" target="_blank" rel="noopener">原文链接</a></p><p>utf-8+bom比utf-8多了三个字节前缀：0xEF0xBB0xBF，有这三个字节前缀的文本或字符串，程序可以自动判断它为utf-8格式，并按照utf-8格式来解析文本或字符串，否则，一个文本或者字符串在未知编码的情况下，需要按照字符编码规范去一个个验证</p><h1 id="UTF-8的BOM含义"><a href="#UTF-8的BOM含义" class="headerlink" title="UTF-8的BOM含义"></a>UTF-8的BOM含义</h1><p><a href="https://www.cnblogs.com/zhangqunshi/p/6645130.html" target="_blank" rel="noopener">原文链接</a></p><h2 id="BOM的介绍"><a href="#BOM的介绍" class="headerlink" title="BOM的介绍"></a>BOM的介绍</h2><p>在github上写md文件的时候，发现生成自己blog时，报出一个错误是让使用UTF-8编码，然后在Notepad++上把文件转成UTF-8时，发现菜单中有”UTF-8无BOM编码格式”。</p><p>上网查了一下BOM的定义：<code>byte order mark</code><br>这个是为UTF-16和UTF-32准备的，用于<code>标记字节序</code>(byte order)。</p><p><strong>「UTF-8」和「带 BOM 的 UTF-8」的区别就是有没有 BOM。即文件开头有没有 U+FEFF。</strong></p><h2 id="BOM的爱恨情仇"><a href="#BOM的爱恨情仇" class="headerlink" title="BOM的爱恨情仇"></a>BOM的爱恨情仇</h2><p>知乎上有个比较好的文章，讲了BOM问题，下面直接引用了原文：</p><p>作者：陈甫鸼<br>链接：<a href="https://www.zhihu.com/question/20167122/answer/14199022" target="_blank" rel="noopener">https://www.zhihu.com/question/20167122/answer/14199022</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>首先，BOM是啥。这个就不解释了，Wikipedia上很详细。<a href="http://en.wikipedia.org/wiki/Byte_order_mark。" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Byte_order_mark。</a><br><strong>在网页上使用BOM是个错误。BOM设计出来不是用来支持HTML和XML的,要识别文本编码</strong>。HTML有charset属性，XML有encoding属性，没必要拉BOM撑场面。</p><p>虽然理论上BOM可以用来识别UTF-16编码的HTML页面，但实际工程上很少有人这么干。毕竟UTF-16这种编码连ASCII都双字节，实在不适用于做网页。其实说BOM是个坏习惯也不尽然。BOM也是Unicode标准的一部分，有它特定的适用范围。</p><p>通常BOM是用来标示Unicode纯文本字节流的，用来提供一种方便的方法让文本处理程序识别读入的.txt文件是哪个Unicode编码（UTF-8，UTF-16BE，UTF-16LE）。Windows相对对BOM处理比较好，是因为Windows把Unicode识别代码集成进了API里，主要是CreateFile()。打开文本文件时它会自动识别并剔除BOM。Windows用这个有历史原因，因为它最初脱胎于多代码页的环境。而引入Unicode时Windows的设计者又希望能在用户不注意的情况下同时兼容Unicode和非Unicode（Multiple byte）文本文件，就只能借助这种小trick了。相比之下，Linux这样的系统在多locale的环境中浸染的时间比较短，再加上社区本身也有足够的动力轻装前进（吐槽：微软对兼容性的要求确实是到了非常偏执的地步，任何一点破坏兼容性的做法都不允许，以至于很多时候是自己绑住自己的双手），所以干脆一步到位进入UTF-8。当然中间其实有一段过渡期，比如从最初全UTF-8的GTK+2.0发布到基本上所有GTK开发者都弃用多locale的GTK+1.2，我印象中至少经历了三到四年。</p><p>BOM不受欢迎主要是在UNIX环境下，因为很多UNIX程序不鸟BOM。主要问题出在<strong>UNIX那个所有脚本语言通行的首行#!标示，这东西依赖于shell解析，而很多shell出于兼容的考虑不检测BOM，所以加进BOM时shell会把它解释为某个普通字符输入导致破坏#!标示，这就麻烦了</strong>。其实很多现代脚本语言，比如Python，其解释器本身都是能处理BOM的，但是shell卡在这里，没办法，只能躺着也中枪。说起来这也不能怪shell，因为BOM本身违反了一个UNIX设计的常见原则，就是文档中存在的数据必须可见。BOM不能作为可见字符被文本编辑器编辑，就这一条很多UNIX开发者就不满意。</p><p>顺便说一句，即使脚本语言能处理BOM，随处使用BOM也不是推荐的办法。各个脚本语言对Unicode的处理都有自己的一套，Python的 # – coding: utf-8 –，Perl的use utf8，都比BOM简单而且可靠。另一个好消息是，即使是必须在Windows和UNIX之间切换的朋友也不会悲催。幸亏在UNIX环境下我们还有VIM这种神器，即使遇到BOM挡道，我们也可以通过 set nobomb; set fileencoding=utf8; w 三条命令解决问题。最后回头想想，似乎也真就只有Windows坚持用BOM了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以下是一些经典语录：</p><ul><li>HTML有charset属性，XML有encoding属性，没必要拉BOM撑场面</li><li>UTF-16这种编码连ASCII都双字节，实在不适用于做网页</li><li>通常BOM是用来标示Unicode纯文本字节流的，让文本处理程序识别txt文件是哪个Unicode编码（UTF-8，UTF-16BE，UTF-16LE）</li><li>Windows相对对BOM处理比较好, 打开文本文件时它会自动识别并剔除BOM.</li><li>BOM不受欢迎主要是在UNIX环境下，因为很多UNIX程序不鸟BOM。因为BOM本身违反了一个UNIX设计的常见原则，就是文档中存在的数据必须可见。</li><li>UNIX环境下我们还有VIM这种神器，即使遇到BOM挡道，我们也可以通过 set nobomb; set fileencoding=utf8; w 三条命令解决问题。</li><li>似乎也真就只有Windows坚持用BOM了,微软在 UTF-8 中使用 BOM 是因为这样可以把 UTF-8 和 ASCII 等编码明确区分开</li><li>UTF-8不需要BOM, 所以不含BOM的UTF-8才是标准形式.</li><li>UTF-8 的网页代码不应使用 BOM，否则常常会出错<br>写C++代码建议程序要在windows 和 mac 还有linux 上运行的话，源代码最好保存成utf-8 带bom的格式，这样比较通用一些。而用utf-16 无论大端还是小端，g++ 都不认的。或者用utf-8 不带bom格式，然后代码不要出现非ascii 127以后的字符。<br>带用bom的utf-8也是符合国际标准的</li><li>为什么windows的记事本要强行给utf8加bom的原因——为了兼容旧系统的编码问题，unix阵营放弃带bom的utf8——为了让它们的上古程序能继续运行下去，这个各自有自己利益诉求的差异决定其实并不对错</li></ul><p>本文链接: <a href="https://www.lansheng.net.cn/blog/9d9c8d3/">utf-8与utf-8+bom的区别</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java IO流 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hexo搭建博客3 Next主题基本配置</title>
      <link href="/blog/60deb6e1/"/>
      <url>/blog/60deb6e1/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:16 GMT+0800 (中国标准时间) --><p>文本完成：</p><ul><li>添加分类页面菜单</li><li>设置代码高亮主题</li><li>侧边栏社交链接</li><li>开启打赏功能</li><li>支持部署到Github</li><li>头像</li></ul><a id="more"></a><h2 id="添加分类页面"><a href="#添加分类页面" class="headerlink" title="添加分类页面"></a>添加分类页面</h2><h3 id="修改菜单"><a href="#修改菜单" class="headerlink" title="修改菜单"></a>修改菜单</h3><p>在菜单中添加链接。编辑 <strong>主题配置文件</strong> ， 取消<code>categories</code>前面的注释<code>#</code>，添加 categories 到 menu 中，如下:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  #about: /about/ || user</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  #schedule: /schedule/ || calendar</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap</span><br><span class="line">  #commonweal: /404/ || heartbeat</span><br></pre></td></tr></table></figure><p></p><p>然后，开启本地服务器，显示效果如下：</p><p><img src="https://i.imgur.com/URgDMoO.png" alt=""></p><h2 id="设置代码高亮主题"><a href="#设置代码高亮主题" class="headerlink" title="设置代码高亮主题"></a>设置代码高亮主题</h2><p>NexT 使用 Tomorrow Theme 作为代码高亮，共有5款主题供你选择。 NexT 默认使用的是 白色的 normal 主题，可选的值有 normal，night， night blue， night bright， night eighties：</p><p>在<strong>主题配置文件</strong>中，更改 <code>highlight_theme</code> 字段，将其值设定成你所喜爱的高亮主题，例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">highlight_theme: night</span><br></pre></td></tr></table></figure><p></p><p>这样，代码框部分就显示如下了。这个根据个人喜好配置。<br><img src="https://i.imgur.com/8OVB603.png" alt=""></p><h2 id="侧边栏社交链接"><a href="#侧边栏社交链接" class="headerlink" title="侧边栏社交链接"></a>侧边栏社交链接</h2><p>侧栏社交链接的修改包含两个部分，第一是链接，第二是链接图标。 两者配置均在 主题配置文件 中。</p><ul><li>链接放置在 <code>social 字段下</code>，一行一个链接。其键值格式是 <code>显示文本: 链接地址</code>。例如：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/lanlan2017 || github</span><br></pre></td></tr></table></figure><p>双竖杠后面的是 <code>Font Awesome</code>图标名。</p><ul><li>设定链接的图标，对应的字段是 <code>social_icons</code>。其键值格式是 匹配键:<code>Font Awesome</code> 图标名称，<code>匹配键</code> 与上一步所配置的链接的 <code>显示文本</code> 相同（大小写严格匹配），<code>图标名称 是 Font Awesome 图标的名字</code>（不必带 fa前缀）。 enable 选项用于控制是否显示图标，你可以设置成 false 来去掉图标。<br>显示效果下：</li></ul><p><img src="https://i.imgur.com/wryxhjA.png" alt=""><br>可以看到侧栏已经重现了Github的连接，点击该连接后，可以跳转到你的GitHub首页。我上面还没什么东西，还是先不要给出的好</p><h2 id="开启打赏功能-由-habren-贡献"><a href="#开启打赏功能-由-habren-贡献" class="headerlink" title="开启打赏功能 由 habren 贡献"></a>开启打赏功能 由 habren 贡献</h2><p>越来越多的平台（微信公众平台，新浪微博，简书，百度打赏等）支持打赏功能，付费阅读时代越来越近，特此增加了打赏功能，支持微信打赏和支付宝打赏。 只需要 主题配置文件 中填入 微信 和 支付宝 收款二维码图片地址 即可开启该功能。<br>找到<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！</span><br><span class="line">wechatpay: /path/to/wechat-reward-image</span><br><span class="line">alipay: /path/to/alipay-reward-image</span><br></pre></td></tr></table></figure><p></p><p>打赏按钮将会显示在每篇文章的末尾，如下所示：<br><img src="https://i.imgur.com/GZrcx1w.png" alt=""><br>如果遇到图片大小不一样的话可以P图，</p><p><img src="https://i.imgur.com/snGV1Rf.png" alt=""></p><p>###解决赞赏码大小不一致的问题–P图啊 ###</p><p>但是这样大小不一样，强迫症的人会不舒服，怎么办呢？P图呗，把两张图片P成一样大小的就行了。</p><p>支付宝的收钱码，不能直接用Photoshop打开，所以，我先<strong>打开支付宝收钱码图片</strong>，<strong>截图</strong>。<br>然后打开Photoshop，按下<strong>ctrl+n</strong>新建一个图层。Photoshop会自动新建一个和我们复制大小一样的图层，<strong>粘贴</strong>这个支付宝的截图就行了，然后，<strong>再按下ctrl+n</strong>，这样会再建立一个大小一样的图层，<strong>把微信赞赏码的图片粘贴进去</strong>，微信赞赏码比较宽，肯定无法全部放下，<strong>拖动调整显示效果</strong>，露出赞赏码就行了。</p><p>然后再在主题配置文件中配置即可，现在效果如下：</p><p><img src="https://i.imgur.com/Oci7YhQ.png" alt=""></p><p>嗯，这样就看起来就舒服了。</p><h2 id="支持部署到Github"><a href="#支持部署到Github" class="headerlink" title="支持部署到Github"></a>支持部署到Github</h2><p>安装插件：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure><p></p><p>在GitHub建立一个，<code>你的用户名.github.io</code>的库。然后复制ssh链接。</p><p>更改站点配置文件中,<code>repo：</code>配置你的ssh链接，使用https的话可能要输入密码。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:你的用户名/你的用户名.github.io.git  # 3中创建的仓库的地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p></p><p>然后开始部署：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp;hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><p></p><p>即可，<a href="mailto:`git@github.com" target="_blank" rel="noopener">`git@github.com</a>:你的用户名/你的用户名.github.io.git`，这个是我的地址，改为你的ssh链接即可。</p><h2 id="头像"><a href="#头像" class="headerlink" title="头像"></a>头像</h2><p>在<strong>主题配置文件</strong>中配置。</p><p>把图片放置在<code>source/images</code>目录下，然后设置 <code>avatar</code> 项为你头像的链接，例如设置<code>avatar: /images/avatar.png</code>。<br>或者使用 <code>url: /images/avatar.jpg</code>来引用链接<br>如下所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">avatar: </span><br><span class="line">  # in theme directory(source/images): /images/avatar.gif</span><br><span class="line">  # in site  directory(source/uploads): /uploads/avatar.gif</span><br><span class="line">  # You can also use other linking images.</span><br><span class="line">  url: /images/avatar.jpg</span><br><span class="line">  # If true, the avatar would be dispalyed in circle.</span><br><span class="line">  rounded: true</span><br><span class="line">  # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar.</span><br><span class="line">  opacity: 1</span><br><span class="line">  # If true, the avatar would be rotated with the cursor.</span><br><span class="line">  rotated: false</span><br></pre></td></tr></table></figure><p></p><p>还有就是如果可能引用不到的话可以改一下作者图片的名称看看。</p><p>剩下的我不想写了，我上次没弄好是因为，next安装有问题。这次安装没问题，按<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">官方文档</a>配置就行了。</p><p>剩下的还有，添加评论，添加搜索引擎，调整显示宽度</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/60deb6e1/">Hexo搭建博客3 Next主题基本配置</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Node_js安装教程</title>
      <link href="/blog/6d7c88e7/"/>
      <url>/blog/6d7c88e7/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:16 GMT+0800 (中国标准时间) --><p>参见：<a href="https://www.cnblogs.com/zhouyu2017/p/6485265.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhouyu2017/p/6485265.html</a></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/6d7c88e7/">Node_js安装教程</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Nodejs </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java网络编程第4版 第3章 线程</title>
      <link href="/blog/4bfc148a/"/>
      <url>/blog/4bfc148a/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>事实上，在Internet只有几百万用户而不是数十亿用户的时候，我们远比现在更容易碰上超负荷的拥塞网站。问题在于，大多数FTP服务器会费每个连接创建(fork)一个新的进程(也就是说100个并发用户意味着要处理100个额外的进程)。由于进程是相当重量级的，太多进程会很快让服务器吃不消。问题不在于机器不够强大，或者网络速度不够开，而是因为你FTP服务器实现得太差。如果不是每个连接都需要一个新的进程，完全可以为更多的并发用户提供服务。<br>早起Web服务器也有这个问题，不过这个问题由于HTTP连接的短暂特性而有所掩盖。由于Web页面嵌入的图片一般很小(至少与通常通过FTP获取的软件包相比要小的多)，也由于Web浏览器在获取各个文件后会”挂起”连接，而不是一次保持数分钟或几小时的连接。所以Web用户不会像FTP用户那样对服务器施加太多负担。不过，随着使用量的增长，Web服务器的性能仍会下降。根本问题在于，很容易编写代码将每个入站和新任务当多独立的进程来处理(至少UNIX下是如此)，这种解决方案将无法扩展。等到服务器要处理成千上万个同时的连接时，性能就会变得像爬行一样慢了。<br><a id="more"></a></p><p>这问题至少有两种解决方案。第一种是重用进程，而不是创建新的进程。服务器启动时，就创建固定数量的进程(比如300个)来处理请求。入站请求将放入一个队列。每个进程从队列中删除一个请求，为这个请求提供服务，然后返回到队列来得到下一个请求。金软仍有300个单独的进程在运行，但是由于避免了建立和销毁进程的所有开销，现在这300个进程就可用完场1000个进程的任务。这个数目是粗略估计的，你的实际情况可能有所出入，尤其是当你的服务器还没有达到一定的处理规模，即还没有遭遇可扩展性问题的时候，到底能有多少获益并不确定。不过，不论不生成新进程有什么好处，起码重用就的进程总会有更好的表现。</p><p>这个问题的第二种解决方案是，使用轻量级的线程来处理连接，而不是重量级的进程。<br>虽然每个单独的进程都有自己的一块内存，但线程在资源使用上更宽松，因为它们会共享内存。使用线程来代替进程，开业让你的服务性能提升三倍。再结合使用可重用线程池(而不是可重用进程池)，在同样的硬件和网络连接条件下，服务器的运行可以快9倍多！在服务器硬件上运行多个不同的线程，其影响是相对最小的，因为致谢线程都在一个进程中运行。如果并发线程达到4000到20000时，大多数Java虚拟机可能会由于内存耗尽而无法承受。不过，通过使用线程池而不是为每个连接生成新线程，服务器每分钟就可以用不到100个线程来处理数千个短连接。</p><hr><p><center>线程的替代方法</center><br>如果一个应用同时需要数千个持续很长时间的连接(这种应用相当少见)，就需要考虑异步I/O而不是线程。选择器，支持一个线程查询一组socket,找出那些socket已经准备就绪可以读写数据，然后顺序地处理这些准备好的socket。在这种情况下，必须基于通道和缓冲区来设计I/O而不是流。</p><p>由于现代虚拟机和操作系统中线程可以用提供很高的性能，而且构建一个基于线程的服务器相对简单，所以开始时总会考虑采用基于线程的设置，知道遇到难以逾越的困难。如果确实遇到了麻烦，应该考虑将应用分解到多个冗余的服务器上，而不要完全一张一个服务器上的3倍性能提升。</p><p>当然，分解又会带来相应的设计问题，特别是在一致性方面，而这个单系统中没有的问题。不过，与利用单个系统相比，不论实现的效率如何，这样确实可以提供更大的可扩展型和冗余性。</p><hr><p>遗憾的是，这种性能的提升并不是没有代价的,它会增加程序的复杂性。特别是多线程服务器(和其他多线程程序)要求程序员解决一些问题，对于单线程程序而言远门不存在这些问题，尤其是安全性和活动性的问题，因为不同的线程共享相同的内存，一个线程完全有可能会破坏另一个线程使用的变量和数据结构。这就类似与如果一个程序在没有内存保护机制的操作系统(如Windows 95)中运行，则有可能会破坏整个系统。因此，不同线程必须分厂注意当时使用的资源。一般来讲，每个线程只能在确保资源不会改变或者它独占访问权的室友才可以使用某个资源。不过，也可能两个线程太多小心，每个线程都在等待对资源的独占访问权，却永远都得不到。这样导致死锁，在这种情况下两个线程都在等待另一个线程所占有的资源。在没有得到另一线程所保留的资源时，两个线程都不会继续处理，但同时都不愿意放弃已经占有的资源。</p><h2 id="运行线程"><a href="#运行线程" class="headerlink" title="运行线程"></a>运行线程</h2><p>线程如果以小写字母t打头(thread)，这表示虚拟机中以单独，独立的执行了路径。如果以大写字母T打头(Thread)，则是java.lang.Thread类的一个实例。在虚拟机中执行的线程与虚拟机构造的Thread对象之间存在一种一一对应的关系。如果确实需要区分这两者，大多数情况下是从上下文就能显示地看出到你是线程还是Thread对象。</p><p>为了启动一个新线程在虚拟机中运行，要构造一个Thread类的一个实例，调用它的start()方法，如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread t =new Thread();</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure><p>当然这个线程没什么意思，因为它什么都没有做。要让线程完成一些操作，可以对Thread类派生子类，覆盖其run()方法。或只实现Runable接口，将Runable对象传递给Thread够着函数。我一般会选择第二种方法，因为这样可以更清楚地将线程完成的任务与线程本分区分开，但是在本书以及其他地方，你会看到这两种技术都在使用。不论采用哪一种方法，关键都在于run()方法，它的签名是：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p></p><p>你应当把线程要做的所有工作够放在这个方法中，这个方法可以调用其他方法;可以构造其他对象。甚至可以生成其他线程，不过线程要在这里启动，并在这里结束。<br>当run()方法完成时，线程也就消失了。事实上，run()对于线程就想main()方法对于非线程化传统程序的作用一样。单线程程序会在main()方法返回时退出。多线程程序会在main()方法以及所有非守护线程(nodaemon thread)都返回时才退出(守护线程完成后台任务，如垃圾回收，守护线程并不阻止虚拟机退出)。</p><h2 id="派生Thread"><a href="#派生Thread" class="headerlink" title="派生Thread"></a>派生Thread</h2><p>考虑编写一个程序来计算多个文件的安全散列算法(SHA)摘要。很大程度上，这是一个受限于I/O的程序(也就是说，它的速度会受到从磁盘读取文件所花费时间的限制)。如果将它编写为一个标准的程序，串行地处理这些文件，程序就会花费大量的时间等待驱动器返回数据。这个限制对于网络程序尤其明显:程序运行的速度要比网络提供的输入的速度快。因此程序的大量时间够耗费在阻塞中。这些时间本可以被其他线程所用，可以处理其他输入源或者完成不依赖于慢速输入的操作(不是所有多线程程序都有这个特点。有时即使没有线程有大量空闲时间可以分配给其他线程，起码采用多线程设计程序会更容易，可以将程序分解为多个线程，分别执行独立的操作)。<br>实例3-1是Thread的子类，它的run()方法将为指定文件计算一个256位的SHA-2消息摘要。为此要用一个DiestInputStream读取这个文件。这个过滤器流在读取文件时计算一个加密散列函数。读取结束时，可以从digest()方法得到这个散列。<br>实例3-1: DigestThread<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> javax.xml.bind.*; <span class="comment">// for DatatypeConverter; requires Java 6 or JAXB 1.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DigestThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String filename;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DigestThread</span><span class="params">(String filename)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.filename = filename;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      FileInputStream in = <span class="keyword">new</span> FileInputStream(filename);</span><br><span class="line">      MessageDigest sha = MessageDigest.getInstance(<span class="string">"SHA-256"</span>);</span><br><span class="line">      DigestInputStream din = <span class="keyword">new</span> DigestInputStream(in, sha);</span><br><span class="line">      <span class="keyword">while</span> (din.read() != -<span class="number">1</span>) ;</span><br><span class="line">      din.close();</span><br><span class="line">      <span class="keyword">byte</span>[] digest = sha.digest();</span><br><span class="line">      </span><br><span class="line">      StringBuilder result = <span class="keyword">new</span> StringBuilder(filename);</span><br><span class="line">      result.append(<span class="string">": "</span>);</span><br><span class="line">      result.append(DatatypeConverter.printHexBinary(digest));</span><br><span class="line">      System.out.println(result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      System.err.println(ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException ex) &#123;</span><br><span class="line">      System.err.println(ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String filename : args) &#123;</span><br><span class="line">      Thread t = <span class="keyword">new</span> DigestThread(filename);</span><br><span class="line">      t.start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>main()方法从命令行中读取文件名，针对每个文件名启动一个新的DigestThread。这个线程的工作实际上是在run()方法中完成。这里，由一个DigestInputStream读取文件，然后结果摘要要以16进制编码方式显示到System.out。注意，首先在一个本地StringBuffer变量result中建立线程的整个输出，再用一次方法调用将它显示在控制台上。更明显的一种方法是使用System.out.print()一次显示一部分，但这里不采取这种方法。其愿意稍后讨论。</p><p>由于run()方法的签名是固定的，所以无法向其传递参数或从中返回值。因此，需要其他方法向线程传递信息和从中获取信息。传递信息最简单的方法是向构造函数传递参数，这会设置Thread子类中的字段，如签名所示。</p><p>由于线程的异步特性，要获得线程的信息并传回最初的调用线程，这会更加困难。示例3-1回避了这个问题，它没有将任何信息返回调用线程。只是把结果显示在System.out上。不过,大多数情况下，你希望把信息传递给程序的其他部分。可以把计算结果存储于一个字段，并提供一个获取方法返回这个字段的值。但是如何知道这个值的计算什么时候结束呢？这非常棘手，本章后面将更详细地进行讨论。</p><hr><p>警告:如果对Thread派生子类，就应当只覆盖run(),而不要覆盖其他方法！Thread类的其他各个方法(如start(),interrupt(),join(),sleep()等)都非常有特定的语义，它们与虚拟机的交互很难在你自己的代码中重新实现。应当覆盖run(),并根据需要提供额外的够着函数和其他方法，但不要替换Thread的任何其他标准方法。</p><hr><p>实现Runable接口</p><p>要想避免覆盖标准Thread方法，一种办法就是不要派生Thread类，而是将希望线程完成的任务编写为Runable接口的一个实例。这个接口声明了run()方法，这与Thread类完全一样:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void run()</span><br></pre></td></tr></table></figure><p></p><p>任何实现这个接口的类都必须提供这个方法，除了这个方法外，你可以自由地创建任何其他方法(可以使用你选择的任何方法名)，而绝不会无意外的妨碍线程的行为。它还运行你将香橙的任务放在其他类的子类中，如Applet或HTTPServlet。要启动Runable任务的一个线程，可以把 这个Runable对象传入Thread构造函数。例如:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread t =new Thread(myRunnableObject);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure><p></p><p>对于大多数通过派生Thread子类来解决的问题，可以很容易地改为使用Runable接口。实例3-2展示了这一点，它将实例3-1改写外使用Runable接口，而不是派生Thread的子类，除了名字的改变外，需要做的唯一修改就将extends Thread改为implements Runable,并在main()方法中把DigestRunable对象传递给Thread构造函数。程序的基本逻辑没有变。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> javax.xml.bind.*; <span class="comment">// for DatatypeConverter; requires Java 6 or JAXB 1.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DigestRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String filename;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DigestRunnable</span><span class="params">(String filename)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.filename = filename;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      FileInputStream in = <span class="keyword">new</span> FileInputStream(filename);</span><br><span class="line">      MessageDigest sha = MessageDigest.getInstance(<span class="string">"SHA-256"</span>);</span><br><span class="line">      DigestInputStream din = <span class="keyword">new</span> DigestInputStream(in, sha);</span><br><span class="line">      <span class="keyword">while</span> (din.read() != -<span class="number">1</span>) ;</span><br><span class="line">      din.close();</span><br><span class="line">      <span class="keyword">byte</span>[] digest = sha.digest();</span><br><span class="line">      </span><br><span class="line">      StringBuilder result = <span class="keyword">new</span> StringBuilder(filename);</span><br><span class="line">      result.append(<span class="string">": "</span>);</span><br><span class="line">      result.append(DatatypeConverter.printHexBinary(digest));</span><br><span class="line">      System.out.println(result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      System.err.println(ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException ex) &#123;</span><br><span class="line">      System.err.println(ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String filename : args) &#123;</span><br><span class="line">      DigestRunnable dr = <span class="keyword">new</span> DigestRunnable(filename);</span><br><span class="line">      Thread t = <span class="keyword">new</span> Thread(dr);</span><br><span class="line">      t.start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>并不认为实现Runable接口一定优于扩展Thread类，没有强有力的理由支持这一点，反之亦然。在一些特殊的情况下，例如本章后面的实例3-14，在每个Thread对象的构造函数中调用Thread类的一些实例方法可能很有中。这就需要使用子类。在另外一些特定的情况下，可能需要将run()方法放在某个类中，而这个类要扩展另一个类(如HTTPServlet),这种情况下就必须使用Runable接口。最后，有些崇尚面向对象的人人文，线程完成的任务实际上不是一种Thread，因此应当放在一个单独的类或接口。(如Runable)中，而不应该放在Thread的子类中。我部分同意这种观点，但我不认为这个观点想其声称的那样理由充分。所以，本书中主要使用Runable接口，但你也可以使用对你来说最方便的任何方法。</p><h2 id="从线程返回信息"><a href="#从线程返回信息" class="headerlink" title="从线程返回信息"></a>从线程返回信息</h2><p>习惯了传统单线程过程模型的程序员在转向多线程环境时，最难掌握的一点就是如何从线程返回信息。从结束的线程获得信息，这是多线程编程中最被误解的反面之一。run()方法和start()方法不不返回任何值。例如，假设不只是像示例3-1和示例3-2那样简单地显示SHA-256摘要，摘要线程需要把摘要返回给执行主线程。大多数人的第一个反应就是把结果存储在一个字段中，再提供一个获取方法，如示例3-3和示例3-4所示。示例3-3是一个计算指定文件摘要的Thread子类。示例3-4是一个简单的命令行用户界面，会接收文件名，并创建线程为这些文件计算摘要。<br>示例3-3:使用存取方法返回结果的线程<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnDigest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String filename;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span>[] digest;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ReturnDigest</span><span class="params">(String filename)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.filename = filename;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      FileInputStream in = <span class="keyword">new</span> FileInputStream(filename);</span><br><span class="line">      MessageDigest sha = MessageDigest.getInstance(<span class="string">"SHA-256"</span>);</span><br><span class="line">      DigestInputStream din = <span class="keyword">new</span> DigestInputStream(in, sha);</span><br><span class="line">      <span class="keyword">while</span> (din.read() != -<span class="number">1</span>) ; <span class="comment">// read entire file</span></span><br><span class="line">      din.close();</span><br><span class="line">      digest = sha.digest();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      System.err.println(ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException ex) &#123;</span><br><span class="line">      System.err.println(ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">byte</span>[] getDigest() &#123;</span><br><span class="line">    <span class="keyword">return</span> digest;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>示例3-4: 使用存取方法获得线程输出的主程序<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.xml.bind.*; <span class="comment">// for DatatypeConverter</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnDigestUserInterface</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String filename : args) &#123;</span><br><span class="line">      <span class="comment">// Calculate the digest</span></span><br><span class="line">      ReturnDigest dr = <span class="keyword">new</span> ReturnDigest(filename);</span><br><span class="line">      dr.start();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// Now print the result</span></span><br><span class="line">      StringBuilder result = <span class="keyword">new</span> StringBuilder(filename);</span><br><span class="line">      result.append(<span class="string">": "</span>);</span><br><span class="line">      <span class="keyword">byte</span>[] digest = dr.getDigest();</span><br><span class="line">      result.append(DatatypeConverter.printHexBinary(digest));</span><br><span class="line">      System.out.println(result); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>ReturnDiggest类把计算结果存储在私有字段digest中，可以通过getDigest()来访问。ReturnDiggestUserInterface中的main()方法循环处理由命令行得到的一个文件列表。它为每个文件启动一个新的ReturnDigest线程，然后试图使用getDigest()获取结果。不过，当你运行这个程序时，结果却不想你期望的那样:<br><img src="https://i.imgur.com/z9vQIDC.png" alt=""></p><p>问题在于，主程序会在线程有机会初始化摘要之前就获取并使用摘要。在单线程程序里这个控制流可以正常工作，但在这里不行，因为在单线程程序里，dr.start()只是在同一个线程中调用run()方法，而这里的情况有所不同。dr.start()启动的计算结果可能在main()方法调用dr.getDigest()之前结束，也可能还没有结束。如果没有结束，dr.getDigest()则会返回null,第一次尝试访问digest时会抛出一个NullPointerException异常。</p><h2 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h2><p>一种可能的方法是吧dr.getDigest()调用移到main()方法的后面部分，如下所示：<br>public void main(String[] args)<br>{<br>ReturnDigest[] digest=new ReturnDigest[args.length];<br>for(int i=0;i&lt;args.length;i++)<br>{<br>digests[i]=new ReturnDigest(args[i]);<br>digest[i].start();<br>}<br>for(int i=0;i&lt;args.length;i++)<br>{<br>//现在显示结果<br>StringBuffered result=new StringBuffer(args[i]);<br>result.append(“: “);<br>byte[] digest=digests[i].getDigest();<br>result.append(DatatypeConverter.printHexBinary(digest));</p><pre><code>    System.out.println(result);}</code></pre><p>}<br>如果你够幸运，这会正常工作，你将的到期望的输出，如下:</p><p><img src="https://i.imgur.com/D0tKKYu.png" alt=""></p><p>但我要强调一下这里所说的”幸运”。你可能得不到这个输出。事实上，你可能仍然会得到一个NullPointerException异常。这段代码是否能正常工作，完全取决于每个ReturnDigest线程是否在其getDigest()方法被调用之前结束。如果第一个for循环太快，在第一个for循环生成的线程结束之前就进入了第二个for循环。那么我们又会回到原点，遭遇同样的问题。更糟糕的是，程序看起来好型被挂起，而没有任何输出，甚至连栈轨迹都没有。</p><p>到底会得到正确的结果还是异常，或者是一个挂起的程序，这取决于很多因素，包括程序生成了多少线程，系统的CPU和磁盘的速度，系统使用多少个CPU,以及Java虚拟机为不同线程分配所用的算法。这些称为竞态条件(race condition)。能否取得到正确结果依赖于不同线程的相对速度，而你无法控制着一点。我们需要一种更好的方法，以保证在摘要就绪前不会调用getDigest()。</p><h2 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h2><p>大多数新手采用的解决方案是，让获取方法返回一个标志值(或者可能抛出一个异常)，直到设置了结束字段为止。然后主线程定期询问获取方法，查看是否返回了标志之外的值。这个例子中，这表示要重复地测试digest是否为空，只有不为空才使用。例如：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ReturnDigesst[] digests=<span class="keyword">new</span> ReturnDigest[args.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;args.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//计算摘要</span></span><br><span class="line">        digest[i]=<span class="keyword">new</span> ReturnDigest(args[i]);</span><br><span class="line">        digest[i].start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;args.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] digest=digest[i].getDigest();</span><br><span class="line">            <span class="keyword">if</span>(digest!=<span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                StringBuilder result=<span class="keyword">new</span> StringBuilder(args[i]);</span><br><span class="line">                result.append(<span class="string">": "</span>);</span><br><span class="line">                result.append(DatatypeConverter.printHexBinary(digest));</span><br><span class="line">                System.out.println(result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这个方案是可行的，它会以正确的顺序给出正确的答案，而不考虑各个线程的相对运行速度。不过，它做了大量不需要的工作。</p><p>更糟糕的是，这个解决方案不能保证一定能工作。在有些虚拟机上，主线程会占用所有可用的时间，而没有给具体的工作线程留出任何时间。主线程太忙与检查工作的完成情况，以至于没有时间来完成任务！显然这不是一个好方法。</p><h2 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h2><p>事实上，还有一种更简单有效的方法来解决这个问题。有了这个方法，我们完全可以淘汰前面的做法，不必通过无线循环来重复地询问每个ReturnDigest对象来查看是否结束。这个方法的技巧在于，不是在主程序中重复地询问每个ReturnDigest线程是否结束(就想一个五岁小孩子在长途汽车旅行中反复的问”我们到了吗?”这就真的很烦人)，而是让线程告诉主程序它何时结束。这是通过调用主类(即启动这个线程的类)中的一个方法来做到。这被称为回调(callback),因为线程在完成时，反过来调用其创建者。这样一来，主程序就可以在等待线程结束期间休息，而不会占用运行线程的时间。</p><p><strong>但当线程的run()方法接近结束时，要做的最后一件事情就是基于结果调用主程序中的一个已知的方法。不是由主程序询问每个线程来寻求答案，而是由每个线程告知主程序答案。</strong></p><h3 id="使用静态方法完成回调"><a href="#使用静态方法完成回调" class="headerlink" title="使用静态方法完成回调"></a>使用静态方法完成回调</h3><p>例如，实例3-5展示了一个与前面很相似的CallbackDigest类。不过，在run()方法的末尾，对于最初启动的这个线程的类，它要将digest传递给这个类的CallbackDigestUserInterface.receiveDigest()静态方法。</p><p>实例3-5: CallbackDigest<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallbackDigest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String filename;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CallbackDigest</span><span class="params">(String filename)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.filename = filename;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      FileInputStream in = <span class="keyword">new</span> FileInputStream(filename);</span><br><span class="line">      MessageDigest sha = MessageDigest.getInstance(<span class="string">"SHA-256"</span>);</span><br><span class="line">      DigestInputStream din = <span class="keyword">new</span> DigestInputStream(in, sha);</span><br><span class="line">      <span class="keyword">while</span> (din.read() != -<span class="number">1</span>) ; <span class="comment">// read entire file</span></span><br><span class="line">      din.close();</span><br><span class="line">      <span class="keyword">byte</span>[] digest = sha.digest();</span><br><span class="line">      <span class="comment">//调用主类的静态方法通知主类</span></span><br><span class="line">      CallbackDigestUserInterface.receiveDigest(digest, filename);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      System.err.println(ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException ex) &#123;</span><br><span class="line">      System.err.println(ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>示例3-6中所示的CallbackDigestUserInterface类提供了main()方法。不过，与这个程序的其他变体中的main()方法不同，这个方法只是为命令行中指定的文件启动线程。它不会具体读取，显示或对计算结果完成其他的操作。这些功能有一个单独的方法，receiveDigest()来处理。receiveDigest()不在main()方法中调用，沿着main()方法的控制流所能到达的任何方法也不会调用这个receiveDigest()方法。实际上，它由每个线程单独调用。也就是说，receiveDigest()在摘要线程中运行，而不是在执行主线程的程序中运行。</p><p>实例3-6: CallbackDigestUserInterface<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.xml.bind.*; <span class="comment">// for DatatypeConverter; requires Java 6 or JAXB 1.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallbackDigestUserInterface</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">receiveDigest</span><span class="params">(<span class="keyword">byte</span>[] digest, String name)</span> </span>&#123;</span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder(name);</span><br><span class="line">    result.append(<span class="string">": "</span>);</span><br><span class="line">    result.append(DatatypeConverter.printHexBinary(digest));</span><br><span class="line">    System.out.println(result);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String filename : args) &#123;    </span><br><span class="line">      <span class="comment">// Calculate the digest</span></span><br><span class="line">      CallbackDigest cb = <span class="keyword">new</span> CallbackDigest(filename);</span><br><span class="line">      Thread t = <span class="keyword">new</span> Thread(cb);</span><br><span class="line">      t.start();</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>实例3-5和实例3-6<strong>使用静态方法完成回调</strong>，这样CallbackDigest只需要知道CallbackDigestUserInterface要调用的方法名。不过，<strong>回调实例方法</strong>也不会太难(而且回调实例方法更为常见)。</p><h3 id="回调实例的方法"><a href="#回调实例的方法" class="headerlink" title="回调实例的方法"></a>回调实例的方法</h3><p>这种情况下，进行回调的类必须有其回调对象的一个引用。通常情况下<br>，这个引用通过线程构造函数的参数来提供。当run()方法接近结束时，要做的最后一件事情就是调用回调对象的实例方法来传递结果。例如，示例3-7展示了一个与前面很类似的CallbackDigest类。不过，这一次它有一个额定的字段，这是一个名为callback的InstanceClassbackDigestUserInterface对象。在run()方法的末尾，digest被传递给callback的receiveDigest()方法。InstanceCallbackDigestUserInterface对象本身在构造函数中设置。</p><p>示例3-7: InstanceCallbackDigest<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceCallbackDigest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String filename;</span><br><span class="line">  <span class="comment">//调用主类的引用</span></span><br><span class="line">  <span class="keyword">private</span> InstanceCallbackDigestUserInterface callback;</span><br><span class="line">  <span class="comment">//通过构造函数，传入调用者(主类)的引用</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">InstanceCallbackDigest</span><span class="params">(String filename, </span></span></span><br><span class="line"><span class="function"><span class="params">   InstanceCallbackDigestUserInterface callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.filename = filename;</span><br><span class="line">    <span class="keyword">this</span>.callback = callback;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      FileInputStream in = <span class="keyword">new</span> FileInputStream(filename);</span><br><span class="line">      MessageDigest sha = MessageDigest.getInstance(<span class="string">"SHA-256"</span>);</span><br><span class="line">      DigestInputStream din = <span class="keyword">new</span> DigestInputStream(in, sha);</span><br><span class="line">      <span class="keyword">while</span> (din.read() != -<span class="number">1</span>) ;  <span class="comment">// read entire file</span></span><br><span class="line">      din.close();</span><br><span class="line">      <span class="keyword">byte</span>[] digest = sha.digest();</span><br><span class="line">      <span class="comment">//线程(被调用)调用主类(调用者)的方法，被主类调用的线程现在反过来调用主类，所以叫做回调。</span></span><br><span class="line">      callback.receiveDigest(digest);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | NoSuchAlgorithmException ex) &#123;</span><br><span class="line">      System.err.println(ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>示例3-8中的InstanceCallbackDigestUserInterface类有main()方法和reciveDigest()方法，用于处理传入的摘要。示例3-8只是显示摘要，但是功能更强的类还可以完成其他操作。如将摘要存储在一个字段中，用它启动另一个线程，或者对它完成进一步的计算。</p><p>示例3-8: InstanceCallbackDigestUserInterface<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.xml.bind.*; <span class="comment">// for DatatypeConverter; requires Java 6 or JAXB 1.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceCallbackDigestUserInterface</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> String filename;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">byte</span>[] digest;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">InstanceCallbackDigestUserInterface</span><span class="params">(String filename)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.filename = filename;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//启动线程计算摘要</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateDigest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建处理线程，传入主类的对象引用，以便线程可以回调本类(主类)的实例</span></span><br><span class="line">    InstanceCallbackDigest cb = <span class="keyword">new</span> InstanceCallbackDigest(filename, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 使用Thread类来启动线程</span></span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(cb);</span><br><span class="line">    t.start(); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//线程会回调这个方法，参数由线程传入</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">receiveDigest</span><span class="params">(<span class="keyword">byte</span>[] digest)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//从参数中获取线程的处理结果</span></span><br><span class="line">    <span class="keyword">this</span>.digest = digest;</span><br><span class="line">    System.out.println(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String result = filename + <span class="string">": "</span>;</span><br><span class="line">    <span class="keyword">if</span> (digest != <span class="keyword">null</span>) &#123;</span><br><span class="line">      result += DatatypeConverter.printHexBinary(digest);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result += <span class="string">"digest not available"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String filename : args) &#123;    </span><br><span class="line">      <span class="comment">// Calculate the digest</span></span><br><span class="line">      <span class="comment">//实例化主类</span></span><br><span class="line">      InstanceCallbackDigestUserInterface d</span><br><span class="line">          = <span class="keyword">new</span> InstanceCallbackDigestUserInterface(filename);</span><br><span class="line">      <span class="comment">//调用主类方法，该方法中启动一个线程计算摘要，线程计算接收后将回调主类的方法把结果传回给主类</span></span><br><span class="line">      d.calculateDigest();</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>//上面的代码一会要好好注释一下</p><p>使用实例方法代替静态方法进行回调要复杂一些，但有很多优点。首先，主类(这个例子中主类是InstanceCallbackDigestUserInterface)的各个实例只映射至一个文件，可以自然地跟踪记录这个文件的信息，而不需要额外的数据结构。此外，这个实例在必要时可以很容易地重新计算某个特定文件的摘要。实际上，经证明这种机制有更大的灵活性。但是也有一个警告。注意这里新增了启动线程的calculateDigest()方法。从逻辑上考虑，你可能认为这属于构造函数。不过，在构造函数中启动线程很危险，特备是线程将回调原来的对象时。这里就有一个竞态条件，可能会在构造函数结束而且对象完全初始化之前允许新线程进行回调。这里不太可能，因为启动新线程是在构造函数做的最后一件。不过，至少理论上是可能的。因此，万无一失的做法是避免在构造函数中启动线程。</p><p>相比于轮询机制，回调机制的第一个有点是不会浪费那么多CPU周期。但更重要的优点是回调更灵活，可以处理涉及更多线程，对象和类的更复杂的情况。例如,如果有多个对象对线程的计算结果感兴趣，那么线程可以保存一个要回调的对象列表。特定的对象可以通过调用Thread或Runnable类的一个方法把自己添加到这个列表中来完成注册，表示自己对计算结果很感兴趣。如果有多个类的实例对结果感兴趣，可以定义一个新的interface(接口)，所有这些类都要实现这个新接口。这个interface(接口)将声明回调方法。</p><p>如果你对此有种似曾相识的感觉，可能是因为你以前见过这种机制。这正是在Swing，AWT和JavaBean中处理事件的方法。AWT在程序之外的一个单独的线程中运行。组件和bean通过回调在特定接口(如ActionListener和PropertyChangeListener)中声明的方法来通知事件的发生。监听者对象使用Component类中的方法(如addActionListenner()和addPropertyChangeListener()）来完成注册，表示对特定组件触发的事件感兴趣。在组件内部，已注册的监听者存储在由java.awt.AWTEventMulticaster构成的一个链表中。这种机制有一个更一般的名字:观察者(Observer)设计模式。</p><p>Future,Callable和Executor<br>Java 5引入了多线程的一个新方法，通过隐藏细节可以更容易地处理回调。不再是直接创建一个线程，你要创建一个ExecutorService,它会根据需要为你创建线程。<br>可以向ExecutorService提交Callable任务，对于每个Callable任务，会分别得到一个Future。之后可以向Future请求得到任务的结果。如果结果已经准备就绪，就会立即得到这个结果。如果还没有准备好，轮询线程会阻塞，知道结果准备就绪。这种做法的好处是，你可以创建很多不同的线程，然后按你需要的顺序得到你需要的答案。</p><p>例如，假设你要找出一个很大的数字数组中的最大值。如果采用最原始的方法实现，需要的时间为O(n),其中n是数字中的元素个数。不过如果可以将这个工作分解到多个线程，每个线程分别在一个单独的内核上运行，这样就会快得多。为了便于说明，下面假设需要两个线程。<br>Callable接口定义了以call()方法，它可以返回任意的类型。示例3-9是一个</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/4bfc148a/">java网络编程第4版 第3章 线程</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Git 删除远程仓库中网络过滤的文本</title>
      <link href="/blog/b1d11119/"/>
      <url>/blog/b1d11119/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:16 GMT+0800 (中国标准时间) --><p>有时候我们不小心把一下文件上传到远程中去了，那么如何删除掉这些过滤的文本呢?</p><p>首先：先把本地仓库拉到和远程仓库一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>然后，在本地仓库下，删除这些文件(剪切到别处去)，例如，<code>\Java\java_net\java网络编程第四版 读书笔记\随书源码\src</code>目录下的源码剪切到<code>C:\Users\lan\Desktop\源码</code>这个空文件中去。<br>编写，过滤文件<code>.gitignore</code>,写入源码的目录，在后续的操作中删除过滤掉这些文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">/Java/java_net/java网络编程第四版 读书笔记/随书源码/src/</span><br></pre></td></tr></table></figure><p>然后同步本地代码库到远程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;从远程库中删除随书源码,不上传这个源码&quot;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>这样远程仓库中就不会再有我们一开始忘掉过滤掉的文件了。</p><p>现在把刚才剪切走的文件再粘贴回来。而<code>.gitigore</code>对这些粘贴过来的新文件有效，后续 git将会忽略掉这些文件。(<code>.gitignore</code>只对新文件有效)<br>粘贴回来后，现在再使用git status查看将查看不到这些新粘贴的文件的信息。也就是说已经被git忽略掉了。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/b1d11119/">Git 删除远程仓库中网络过滤的文本</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> git教程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>挖掉图片中间一部分</title>
      <link href="/blog/ad610aad/"/>
      <url>/blog/ad610aad/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:16 GMT+0800 (中国标准时间) --><h2 id="明确需求"><a href="#明确需求" class="headerlink" title="明确需求"></a>明确需求</h2><p>例如这里有一张图片(1.png):<br><img src="https://i.imgur.com/0k5imP2.png" alt=""></p><p>现在要求把中间的两页之间的空白部分删除掉，如下图所示：<br><a id="more"></a><br><img src="https://i.imgur.com/MQrLjtL.png" alt=""></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="裁剪上半部分"><a href="#裁剪上半部分" class="headerlink" title="裁剪上半部分"></a>裁剪上半部分</h3><p>用Photoshop打开”1.png”图片,然后把上半部分裁剪下来:<br><img src="https://i.imgur.com/6gECz1F.png" alt=""></p><p>另存为”上部分.png”:</p><p><img src="https://i.imgur.com/nZyntjl.png" alt=""></p><p>这个时候Photoshop中显示的是我们刚生成的”上部分.png”这个图片，下面来裁剪下半部分。</p><h3 id="裁剪下半部分"><a href="#裁剪下半部分" class="headerlink" title="裁剪下半部分"></a>裁剪下半部分</h3><p>还是一样，打开”1.png”图片，然后把下半部分裁剪下来，裁剪好后就是下半部分的内容了，不在需要另存为，保存即可。</p><p><img src="https://i.imgur.com/zjJXZiV.png" alt=""></p><p>然后，切换到移动工具。避免误触碰造成没必要的裁剪。</p><h3 id="拼图-把上下两个部分拼到一张图片中"><a href="#拼图-把上下两个部分拼到一张图片中" class="headerlink" title="拼图:把上下两个部分拼到一张图片中"></a>拼图:把上下两个部分拼到一张图片中</h3><h4 id="计算两个图片的高度之和"><a href="#计算两个图片的高度之和" class="headerlink" title="计算两个图片的高度之和"></a>计算两个图片的高度之和</h4><p>选择图像-&gt;图像大小查看图像的高度:</p><p><img src="https://i.imgur.com/POk3sRF.png" alt=""></p><p>可以看到下部分(“1.png”)的高度为：<code>334</code></p><p><img src="https://i.imgur.com/BOTPTJD.png" alt=""></p><p>然后查看“上部分.png”的高度：<code>506</code></p><p><img src="https://i.imgur.com/hLib2rY.png" alt=""></p><h4 id="修改其中一张图片的高度为两者高度之和"><a href="#修改其中一张图片的高度为两者高度之和" class="headerlink" title="修改其中一张图片的高度为两者高度之和"></a>修改其中一张图片的高度为两者高度之和</h4><p>计算两部分的高度<code>506+334=840</code>,然后点击：<code>图像&gt;画布大小</code>。</p><p><img src="https://i.imgur.com/tjvwrMX.png" alt=""></p><p>调整”上部分.png”的画布大小由50改为840像素：<br><img src="https://i.imgur.com/DUa7TM1.png" alt=""></p><p><img src="https://i.imgur.com/NZZAPFg.png" alt=""></p><h4 id="解锁图层，调整图层位置"><a href="#解锁图层，调整图层位置" class="headerlink" title="解锁图层，调整图层位置"></a>解锁图层，调整图层位置</h4><p>效果如下所示，然后双击解锁该图层：</p><p><img src="https://i.imgur.com/oOu0siN.png" alt=""></p><p>然后使用移动工具，把该图层移动到顶部：<br><img src="https://i.imgur.com/nsirBGX.png" alt=""></p><h4 id="复制粘贴移动另一部分"><a href="#复制粘贴移动另一部分" class="headerlink" title="复制粘贴移动另一部分"></a>复制粘贴移动另一部分</h4><p>然后切换到1.png，使用矩形选框，选中整个图层，按下<code>Ctrl+C</code>复制整个图层：</p><p><img src="https://i.imgur.com/OS38DT7.png" alt=""></p><p>然后切换到 上部分.png，粘贴该图层,使用移动工具移动调整位置对齐即可：</p><p><img src="https://i.imgur.com/uuWumpz.png" alt=""></p><p>最后保存即可，这样就能图片中间无用的部分去掉了，拼接后的效果如下：</p><p><img src="https://i.imgur.com/Afqg3MY.jpg" alt=""></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/ad610aad/">挖掉图片中间一部分</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> PS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java网络编程第4版 第2章 流</title>
      <link href="/blog/d3f6b577/"/>
      <url>/blog/d3f6b577/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>网络程序所做的很大一部分工作都是简单的输入和数据:<br>将数据字节从一个系统移动到另一个系统。字节就是字节。很短程度上讲，读取服务器发送给你的数据与读取文件并没有什么不同。向客户端发送文本和写文件也没有什么不同。但是,<code>Java</code>中输入和输出(<code>I/O)</code>的组织与其他大多数语言如(<code>Fortran</code>,<code>C</code>和<code>C</code>++)都不一样。因此，这里要用几页来总结一下<code>Java</code>独特的<code>I/O</code>方法。<br><a id="more"></a><br><code>Java</code>的<code>I/O</code>流建立与流(<code>stream)</code>之上。输入流用于读取数据，输出流用于写入数据。不同的流类，如<code>java.io.FileInputStream</code>和<code>sun.net.TelnetOutputStream</code>会读/写某个特定的数据源。但是，所有输出流都有相同的基本方法来写入数据，所有输入也使用相同的方法来读取数据。创建一个流之后，读/写时通常可以忽略读/写的具体细节。</p><p>过滤器(filter)流可以串联到输入流或输出流上。读写数据时，过滤器可以修改数据(例如,通过加密或压缩)，或者只是提供额外的方法，将读写的数据转换为其他格式。例如，java.io.DataOutputStream类就提供了一个方法，可以将int转换为4字节，并把这些字节写入低层的输出流。<br>阅读器(reader)和书写器(writer)可以串联到输入流和输出流上，允许程序读写文本(即字符)而不是字节。只要正确的使用，阅读器和书写器可以处理很多字符编码，包括多字节字符集，如SJIS和UTF-8</p><p>流是同步的。也就是说，当程序(确切的讲是线程)请求一个流读写一段数据时，在做任何其他操作前，它要等待所读写的数据。<br>Java还支持使用通道和缓冲区的非阻塞I/O。非阻塞I/O稍微有些复杂，但是在某些高吞吐量的应用程序中(如Web服务器)，非阻塞I/O要快的多。通常情况下，基本流模型就是实现客户端所需要和应当使用的全部内容。由于通道和缓冲依赖于流，下面将介绍流和客户端。</p><blockquote><h2 id="输出流"><a href="#输出流" class="headerlink" title="输出流"></a>输出流</h2><p><code>Java</code> 的基本输出流式<code>java.io.OutputStream</code>:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; public abstract class OutputStreamextends Objectimplements Closeable, Flushable</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>这个类提供了写入数据所需的基本方法，这些方法包括：</p></blockquote><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>public abstract void write(int b) throws IOException</code></td><td style="text-align:left">将指定的字节写入此输出流。</td></tr><tr><td style="text-align:left"><code>public void write(byte[] b) throws IOException</code></td><td style="text-align:left">将 b.length 个字节从指定的 byte 数组写入此输出流。</td></tr><tr><td style="text-align:left"><code>public void write(byte[] b,int off,int len) throws IOException</code></td><td style="text-align:left">将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流。</td></tr><tr><td style="text-align:left"><code>public void close() throws IOException</code></td><td style="text-align:left">关闭此输出流并释放与此流有关的所有系统资源。</td></tr><tr><td style="text-align:left"><code>public void flush() throws IOException</code></td><td style="text-align:left">刷新此输出流并强制写出所有缓冲的输出字节。</td></tr></tbody></table><blockquote><p><code>OutputStream</code>的子类使用这些方法向某种特定介质写入数据。例如，<code>FileOutputStream</code>使用这些方法写入文件，<code>TelnetOutputStream</code>使用这些方法写入网络连接。<code>ByteArraryOutputStream</code>使用这些方法将数据写入可扩展的字节数组。但不管写那种介质，大多都会使用同样的这5个方法。有时候甚至可能不知道所写入的流具体是何种类型。例如，在<code>Java</code>类库文档中找不到<code>TelnetOutputStream</code>。它被有意的隐藏在<code>sun</code>包<br>中。<code>java.net</code>中很多方法都会返回<code>TelnetOutputStream</code>，如<code>Java.net.Socket</code>的<code>getOutputStream()</code>方法。但是，这些方法声明为只返回<code>OutputStream</code>,而不是更特定的子类<code>TelnetOutputStream</code>。这正是多态的威力。如果你知道如何使用这些超类，那也就知道如何使用所有这些子类。</p><h3 id="write-int-b-方法"><a href="#write-int-b-方法" class="headerlink" title="write(int b)方法"></a>write(int b)方法</h3><p><code>OutputStream</code>的基本方法是<code>write(int b)</code>。这个方法接收一个<code>0-255</code>之间的整数作为参数，将对应的字节写入输出流中。这个方法声明为抽象方法，因为各个子类需要修改这个方法来处理特定的介质。例如，ByteArrayOutputStream可以<code>用纯Java代码</code>实现这个方法，将字节复制到数组中。与此不同，FileOutputStream则需要使用<code>原生代码</code>，这些代码了解如何将数据写入到主机平台的文件中。</p><p>注意，虽然这个方法接受一个int作为参数，但它实际上会写入一个无符号字节。Java没有无符号字节数据类型，所以这里要使用int来代替。无符号字节和有符号字节之间唯一真正的区别在于解释。它们都是由8个二进制位组成，当使用write(int b)将int协议一个网络连接时，线缆上只会放入8个二进制位。如果将一个超出0~255的int传入write(int b),将写入这个数的最低字节，其他3字节将被忽略(这正是将int强制转换为byte的结果)。<br>提示: 不过在极少数情况下，你可能会看到一些有问题的第三方类，在写超出0~255的值时，它们的做法有所不同，比如会抛出<code>IllegalArgumentException</code>异常或者总是写入255，所以尽可能要避免写入超出0~255的int</p><h3 id="write-int-b-方法实例"><a href="#write-int-b-方法实例" class="headerlink" title="write(int b)方法实例"></a>write(int b)方法实例</h3><p>例如，字符生成器协议定义了一个发出ASCII文本的服务器。这个协议最流行的变体是发送72个字符的文本行，其中包含可显示的ASCII字符。(可显示的ASCII字符是33~126之间的字符，不包括各种空白行和控制字符)。第一行按顺序包含字符33到字符104.第二行包含字符33+1到104+1,也就是字符34到字符105。第三行宝行字符35到字符106。一直到第29行宝行字符55到字符126。到这里，字符将回绕，第30行包含字符56到字符126加上字符33。各行用回车(ASCII 13)和换行(ASCII 10)结束。输出结果如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">!&quot;#$%&amp;&apos;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefgh</span><br><span class="line">&quot;#$%&amp;&apos;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghi</span><br><span class="line">#$%&amp;&apos;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghij</span><br><span class="line">$%&amp;&apos;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijk</span><br><span class="line">%&amp;&apos;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijkl</span><br><span class="line">&amp;&apos;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklm</span><br><span class="line">&apos;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmn</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>可以看到第一行第第一个字符是<code>!</code>到了第二行它将变为最后一个字符<code>!</code><br>由于ASCII是一个7位字符集，所以每个字符都作为单字节发送。因此，这个协议可以直接使用基本write()方法实现。实现代码如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generatecharacters</span><span class="params">(OutputStream out)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">&gt; </span>&#123;</span><br><span class="line">&gt; <span class="keyword">int</span> firstPrintableCharacter = <span class="number">33</span>;</span><br><span class="line">&gt; <span class="keyword">int</span> numberOfPrintableCharacters = <span class="number">94</span>;</span><br><span class="line">&gt; <span class="keyword">int</span> numberOfCharactersPerLine = <span class="number">72</span>;</span><br><span class="line">&gt; <span class="keyword">int</span> start = firstPrintableCharacter;</span><br><span class="line">&gt; <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">&gt; &#123;<span class="comment">/* 无限循环 */</span></span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; start + numberOfCharactersPerLine; i++)</span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt; out.write((i - firstPrintableCharacter)</span><br><span class="line">&gt; % numberOfCharactersPerLine + firstPrintableCharacter);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; out.write(<span class="string">'\r'</span>);<span class="comment">// 回车</span></span><br><span class="line">&gt; out.write(<span class="string">'\n'</span>);<span class="comment">// 换行</span></span><br><span class="line">&gt; start = ((start + <span class="number">1</span>) - firstPrintableCharacter)</span><br><span class="line">&gt; % numberOfPrintableCharacters + firstPrintableCharacter;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>这里将一个OutputStream通过out参数传入到generatecharacters()方法中。一次项out写入1字节。这些字节作为33到126之间循环列出中的整数给出。这里的大部分运算都是让循环在这个范围内回绕。并写入每个72字符块之后，就想输出流写入一个回车和一个换行。<br>然后计算下一个起始字符,重复这个循环。整个方法声明为抛出IOException异常。这一点很重要，因为字符生成器服务器只又在客户端关闭连接时才会终止。Java代码会把它看做是一个IOException异常。</p></blockquote><p>看到这里可以能回迷惑，其实，作者这里是在介绍write(int b)这个方法的用法。不用去理解这个什么字符生成器的原理和作用。<br>main()方法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException</span><br><span class="line">&#123;</span><br><span class="line">generatecharacters(System.out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>一次写入1字节通常效率不高。例如，流出以太网卡的每个TCP分片包含至少40字节的开销用于路由和纠错。如果每字节都单独发送，那么与你预想的数据量相比，使用write(int b)方法实际填入到网络中的数据可能是41个字节,也就是说比实际写入一个字节高了41倍。如果增加主机网络层协议的开销，情况可能更糟糕。因此，大多数TCP/IP实现都会在某种程度上缓存数据。也就是说，它们在内存中积累数据字节，只有积累到一定的数量后，或经过一定的时间后，才将积累的数据发送到最终目的地。不过，如果有多字节要发送。则一次全部发送，不失为一个好主意。使用write(byte[] data)或write(byte[] data,int offset,int length)一次写入一个数组，或数组中的一部分，通常比write(int b)一次写入一个字节要快的多。例如，下面是generatecharacters()方法的另一个实现，它将整行打包字节数组中，一次发送一行:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static void generateCharacters(OutputStream out) throws IOException</span><br><span class="line">&#123;</span><br><span class="line">int firstPrintableCharacter = 33;</span><br><span class="line">int numberOfPrintableCharacters = 94;</span><br><span class="line">int numberOfCharactersPerLine = 72;</span><br><span class="line">int start = firstPrintableCharacter;</span><br><span class="line">//+2对应回车和换行</span><br><span class="line">byte[] line=new byte[numberOfCharactersPerLine+2];</span><br><span class="line">int count=0;</span><br><span class="line">while (true)</span><br><span class="line">&#123;/* 无限循环 */</span><br><span class="line">for (int i = start; i &lt; start + numberOfCharactersPerLine; i++)</span><br><span class="line">&#123;</span><br><span class="line">line[i-start]=(byte)((i-firstPrintableCharacter)%numberOfPrintableCharacters+firstPrintableCharacter);</span><br><span class="line">&#125;</span><br><span class="line">line[72]=(byte)&apos;\r&apos;;</span><br><span class="line">line[73]=(byte)&apos;\n&apos;;</span><br><span class="line">out.write(line);</span><br><span class="line">start = ((start + 1) - firstPrintableCharacter)</span><br><span class="line">% numberOfPrintableCharacters + firstPrintableCharacter;</span><br><span class="line">if((count++)&gt;=72)</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>计算何时写那些字节的算法与前面的实现中是一样的。重要的区别在于这些字节在写入网络之前先打包到字节数组中。<br>还要注意计算的结果是int类型的，在存储到字节数组是要强制类型转换。这在前面的实现中是不需要强制类型转换的，因为write(int b )方法声明为接收一个int作为参数。</p><h3 id="flush-方法"><a href="#flush-方法" class="headerlink" title="flush()方法"></a>flush()方法</h3><p>与网络硬件中缓存一样，流还是可以在软件中得到缓冲，即直接使用Java代码缓存。一般来说，这可以通过把BufferedOutputStream或BufferedWriter串链到低层流上来实现，因此，在写入数据完成后，刷新(flush)输出流非常重要。例如假设已经向使用HTTP Keep-Alive的HTTP1.1服务器写入了300字节的请求到输出流中，然后服务器会等待客户端的响应。然后再发送更过的数据。不过，如果输出流有一个1024字节的缓冲区，那么这个流在发送缓冲区中的数据之前会等待等过的数据到达，以填满这个1024字节的缓冲区。不过在客户端的响应到达之前，服务器不会向流写入更多的数据，但是请求现在其实还在缓冲区中，没有发给客户端，所以客户端的响应是永远不会到来的。客户端等待服务器的消息，而服务端等待客户端的响应，两个相互等待，造成死锁，如下图所示。<br><img src="https://i.imgur.com/SvzwLF8.png" alt=""><br>这种情况，应该使用flush()方法，flush()方法可以强迫缓冲的流发送数据，即使缓冲区还没填满，以此来打破这种死锁状态。<br>不管你是否认为有必要，刷新输出流都很重要，取决于以如何控制流的引用，你可能知道流是否有缓冲，也可能不知道(例如，不论你是否希望如此，System.out都会使用缓冲)。<br>如果有必要刷新输出,不刷新，那么可能导致不可预知，不可重现的程序挂起。相应的，应当在关闭流之前立即刷新输出所有流，否则，关闭流时留在缓冲区中的数据可能会丢失。</p><h3 id="close-方法"><a href="#close-方法" class="headerlink" title="close()方法"></a>close()方法</h3><p>最后，当结束一个流的操作时,要通过调用他的close()方法将其关闭。这会释放与这个流相关联的所有资源，如文件句柄或端口。如果流来自一个网络连接，那么关闭这个流也会终止这个连接。一旦输出流关闭，继续写入时就会抛出IOException异常。不过，有些流仍允许对这个对象做一些处理。例如，关闭的ByteArrayOutputStream仍然可以转换为实际的字节数组，关闭的DigesOutputStream仍然可以返回其摘要。</p><h3 id="close-方法正确的写法"><a href="#close-方法正确的写法" class="headerlink" title="close()方法正确的写法"></a>close()方法正确的写法</h3><p>在一个长时间运行的程序中，如果未能关闭一个流，则可能会泄露文件句柄，网络端口和其他资源。因此在Java6和更早的版本中，明智的做法是在finally块中关闭流。而为了正确的变量作用域，必须在try块之前声明流变量，但必须在try块内完成初始化。另外为了避免NullPointerException异常，在关闭流之前需要检查流变量是否为null.最后通常都希望忽略关闭流时出现的异常，或者最多只是把这些异常记入日志中。例如：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出流引用定义在try块外面，以提高作用域</span></span><br><span class="line">OutputStream out =<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化输出流</span></span><br><span class="line">    out=<span class="keyword">new</span> FileOutputStream(<span class="string">"data.txt"</span>);</span><br><span class="line">    <span class="comment">//处理输出流...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(IOEXception ex)</span><br><span class="line">&#123;</span><br><span class="line">    System.err.println(ex.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(out!=<span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            out.colse();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException ex)&#123;</span><br><span class="line">            <span class="comment">//忽略</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这个技术有时称为释放模式(dispose pattern),这对于需要在垃圾回收前先进行清理的对象时很常见的。你会看到，这个技术不仅用于流，还可以用于socket,通道，JDBC连接和语句等。</p><p>Java 7引入了<code>带资源的try</code>构造(try with resources),可以更简洁地完成这个清理。<br>不需要再try块之外声明流变量，完全可以在try块的一个参数表中声明。例如，前面的代码段现在就变得简单多了：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try(OutputStream out=new FileOutputStream(&quot;data.txt&quot;))</span><br><span class="line">&#123;</span><br><span class="line">    //处理输出流</span><br><span class="line">&#125;</span><br><span class="line">catch(IOException ex)</span><br><span class="line">&#123;</span><br><span class="line">    System.err.println(ex.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>现在不需要Finally子句，Java会对try块参数表中声明的所有AutoCloseable对象自动调用close()。<br>提示：只要对象事项了Closeable接口，都可以使用<code>带资源的try</code>构造。这包括几乎所有需要释放的对象。到到目前为止，JavaMail Transport对象是我见过的唯一的例外，这些对象还需要显式的释放。</p><h2 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h2><p><code>Java</code>的基本输入流类是<code>java.io.InputStream</code>:<br><code>public abstract class InputStreamextends Objectimplements Closeable</code><br>这个类提供两个将数据读取为原始字节所需要的基本方法。这些方法包括：</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>public abstract int read() throws IOException</code></td><td style="text-align:left">从输入流中读取数据的下一个字节。</td></tr><tr><td style="text-align:left"><code>public int read(byte[] b) throws IOException</code></td><td style="text-align:left">从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。</td></tr><tr><td style="text-align:left"><code>public int read(byte[] b, int off, int len) throws IOException</code></td><td style="text-align:left">将输入流中最多 len 个数据字节读入 byte 数组。</td></tr><tr><td style="text-align:left"><code>public long skip(long n) throws IOException</code></td><td style="text-align:left">跳过和丢弃此输入流中数据的 n 个字节。</td></tr><tr><td style="text-align:left"><code>public int available() throws IOException</code></td><td style="text-align:left">返回此输入流下一个方法调用可以不受阻塞地从此输入流读取（或跳过）的估计字节数。</td></tr><tr><td style="text-align:left"><code>public void close() throws IOException</code></td><td style="text-align:left">关闭此输入流并释放与该流关联的所有系统资源。</td></tr><tr><td style="text-align:left"><code>public void mark(int readlimit)</code></td><td style="text-align:left">在此输入流中标记当前的位置。</td></tr><tr><td style="text-align:left"><code>public boolean markSupported()</code></td><td style="text-align:left">测试此输入流是否支持 mark 和 reset 方法。</td></tr><tr><td style="text-align:left"><code>public void reset() throws IOException</code></td><td style="text-align:left">将此流重新定位到最后一次对此输入流调用 mark 方法时的位置。</td></tr></tbody></table><p>InputStream的具体子类使用这些方法从某种特定介质中读取数据。例如，FileInputStream从文件中读取数据。TelnetInputStream从网络中读取数据。ByteArrayInputStream从字节数组中读取数据。但无论读完哪种数据源，主要使用以上这六个方法。<br>有时你不知道正在读取的流具体是何种类型。例如，TelnetInputStream类隐藏在sun.net包中，没有提供相关文档。java.net包中的很多方法都会返回这个类的实例(例如java.net.URL的openStream()方法)。不过，这些方法声明为只返回InputStream，而不是特定的子类TelnetInputStream。这又是多态在起作用。子类的实例可以透明的作为其超类的实例来使用。而不需要子类更特定的知识。</p><p>InputStream的基本方法是没有参数的read()方法。这个方法从输入流的源中读取1个字节数据，作为一个0~255的int返回。流的结束通过放回-1来表示。read()方法会等待并阻塞其后任何代码的执行，知道有1字节的数据可供读取。输入和输出可能很慢，所以如果程序在做其他重要的工作，要尽量将I/O放在单独的线程中。</p><h3 id="read-方法"><a href="#read-方法" class="headerlink" title="read()方法"></a>read()方法</h3><p>read()方法声明为抽象方法，因为各个子类需要修改这个方法来处理特定的介质。例如，ByteArraryInputStream会用纯Java代码实现这个方法，从数组复制字节。不过，TelnetInputStream需要使用一个原生库，它知道如何从主机平台的网络接口读取数据。</p><p>下面的代码段从InputStream in中读取10个字节，存储在byte数组input中。不过，如果检测到流结束,循环就会提前终止。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">byte[] input =new byte[10];</span><br><span class="line">for(int i=0;i&lt;input.length,i++)</span><br><span class="line">&#123;</span><br><span class="line">    int b=in.read();</span><br><span class="line">    if(b==-1) break;</span><br><span class="line">    input[i]=(byte)b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="有符号字节转换为无符号字节"><a href="#有符号字节转换为无符号字节" class="headerlink" title="有符号字节转换为无符号字节"></a>有符号字节转换为无符号字节</h4><p>虽然read()只读取一个字节，但它会返回一个int.这样把结果存储到字节数组之前就必须进行强制类型转换。当然，这会产生一个-128到127之间的有符号字节，而不是read()方法返回的0到255之间的一个无符号字节。不过，只要你清楚在做什么，这就不是大问题。<br>你可以如下将一个有符号字节转换为无符号字节：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int i=b&gt;=0 ? b :256+b;</span><br></pre></td></tr></table></figure><p></p><p>与一次写入1字节的数据一样，一次读取1字节的效率也不高。因此，有两个重载的read()方法，可以用流中读取多个字节的数据来填充一个指定的数组：read(byte[] input)和read(byte[] input,int offset,int length)。第一个犯法尝试填充指定的数组input,第二个方法尝试填充指定的input从offset开始连续length字节的子数组。</p><p>注意我说着这些方法是在尝试填充数组，也就是说不是一定会成功。尝试可能会以很多不同的方式失败。例如，你可能听说说，当你的程序正在通过DSL从远程Web服务器读取数据时，由于电话公式中心办公室的交换机存在bug，这会断开你与其他地方数百个邻居的连接。这会导致一个IOException异常。但更常见的是，读尝试可能不会完全失败，但也不会完全成功。可能读取到一些请求的字节，但未能全部读取到。例如，你可能尝试从一个网络连接中读取1024字节，限制实际上只有512字节到达，其他的仍在传输中。尽管它们最终会到达，但此时却不可用。考虑这一点，读取多字节的方法会返回实际读取的字节数。例如，考虑下面的代码段：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte[] input =new byte[1024];</span><br><span class="line">int bytesRead=in.read(input);</span><br></pre></td></tr></table></figure><p></p><p>它尝试从InputStream in向数组input读入1024字节。不过，如果只有512字节可用，那就只会读取这么多，bytesRead将会设置为512。为了保证你希望的所有数据都真正读取到，要把读取方法放在循环中，这样会重复读取，知道数组填满为止。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int bytesRead=0；</span><br><span class="line">int bytesToRead=1024;</span><br><span class="line">byte[] input= new byte[bytesToRead];</span><br><span class="line">while(bytesRead&lt;bytesToRead)</span><br><span class="line">&#123;</span><br><span class="line">    bytesRead+=in.read(intput,bytesRead,bytesToRead-bytesRead);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这项技术对于网络流尤为重要,一般来讲如果一个文件完全可用，那么文件的所有字节也都可用。不过由于网络要不CPU慢很多，所以郑旭很容易在所有数据到达前清空网络缓冲区。事实上，如果这两个方法读取展示为空但打开的网络缓冲区，它通常会返回0，表示没有数据可用，但是流还没有关闭。这往往要比单个字节的read()方法要好，因为在这种情况下单字节方法会阻塞正在运行的线程。</p><p>所有3个read()方法都用返回-1表示流的结束。如果流已经结束，而又没有读取的数据，多字节read()方法会返回这些数据，直到缓冲区清空。其后任何一个read()方法调用会返回-1，-1永远不会放进数组中，数组中只包含实际的数据。前面的代码段中存在一个bug,因为它没有考虑所有1024字节永远不可能到达的情况(这与前面所说的情况不同，那只是当时不可用,但以后所有字节总会到达)。要修复这个bug,需要先测试read()的返回值，然后在增加到哦bytesRead中。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int bytesRead=0；</span><br><span class="line">int bytesToRead=1024;</span><br><span class="line">byte[] input=new byte[bytesToRead];</span><br><span class="line">while(bytesRead&lt;bytesToRead)</span><br><span class="line">&#123;</span><br><span class="line">    int result=in.read(input,bytesRead,bytesToRead-bytesRead);</span><br><span class="line">    if(result==-1) break;//流结束</span><br><span class="line">    bytesRead+=result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="available-方法"><a href="#available-方法" class="headerlink" title="available()方法"></a>available()方法</h3><p>如果不想等待所需的全部字节都立即可用，可以使用available()方法来确定不阻塞的情况下有多少字节可用读取。它会返回可以读取的最少字节数。事实上还能读取更多字节，但至少可以读取available()建立的字节数。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int byteAvailable = in.available();</span><br><span class="line">byte[] input=new byte[bytesAvailable];</span><br><span class="line">int bytesRead=in.read(input,0,bytesAvailable);</span><br><span class="line">//立即继续执行程序的其他部分...</span><br></pre></td></tr></table></figure><p></p><p>在这种情况下，可以人文bytesRead与bytesAvailable相等。不过，不能期望bytesRead大于0。有可能没有可用的字节，在流的最后，available()会返回0。一般来说，read(byte[] input,int offset,int length)在流结束时返回-1;但如果length是0,那么他不会注意流的结束，而是返回0。</p><h3 id="skip-方法"><a href="#skip-方法" class="headerlink" title="skip()方法"></a>skip()方法</h3><p>在少数情况下，你可能希望跳过数据不进行读取。skip()方法会完全完成这项任务。与读取文件相比，在网络连接中它的用处不大。网络连接是顺序的，一般情况下很慢，所以与跳过数据(不读取)相比，读取数据并不会耗费太长时间。文件是随机访问的，所以要跳过数据，可以简单的实现为重新指定文件指针位置，而不需要跳过的各字节。</p><h3 id="close-方法-1"><a href="#close-方法-1" class="headerlink" title="close()方法"></a>close()方法</h3><p>与输出流一样，一旦结束对输入流的操作，应当调用他的close()方法将其关闭。这会释放与这个流关联的所有资源如句柄或端口。一旦输入流已关闭,进一步读取这个流会抛出IOException异常。不过，有些流可能仍然允许处理这个对象。例如，你通常会在读取了数据并关闭之后才会从java.security.DigestInputStream获取消息摘要。</p><h3 id="标记和重置"><a href="#标记和重置" class="headerlink" title="标记和重置"></a>标记和重置</h3><p>InputStream类还有3个不太用的方法，允许程序备份和重新读取已经读取的数据。这些方法是：</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>public void mark(int readAheadLimit)</code></td><td style="text-align:left">在此输入流中标记当前的位置。</td></tr><tr><td style="text-align:left"><code>public void reset() throws IOException</code></td><td style="text-align:left">将此流重新定位到最后一次对此输入流调用 mark 方法时的位置。</td></tr><tr><td style="text-align:left"><code>public boolean markSupported()</code></td><td style="text-align:left">测试此输入流是否支持 mark 和 reset 方法。</td></tr></tbody></table><p>为了重新读取数据，用mark()方法标记流的当前位置。在以后某个时刻，可以用reset()方法把流重置到之前标记的位置。接下来的读取操作会返回从标记位置开始的数据。不过，不能随心所欲的向前重置任意远的位置。从标记处读取和重置的字节数有mark()的readAheadLimit参数确定。如果试图重置的太远，就会抛出IOException异常。此外，一个流在任何时刻都只能有一个标记，标记第二个位置会清除第一个标记。</p><p>标记和重置通常通过将标记位置之后的所有字节存储在一个内部缓冲区来事项。不过，不是所有输入流都支持这一点。在尝试使用标记和重置之前，要检查markSupported()方法是否返回true。如果返回true,那么这个流确实支持标记和重置。否则，mark()方法会什么都不做，而调用reset()方法将抛出一个IOException异常。</p><hr><p>提示：在我看来，这是一个非常差的设计，实际上，不支持标记和重置的流比支持的更过。如果向抽象的超类附加一个功能，但这个功能对很多(甚至可能是大多数)子类都不可用，这就是一个很不好的想法。把这三个方法放在一个单独的接口中，由提供这个功能的类实现这个接口，这样做可能会更好。这个方法的缺点是不能在外置类型的任意输入流上调用这些方法，但实际上也不会这么做，因为并不是所有流都支持标记和重置。可以提供一个方法(如markSupport())在运行时进行检查，这是针对该问题的一个更传统的非面向对象的解决方案。面向对象的方法是通过接口和类将其嵌入在类型系统中，这样就可以在编译时进行检查。</p><hr><p>java.io中仅有连个的使用支持标记的输入流时BufferedInputStream和ByteArrayInputStream。而其他输入流(如TelnetInputStream)如果先串链到缓冲的输入流才支持标记，这里的串链，应该是这种类型的写法：<br>BufferedInputStream in=new BufferedInputStrem(new TelnetInputStream);<br>其实这样不就是直接使用了BufferedInputStream的标记功能了吗</p><h2 id="过滤器流"><a href="#过滤器流" class="headerlink" title="过滤器流"></a>过滤器流</h2><p>InputStream和OutputStream是相当原始的类。他们可以单个或成组的读写字节，但仅此而已。要确定这些字节的含义(比如，他们是整数还是IEEE 754浮点数，或者是Unicode文本)，这就完全由程序员和代码来完成。不过，有一些极为常见的数据格式，如果在类库中提供这些数据格式的固定实现，会有很多好处。例如，许多作为网络协议一部分传递的整数是32位的big-endain整数。许多通过Web发送的文本是7位ASCII,8位Latin-1或多字节UTF-8。许多由FTP传输的文件存储为zip格式。Java提供了很多过滤器类，可以附加到原始流中，在原始字节和个中格式之间来回转换。</p><hr><p>这里有必要说一下过滤器流<br>BufferedInputStream, CheckedInputStream, CipherInputStream, DataInputStream, DeflaterInputStream, DigestInputStream, InflaterInputStream, LineNumberInputStream, ProgressMonitorInputStream, PushbackInputStream</p><hr><p>过滤器有两个版本:过滤器流以及阅读器和书写器。过滤器流仍然主要讲原始数据作为字节处理，例如通过压缩数据或解释为二进制数字。阅读器和书写器处理多种编码文本的特殊情况，如UTF-8和ISO 8859-1。</p><p>过滤器流以链的形式进行组织，如下图所示。链中的每个环节都接收一个过滤器或流的数据，并把数据传递给链中的下一个环节。在这个示例中，从本地网络结构结构到一个压缩的加密文本文件，在这里本地代码将这个文件表示为TelnetInputStream(TelnetInputStream没有相关文档提供说明)。通过一个BufferedInputStream缓冲这个数据来加速整个过程。由一个CipherInputStream将数据解密。再由一个GZIPInputStream解压解密后的数据。一个InputStreamReader将解压后的数据转换为Unicode文本。最后，文本由应用程序读取并处理。<br><img src="https://i.imgur.com/685kwhH.png" alt=""><br>每个过滤器输出流都有与java.io.OutputStream相同的write(),close()和flush()方法。每个过滤器输入流都有与java.io.InputStream相同的read(),close()和available()方法。有些情况下，如BufferedInputStream和BufferedOutputStream,过滤器可能只有这些方法。过滤纯粹是内部操作，不提供任何新的公共接口。不过，在大多数情况下，过滤器流还增加一些公共方法提供额外的作用。有时除了平常的read()和write()方法之外，还需要使用这些方法，如PushbackInputStream的unread()方法。另外一些情况下，它们几乎完全代替了最初的接口。例如PrintStream的write()方法就很少使用，而会使用它的print()和println()方法。</p><h2 id="将过滤器串链在一起"><a href="#将过滤器串链在一起" class="headerlink" title="将过滤器串链在一起"></a>将过滤器串链在一起</h2><p>过滤器通过其构造函数与流连接。例如，下面的代码段将缓冲文件data.txt的输入。首先，创建一个FileInputStream对象fin，为此将文件名作为参数传递给FileInputStram构造函数。然后，通过将fin作为参数传递给BufferedInputStream构造函数来创建一个BufferendInputStream对象bin:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fin=new FileInputStream(&quot;data.txt&quot;);</span><br><span class="line">BufferedInputStream bin=new BufferedInputStream(fin);</span><br></pre></td></tr></table></figure><p></p><p>在此之后，从文件data.txt中读取文件可能会同时使用fin和bin的read()方法。不过，如果很合调用连接到同一和源的不同流，这可能睡违反过滤流的一些隐含的约定。大多数情况下，应当只使用链中最后一个过滤器进行实际的读写。想要在编写代码时尽量不带入这个中bug,可以有意的重写低层输入流的引用。例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStream in =new FileInputStream(&quot;data.txt&quot;);</span><br><span class="line">in=new BufferedInputStream(in);</span><br></pre></td></tr></table></figure><p></p><p>执行这两行代码后，再没有任何方法能够访问低层文件输入流了，所以也就不会不小心读取这个流而破坏缓冲区。这个实例之所以可运行，原因是既然BufferedInputStream可以多态的用作InputStream的实例，所以没有必要区分InputStream和BufferedInputStream的方法。如果必须使用超类中没有声明的过滤器流的其他方法，可以直接在一个流中构建另一个流，例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DateOutputStream dout=new DataOutputStream(new BufferesOutputStream(new FileOutputStream(&quot;data.txt&quot;)));</span><br></pre></td></tr></table></figure><p></p><p>虽然这些语句有些长，不过很容易将这条语句分成多行，像这样：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DataOutputStream dout =new DataOutputStream（</span><br><span class="line">                                        new BufferedOutputStream(</span><br><span class="line">                                        new FileOutputStream(&quot;data.txt&quot;)</span><br><span class="line">                                        ));</span><br></pre></td></tr></table></figure><p></p><p>这种连接时永久的，过滤器无法与流断开连接。</p><p>有时可能会需要使用链找那个多个过滤器的方法。例如，在读取Unicode文本文件时，可能希望读取前3个字节的字节顺序标记，来判断文件时用big-endian UCS-2,little-endian USC-2，还是UTF-8编码的。然后选择读取服务器发送的首部，找到Content-encoding(内容编码)，然后用这个内容编码方式选取正确的Reader(阅读器)过滤器来读取响应主体。或者可能希望通过网络连接使用DataOutputStream发送浮点数，然后从DataOutputStream所连接的DigestOutputStream中获取一个MessageDigest。在所有这些情况下，都小保存和使用各低层流的引用。不过，除了链中最后一个过滤器之外，无论如何你都不应该从其他过滤器读取数据，或想其写入任何内容。</p><h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><p>BufferedOutputStream类将写入的数据存储在缓冲区中(一个名为buff的保护字节数组字段)，直到缓冲区满或刷新输出流。然后它将数据一次全部写入低层输出流。如果一次写入多字节，这与多次写入少量字节(但字节加起来是一样的)相比，前者往往要快得多。对于网络连接尤其是这样，因为每个TCP片或UDP包都有一定的开销，一般大约为40字节。这里就假设为40字节，这意味着，如果一次发送1字节，则实际发送40+1=41字节。那么发送1K数据，要发送1K次，则实际上需要通过线缆发送41K，而一次全部发送只需要发送1K+40字节。不过大多数网卡和TCP实现自身都是提供了一定程度的缓冲，所以实际的数量不会那么夸张。尽管如此，缓冲网络输出通常会带来巨大的性能提升。</p><p>BufferedInputStream类也有一个缓冲区的保护字节数组，名为buf。当调用某个流的read()方法时，它会首先尝试从缓冲区获得请求的数据。只有当缓冲区没有数据时，流才从底层的源中读取数据。这时，它会从源中读取尽可能多的数据存入缓冲区，而不管是否马上需要所有这些数据。不会立即用到的数据可以在以后调用read()时读取。当文本从本地磁盘中读取文件时，从底层流中读取几百字节的数据与读取1字节数据几乎一样快。因此，缓冲和显著提高性能。对于网络连接，这种效果则不甚明显，在这里瓶颈往往是网络传送数据的速度，而不是网络结构向程序传送数据的速度或程序运行的速度。尽管如此，缓冲输入没有什么坏处，随着网络的速度加快会变得更为重要。<br>BufferedInputStream有两个构造函数，BufferedOutputStream也一样：</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>BufferedInputStream(InputStream in)</code></td><td style="text-align:left">创建一个 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。</td></tr><tr><td style="text-align:left"><code>BufferedInputStream(InputStream in, int size)</code></td><td style="text-align:left">创建具有指定缓冲区大小的 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。</td></tr></tbody></table><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>BufferedOutputStream(OutputStream out)</code></td><td style="text-align:left">创建一个新的缓冲输出流，以将数据写入指定的底层输出流。</td></tr><tr><td style="text-align:left"><code>BufferedOutputStream(OutputStream out, int size)</code></td><td style="text-align:left">创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流。</td></tr></tbody></table><p>第一个参数是底层流，可以从中读取未缓冲的数据，或向其写入缓冲的数据。如果给出第二个参数，它会指定缓冲区的字节数。否则，输入流的缓冲区大小设置为8192字节。输入流的缓冲区大小也设置为8192字节。缓冲区的理想大小取决于所缓冲的流时何种类型。对于网络连接，你希望比一般的包大小更大一些。不过，这很难预测，根据本地网络连接和协议不同也有所区别。更快，更大带宽的网络倾向于使用更大的包，不过TCP片通常不会大于1K字节。</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>int read()</code></td><td style="text-align:left">参见 InputStream 的 read 方法的常规协定。</td></tr><tr><td style="text-align:left"><code>int read(byte[] b, int off, int len)</code></td><td style="text-align:left">从此字节输入流中给定偏移量处开始将各字节读取到指定的 byte 数组中。</td></tr><tr><td style="text-align:left"><code>int available()</code></td><td style="text-align:left">返回可以从此输入流读取（或跳过）、且不受此输入流接下来的方法调用阻塞的估计字节数。</td></tr><tr><td style="text-align:left"><code>void close()</code></td><td style="text-align:left">关闭此输入流并释放与该流关联的所有系统资源。</td></tr><tr><td style="text-align:left"><code>long skip(long n)</code></td><td style="text-align:left">参见 InputStream 的 skip 方法的常规协定。</td></tr><tr><td style="text-align:left"><code>boolean markSupported()</code></td><td style="text-align:left">测试此输入流是否支持 mark 和 reset 方法。</td></tr><tr><td style="text-align:left"><code>void mark(int readlimit)</code></td><td style="text-align:left">参见 InputStream 的 mark 方法的常规协定。</td></tr><tr><td style="text-align:left"><code>void reset()</code></td><td style="text-align:left">参见 InputStream 的 reset 方法的常规协定。</td></tr></tbody></table><p>从类 java.io.FilterInputStream 继承的方法 (没有覆盖)<br><code>public int read(byte[] b) throws IOException</code></p><blockquote><p><strong>BufferedInputStream没有声明自己的任何新方法,它只覆盖了InputStream的方法。</strong>它折尺标记和重置。两个多字节read(byte[] b)和read(byte[] b, int off, int len)方法<strong>尝试根据需要多次从底层输入流中读取数据，从而完全填充指定的数组或子数组。只有当数组或子数组完全填满，到达流的结尾或低层流阻塞而无法进一步读取时，这两个read()方法才返回</strong>。而大多数输入流(如FileInputStream等)都不这样做。它们在返回前只从低层流或数据源中读取一次。</p></blockquote><blockquote><p><strong>BufferedOutputStream也没有声明自己的任何新方法。</strong>调用它的方法与任何输出流的方法是一样的。区别在于，每次写入会把数据放在缓冲区中，而不是直接放入底层的输出流。因此，<strong>需要发送数据时应当刷新输出流，这一点非常重要。</strong></p></blockquote><h2 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a>PrintStream</h2><p>PrintStream类是大多数程序员都会遇到的第一个过滤器输出流，因为System.out就是一个PrintStream。不过还可以使用下面两个构造函数将其他输出流串链到打印流:</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>PrintStream(OutputStream out)</code></td><td style="text-align:left">创建新的打印流。</td></tr><tr><td style="text-align:left"><code>PrintStream(OutputStream out, boolean autoFlush)</code></td><td style="text-align:left">创建新的打印流。</td></tr></tbody></table><p>默认情况下，打印流应当显示刷新输出。不过，如果autoFlush参数为true,那么每次写入1字节数组或换行，或者调用println()方法时，都会刷新输出流。<br>除了平常的write()，flsuh()和close()方法，PrintStream还有9个重载的print()方法和10个重载的println()方法。每个print()方法都当参数以可预见的方式转换为一个字符串，再用默认的编码方式把每个字符串写入低层输出流。println()方法也完成相同的操作，但会在所写的行尾追加一个与平台有关的行分隔符。在UNIX(包括Mac OS)下是换行符(<code>\n</code>)。在Windows下是回车/换行符(<code>\r\n</code>)。</p><hr><p><strong>警告:</strong> PrintStream是有害的，网络程序员应当向躲避瘟疫一样避开它!</p><hr><p>第一个问题是println()的输出是与平台相关的，取决于运行代码的机器各行有时用换行符分割，有时则用回车符或者回车/换行符来分割。写入控制台时不会产生问题，但对于编写必须遵循明确协议的网络客户端和服务而言，这却是个灾难。大多数网络协议(如HTTP和Gnutela)明确指定行应当以回车/换行符结束。而使用println()写出的程序可能在Windows上正常工作，但在UNIX和Mac上无法工作。虽然许多服务和客户端能够”宽容”地接收而器能处理不正确的行结束符，但偶尔也有例外。</p><p>第二个问题是Printstream假定使用所在平台的默认编码方式。不过,这种编码方式可能不是服务器或客户端所期望的。例如，以接收XML文件的Web浏览器希望文件已UTF-8或UTF16方式编码，除非服务器另行要求。不过，一个使用PrintStream的Web服务器可能会从一个没做本地化环境的Windows胸发送CP1252编码的文件，或者从日本本地化环境的系统发送SJIS编码的文件，而不管客户端是否期望或理解这些编码方式。PrintStream不提供任何改变默认编码的机制。这个问题可以通过使用相关的PrintWriter类来修补。但是其他问题依旧。</p><p>第三个问题是PrintStream吞掉了所有的异常。这使得PrintSteam很适合作为教科书程序，比如HelloWrold,因为你要讲授简单的控制台输出，不用让学生先去学习异常处理的所有闲逛的知识。不过，网络连接不如控制台那么可靠。连接经常会由于网络拥塞，电话公司的错误，远程系统崩溃，以及很多其他原因而断开。网络程序必须准备处理数据流中意外的中断。要做到这一点，就需要使用异常处理。不过，PrintStream捕获了低层输出流抛出的所有异常。注意PrintStream中重写过的标准的OutputStream方法的声明没有平常的throws IOExceprion:</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>public void write(int b)</code></td><td style="text-align:left">将指定的字节写入此流。</td></tr><tr><td style="text-align:left"><code>public void write(byte[] buf, int off, int len)</code></td><td style="text-align:left">将 len 字节从指定的初始偏移量为 off 的 byte 数组写入此流。</td></tr><tr><td style="text-align:left"><code>public void close()</code></td><td style="text-align:left">关闭流。</td></tr><tr><td style="text-align:left"><code>public void flush()</code></td><td style="text-align:left">刷新该流的缓冲。</td></tr></tbody></table><p>实际上，PrintStream要依靠一个过时的不充分的错误标志。如果低层流抛出一个异常，就是设置这个内部错误标志。要由程序员使用checkError()方法来检查这个标志的值：<br>public boolean checkError()</p><p>要对PrintStream完成任何错误检查，代码必须显示的检查每一个调用。此外，异动单出现错误，就没有办法重置这个标志再进行进一步的错误检测，也就没有关于这个错误的更多信息。简而言之，PrintStream提供的错误通知对于不可靠的网络连接来说还远远不够。</p><h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p>DataInputStream和DataOutputStream类提供了一些方法，可用二进制格式读写Java的基本数据类型和字符串。所用的二进制格式主要<strong>用于在两个不同的Java程序之间交换数据</strong>(可能通过网络连接，数据文件，管道或者其他中间介质)。输出流写入什么数据，输入流就能读取什么数据。不过，这碰巧与大多数交换二进制的Internet协议所用的格式相同。例如，事件协议使用32位的IEEE 754浮点数，类似于Java的float数据类型(这是有关联的，而不只是巧合。Java和大多数网络协议都是由UNIX程序员设计的，因此都倾向于使用大多数UNIX系统中的常见格式)。然而，这并不适用与所有网络协议，所以请检查你使用的协议的具体细节。例如,网络时间协议(NTP)会把时间表示为64位无符号定点数，前32位是整数部分，后32位是小数部分。这与所有常见编程语言中的基本类型都不相同，不过处理起来相当简单，至少对NTP必须使用这种格式。<br>DataOutputStream类提供了下面11中方法，可以写入特定的Java数据类型:</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>void writeBoolean(boolean v)</code></td><td style="text-align:left">将一个 boolean 值以 1-byte 值形式写入基础输出流。</td></tr><tr><td style="text-align:left"><code>void writeByte(int v)</code></td><td style="text-align:left">将一个 byte 值以 1-byte 值形式写出到基础输出流中。</td></tr><tr><td style="text-align:left"><code>void writeBytes(String s)</code></td><td style="text-align:left">将字符串按字节顺序写出到基础输出流中。</td></tr><tr><td style="text-align:left"><code>void writeShort(int v)</code></td><td style="text-align:left">将一个 short 值以 2-byte 值形式写入基础输出流中，先写入高字节。</td></tr><tr><td style="text-align:left"><code>void writeInt(int v)</code></td><td style="text-align:left">将一个 int 值以 4-byte 值形式写入基础输出流中，先写入高字节。</td></tr><tr><td style="text-align:left"><code>void writeLong(long v)</code></td><td style="text-align:left">将一个 long 值以 8-byte 值形式写入基础输出流中，先写入高字节。</td></tr><tr><td style="text-align:left"><code>void writeFloat(float v)</code></td><td style="text-align:left">使用 Float 类中的 floatToIntBits 方法将 float 参数转换为一个 int 值，然后将该 int 值以 4-byte 值形式写入基础输出流中，先写入高字节。</td></tr><tr><td style="text-align:left"><code>void writeDouble(double v)</code></td><td style="text-align:left">使用 Double 类中的 doubleToLongBits 方法将 double 参数转换为一个 long 值，然后将该 long 值以 8-byte 值形式写入基础输出流中，先写入高字节。</td></tr><tr><td style="text-align:left"><code>void writeChar(int v)</code></td><td style="text-align:left">将一个 char 值以 2-byte 值形式写入基础输出流中，先写入高字节。</td></tr><tr><td style="text-align:left"><code>void writeChars(String s)</code></td><td style="text-align:left">将字符串按字符顺序写入基础输出流。</td></tr><tr><td style="text-align:left"><code>void writeUTF(String str)</code></td><td style="text-align:left">以与机器无关方式使用 UTF-8 修改版编码将一个字符串写入基础输出流。</td></tr></tbody></table><hr><h3 id="网络字节顺序"><a href="#网络字节顺序" class="headerlink" title="网络字节顺序"></a>网络字节顺序</h3><p><strong>字节序</strong>，顾名思义<strong>字节的顺序</strong>，就是<strong>大于一个字节类型的数据在内存中的存放顺序</strong>(一个字节的数据当然就无需谈顺序的问题了)。其实大部分人在实际的开发中都很少会直接和字节序打交道。<strong>唯有在跨平台以及网络程序中字节序才是一个应该被考虑的问题。</strong></p><p>在所有的介绍字节序的文章中都会提到字节序分为两类：Big-Endian和Little-Endian，引用标准的Big-Endian和Little-Endian的定义如下：<br>a) <code>Little-Endian</code>就是<strong>低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。</strong><br>b)<code>Big-Endian</code>就是<strong>高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。</strong><br>c<strong>) 网络字节序</strong>：<code>TCP/IP</code>各层协议将字节序定义为<code>Big-Endian</code>，因此<code>TCP/IP</code>协议中使用的字节序通常称之为网络字节序。</p><p>little-endian是x86系列CPU的数据存储方式，即将低序的部分存储在前面。<br>而big-endian是将高序部分存储在前面。</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>例如，要存储0xF432，little-endian将以32F4存储，而使用big-endian与此相反，将存储为F432</p><hr><p>所有数据都以big-endian格式写入。整数用尽可能少的字节写为2进制的补码。因此，byte会写为1字节，short写为2字节，int写为4字节，long写为8字节。浮点数和双精度分别写为4字节和8字节的IEEE 754格式。布尔数写为1字节。0表示false,1表示true。字符写为两个无符号字节。</p><p>最后三个方法有些棘手，writeChars()方法只是对String参数迭代(循环)处理,将各个字符安顺序写为一个2字节的big-endain Unicode字符(确切的讲是UTF-16码点),writeBytes()犯法迭代处理String参数，但只写入每个字符的低字节。因此，如果字符串中包换有<code>Latin-1</code>字符集以外的字符，其中的信息将会丢失。对于一些指定了ASCII编码的网络协议来说，这个方法或许有用，但多数情况下都应当避免使用。</p><p>writeChars和writeBytes都不会对输出流的字符串的长度编码。因此，你无法真正区分原始字符和作为字符串一部分的字符。writeUTF()方法则包含了字符串的长度。它将字符串本社用Unicode UTF-8编码的一个变体进行编码，由于这个变体的编码与大多数非Java软件有点不兼容，所以应当只用于与其他使用DataInputStream读取字符串的Java程序进行数据交换。<br>为了与所有其他软件交换UTF-8文本,应当使用有适当编码的InputStreamReader(如果Sun当初把这个方法的以及相应的读取方法命名为writeString()和readString(),而不是writeUTF()和readUTF(),那就不会产生任何混淆了)。</p><p>除了这些写入二进制数字和字符串的方法，DataOutputStream当然还有OutputStream类平常的write(),flush()和close()方法。</p><p><strong>重写或继承与父类的方法：</strong></p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>void write(int b)</code></td><td style="text-align:left">将指定字节（参数 b 的八个低位）写入基础输出流。</td></tr><tr><td style="text-align:left"><code>void write(byte[] b, int off, int len)</code></td><td style="text-align:left">将指定 byte 数组中从偏移量 off 开始的 len 个字节写入基础输出流。</td></tr><tr><td style="text-align:left"><code>void write(byte[] b)</code></td><td style="text-align:left">写一个数组，继承于父类</td></tr><tr><td style="text-align:left"><code>void flush()</code></td><td style="text-align:left">清空此数据输出流。</td></tr><tr><td style="text-align:left"><code>public void close() throws IOException</code></td><td style="text-align:left">关闭此输出流并释放与此流有关的所有系统资源。</td></tr></tbody></table><p>DataInputStream和DataOutputStream是互补的。DataOutputStream协议一种格式，DataInputStream都可以读取。此外DateInputSteam还有通常的read()，available(),skip()和close()方法，以及读取整个字节数组和文本行的方法。</p><p>有9个读取而二进制数据的方法，这些方法对应于DataOutputStream的11个方法(writeBytes()或writeChars()没有相应的读取方法，这要通过一次读取1字节和字符来处理):</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>boolean readBoolean()</code></td><td style="text-align:left">参见 DataInput 的 readBoolean 方法的常规协定。</td></tr><tr><td style="text-align:left"><code>byte readByte()</code></td><td style="text-align:left">参见 DataInput 的 readByte 方法的常规协定。</td></tr><tr><td style="text-align:left"><code>short readShort()</code></td><td style="text-align:left">参见 DataInput 的 readShort 方法的常规协定。</td></tr><tr><td style="text-align:left"><code>int readInt()</code></td><td style="text-align:left">参见 DataInput 的 readInt 方法的常规协定。</td></tr><tr><td style="text-align:left"><code>long readLong()</code></td><td style="text-align:left">参见 DataInput 的 readLong 方法的常规协定。</td></tr><tr><td style="text-align:left"><code>float readFloat()</code></td><td style="text-align:left">参见 DataInput 的 readFloat 方法的常规协定。</td></tr><tr><td style="text-align:left"><code>double readDouble()</code></td><td style="text-align:left">参见 DataInput 的 readDouble 方法的常规协定。</td></tr><tr><td style="text-align:left"><code>char readChar()</code></td><td style="text-align:left">参见 DataInput 的 readChar 方法的常规协定。</td></tr><tr><td style="text-align:left"><code>String readUTF()</code></td><td style="text-align:left">参见 DataInput 的 readUTF 方法的常规协定。</td></tr></tbody></table><p>此外，DataInputStream提供了两个方法，可以读取无符号字节和无法好短整数，并返回等价的int。Java没有这些数据类型，但在读完C程序写入的二进制数据时会遇到：</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>int readUnsignedByte()</code></td><td style="text-align:left">参见 DataInput 的 readUnsignedByte 方法的常规协定。</td></tr><tr><td style="text-align:left"><code>int readUnsignedShort()</code></td><td style="text-align:left">参见 DataInput 的 readUnsignedShort 方法的常规协定。</td></tr></tbody></table><p>DataInputStream有两个通常的多字节read()方法，可以把数据读入一个数组或子数组，并返回读取的字节数。它还有两个readFully()方法，会重复的从底层输入流像一个数组读取数据，知道读取了所有请求的字节数为止。如果不能读取到足够的数据，就会抛出IOException异常。如果你能提前知道要读取多少字节，使用这些方法尤其有用。例如如果你已经从HTTP首部读取了Content-lenght(内容长度)字段，就能知道有多少字节的数据，这种情况下就可以很好的利用这些方法：</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>int read(byte[] b)</code></td><td style="text-align:left">从包含的输入流中读取一定数量的字节，并将它们存储到缓冲区数组 b 中。</td></tr><tr><td style="text-align:left"><code>int read(byte[] b, int off, int len)</code></td><td style="text-align:left">从包含的输入流中将最多 len 个字节读入一个 byte 数组中。</td></tr><tr><td style="text-align:left"><code>void readFully(byte[] b)</code></td><td style="text-align:left">参见 DataInput 的 readFully 方法的常规协定。</td></tr><tr><td style="text-align:left"><code>void readFully(byte[] b, int off, int len)</code></td><td style="text-align:left">参见 DataInput 的 readFully 方法的常规协定。</td></tr></tbody></table><p>最后,DataInputStream还提供了流行的readLine()方法,它读取用行结束符分隔的一行，文本，并返回一个字符串:</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>String readLine()</code></td><td style="text-align:left">已过时。 该方法无法将字节正确转换为字符。从 JDK 1.1 开始，读取文本行的首选方法是使用 BufferedReader.readLine() 方法。</td></tr></tbody></table><p>不过，任何情况下都不要使用这个方法，不仅是因为它已经被废弃，而且它还有bug。之所以将这个方法废弃，是因为你在大多数情况下它不能正确地将非ASCII字符转换为字节。这个任务现在有BufferedReader类的readLine()方法来处理。不过，这两个方法都存在一个隐含的bug:它们并不总能把一个回车识别为行结束。实际上，readLine()只能识别换行或回车/换行对。如果是换行，则抛出这个回车和换行。把这一行作为String返回。如果不是换行，就抛掉这个回车，把这一行作为String返回，刚读取的这个额外的字符会成为下一行的一部分。不过，如果回车是流的最后一个字符，那么readLine()会挂起，等待最后一个字符的出现，但这个字符永远也不会出现。</p><p>这个问题在读取文件时，不太明显，因为几乎可以肯定会有下一个字符:如果没有别的字符，那么会由-1表示流结束。不过，在持久的网络连接中(如用于FTP和新型HTTP的连接),服务器或客户端可能只是在最后一个字符之后停止发送数据，并等待响应，二不会真正关闭连接。如果幸运，最终可能某一端的连接超时，你将得到一个IOEception异常，不过这可能至少要花费几分钟，而且会使你丢失流的最后一行数据，如果不够幸运，程序将永远挂起。</p><h2 id="阅读器和书写器"><a href="#阅读器和书写器" class="headerlink" title="阅读器和书写器"></a>阅读器和书写器</h2><p>许多程序员在编码时有一个坏习惯，好像所有文本都是ASCII,或者至少是该平台的内置编码方式。虽然有些比较老，较简单的网络协议(如daytime,quete of the day和chargen)确定指定文本采用ASCII编码方式,如<code>K0I8-R</code>西里尔文，Big-5中文和土耳其语使用的是ISO8859-9。Java的内置字符集是Unicode的UTF-16编码。当编码不再是ASCII时，如果假定字节和字符实质上是一样的，这也会出现问题。因此，对应输入和输出流类层次体系，Java提供了一个基本上完整的镜像，用来处理字符而不是字节。</p><p>这个镜像体系中，两个抽象超类定义了读/写字符的基本API，java.io.Reader类指定读取字符的API。java.io.Writer指定写字符的API。对应输入和输出流使用字节的地方，阅读器和书写器会使用Unicode字符。Reader和Writer的具体子类允许读取特定的源和写入特定的目标。过滤器阅读器和书写器可以附加在其他阅读器或书写器上，以提供额外的服务或接口。</p><p>Reader和Writer最重要的具体子类是InputStreamReader和OutputStreamWriter类。InputStreamReader类包含一个底层输入流，可以从中读取原始字节。它根据指定的编码方式，将这些字节转换为Unicode字符。OutputStreamWriter从运行的程序中接收Unicode字符。然后使用指定的编码方式将这些字符转换为字节，再将这些字节写入低层输出流中。</p><p>除了这两个类，java.io包还提供了几个原始阅读器和书写器类,它们可以读取字符而不需要一个地城输入流，这些类包括：</p><ul><li>FileReader</li><li>FileWriter</li><li>StringReader</li><li>StringWriter</li><li>CharArrayReader</li><li>CharArrayWriter</li></ul><p>以上所列的两个类可以处理文件，后四个由Java内部使用，所以在网络编程中不太常用。不过，除了构造函数不同，这些类与其他阅读器和书写器类一样，都有相同的公共接口。</p><h2 id="书写器"><a href="#书写器" class="headerlink" title="书写器"></a>书写器</h2><p>Writer类是java.io.OutputStream类的映射。它是一个抽象类，有两个保护类型的构造函数，与OutputStream类似，Writer类从不直接使用;相反，会通过它的某个子类以多态方式使用。它有5个write()方法，另外还有flush()和close()方法：</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>protected Writer()</code></td><td style="text-align:left">创建一个新的字符流 writer，其关键部分将同步 writer 自身。</td></tr><tr><td style="text-align:left"><code>protected Writer(Object lock)</code></td><td style="text-align:left">创建一个新的字符流 writer，其关键部分将同步给定的对象。</td></tr></tbody></table><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>void write(int c)</code></td><td style="text-align:left">写入单个字符。</td></tr><tr><td style="text-align:left"><code>void write(char[] cbuf)</code></td><td style="text-align:left">写入字符数组。</td></tr><tr><td style="text-align:left"><code>abstract void write(char[] cbuf, int off, int len)</code></td><td style="text-align:left">写入字符数组的某一部分。</td></tr><tr><td style="text-align:left"><code>void write(String str)</code></td><td style="text-align:left">写入字符串。</td></tr><tr><td style="text-align:left"><code>void write(String str, int off, int len)</code></td><td style="text-align:left">写入字符串的某一部分。</td></tr><tr><td style="text-align:left"><code>Writer append(char c)</code></td><td style="text-align:left">将指定字符添加到此 writer。</td></tr><tr><td style="text-align:left"><code>Writer append(CharSequence csq)</code></td><td style="text-align:left">将指定字符序列添加到此 writer。</td></tr><tr><td style="text-align:left"><code>Writer append(CharSequence csq, int start, int end)</code></td><td style="text-align:left">将指定字符序列的子序列添加到此 writer.Appendable。</td></tr><tr><td style="text-align:left"><code>abstract void close()</code></td><td style="text-align:left">关闭此流，但要先刷新它。</td></tr><tr><td style="text-align:left"><code>abstract void flush()</code></td><td style="text-align:left">刷新该流的缓冲。</td></tr></tbody></table><p>write(char[] text,int offset,int length)方法是基础方法，其他四个write()都是根据它实现的。子类至少要覆盖这个方法以及flush()和close()，但是为了提供更搞笑的实现方法，大多数子类还覆盖了其他一些write()方法。例如，给定一个Writer对象w,可以这样写入字符串“Network”<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char[] network=&#123;&apos;N&apos;,&apos;e&apos;,&apos;t&apos;,&apos;w&apos;,&apos;o&apos;,&apos;r&apos;,&apos;k&apos;&#125;;</span><br><span class="line">w.write(network,0,network.length);</span><br></pre></td></tr></table></figure><p></p><p>也可以用其他write()方法完成同样的任务:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">w.write(network);</span><br><span class="line">for(int i=0;i&lt;network.length;i++)</span><br><span class="line">    w.write(network[i]);</span><br></pre></td></tr></table></figure><p></p><p>或者：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.write(&quot;Network&quot;);</span><br></pre></td></tr></table></figure><p></p><p>或者：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.write(&quot;Network&quot;,0,7);</span><br></pre></td></tr></table></figure><p></p><p>所有这些例子表述都是同样的事情，只不过方式有所不同。在任何给定情况下，选择使用哪个方法主要考虑是否方便，以及你有什么偏好。不过，这些代码写入多字节以及写入哪些字节，则取决于w使用的编码方式。如果使用big-endian UTF-16编码，那么它将依次写入下面14字节(以16进制显示):<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00 4E 00 65 00 74 00 77 00 6F 00 72 00 8B</span><br></pre></td></tr></table></figure><p></p><p>另一方面，如果w使用little-endain UTF-16，则写入下面14字节序列：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4E 00 65 00 74 00 77 00 6f 00 72 00 8B 00</span><br></pre></td></tr></table></figure><p></p><p>如果w使用<code>Latin-1</code>,UTF-8或MacRoman,则写入下面7字节的序列:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4E 65 74 77 6F 72 6B</span><br></pre></td></tr></table></figure><p></p><p>其他编码方式可能写入不同的字节序列。具体的输出取决于编码方式。<br>书写器可以缓冲，有可能直接串链到BufferedWriter,也有可能间接链入(因为其低层输出流时缓冲的)。为了强制将一个写入提前交给输出介质，要调用flush()方法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w.flush();</span><br></pre></td></tr></table></figure><p></p><p>close()方法的行为与OutputStream的close()方法类似。close()刷新输出书写器，然后关闭低层输出流，并释放与之关联的所有资源:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public absctract void close() throws IOException</span><br></pre></td></tr></table></figure><p></p><p>在书写器关闭之后，进一步的写入会抛出IOException异常。</p><h2 id="OutputStreamWrter"><a href="#OutputStreamWrter" class="headerlink" title="OutputStreamWrter"></a>OutputStreamWrter</h2><p>OutputStreamWriter是Writer的最重要的具体子类。OutputStreamWriter会从Java程序接收字符。它根据指定的编码方式将这些字符转换为字节，并写入低层输出流。它的构造函数指定了要写入的输出流和使用的编码方式：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public OutputStreamWriter(OutputStream out,String encoding) throws UnsupportedEncodingException</span><br></pre></td></tr></table></figure><p></p><p>JDK中包括一个Sun的native2ascii工具，其相关文档中列出了所有合法的编码方式，如果没有指定编码方式，就使用平台的默认编码方式。2013年，Mac上默认编码方式是UTF-8,Linux上也大多如此。不过，在Linux上，如果本地操作系统配置为默认使用另外某个字符集，Linux上的默认编码方式可能有变化。在Windows上，默认编码方式会根据国家和配置而改变，但是在美国，Windows上默认的编码方式往往是<code>Windows-1252</code>，又叫做<code>CP1252</code>。默认字符集可能会在出乎意料的时候导致意外的问题。<strong>如果能明确地指定字符集，这往往比让Java为你选择一个字符集要好。</strong></p><p>除了构造函数，OutputStramWriter只有通常的Writer方法(这些方法与所有Writer类中的用法相同)，还有一个返回对象编码方式的方法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public String getEncoding()</span><br></pre></td></tr></table></figure><p></p><h2 id="阅读器"><a href="#阅读器" class="headerlink" title="阅读器"></a>阅读器</h2><p>Reader类是java.io.InputStream类的镜像。它是以抽象类，有两个保护的构造函数。与InputStream和Writer类似，Reader类从不直接使用，只通过其子类来使用。他有三个read()方法，另外还有skip()，close()，ready()，mark()，reset()和markSupported()方法</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>protected Reader()</code></td><td style="text-align:left">创建一个新的字符流 reader，其重要部分将同步其自身的 reader。</td></tr><tr><td style="text-align:left"><code>protected Reader(Object lock)</code></td><td style="text-align:left">创建一个新的字符流 reader，其重要部分将同步给定的对象。</td></tr></tbody></table><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>void reset()</code></td><td style="text-align:left">重置该流。</td></tr><tr><td style="text-align:left"><code>int read()</code></td><td style="text-align:left">读取单个字符。</td></tr><tr><td style="text-align:left"><code>int read(char[] cbuf)</code></td><td style="text-align:left">将字符读入数组。</td></tr><tr><td style="text-align:left"><code>abstract int read(char[] cbuf, int offset, int len)</code></td><td style="text-align:left">将字符读入数组的某一部分。</td></tr><tr><td style="text-align:left"><code>int read(CharBuffer target)</code></td><td style="text-align:left">试图将字符读入指定的字符缓冲区。</td></tr><tr><td style="text-align:left"><code>boolean markSupported()</code></td><td style="text-align:left">判断此流是否支持 mark() 操作。</td></tr><tr><td style="text-align:left"><code>void mark(int readAheadLimit)</code></td><td style="text-align:left">标记流中的当前位置。</td></tr><tr><td style="text-align:left"><code>long skip(long n)</code></td><td style="text-align:left">跳过字符。</td></tr><tr><td style="text-align:left"><code>boolean ready()</code></td><td style="text-align:left">判断是否准备读取此流。</td></tr><tr><td style="text-align:left"><code>abstract void close()</code></td><td style="text-align:left">关闭该流并释放与之关联的所有资源。</td></tr></tbody></table><p><code>read(char[] cbuf, int off, int len)</code>方法是基本方法，其他两个read()方法都是根据它实现的。子类必须至少覆盖这个方法以及close()方法，但是为了提供更搞笑的实现，大多数子类还会覆盖其他一些read()方法。</p><p>由于与对应的InputStream类似，大多数方法都很容易理解。read()方法将一个Unicode字符作为一个int返回。可以是0到65535之间的一个值,或者在流结束时返回-1(理论上讲，它会返回一个UTF-16码点,不过这基于等同于Unicode字符)。<code>read(char[] cbuf)</code>方法尝试使用字符填充<code>cbuf</code>,并返回实际读取的字节数，或者在流结束时返回-1。<code>read(char[] cbuf, int offset, int length)</code>方法尝试将length个字符读入text的子数组中(从offset开始持续读入length个字符)。它也会返回实际读取的字符数，或者在流结束时返回-1。</p><ul><li>skip(long n)方法跳过n个字符。</li><li>mark()和reset()方法允许一些阅读器重置到字符序列中做标记的位置。</li><li>markSupported()方法会告知阅读器是否支持标记和重置。</li><li>close()方法会关闭阅读器和所有底层输入流，如果试图进一步读取则会抛出IOException异常。</li></ul><p>尽管与InputStream非常相似，但也有所例外: Reader类有一个ready()方法，它与InputStream的available()的用途相同，但语义却不尽相同，尽管都涉及字节到字符转换。available()返回一个int,指定可无阻赛的最少读取多少字节。但ready()犯法只返回一个boolean,指示阅读器是否可以无阻赛的读取。问题在于，有些字符编码仿方式(如UTF-8)对于不同的字符会使用不同数量的字节。因此在实际从缓冲区读取之前，很难说有多好个字符正在网络或文件系统的缓冲区中等待。</p><p>InputStreamReader是Reader的最重要的具体子类。InputStreamReader从底层输入流(FileInputStream或TelnetInputStream)中读取字节。它根据指定的编码方式将这些字节转换为字符。并返回这些字符。构造函数指定要读取的输入流所用的编码方式:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public InputStreamReader(InputStream in)</span><br><span class="line">public InputStreamReader(InputStream in,String encoding) </span><br><span class="line">    throws UnsupportedEncodingException</span><br></pre></td></tr></table></figure><p></p><p>如果没有指定编码方式，就使用平台的默认编码方式。如果指定了一个未知的编码方式，会抛出<code>UnsupportEncodingException</code>异常。<br>例如，下面的方法将读取一个输入流，使用MacCyrillic编码方式将其全部转换为一个Unicode字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static String getMacCyrillicString(InputStream in)</span><br><span class="line">    throws IOExceptionn </span><br><span class="line">&#123;</span><br><span class="line">    InputStreamReader r=new InputStreamReader(in,&quot;MacCyrillic&quot;);</span><br><span class="line">    StringBuilder sb=new StringBuilder();</span><br><span class="line">    int c;</span><br><span class="line">    while( (c=r.read()!=-1) )</span><br><span class="line">        sb.append((char) c);</span><br><span class="line"></span><br><span class="line">    return sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="过滤器阅读器和书写器"><a href="#过滤器阅读器和书写器" class="headerlink" title="过滤器阅读器和书写器"></a>过滤器阅读器和书写器</h2><p>InputStreamReader和OutputStreamWriter类就相当于输入和输出流的装饰器，把面向字节的接口改为面向字符的接口。完场之后，就可以将其他面向字符的过滤器放在用java.io.FilterReader和java.io.FilterWriter类的阅读器或书写器上面。与过滤器流一样，有很多子类可以完成特定的过滤工作，包括:</p><ul><li>BufferedReader</li><li>BufferedWriter</li><li>LineNumberReder</li><li>PushbackReader</li><li>PrintWriter<br>BufferedReader和BufferedWriter类是基于字符的，而BufferedInputStream和BufferedOutputStream类是面向<code>字节</code>的<br>BufferedInputStream和BufferedOutputStream使用一个内部字节数组作为缓冲区，响应的，BufferedReader和BufferedWriter使用一个内部字符数组作为缓冲区。</li></ul><p><strong>当程序从BufferedReader读取时，文本会从缓冲区得到，而不是直接同低层输入流或其他文本源读取</strong>。当缓冲区清空时，BufferedReader将用尽可能多的文本再次填充，尽管这些文本不是全部都立即需要，这样可以使以后的读取速度更快。当程序写入一个BufferedWriter时，文本被放置在缓冲区中。只有当缓冲区填满或者当书写器显示刷新输出时，文本才会被一道低层输出流或其他目标，这样使得写入也要快得多。</p><p>如果没有设置大小，则默认使用的大小为8192字符：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public BufferedReader(Reader in,int bufferSize)</span><br><span class="line">public BufferedReader(Reader in)</span><br><span class="line">public BufferedWriter(Writer out)</span><br><span class="line">public BufferedWriter(Writer out,int bufferSize)</span><br></pre></td></tr></table></figure><p></p><p>例如，前面的getMacCyrillicString()示例效率不太高，因为它每次只读取一个字符。由于MacCyrillic是一个单字节的字符集，所以也是每次读取1字节。不过,通常将一个BufferedReader串链到InputStreamReader，会是它运行得更快，如下所示:<br>public static String getMacCyrillicString(InputStream in)<br>throws IOException<br>{<br>Reader r=new InputStreamReader(in,”MacCyrillic”);<br>r=new BufferedReader(r,1024);<br>StringBuider sb=new StringBuilder();<br>int c;<br>while((c=r.read())!=-1)<br>sb.append((char)c);</p><pre><code>return sb.toString();</code></pre><p>}</p><p>要让这个方法进行缓冲，只需要增加另外一行代码。算法的其他部分都不用改变，因为要用到的InputStreamReader方法只是Reader超类中声明的read()和close()方法，所有的Reader子类都有着两个方法，BufferedReader也不例外。<br>BufferedReader类还有一个readeLine()方法，它读取一行文本，并作为一个字符串返回:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public String readLine() throws IOException</span><br></pre></td></tr></table></figure><p></p><p>这个方法可以替代DataInputStream中已废弃的readerLine()方法，它与该方法的行为基本相同。主要区别在于，通过将BufferedReader串链到InputStreamReader,你可以采用正确的字符集进读取行，而不是采用平台的默认编码方式。</p><p>这个BufferedWriter()类增加了一个其超类所没有的新的方法，名为newLine()，也用于写入一行:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void newLine() throws IOException</span><br></pre></td></tr></table></figure><p></p><p>这个方法向输出插入一个与平台有关的行分隔符字符串。line.separator系统属性会确定这个字符串是什么:在UNIX和Mac OS X可能是换行”<code>\n</code>“,在Windows下是回车/换行对。由于网络协议一般会指定所需的行结束符，所以网络编程中不要使用这个方法。而是应当显示的下如协议所需的行结束符。大多数情况下，所需的结束符都是回车/换行对(“\r\n”)</p><h2 id="PrintWriter"><a href="#PrintWriter" class="headerlink" title="PrintWriter"></a>PrintWriter</h2><p>PrintWriter类用于取代Java 1.0的PrintStream类，它能正确的处理多字节字符集和国际化文本。Sun最初计划废弃PrintStream而支持PrintWriter，但是当它意识到这样做会使太多现有的代码失效(尤其是依赖于System.out的代码)，就放弃了这种想法。尽管如此，新编写的代码还是应当使用PrintWriter而不是PrintStream。</p><p>除了构造函数，PrintWriter类也有与PrintStream几乎相同的方法集。包括:</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>PrintWriter(File file)</code></td><td style="text-align:left">使用指定文件创建不具有自动行刷新的新 PrintWriter。</td></tr><tr><td style="text-align:left"><code>PrintWriter(File file, String csn)</code></td><td style="text-align:left">创建具有指定文件和字符集且不带自动刷行新的新 PrintWriter。</td></tr><tr><td style="text-align:left"><code>PrintWriter(OutputStream out)</code></td><td style="text-align:left">根据现有的 OutputStream 创建不带自动行刷新的新 PrintWriter。</td></tr><tr><td style="text-align:left"><code>PrintWriter(OutputStream out, boolean autoFlush)</code></td><td style="text-align:left">通过现有的 OutputStream 创建新的 PrintWriter。</td></tr><tr><td style="text-align:left"><code>PrintWriter(String fileName)</code></td><td style="text-align:left">创建具有指定文件名称且不带自动行刷新的新 PrintWriter。</td></tr><tr><td style="text-align:left"><code>PrintWriter(String fileName, String csn)</code></td><td style="text-align:left">创建具有指定文件名称和字符集且不带自动行刷新的新 PrintWriter。</td></tr><tr><td style="text-align:left"><code>PrintWriter(Writer out)</code></td><td style="text-align:left">创建不带自动行刷新的新 PrintWriter。</td></tr><tr><td style="text-align:left"><code>PrintWriter(Writer out, boolean autoFlush)</code></td><td style="text-align:left">创建新 PrintWriter。</td></tr></tbody></table><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>PrintWriter append(char c)</code></td><td style="text-align:left">将指定字符添加到此 writer。</td></tr><tr><td style="text-align:left"><code>PrintWriter append(CharSequence csq)</code></td><td style="text-align:left">将指定的字符序列添加到此 writer。</td></tr><tr><td style="text-align:left"><code>PrintWriter append(CharSequence csq, int start, int end)</code></td><td style="text-align:left">将指定字符序列的子序列添加到此 writer。</td></tr><tr><td style="text-align:left"><code>void close()</code></td><td style="text-align:left">关闭该流并释放与之关联的所有系统资源。</td></tr><tr><td style="text-align:left"><code>void flush()</code></td><td style="text-align:left">刷新该流的缓冲。</td></tr><tr><td style="text-align:left"><code>boolean checkError()</code></td><td style="text-align:left">如果流没有关闭，则刷新流且检查其错误状态。</td></tr><tr><td style="text-align:left"><code>protected void clearError()</code></td><td style="text-align:left">清除此流的错误状态。</td></tr><tr><td style="text-align:left"><code>protected void setError()</code></td><td style="text-align:left">指示已发生错误。</td></tr><tr><td style="text-align:left"><code>void write(char[] buf)</code></td><td style="text-align:left">写入字符数组。</td></tr><tr><td style="text-align:left"><code>void write(char[] buf, int off, int len)</code></td><td style="text-align:left">写入字符数组的某一部分。</td></tr><tr><td style="text-align:left"><code>void write(int c)</code></td><td style="text-align:left">写入单个字符。</td></tr><tr><td style="text-align:left"><code>void write(String s)</code></td><td style="text-align:left">写入字符串。</td></tr><tr><td style="text-align:left"><code>void write(String s, int off, int len)</code></td><td style="text-align:left">写入字符串的某一部分。</td></tr><tr><td style="text-align:left"><code>PrintWriter format(Locale l, String format, Object... args)</code></td><td style="text-align:left">使用指定格式字符串和参数将一个格式化字符串写入此 writer 中。</td></tr><tr><td style="text-align:left"><code>PrintWriter format(String format, Object... args)</code></td><td style="text-align:left">使用指定格式字符串和参数将一个格式化字符串写入此 writer 中。</td></tr><tr><td style="text-align:left"><code>void print(boolean b)</code></td><td style="text-align:left">打印 boolean 值。</td></tr><tr><td style="text-align:left"><code>void print(char c)</code></td><td style="text-align:left">打印字符。</td></tr><tr><td style="text-align:left"><code>void print(char[] s)</code></td><td style="text-align:left">打印字符数组。</td></tr><tr><td style="text-align:left"><code>void print(double d)</code></td><td style="text-align:left">打印 double 精度浮点数。</td></tr><tr><td style="text-align:left"><code>void print(float f)</code></td><td style="text-align:left">打印一个浮点数。</td></tr><tr><td style="text-align:left"><code>void print(int i)</code></td><td style="text-align:left">打印整数。</td></tr><tr><td style="text-align:left"><code>void print(long l)</code></td><td style="text-align:left">打印 long 整数。</td></tr><tr><td style="text-align:left"><code>void print(Object obj)</code></td><td style="text-align:left">打印对象。</td></tr><tr><td style="text-align:left"><code>void print(String s)</code></td><td style="text-align:left">打印字符串。</td></tr><tr><td style="text-align:left"><code>PrintWriter printf(Locale l, String format, Object... args)</code></td><td style="text-align:left">使用指定格式字符串和参数将格式化的字符串写入此 writer 的便捷方法。</td></tr><tr><td style="text-align:left"><code>PrintWriter printf(String format, Object... args)</code></td><td style="text-align:left">使用指定格式字符串和参数将格式化的字符串写入此 writer 的便捷方法。</td></tr><tr><td style="text-align:left"><code>void println()</code></td><td style="text-align:left">通过写入行分隔符字符串终止当前行。</td></tr><tr><td style="text-align:left"><code>void println(boolean x)</code></td><td style="text-align:left">打印 boolean 值，然后终止该行。</td></tr><tr><td style="text-align:left"><code>void println(char x)</code></td><td style="text-align:left">打印字符，然后终止该行。</td></tr><tr><td style="text-align:left"><code>void println(char[] x)</code></td><td style="text-align:left">打印字符数组，然后终止该行。</td></tr><tr><td style="text-align:left"><code>void println(double x)</code></td><td style="text-align:left">打印双精度浮点数，然后终止该行。</td></tr><tr><td style="text-align:left"><code>void println(float x)</code></td><td style="text-align:left">打印浮点数，然后终止该行。</td></tr><tr><td style="text-align:left"><code>void println(int x)</code></td><td style="text-align:left">打印整数，然后终止该行。</td></tr><tr><td style="text-align:left"><code>void println(long x)</code></td><td style="text-align:left">打印 long 整数，然后终止该行。</td></tr><tr><td style="text-align:left"><code>void println(Object x)</code></td><td style="text-align:left">打印 Object，然后终止该行。</td></tr><tr><td style="text-align:left"><code>void println(String x)</code></td><td style="text-align:left">打印 String，然后终止该行。</td></tr></tbody></table><p>这些方法的行为大多与PrintStream中相同。只有4个write()方法有所例外，他们写入字符而不是字节。此外，如果低层的书写器能够正确地处理字符集转换，那么PrintWriter的所有方法也能处理这种转换。这是对非国际化的PrintStream类的改进，但对弈网络编程来说，仍然不太合适。很遗憾，PrintWriter也存在困扰PrintStream类的平台依赖性和错误检查报告信息量小的问题。</p><hr><p>提示:本章快速的浏览了java.io包，涵盖了编写网络程序所需要的最起码的知识。更详细的介绍及更多的实例请查阅这个系列中我的另一本数《Java I/O》(O’Reilly出版)。</p><hr><p>好的，一定看看。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/d3f6b577/">java网络编程第4版 第2章 流</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>BufferedInputStream读数组方法和FileInputStream读数组方法的区别：</title>
      <link href="/blog/d4b540e/"/>
      <url>/blog/d4b540e/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><ul><li>BufferedInputStream读数组方法，尽量读满整个数组，然后再返回，所以可能会多次读取，才返回。</li><li>而FileInputStream的读数组方法只会读取一次，读到多少就返回多少。读取一次，就返回一次。不管数组有没有读满。</li></ul><p>本文链接: <a href="https://www.lansheng.net.cn/blog/d4b540e/">BufferedInputStream读数组方法和FileInputStream读数组方法的区别：</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java IO流 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>linux下删除目录及其子目录下某种类型文件</title>
      <link href="/blog/d10c0440/"/>
      <url>/blog/d10c0440/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:16 GMT+0800 (中国标准时间) --><p>原文：<a href="https://www.cnblogs.com/wyb628/p/7374372.html" target="_blank" rel="noopener">https://www.cnblogs.com/wyb628/p/7374372.html</a></p><p>Linux下，如果想要删除目录及其子目录下某种类型文件，比如说所有的txt文件，则可以使用下面的命令：</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name "*.txt" -type f -print -exec rm -rf &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> find . -name "*.txt" -type f -print -exec rm -rf &#123;&#125; \;</span><br><span class="line">./a.txt</span><br><span class="line">./b.txt</span><br><span class="line">./Java/c.txt</span><br><span class="line">./其他/d.txt</span><br></pre></td></tr></table></figure><p>可以看到，当前目录下的<code>a.txt</code>,<code>b.txt</code>,子目录<code>./Java/</code>下的<code>c.txt</code>，子目录<code>./其他/</code>下的<code>d.txt</code>都被删除掉了。<br><a id="more"></a></p><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><p><code>.</code>: 表示在当前目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-name "*.txt"</span><br></pre></td></tr></table></figure><p>表示查找所有后缀为txt的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-type f</span><br></pre></td></tr></table></figure><p>表示文件类型为一般正规文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-print</span><br></pre></td></tr></table></figure><p>表示将查询结果打印到屏幕上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-exec command</span><br></pre></td></tr></table></figure><p><code>command</code>为其他命令，<code>-exec</code>后可再接其他的命令来处理查找到的结果，上式中，<code>{}</code>表示”由<code>find</code>命令查找到的结果“，如上所示，find所查找到的结果放置到{}位置，-exec一直到”\;“是关键字，表示<code>find</code>额外命令的<strong>开始（<code>-exec</code>）</strong>到<strong>结束（<code>\;</code>）</strong>，这中间的就是find命令的额外命令，上式中就是<code>rm -rf</code></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/d10c0440/">linux下删除目录及其子目录下某种类型文件</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Git忽略eclipse中的Java工程</title>
      <link href="/blog/5e9f32fb/"/>
      <url>/blog/5e9f32fb/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:16 GMT+0800 (中国标准时间) --><p>如果已经添加过了的话，<code>.gitignore</code>是无法过滤的，<br>所以，先删掉版本库吧，好在不是什么重要的代码；<br><a id="more"></a></p><h2 id="删除本地版本库："><a href="#删除本地版本库：" class="headerlink" title="删除本地版本库："></a>删除本地版本库：</h2><p>git-bash中，在当前工程路径下输入<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf  .git</span><br></pre></td></tr></table></figure><p></p><p>强制删除版本库。</p><h2 id="删除远程仓库"><a href="#删除远程仓库" class="headerlink" title="删除远程仓库"></a>删除远程仓库</h2><p>登录码云，github等，把上面的仓库删除掉。</p><h2 id="重新初始化本地版本库"><a href="#重新初始化本地版本库" class="headerlink" title="重新初始化本地版本库"></a>重新初始化本地版本库</h2><p>然后git-bash中输入<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p></p><p>重新初始化本地版本库</p><h3 id="创建readme文件："><a href="#创建readme文件：" class="headerlink" title="创建readme文件："></a>创建readme文件：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch README.md</span><br></pre></td></tr></table></figure><h3 id="添加readme-md文件"><a href="#添加readme-md文件" class="headerlink" title="添加readme.md文件"></a>添加readme.md文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add README.md</span><br></pre></td></tr></table></figure><h3 id="新建-gitignore文件"><a href="#新建-gitignore文件" class="headerlink" title="新建.gitignore文件"></a>新建<code>.gitignore</code>文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch .gitignore</span><br></pre></td></tr></table></figure><p>编辑过滤文件<code>.gitignore</code>输入下面的内容<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/bin/</span><br><span class="line">/.settings/</span><br></pre></td></tr></table></figure><p></p><ul><li><code>/bin/</code>上面的意思是忽略工程<code>bin</code>目录下下的所有文件，注意这里的<code>/</code>指的是当前的工程路径，而不是系统的根路径。</li><li><p><code>/.settings/</code>表示忽略工程根路径下色<code>.setings/</code>目录中的所有文件<br>输入<code>git status</code>查看<br><img src="https://i.imgur.com/34nDLd0.png" alt=""><br>可以看到还有几个文件我也不需要提交，在<code>.gitignore</code>加上这几个文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/bin/</span><br><span class="line">/.settings/</span><br><span class="line">.gitignore</span><br><span class="line">.classpath</span><br><span class="line">.project</span><br></pre></td></tr></table></figure></li><li><p><code>.gitignore</code>表示忽略<code>.gitignore</code>文件自身</p></li><li><code>.classpath</code>表示忽略.classpath文件</li><li><code>.project</code>表示忽略.project文件</li></ul><p>然后在输入<code>git status</code>查看状态：<br><img src="https://i.imgur.com/JThORER.png" alt=""><br>可以看到其他文件都过滤掉了，只需要提交src中的源码就行了。</p><p>添加所有的文件：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p></p><p>查看状态：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p></p><p><img src="https://i.imgur.com/24mlW1c.png" alt=""><br>可以看到现在只会添加<code>src</code>目录下的文件<br>重新提交：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m “删除临时文件,重新提交”</span><br></pre></td></tr></table></figure><p></p><p>然后重新在码云上重新创建代码库，然后重新连接，重新提交即可。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/5e9f32fb/">Git忽略eclipse中的Java工程</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> git教程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java IO流 节点流和处理流</title>
      <link href="/blog/2e0f7472/"/>
      <url>/blog/2e0f7472/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><ul><li>节点流：可以从或向一个特定的地方（节点）读写数据。如FileReader.</li><li>处理流：是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。如BufferedReader.处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。</li></ul><h2 id="JAVA常用的节点流："><a href="#JAVA常用的节点流：" class="headerlink" title="JAVA常用的节点流：  ##　"></a>JAVA常用的节点流： ##</h2><ul><li>文 件: FileInputStream FileOutputStrean FileReader FileWriter 文件进行处理的节点流。</li><li>字符串: StringReader StringWriter 对字符串进行处理的节点流。</li><li>数 组: ByteArrayInputStream ByteArrayOutputStream CharArrayReader CharArrayWriter 对数组进行处理的节点流（对应的不再是文件，而是内存中的一个数组）。</li><li><p>管 道: PipedInputStream PipedOutputStream PipedReaderPipedWriter对管道进行处理的节点流。</p><a id="more"></a><h2 id="常用处理流（关闭处理流使用关闭里面的节点流）"><a href="#常用处理流（关闭处理流使用关闭里面的节点流）" class="headerlink" title="常用处理流（关闭处理流使用关闭里面的节点流）"></a>常用处理流（关闭处理流使用关闭里面的节点流）</h2></li><li><p>缓冲流：BufferedInputStrean BufferedOutputStream BufferedReader BufferedWriter—增加缓冲功能，避免频繁读写硬盘。</p></li><li></li><li>转换流：InputStreamReader OutputStreamReader实现字节流和字符流之间的转换。</li><li>数据流 DataInputStream DataOutputStream 等-提供将基础数据类型写入到文件中，或者读取出来.</li></ul><h2 id="流的关闭顺序"><a href="#流的关闭顺序" class="headerlink" title="流的关闭顺序"></a>流的关闭顺序</h2><ul><li>一般情况下是：先打开的后关闭，后打开的先关闭</li><li>另一种情况：看依赖关系，如果流a依赖流b，应该先关闭流a，再关闭流b。例如，处理流a依赖节点流b，应该先关闭处理流a，再关闭节点流b</li><li>可以只关闭处理流，不用关闭节点流。处理流关闭的时候，会调用其处理的节点流的关闭方法。</li></ul><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ul><li>如果将节点流关闭以后再关闭处理流，会抛出IO异常。</li><li>如果关闭了处理流，在关闭与之相关的节点流，也可能出现IO异常。（hadoop编程文件流操作中遇到了。）</li></ul><p><strong>总结：通常在IO的继承树中，<code>继承自Filter开头的流</code>或者转换流(InputStreamReader,OutputStreamReader)都是处理流，其他的都是节点流。</strong></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/2e0f7472/">Java IO流 节点流和处理流</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java IO流 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java IO流 过滤器流</title>
      <link href="/blog/c52cb4ad/"/>
      <url>/blog/c52cb4ad/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>文件流、字节数组流、管道流等等被称之为原始流，它们提供了对某类数据的输入输出功能。为了在流处理的过程中简化和标准化某一类功能，例如缓冲、压缩、加密、摘要等，Java提供了一系列过滤器类，每组类提供了一种典型的信息处理功能。根据操作对象是字节还是字符，过滤器又分为过滤器流和阅读器/书写器两类，举例如下：</p><ul><li>BufferedInputStream/BufferedOutputStream 提供了字节流的缓冲功能；</li><li>BufferedReader/BufferedWriter 提供了字符流的缓冲功能；</li><li>DataInputStream/DataOutputStream 用来将java的简单数据类型和字符串保存为二进制格式，并从二进制格式读取；</li><li>ZipInputStream/ZipOutputStream 提供了字节流的zip格式压缩功能；</li><li>GZIPInputStream/GZIPOutputStream 提供了字节流的gzip格式压缩功能；</li><li>DigestInputStream/DigestOutputStream 提供了字节流的信息摘要功能；</li><li>CipherInputStream/CipherOutputStream 提供了字节流的加密解密功能；</li></ul><a id="more"></a><h2 id="过滤器使用规则"><a href="#过滤器使用规则" class="headerlink" title="过滤器使用规则"></a>过滤器使用规则</h2><p>过滤器可以和其他过滤器、原始流和阅读器/书写器链接使用，但要遵守以下规则：</p><ul><li>过滤器流可以置于原始流或其他过滤器流之上；</li><li>阅读器/书写器可置于原始流、过滤器流或其他阅读器/书写器之上；</li><li>过滤器流不能放在阅读器/书写器之后。</li></ul><p>本文链接: <a href="https://www.lansheng.net.cn/blog/c52cb4ad/">Java IO流 过滤器流</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java IO流 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java网络编程第4版 第1章 基本网络概念</title>
      <link href="/blog/40aaea03/"/>
      <url>/blog/40aaea03/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>网络是几乎可以实时相互发送和接收数据的计算机和其他设备的集合</p><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>网络中的每台机器称为一个节点(node),</p><h2 id="主机"><a href="#主机" class="headerlink" title="主机"></a>主机</h2><p>具有玩呗功能的计算机节点称为主机(host)<br>用节点指代网络的所有设备，主机指代通用的计算机节点</p><h2 id="分组交换网络"><a href="#分组交换网络" class="headerlink" title="分组交换网络"></a>分组交换网络</h2><p>所有的现代计算机网络都是分组交换网络，流经网络的数据被分割成一个个的小块数据，称为包(packet,也称为分组)</p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>协议(protocol)是定义计算机如何通信的一组明确的规则：包括</p><ul><li>地址格式，</li><li>数据如何分包等</li></ul><p>例如超文本传输协议(Hypertext Transfer Protocol,HTTP)定义了Web浏览器如何与服务器通信</p><h2 id="网络的分层"><a href="#网络的分层" class="headerlink" title="网络的分层"></a>网络的分层</h2><p>在理论生，每一层只与紧挨其上和其下的层对话。<br>将网络分层，这样就可以修改甚至替换某一层的软件，只要层与层之间的接口保持不变，就不会影响到其他层。<br><img src="https://i.imgur.com/nNoT9rR.png" alt=""></p><h2 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a>TCP/IP四层模型</h2><p><img src="https://i.imgur.com/sjwPvWI.png" alt=""></p><h3 id="Web浏览器发送请求过程"><a href="#Web浏览器发送请求过程" class="headerlink" title="Web浏览器发送请求过程"></a>Web浏览器发送请求过程</h3><p>例如，当Web浏览器向Web服务器发送获取网页的请求是，浏览器实际上只与本地客户机上的传输层对话。</p><ul><li>传输层将请求分解为TCP片，向数据添加序列号和校验和，让后将请求(处理后的TCP片)传递给本地网际层。</li><li>网际层根据本地网络所需的大小将各个TCP片分成IP数据报。并传递到主机物理网络层，以便通过线缆传输数据。</li><li>主机物理网络层将数字编码为合适特定物理介质的模拟信号，将请求发送到线缆，目的地址的远程系统的主机网络层可以由此读取请求。</li></ul><p>远程系统的主机物理网络层将模拟信号解码为数字数据，将生成的IP数据包传递给服务器的网际层。<br>网网际层简单的检查IP数据报是否被破坏，如果已经分片则重组数据，然后传递给服务器的传输层。<br>服务器的传输层检查所有的数据是否都已经到达，对于丢失或破坏的部分，则要去重传(这个请求实际上将向下通过服务器的网际层，再通过服务器的主机网络层,回到客户端系统，然后再在客户端系统向上返回客户端的传输层，传输层在通过本地网际层和主机网络层重传前面丢失的数据。所有这些对于应用层是完全透明的)，一旦服务器的传输层接收到足够多的连续顺序数据报，就将这些连续的数据报重组写入一个流，由服务器应用层上运行的Web服务器读取。<br>服务器响应这个请求，再通过服务器系统的各个分层发回响应。通过Internet进行传输并分发给Web客户端。</p><p>可以猜到，实际的过程更为错综复杂。主机网络层是最为复杂的，特意地隐藏了很多细节。例如Internet发送的数据在最终目的地之前，完全有可能经过几个路由器以及相应的分层。可能需要从大气中的无线电波转换为铜线缆中的电子信号，在转换到光缆中的光脉冲，然后再反过来，从光脉冲转换到电子信号再到无线电波。不过，90%的情况下Java代码都将在应用层工作，只需要与传输层对话。其他10%的时间会在传输层处理，与应用层或网际层对话。</p><p><strong>主机网络层的复杂性对你是隐藏的，这是分层模型的关键。</strong></p><h2 id="主机网络层"><a href="#主机网络层" class="headerlink" title="主机网络层"></a>主机网络层</h2><p>在基于IP的Internet(Java唯一真正理解的网络)的标准参考模型中，网络中隐藏的部分数据主机网络层(host-to-work layer,也成链路层，数据链路层或网络接口层)<br>主机网络层，定义了一个特定的网络接口(如以太网卡或WiFi天线)如何通过物理连接想本地网络或世界其他地方发送IP数据报</p><p>Java从来都看不到物理层</p><p>需要考虑网络层和物理层的主要与原因是性能</p><h2 id="网际层"><a href="#网际层" class="headerlink" title="网际层"></a>网际层</h2><p>网际层(internet layer)这个是需要你考虑的第一层，在OSI模型中，网际层使用一个更一般的名字，称为网络层(network layer)。<br>网络层协议定义了数据为和字节如何组织为更大的分组，称为<code>包</code>,还定义了寻址机制，不同计算机要按照这个寻址机制查找对方。<br>忘记协议(IP)是世界上使用最广泛的网络层协议，也是java唯一理解的网络层协议。</p><p>数据按包在网际层上传输，这些包称为数据包(datagram)。每个IPv4数据报包含一个长度为20到60个字节的首部，以及一个包含多大65515字节的有效载荷(payload)。实际上，大多数IPv4数据包都小得多，从几十个字节到大约8K字节不等。<br>IPv6数据报包含一个更大的首部，数据可以多大4G字节。<br>下图展示了各个部分再IPv4数据报是如何排列的，所有为和字节都采用big-endian方式，从左至右为最高位到最低位。<br><img src="https://i.imgur.com/4WPEwkR.png" alt=""><br>除了路由和寻址，网际层的第二个作用是支持不同类型的主机网络层相互对话。Internet路由器会完成WiFi和Ethernet,Ethernet和DSL,DSL和光纤往返等协议之间的转换。如果没有网际层或类似的分层，则每个计算机只能与同一类网络上的其他计算进对话。</p><p>网际层负责使用同构协议将异构网络相互连接。</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>原始数据报有一些特点。最显著的缺点是不能保证发送可靠，即使能传送也可能在传输中遭到破坏。首部校验和只能检测首部中的破坏情况，而不能检测数据部分。最后即使数据包能到达目的地儿为被破坏，也不一定会以发送时的顺讯到达。各个数据报可能经过不同路由从源到达目的地。如果数据报A在数据报B之前发送，这并不意味着数据报A会在数据报B之前到达。<br>传输层(transport layer)负责确保各包以发送的顺序接收，并保证没有数据丢失或被破坏，如果丢包，传输层会要求发送方重传这个包。为了实现这个目标IP网络会给每个数据报添加一个附加首部，其中包含有更多信息。<br>传输层上主要有两个协议，一个是传输控制协议(Transmission Control Protocol，TCP)，这是一个开销很高的协议，支持对丢失或破坏的数据进行重传，并按照发送时的顺序进行传送。<br>第二个协议是用户数据报协议(User Dategram Protocol,UDP),它允许接收方法检测被破坏的包，但不保证这些包以正确的顺序传输(或者包有可能根本未传送)。但是UDP通常比TCP快。<br>TCP称为可靠的协议；UDP是不可靠的协议。</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>向用户传送数据的层称为应用层(application layer)。它下面的三层共同定义了数据如何从一台计算机传输到另一台计算机。应用层确定了数据传输后的操作。<br>例如应用层协议如HTTP(用于国际互联网)可以确保Web浏览器将图像显示为图片，而不是一长串数字。<br>你的程序中有关网络的部分大多是在应用层花费时间。<br>除了用于Web的HTTP，还有用于电子邮件的SMTP,POP和IMAP;<br>用于文件传输的FTP,FSP,和TFTP<br>用于文件访问的NFS,<br>用于文件共享的Guntella和BitTorrent;<br>用于语言通话的会话启动协议(Session Initiation Protocol，SIP)和Skype等。<br>此外，你的程序可以在必要时，定义自己的应用层协议</p><p>IP,TCP和UDP<br>IP(网际协议)</p><p>IP设计为允许任意两点之间有多个路由，可以绕过被破坏的路由器实现数据包的路由<br>IP必须是开放的，与平台无关</p><p>TCP置于IP之上，使得连接的两端能够确认接收到的IP包，以及请求重传丢失或被破坏的包。此外TCP允许接收端的包按发送时的顺序重新组合在一起。<br>不过TCP会有很大开销，因此，如果数据的顺序不是特别重要，而且单个包的丢失不会完全破坏数据流，那么有时候可以使用UDP发送数据包，而不需要TCP提供的保证。</p><p>UDP是不可靠的协议，它不能保证包一定到达目的地，也不保证包会以发送时相同的顺序到达。虽然这对于文件传输等用途来说存在问题，但是有些应用程序中，即使丢失部分数据最终用户也不会注意到，对于这种应用程序而言，UDP则完全可以接收。<br>例如，丢失视屏或银屏中的一些数据为不会造成太大的质量下降。如果要等待类似TCP等协议请求重传丢失的数据，那才会是更严重的问题。<br><strong>此外，可以在应用层的UDP数据流中建立纠错码，来解决数据丢失问题</strong></p><p>可以在IP之上运行很多其他协议。最常使用的是ICMP，即网际控制消息协议(Internet Control Message Protocol),它使用原始IP数据报在主机之间传递错误消息。使用这个协议最著名的应用是ping程序。Java不支持ICMP,也不允许发送原始IP数据报(而值运行发送TCP片或UDP数据报)</p><p>Java支持的协议只有TCP和UDP,如ICMP,IGMP，ARP,RARP,RSVP和其他协议在Java程序中都只能通过链接到原生代码来实现。</p><h2 id="IP地址和域名"><a href="#IP地址和域名" class="headerlink" title="IP地址和域名"></a>IP地址和域名</h2><p>作为Java程序员，你不需要担心IP的内部工作原理，但你必须了解寻址。IPv4网络中的每台计算机都由有一个4字节的数字来标识。一般写为点分四段格式，如<code>199.1.32.90</code>,这4个数中，每个数都是一个无符号字节，范围从0到255。IPv4网络中的每台计算机都有唯一的4字节地址。当数据通过网络传输时，包的首部会包括发往的机器地址(目的地址)和发送这个包的机器地址(源地址)。</p><p>沿途的路由器通过检查目的地址来发送数据包的最佳路由。IP包中包括源地址是为了让接收方知道要向谁回复。</p><p>IP地址不够用，现在正在想IPv6慢慢的过渡<br>IPv6使用16个字节的地址，这样就能有足够的地址来表示每个人，每天计算机，甚至是地球上的每一个设备。</p><h3 id="IPv6地址格式"><a href="#IPv6地址格式" class="headerlink" title="IPv6地址格式:"></a>IPv6地址格式:</h3><p><strong>IPv6地址通常为冒号分割的8个区块</strong>，每个区块是<code>4</code>个<code>16</code>进制数字，如<code>FEDC:BA98:7654:3210:FEDC:BA98:7654:3210</code>。前导的0不需要写，两个冒号表示多个0区块。例如<code>FEDC:0000:0000:0000:00DC:0000:7076:0010</code>可以写为更紧凑的形式，如：<code>FEDC::DC:0:7076:10</code></p><p>在IPv6和IPv4的混合网络中，IPv6地址的最后4个字节有时候写为IPv4的点分四段地址。例如,<code>FEDC:BA98:7654:3210:FEDC:BA98:7654:3210</code>可以写为：<code>FEDC:BA98:7654:3210:118.84.50.16</code></p><p>IPv6只在Java1.4以及以后版本中支持。Java1.3及以前版本只支持4字节地址。</p><h3 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h3><p>虽然计算机可以轻松的处理数字，但是人来对记忆数字不在行。所以开发了域名系统(Domain Name System,DNS)，用来将人类易于记忆的主机名(例如：<code>github.com</code>)转换为数字Internert地址(例如<code>52.74.223.119</code>)。当Java程序访问网络时，它们需要同时处理数字地址和响应的主机名。这些方法由<code>java.net.InetAddress</code>类提供。</p><p>有些计算机(尤其是服务器)有固定的地址。也有些其他计算机(特别是局域网和无线连接上的客户端)可能每次启动时会分配到不同的地址，这通常有DHCP服务器提供。</p><p><strong>你只需要记住IP地址可能会随着时间而改变，写代码时不要假定系统有相同的IP地址。</strong></p><h3 id="不可路由的地址"><a href="#不可路由的地址" class="headerlink" title="不可路由的地址"></a>不可路由的地址</h3><p>有一些地址区块和模式很特殊，以<code>10.</code>，<code>172.16.</code>，<code>172.31.</code>，和<code>192.168.</code>开头的所有IPv4地址都未分配。这些地址可以在内部网络使用，但是使用这些地址的主机不允许加入全球<code>Internet</code>。不过这些不可路由的地址对于建立Internet上看不到的专用网会很有用。</p><h3 id="本地回送地址"><a href="#本地回送地址" class="headerlink" title="本地回送地址"></a>本地回送地址</h3><p>以127开头的IPv4地址(最常见的是<code>127.0.0.1</code>)总是表示本地回送地址(<code>local loopback address</code>)。这就是说，这些地址总是指向本地计算机，而不论你在哪个计算机上运行。这个地址的主机名通常是<code>localhost</code>。</p><h3 id="广播地址"><a href="#广播地址" class="headerlink" title="广播地址"></a>广播地址</h3><p><code>4</code>个字节都使用相同数字的IPv4地址(如<code>255.255.255.255</code>)是一个广播地址。发送到这个地址的包将由本地网络多行的所有节点接收，但不能超越这个本地网络。例如,一个临时使用的客户端(如笔记本电脑)启动时，他会想<code>255.255.255.255</code>发送一个特定的消息，查找本地<code>DHCP</code>服务器。这个网络上的所有节点都接收到这个包，不过只有<code>DHCP</code>服务器做出相应。具体地，它会想这个笔记本电脑发送本地网络配置的有关信息，包括这个笔记本电脑在余下的会话中要使用的<code>IP</code>地址以及用来解析主机名的<code>DNS</code>服务器的地址。</p><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>如果每台计算机每次只做一件事情，那么地址可能就足够了。但是，现代计算机同时要做很多不同的事情。电子邮件需要与FTP请求分开，而FTP又要与Web业务流分开。<br>这是通过端口(port)来实现的。每台有IP地址的计算机都有几千个逻辑端口，确切的讲，每个传输层洗衣有65535个端口。这些知识计算机内存中的抽象，不表示任何物理实体，与USB端口不同。每个端口都是由1到65535之间的一个数字标识。每个端口可以分配给一个特定的服务。<br>例如，Web层协议HTTP一般使用80端口，我们说Web服务器在端口80监听(listen)入站连接(incomming connection)。<br>当数据发送到特定IP地址的某个机器上的Web服务器时,它还会发送到该机器的特定端口(通常是80端口)。<br>接收方检查接口收到的每个包，将数据发送给监听这个端口的程序。各种通信业务流就是这样区分的。<br>1到1023的端口号保留给已知的服务，如finger,FTP，HTTP和IMAP.在UNIX系统上包括Linux,这有root用户运行的程序来可以接收这些端口的数据。但是所有的程序都可以想这些端口发送数据。<br>在Windows上，所有的程序都可以使用这些端口，不需要专门的特权。</p><table><thead><tr><th style="text-align:left">协议名</th><th style="text-align:left">端口</th><th style="text-align:left">使用的传输协议</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left"><code>echo</code></td><td style="text-align:left">7</td><td style="text-align:left">TCP/UDP</td><td style="text-align:left">echo是一个测试协议，通过回显另一台机器的输入来验证两台机器是否连接成功</td></tr><tr><td style="text-align:left"><code>discard</code></td><td style="text-align:left">9</td><td style="text-align:left">TCP/UDP</td><td style="text-align:left">discard是一种用处不太大的协议，它将忽略服务器收到的所有数据</td></tr><tr><td style="text-align:left"><code>daytime</code></td><td style="text-align:left">13</td><td style="text-align:left">TCP/UDP</td><td style="text-align:left">提供服务器当前时间的ASCII表示</td></tr><tr><td style="text-align:left"><code>FTP数据</code></td><td style="text-align:left">20</td><td style="text-align:left">TCP</td><td style="text-align:left">FTP使用两个已知端口，这个20端口用来传输文件</td></tr><tr><td style="text-align:left"><code>FTP</code></td><td style="text-align:left">21</td><td style="text-align:left">TCP</td><td style="text-align:left">这个端口用来发送FTP命令，如put和get</td></tr><tr><td style="text-align:left"><code>SSH</code></td><td style="text-align:left">22</td><td style="text-align:left">TCP</td><td style="text-align:left">用于加密的远程登录</td></tr><tr><td style="text-align:left"><code>Telnet</code></td><td style="text-align:left">23</td><td style="text-align:left">TCP</td><td style="text-align:left">用于交互式远程命令行会话</td></tr><tr><td style="text-align:left"><code>smtp</code></td><td style="text-align:left">25</td><td style="text-align:left">TCP</td><td style="text-align:left">简单邮件传输协议(Simple Mail Transfer Protocol)用来在机器间发送邮件</td></tr><tr><td style="text-align:left"><code>time</code></td><td style="text-align:left">37</td><td style="text-align:left">TCP/UDP</td><td style="text-align:left">时间服务器返回服务器从1990年1月1日0:0:0之后过去的秒数，这是一个4字节有符号big-endain整数</td></tr><tr><td style="text-align:left"><code>whois</code></td><td style="text-align:left">43</td><td style="text-align:left">TCP</td><td style="text-align:left">用于Internet网络管理的简单目录服务</td></tr><tr><td style="text-align:left"><code>finger</code></td><td style="text-align:left">79</td><td style="text-align:left">TCP</td><td style="text-align:left">返回本地系统中用户(或多个用户)有关信息的服务</td></tr><tr><td style="text-align:left"><code>HTTP</code></td><td style="text-align:left">80</td><td style="text-align:left">TCP</td><td style="text-align:left">国际互联网的低层协议</td></tr><tr><td style="text-align:left"><code>POP3</code></td><td style="text-align:left">110</td><td style="text-align:left">TCP</td><td style="text-align:left">邮局协议版本3(Post Office Protocol Version 3)协议可以将积累的电子邮件从主机传输到偶然连接的客户端</td></tr><tr><td style="text-align:left"><code>NNTP</code></td><td style="text-align:left">119</td><td style="text-align:left">TCP</td><td style="text-align:left">Usenet新闻传输，正式的说无法为”网络新闻传输协议”(Network News Transfer Protocol)</td></tr><tr><td style="text-align:left"><code>IMAP</code></td><td style="text-align:left">143</td><td style="text-align:left">TCP</td><td style="text-align:left">Internet消息访问协议(Internet Message Access Protocol)是访问存储在服务器上的邮件的协议</td></tr><tr><td style="text-align:left"><code>dict</code></td><td style="text-align:left">2628</td><td style="text-align:left">TCP</td><td style="text-align:left">提供单词定义的UTF-8编码的字典服务</td></tr></tbody></table><h2 id="Internet"><a href="#Internet" class="headerlink" title="Internet"></a>Internet</h2><p>Internet是世界上最大的基于IP的网络。Internet不属于任何人(不过它的各个部分有响应的所有者)。它只是约定以只用标准方式相互对话的一个非常大的计算机集合。<br><code>Internet</code>不是唯一的基于IP的网络，但却是最大的一个。其他的IP网络成为<code>internet</code>(首字母<code>i</code>小写)</p><p>为确保Internet上不同网络的主机可以相互通信，就需要遵守一些对纯粹内部<code>internet</code>不适用的规则。更重要的规则是要处理不同组织，公司和个人地址的分配。<br>如果每个人都随意地挑选Internet地址，那么有相同地址的不同计算机出现在Internet上立即就会引起冲突。</p><h2 id="Internet地址分块"><a href="#Internet地址分块" class="headerlink" title="Internet地址分块"></a>Internet地址分块</h2><p>为了避免这个问题，区域Internet注册机构为Internet服务提供商(ISP)分配IPv4地址块。当公式或组织要建立一个基于IP的网络连接到Internet时，它们的ISP会给她们分配一个地址块。每个地址块有固定的前缀。例如如果前缀是<code>216.254.85</code>，那么本地网络可以使用从216.254.85.0到216.254.85.255的地址。由于这个块固定了前24位，所以称为<code>/24</code>。<br>同理：<br><code>/23</code>指定了前<code>23</code>位,而留出9位表示总共<code>2^9=512</code>个本机IP地址。<br>“/30”子网(最小的子网)指定了子网中IP地址的前30位，留出2位表示2^2=4个本地IP地址。</p><p>不过，所有块中最低地址用于表示网络本身，最高地址是这个网络的一个广播地址。所以可用地址比分到的地址要少两个。</p><p>那么”<code>/30</code>“中的四个本地IP地址中，除去一个表示网络本身的最低地址，除去一个用于广播的最高地址，就只剩下两个可用自由分配的地址了。</p><h2 id="网络地址转换"><a href="#网络地址转换" class="headerlink" title="网络地址转换"></a>网络地址转换</h2><p>由于IP地址越来越稀缺，而对原始IP地址的需求越来越大，如今大多数网络都使用了网络地址转换(Network Address Translation,NAT)。<br>基于NAT的网络中，大多数阶段只有不可路由的本地地址，这些地址可能从<code>10.x.x.x</code>,<code>172.16.x.x</code>到<code>172.31.x.x</code>或<code>192.168.x.x</code>选择。<br>例如，我的公寓里大学有十来个IP节点，大家会公用一个外部可见的IP(<code>216.254.85.72</code>)地址。我现在用的这个计算机的IP地址是<code>192.168.1.5</code>，不过在你的网络中<code>192.168.1.5</code>这个地址可能指示的是一个完全不同的主机(如果存在这样一个主机)。<br>另外，你也无法使用<code>192.168.1.5</code>发送数据到我的计算机。</p><p>实际上你必须把数据发送到到<code>216.254.85.72</code>这个地址(即使如此，只有当为把NAT路由器配置为<code>将入站连接传递到`</code>192.168.1.5`时,数据才会真正送达我的计算机)。</p><p>路由器会监视出站和入站连接，调整IP包中地址。例如，我向外网发数据，对于这些出站的包，路由器将这个包的源地址该为路由器的外部地址(在我这个网络是:<code>2016.254.85.72</code>)。<br>而外网发来的这些入站的包，路由器将目的地址改为一个本地地址。如<code>192.168.1.12</code>。<br>那么路由器如何记录哪些连接来自或发往那台内部计算机,这对于Java程序员并不是特别重要。只要正确配置了你的机器，这个过程基本上<br>就是透明的。<strong>你只需要记住外部地址和内部地址有可能不同就行了。</strong><br>感觉作者这里没有说清楚，说了一半的感觉</p><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><p>位于Internet和本地网络之间的一些硬件和软件会检查所有进出的数据，以保证其合法性。这就称为防火墙(firewall)。</p><p><strong>防火墙要负责检查传入或传出其网络结构的各个包，根据一组规则接收或拒绝这些包。</strong></p><p><strong>过滤通常是基于地址和端口的。</strong>例如，多有来自C类网络<code>193.28.25.x</code>的通信会被拒绝，因为你过去遭受过这个网站中黑客的攻击。</p><p>出站的SSH连接可能是允许的，但入站的SSH连接不允许，端口<code>80</code>(Web)的入站连接时允许的，但只限于公司的Web服务器。</p><p><strong>更智能的防火墙会查看包的内容，确定是否接收或拒绝</strong>。防火墙具体的配置(哪些数据包允许通过而哪些不允许通过)取决于网站的安全需求。Java与防火墙没有太大关系，除非防火墙总是妨碍你的事。</p><h2 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h2><blockquote><p>代理服务器(proxy server)与防火墙有关。如果说防火墙会阻止一个网络上的主机与外界直接建立连接，那么代理服务器就起到中间人的作用。</p><p>如果防火墙阻止一个机器连接外部网络，这个机器可以请求本地代理服务器的Web页面，而不是直接请求远程Web服务器的Web页面。<br>然后代理服务器会请求远程Web服务器的页面，将远程Web服务器的响应转发给最初发出请求的机器。</p><p>代理还可以用于FTP服务器和其他连接。</p><p>使用代理服务器的安全优势之一是外部主机只能看到代理服务器，而不会知道内部机器的主机名和IP地址，这样就是的攻击内部网络更加困难。</p></blockquote><p>个人绝对代理服务器就好比黄牛，通过访问代理服务器来访问外网，就跟我们跟黄牛买票差不多。<br>防火墙一般工作与传输层或网际层，而代理服务器通常工作与应用层。代理服务器对一些应用层协议非常了解，如HTTP和FTP(一个值得注意的例外是SOCKS代理服务器，Socks服务器工作与传输层，可以代理所有的TCP和UDP连接，而不考虑应用层协议)</p><p>可以检查通过代理服务的包，确保其中包含适当类型的数据。<br>下图展示了代理服务器在分层模型中的位置：<br><img src="https://i.imgur.com/0lDn1pg.png" alt=""></p><p>只要所有对Internet的访问都通过代理服务器转发，那么访问就可以收到严格的控制。<br>例如，公司可能选择组织访问<a href="http://www.playboy.com,但允许访问www.microsoft.com。一些公式允许入站FTP，但不允许出站FTP。这样公司的机密数据就不会容易的被非法带出公司。" target="_blank" rel="noopener">www.playboy.com,但允许访问www.microsoft.com。一些公式允许入站FTP，但不允许出站FTP。这样公司的机密数据就不会容易的被非法带出公司。</a></p><p>其他公式已经开始使用代理服务器来跟踪员工的Web使用情况，这样可以看到是谁在利用Internet获取技术支持，是谁在利用它找私人朋友。</p><h3 id="实现本地缓存"><a href="#实现本地缓存" class="headerlink" title="实现本地缓存"></a>实现本地缓存</h3><p>代理服务器还可以用来实现本地缓存(local caching)。当请求Web服务器的文件时，代理服务器首先查看此文件是否已经在缓存中。如果文件在缓存中，那么代理服务器将提供缓存中的文件，而不是Internet上的文件。如果这个文件不在缓存中，那么代理服务器将从Internet中获取此文件，然后转发给请求方，并将该文件存储在缓存中，供下次请求使用。这种机制可以显著的降低Internet连接的负载，大大提高响应时间。</p><p>例如，美国在线(America Online)<code>aol.com</code>运行着世界上最大的代理服务器<code>场</code>之一，代理服务器可以加快向用户传输数据的速度。如果你查看Web服务器的日志文件，可能会发现<code>aol.com</code>域客户的一些点击记录，但不想你想象的那么多，要知道AOL用户已经超过300万。按理说，这么多人访问，点击记录应该很多才是。<br>这是因为当用户访问时，AOL代理服务器优先从其缓存中提供了许多页面，而不是为每位用户都重新请求页面。很多其他大的ISP也是这样做的。</p><h3 id="代理服务器的缺点"><a href="#代理服务器的缺点" class="headerlink" title="代理服务器的缺点"></a>代理服务器的缺点</h3><p>代理服务器最大的问题在于它无法应对所有协议。通常已有的协议如HTTP,FTP和SMTP允许通过，而新的协议如BitTorrent则可能不允许通过。在快速改变的Internet世界，这是一个很大的缺点，对于Java程序员而言这是一个缺点，因为他限制了定制协议的有效性。</p><p>使用Java可以很容易地创建为你的应用而优化的新协议，这么做通常也很有用。但是，没有代理服务器能够理解你这些独一无二的协议。<br>因此，有些开发人员开始通过HTTP来接入他们定制的协议，最著名的是SOAP。</p><h2 id="客户-服务器模型"><a href="#客户-服务器模型" class="headerlink" title="客户/服务器模型"></a>客户/服务器模型</h2><p>大多数现代网络编程都基于<code>客户/服务器模型</code>。</p><h3 id="客户端和服务器端功能分解"><a href="#客户端和服务器端功能分解" class="headerlink" title="客户端和服务器端功能分解"></a>客户端和服务器端功能分解</h3><ul><li>客户/服务器应用程序一般讲大量数据存储在昂贵的高性能服务器或服务器云上。</li><li>而大多数程序逻辑和用户界面有客户端软件处理，这些客户端软件运行在相对便宜的个人计算机上。</li></ul><p>在多数情况下，服务器主要发送数据，而客户端主要接收数据，但是很少有一个程序只发送或只接受数据。</p><p>更有可能的是客户端发起对话，而服务器等待客户端与它开始对话。在有些情况下，同一个程序会同时作为客户端和服务器，下图展示了这两种可能性。<br><img src="https://i.imgur.com/UaS3Rtg.png" alt=""></p><blockquote><p>Internet上最流行的客户/服务器系统是Web,Web服务器(如Apache)响应Web客户端(如Firefox)的请求。数据存储在Web服务器上，会发送给请求数据的客户端。除了最初的页面请求，几乎所有数据都从服务器想客户端传输，而不是从客户端传输到服务器。</p><p>FTP是符合客户端/服务器模型的更古老的服务。FTP使用不同的应用协议和不同的软件，但依然分为<strong>发送文件的FTP服务器和接收文件的FTP客户端。</strong>人们通常使用FTP从客户端向服务器上传文件，所以很难讲数据传输是一个方向传输的。但是要说FTP客户端发起连接而FTP服务器进行响应，这仍然是正确的。</p></blockquote><h3 id="对等连接"><a href="#对等连接" class="headerlink" title="对等连接"></a>对等连接</h3><p>不是所有应用程序都简单的符合客户端/服务器模型。例如，在网络游戏中，看起来两个玩家都能大致相同的来回发送数据(公平游戏中)。这种连接称为<code>对等</code>(peer-to-peer)连接。</p><h4 id="对等网路典型例子"><a href="#对等网路典型例子" class="headerlink" title="对等网路典型例子"></a>对等网路典型例子</h4><p>电话系统就是典型的对等网络例子,每部电话都可以呼叫另外的电话，或者被另外的电话呼叫。<br>Java在其核心网络API中没有显示的对等通信。不过，引用程序可以很容易的通过集中方式提供对等通信，最常见的是同时所谓服务器和客户端。另外，对等端可以通过中间服务器程序相互通信，这个程序将程序从一端转发到其他对等端。这样就很好的解决了两个对等端如何发现对方的问题。</p><h2 id="Internet标准"><a href="#Internet标准" class="headerlink" title="Internet标准"></a>Internet标准</h2><p>世界上有很多标准组织，但是关于应用层网络编程的协议大多数标准都是由下面两个组织制定的，它们分别是IETF(Internet Engineering Task Forse,Internet工程任务组)和W3C(World Wide Web Consortium,国际互联网协会)。</p><p>IETF是不太正式的民间团体,向所有感兴趣参与的团队开放。它的标准是根据”多数人的意见和正在运行的代码”做出决定,倾向于跟踪而不是引导实现。IETF(Internet工程任务组)标准包括TCP/IP,MIME和SMTP。</p><p>与IETF不同W3C是厂商组织，由缴纳会费的成员公司控制，明确拒绝个人参与。在极大程度上，W3C会尽力在实现之前定义标准，W3C标准包括HTTP，HTML和XML。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/40aaea03/">java网络编程第4版 第1章 基本网络概念</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> java网络编程第四版 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>匹配IP地址</title>
      <link href="/blog/9e1b6b70/"/>
      <url>/blog/9e1b6b70/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>正则表达式匹配IP地址</p><blockquote><p>正则表达式，又称规则表达式。接下来通过本文给大家介绍正则表达式匹配<code>IP</code>的表达式，非常不错，具有参考借鉴价值，需要的的朋友参考下吧</p></blockquote><p>这里给大家详细讲解一下一个匹配IP地址的正则表达式，<br>有关正则方面的知识，会在详细的讲解中提到。<br>在讲解之前，我先给大家介绍一下，ip地址的生成规则。<br>IP地址，是由32位数字二进制转为四个十进制的字符串组成。<br>怎么转化？下面讲解：</p><p>二进制：<code>11111111111111111111111111111111</code><br>分为四部分：<code>11111111.11111111.11111111.11111111</code><br>转化：<code>2^7+2^6+2^5+2^4+2^3+2^2+2^1+2^0=255</code><br>转为十进制范围：<code>0~255.0~255.0~255.0~255</code><br>这就是<code>IP</code>地址的范围。<br>根据这个生成<code>IP</code>的规则和范围，我们可以用正则表达式来匹配出<code>IP</code>地址，但怎么匹配呢？各人有各人的方法，这里我讲解一下我的思路。</p><p>根据IP地址的字符串规律，我把匹配IP地址的表达式分为两部分来考虑。<br>第一部分：匹配3个<code>0~255.</code>（注意后面的一个点）<br>第二部分：匹配最后的数字<code>0~255</code><br>也就是说，<strong>先匹配出<code>0~255.</code>（注意后面的一个点） 这个字符串，然后重复匹配3次，然后再匹配最后的数字部分0~255</strong>。这就是我匹配<code>IP</code>地址的思路。</p><p>首先，我要提一下<strong>，正则是没有办法做数字运算的</strong>，所以，我们无法用数字运算的方式筛选出IP的数字范围。既然没法用数字运算的方式筛选出IP的数字范围，那么我们应该用什么其他方式来筛选这个数字范围呢？我的思路是分组讨论，然后再把这些分组合并起来组成IP的数字范围。</p><h2 id="匹配一个合法的数字"><a href="#匹配一个合法的数字" class="headerlink" title="匹配一个合法的数字"></a>匹配一个合法的数字</h2><h3 id="三位数的情况："><a href="#三位数的情况：" class="headerlink" title="三位数的情况："></a>三位数的情况：</h3><ul><li>假设百位是<code>2</code>，那么根据<code>IP</code>数字的范围规则，这里又要分为两种情况，为什么？你想想，最大数字是<code>255</code>，当十位数为<code>5</code>时，个位数最大只能为<code>5</code>是吧？(<code>250-255</code>).而当十位数为<code>0到4</code>时，个位数可以是任意数字对吧？(<code>200-249</code>)<br>所以，这里的两种情况分别为：<ul><li><code>2[0-4][0-9]</code></li><li><code>25[0-5]</code></li></ul></li><li>假设百位数是<code>1</code>，那么这个数字的范围为<code>100-199</code>,对应正则表达式就为<code>1[0-9][0-9]</code>。这个应该不难理解，就不解释。</li></ul><h3 id="两位数的情况"><a href="#两位数的情况" class="headerlink" title="两位数的情况"></a>两位数的情况</h3><p>分析完了三位数数的情况，接下来就是两数的情况了，假如是两位数，那么十位数的前面第一个数不能为零是吧？也就是范围为<code>10-99</code>(<code>10,11...,19,20,...,99</code>),对应的正则表达式为<code>[1-9][0-9]</code></p><h3 id="一位数的情况"><a href="#一位数的情况" class="headerlink" title="一位数的情况"></a>一位数的情况</h3><p>剩下的就是个位数的情况了，个位数的情况，大家应该很容易得出结论，就是：<code>[0-9]</code>。</p><p>四种情况分析下来，我们得出了IP数字的范围分组为：</p><ul><li><code>25[0-5]</code></li><li><code>2[0-4][0-9]</code></li><li><code>1[0-9][0-9]</code></li><li><code>[1-9][0-9]</code></li><li><code>[0-9]</code></li></ul><h3 id="匹配一个合法的数字-1"><a href="#匹配一个合法的数字-1" class="headerlink" title="匹配一个合法的数字"></a>匹配一个合法的数字</h3><p>所以匹配IPv4中一个和法的数组的正则表达式为<code>(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])</code></p><h3 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h3><ul><li>可以把两位数<code>[1-9][0-9]</code>和一位数的情况<code>[0-9]</code>合并，写为<code>[1-9]?[0-9]</code>.</li><li>用简写<code>\d</code>替代<code>[0-9]</code></li></ul><p>所以优化后的一个合法的数字的正则表达式为：<code>(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)</code></p><h2 id="匹配一个合法的数字和点号三次-："><a href="#匹配一个合法的数字和点号三次-：" class="headerlink" title="匹配一个合法的数字和点号三次 ##："></a>匹配一个合法的数字和点号三次 ##：</h2><p>点号要转义为<code>\.</code>,<br><code>((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}</code></p><h2 id="最终的表达式："><a href="#最终的表达式：" class="headerlink" title="最终的表达式："></a>最终的表达式：</h2><p>三组数字和点号之后，后面还有一组数字。这样的话综合起来就是：<br><code>((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)</code></p><h3 id="优化：-1"><a href="#优化：-1" class="headerlink" title="优化："></a>优化：</h3><p>上面我们使用了括号<code>(...)</code>来限定量词和多选的作用范围。但是这样也会在匹配的时候进行捕获，捕获的话会造成不必要的开销，这里使用<code>(?:...)</code>来限定，这样省去捕获分组的开销。<br><code>(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)</code><br>测试：<br>合法的IP地址：</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/9e1b6b70/">匹配IP地址</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java 正则表达式 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>通过FTP快速传输文件到手机</title>
      <link href="/blog/5b873e00/"/>
      <url>/blog/5b873e00/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><h2 id="手机上安装了ES文件浏览器"><a href="#手机上安装了ES文件浏览器" class="headerlink" title="手机上安装了ES文件浏览器"></a>手机上安装了ES文件浏览器</h2><p>在手机下载安装APP“ES文件管理器“（其他文件管理器只要具有“远程管理器”功能的也可以)</p><h2 id="ES文件浏览器中的设置"><a href="#ES文件浏览器中的设置" class="headerlink" title="ES文件浏览器中的设置"></a>ES文件浏览器中的设置</h2><ul><li><p><strong>首先将手机连上wifi（和电脑在同一个局域网)，或者直接连接到电脑开的热点</strong></p></li><li><p><strong>打开APP后点左上角的菜单。</strong></p><center><img src="https://i.imgur.com/xRfQj57.jpg" width="50%"></center></li><li><strong>点“网络”项，</strong><center><img src="https://i.imgur.com/6J2YI8u.jpg" width="50%"></center></li><li><strong>然后点“<code>远程管理器</code>”</strong></li></ul><p>这里解释一下为什么不用 “局域网” 和 “FTP” ，这两种方法也可以实现无线传输文件的功能，但使用局域网可能会由于权限而导致拒绝访问的问题，对普通用户来说解决这个问题有点头疼。而”FTP”和”远程管理器”的其实都是使用的FTP协议，区别在于”FTP”是手机做为FTP客户端，电脑上需要安装一个FTP服务器软件。“远程管理器”则手机是FTP服务端，电脑上安装的是FTP客户端，本文使用远程管理器，相对来说在电脑安装FTP客户端软件更简单.</p><center><img src="https://i.imgur.com/lC3E8nU.jpg" width="50%"></center><ul><li><strong>点“<code>打开</code>“即可看到主机地址和端口号，</strong></li></ul><center><img src="https://i.imgur.com/nHUh2Zg.jpg" width="50%"></center><ul><li><strong>把这个记下来，在电脑上要使用，如图</strong></li></ul><center><img src="https://i.imgur.com/ZFBIfTs.jpg" width="50%"></center><ul><li><strong>按下Win+E快捷键，打开文件资源管理器输入这个地址</strong></li></ul><center><img src="https://i.imgur.com/NMcbvNi.png" width="80%"></center><ul><li><strong>按下回车，就可进入手机中的目录啦</strong><br><img src="https://i.imgur.com/BziPLyj.png" alt=""><h2 id="传输文件"><a href="#传输文件" class="headerlink" title="传输文件"></a>传输文件</h2></li></ul><p>进入手机目录，可以很方便的在手机和电脑之间互相传输(复制粘贴)文件,这种方式比蓝牙快的多了。</p><ul><li>从电脑中复制文件：</li></ul><p><img src="https://i.imgur.com/UnByZow.png" alt=""></p><ul><li>粘贴到手机中：</li></ul><p><img src="https://i.imgur.com/WnZDMj7.png" alt=""></p><ul><li>很快就传输好啦：</li></ul><p><img src="https://i.imgur.com/zsHwKNN.png" alt=""></p><ul><li>复制成功：</li></ul><p><img src="https://i.imgur.com/QdLVFRl.png" alt=""></p><h2 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h2><ul><li>最后再ES文件浏览器中关闭连接即可：</li></ul><center><img src="https://i.imgur.com/fmOTpnh.jpg" width="50%"></center><p>参考：<a href="http://baijiahao.baidu.com/s?id=1596833763494677229&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">http://baijiahao.baidu.com/s?id=1596833763494677229&amp;wfr=spider&amp;for=pc</a></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/5b873e00/">通过FTP快速传输文件到手机</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
          <category> Windows相关 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>DatagramSocket类</title>
      <link href="/blog/c1fee13e/"/>
      <url>/blog/c1fee13e/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>DatagramSocket()</code></td><td style="text-align:left">构造数据报套接字并将其绑定到本地主机上任何可用的端口。</td></tr><tr><td style="text-align:left"><code>DatagramSocket(int port)</code></td><td style="text-align:left">创建数据报套接字并将其绑定到本地主机上的指定端口。</td></tr><tr><td style="text-align:left"><code>DatagramSocket(int port, InetAddress laddr)</code></td><td style="text-align:left">创建数据报套接字，将其绑定到指定的IP地址</td></tr><tr><td style="text-align:left"><code>DatagramSocket(SocketAddress bindaddr)</code></td><td style="text-align:left">创建数据报套接字，将其绑定到指定的本地套接字地址。</td></tr><tr><td style="text-align:left"><code>protected DatagramSocket(DatagramSocketImpl impl)</code></td><td style="text-align:left">创建带有指定 DatagramSocketImpl 的未绑定数据报套接字。</td></tr></tbody></table><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>void bind(SocketAddress addr)</code></td><td style="text-align:left">将此 DatagramSocket 绑定到特定的地址和端口。</td></tr><tr><td style="text-align:left"><code>void close()</code></td><td style="text-align:left">关闭此数据报套接字。</td></tr><tr><td style="text-align:left"><code>void connect(InetAddress address, int port)</code></td><td style="text-align:left">将套接字连接到此套接字的远程地址。</td></tr><tr><td style="text-align:left"><code>void connect(SocketAddress addr)</code></td><td style="text-align:left">将此套接字连接到远程套接字地址（IP 地址 + 端口号）。</td></tr><tr><td style="text-align:left"><code>void disconnect()</code></td><td style="text-align:left">断开套接字的连接。</td></tr><tr><td style="text-align:left"><code>boolean getBroadcast()</code></td><td style="text-align:left">检测是否启用了 SO_BROADCAST。</td></tr><tr><td style="text-align:left"><code>DatagramChannel getChannel()</code></td><td style="text-align:left">返回与此数据报套接字关联的唯一 DatagramChannel 对象（如果有）。</td></tr><tr><td style="text-align:left"><code>InetAddress getInetAddress()</code></td><td style="text-align:left">返回此套接字连接的地址。</td></tr><tr><td style="text-align:left"><code>InetAddress getLocalAddress()</code></td><td style="text-align:left">获取套接字绑定的本地地址。</td></tr><tr><td style="text-align:left"><code>int getLocalPort()</code></td><td style="text-align:left">返回此套接字绑定的本地主机上的端口号。</td></tr><tr><td style="text-align:left"><code>SocketAddress getLocalSocketAddress()</code></td><td style="text-align:left">返回此套接字绑定的端点的地址，如果尚未绑定则返回 null。</td></tr><tr><td style="text-align:left"><code>int getPort()</code></td><td style="text-align:left">返回此套接字的端口。</td></tr><tr><td style="text-align:left"><code>int getReceiveBufferSize()</code></td><td style="text-align:left">获取此 DatagramSocket 的 SO_RCVBUF 选项的值，该值是平台在 DatagramSocket 上输入时使用的缓冲区大小。</td></tr><tr><td style="text-align:left"><code>SocketAddress getRemoteSocketAddress()</code></td><td style="text-align:left">返回此套接字连接的端点的地址，如果未连接则返回 null。</td></tr><tr><td style="text-align:left"><code>boolean getReuseAddress()</code></td><td style="text-align:left">检测是否启用了 SO_REUSEADDR。</td></tr><tr><td style="text-align:left"><code>int getSendBufferSize()</code></td><td style="text-align:left">获取此 DatagramSocket 的 SO_SNDBUF 选项的值，该值是平台在 DatagramSocket 上输出时使用的缓冲区大小。</td></tr><tr><td style="text-align:left"><code>int getSoTimeout()</code></td><td style="text-align:left">获取 SO_TIMEOUT 的设置。</td></tr><tr><td style="text-align:left"><code>int getTrafficClass()</code></td><td style="text-align:left">为从此 DatagramSocket 上发送的包获取 IP 数据报头中的流量类别或服务类型。</td></tr><tr><td style="text-align:left"><code>boolean isBound()</code></td><td style="text-align:left">返回套接字的绑定状态。</td></tr><tr><td style="text-align:left"><code>boolean isClosed()</code></td><td style="text-align:left">返回是否关闭了套接字。</td></tr><tr><td style="text-align:left"><code>boolean isConnected()</code></td><td style="text-align:left">返回套接字的连接状态。</td></tr><tr><td style="text-align:left"><code>void receive(DatagramPacket p)</code></td><td style="text-align:left">从此套接字接收数据报包。</td></tr><tr><td style="text-align:left"><code>void send(DatagramPacket p)</code></td><td style="text-align:left">从此套接字发送数据报包。</td></tr><tr><td style="text-align:left"><code>void setBroadcast(boolean on)</code></td><td style="text-align:left">启用/禁用 SO_BROADCAST。</td></tr><tr><td style="text-align:left"><code>static void setDatagramSocketImplFactory(DatagramSocketImplFactory fac)</code></td><td style="text-align:left">为应用程序设置数据报套接字实现工厂。</td></tr><tr><td style="text-align:left"><code>void setReceiveBufferSize(int size)</code></td><td style="text-align:left">将此 DatagramSocket 的 SO_RCVBUF 选项设置为指定的值。</td></tr><tr><td style="text-align:left"><code>void setReuseAddress(boolean on)</code></td><td style="text-align:left">启用/禁用 SO_REUSEADDR 套接字选项。</td></tr><tr><td style="text-align:left"><code>void setSendBufferSize(int size)</code></td><td style="text-align:left">将此 DatagramSocket 的 SO_SNDBUF 选项设置为指定的值。</td></tr><tr><td style="text-align:left"><code>void setSoTimeout(int timeout)</code></td><td style="text-align:left">启用/禁用带有指定超时值的 SO_TIMEOUT，以毫秒为单位。</td></tr><tr><td style="text-align:left"><code>void setTrafficClass(int tc)</code></td><td style="text-align:left">为从此 DatagramSocket 上发送的数据报在 IP 数据报头中设置流量类别 (traffic class) 或服务类型八位组 (type-of-service octet)。</td></tr></tbody></table><p>本文链接: <a href="https://www.lansheng.net.cn/blog/c1fee13e/">DatagramSocket类</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> java 网络编程 </category>
          
          <category> API </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>7网络协议</title>
      <link href="/blog/12786bb5/"/>
      <url>/blog/12786bb5/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>参考：<a href="http://www.cnblogs.com/springcsc/archive/2009/12/03/1616413.html" target="_blank" rel="noopener">http://www.cnblogs.com/springcsc/archive/2009/12/03/1616413.html</a><br>对于需要从事网络编程的程序员来说，网络协议是一个需要深刻理解的概念。那么什么是网络协议呢？</p><p><strong>网络协议是指对于网络中传输的数据格式的规定。</strong>对于网络编程初学者来说，没有必要深入了解TCP/IP协议簇，所以对于初学者来说去读大部头的《TCP/IP协议》也不是一件很合适的事情，因为深入了解TCP/IP协议是网络编程提高阶段，也是深入网络编程底层时才需要做的事情。<br>对于一般的网络编程来说，更多的是关心网络上传输的逻辑数据内容，也就是更多的是应用层上的网络协议，所以后续的内容均以实际应用的数据为基础来介绍网络协议的概念。</p><p>那么什么是网络协议呢，下面看一个简单的例子。春节晚会上“小沈阳”和赵本山合作的小品《不差钱》中，小沈阳和赵本山之间就设计了一个协议，协议的内容为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果点的菜价钱比较贵是，就说没有。</span><br></pre></td></tr></table></figure><p></p><p>按照该协议的规定，就有了下面的对话：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">赵本山：<span class="number">4</span>斤的龙虾</span><br><span class="line">小沈阳：(经过判断，得出价格比较高)，没有</span><br><span class="line">赵本山：鲍鱼</span><br><span class="line">小沈阳：(经过判断，得出价格比较高)，没有</span><br></pre></td></tr></table></figure><p></p><p>这就是一种双方达成的一种协议约定，其实这种约定的实质和网络协议的实质是一样的。<strong>网络协议的实质也是客户端程序和服务器端程序对于数据的一种约定，只是由于以计算机为基础，所以更多的是使用数字来代表内容，这样就显得比较抽象一些。</strong></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>下 面再举一个简单的例子，介绍一些基础的网络协议设计的知识。例如需要设计一个简单的网络程序：网络计算器。也就是在客户端输入需要计算的数字和运算符，在 服务器端实现计算，并将计算的结果反馈给客户端。在这个例子中，就需要约定两个数据格式：<strong>客户端发送给服务器端的数据格式，以及服务器端反馈给客户端的数 据格式。</strong></p><h3 id="客户端发送给服务器的数据格式"><a href="#客户端发送给服务器的数据格式" class="headerlink" title="客户端发送给服务器的数据格式"></a>客户端发送给服务器的数据格式</h3><p>可能你觉得这个比较简单，例如客户端输入的数字依次是<code>12</code>和<code>432</code>，输入的运算符是加号，可能最容易想到的数据格式是形成字符串“<code>12+432</code>”，这样格式的确比较容易阅读，但是服务器端在进行计算时，逻辑就比较麻烦，因为需要首先拆分该字符串，然后才能进行计算，所以可用的数据格式就有了一下几种：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“<span class="number">12</span>，<span class="number">432</span>，+”     格式为：第一个数字，第二个数字，运算符</span><br><span class="line">“<span class="number">12</span>，+，<span class="number">432</span>”     格式为：第一个数字，运算符，第二个数字</span><br></pre></td></tr></table></figure><p></p><p>其实以上两种数据格式很接近，比较容易阅读，在服务器端收到该数据格式以后，使用“<code>，</code>”为分隔符分割字符串即可。</p><p>假设对于运算符再进行一次约定，例如约定数字<code>0</code>代表加法<code>+</code>，<code>1</code>代表减法<code>-</code>，2代表乘法<code>*</code>，3代表除法<code>/</code>，整体格式遵循以上第一种格式，则上面的数字生产的协议数据为：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“<span class="number">12</span>，<span class="number">432</span>，<span class="number">0</span>”</span><br></pre></td></tr></table></figure><p></p><p>这就是一种基本的发送的协议约定了。</p><h3 id="服务器反馈的数据格式"><a href="#服务器反馈的数据格式" class="headerlink" title="服务器反馈的数据格式"></a>服务器反馈的数据格式</h3><p>另 外一个需要设计的协议格式就是服务器端反馈的数据格式，其实服务器端主要反馈计算结果，但是在实际接受数据时，有可能存在格式错误的情况，这样就需要简单 的设计一下服务器端反馈的数据格式了。例如规定，如果发送的数据格式正确，则反馈结果，否则反馈字符串“错误”。这样就有了以下的数据格式：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">客户端：“<span class="number">1</span>,<span class="number">111</span>,<span class="number">1</span>”     服务器端：”-<span class="number">110</span>”</span><br><span class="line">客户端：“<span class="number">123</span>,<span class="number">23</span>,<span class="number">0</span>”    服务器端：“<span class="number">146</span>”</span><br><span class="line">客户端：“<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>”       服务器端：“错误”</span><br></pre></td></tr></table></figure><p></p><p>这样就设计出了一种最最基本的网络协议格式，从该示例中可以看出，<strong>网络协议就是一种格式上的约定，可以根据逻辑的需要约定出各种数据格式</strong>，在进行设计时一般遵循“简单、通用、容易解析”的原则进行。</p><p>而对于复杂的网络程序来说，需要传输的数据种类和数据量都比较大，这样只需要依次设计出每种情况下的数据格式即可，例如QQ程序，在该程序中需要进行传输的网络数据种类很多，那么在设计时就可以遵循：登录格式、注册格式、发送消息格式等等，一一进行设计即可。所以对于复杂的网络程序来说，只是增加了更多的命令格式，在实际设计时的工作量增加不是太大。</p><p>不管怎么说，在网络编程中，<strong>对于同一个网络程序来说，一般都会涉及到两个网络协议格式：客户端发送数据格式和服务器端反馈数据格式</strong>，在实际设计时，需要一一对应。这就是最基本的网络协议的知识。</p><p>网络协议设计完成以后，在进行网络编程时，就需要根据设计好的协议格式，在程序中进行对应的编码了，客户端程序和服务器端程序需要进行协议处理的代码分别如下。</p><p>客户端程序需要完成的处理为：</p><ul><li>客户端发送协议格式的生成</li><li>服务器端反馈数据格式的解析</li></ul><p>服务器端程序需要完成的处理为：</p><ul><li>服务器端反馈协议格式的生成</li><li>客户端发送协议格式的解析</li></ul><p>这里的<strong>生成是指将计算好的数据，转换成规定的数据格式</strong>，这里的<strong>解析指，从反馈的数据格式中拆分出需要的数据。</strong>在进行对应的代码编写时，严格遵循协议约定即可。</p><p>所以，对于程序员来说，在进行网络程序编写时，需要首先根据逻辑的需要设计网络协议格式，然后遵循协议格式约定进行协议生成和解析代码的编写，最后使用网络编程技术实现整个网络编程的功能。</p><p>由于各种网络程序使用不同的协议格式，所以不同网络程序的客户端之间无法通用。</p><h2 id="常见协议"><a href="#常见协议" class="headerlink" title="常见协议"></a>常见协议</h2><p>而对于常见协议的格式，例如</p><ul><li><code>HTTP(Hyper Text Transfer Protocol</code>，超文本传输协议)、</li><li><code>FTP(File Transfer Protocol</code>，文件传输协议)，</li><li><code>SMTP(Simple Mail Transfer Protocol</code>，简单邮件传输协议)等等，</li></ul><p>都有通用的规定，具体可以查阅相关的<code>RFC</code>文档。</p><p>最后，对于一种网络程序来说，网络协议格式是该程序最核心的技术秘密，因为一旦协议格式泄漏，则任何一个人都可以根据该格式进行客户端的编写，这样将影响服务器端的实现，也容易出现一些其它的影响。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>关于网络编程基本的技术就介绍这么多，该部分介绍了网络编程的基础知识，以及Java语言对于网络编程的支持，网络编程的步骤等，并详细介绍了TCP方式网络编程和UDP方式网络编程在Java语言中的实现。</p><p>网络协议也是网络程序的核心，所以在实际开始进行网络编程时，设计一个良好的协议格式也是必须进行的工作。</p><h2 id="网络编程示例"><a href="#网络编程示例" class="headerlink" title="网络编程示例"></a>网络编程示例</h2><p>“实践出真知”，所以在进行技术学习时，还是需要进行很多的练习，才可以体会技术的奥妙，下面通过两个简单的示例，演示网络编程的实际使用。</p><h2 id="质数判别示例"><a href="#质数判别示例" class="headerlink" title="质数判别示例"></a>质数判别示例</h2><p>该示例实现的功能是质数判断，<strong>程序实现的功能为客户端程序接收用户输入的数字，然后将用户输入的内容发送给服务器端，服务器端判断客户端发送的数字是否是质数，并将判断的结果反馈给客户端，客户端根据服务器端的反馈显示判断结果。</strong></p><p><strong>质数的规则是</strong>：<strong>最小的质数是2，只能被1和自身整除的<code>自然数</code>。当用户输入小于2的数字，以及输入的内容不是自然数时，都属于非法输入。</strong></p><p>网络程序的功能都分为客户端程序和服务器端程序实现，下面先描述一下每个程序分别实现的功能：</p><h3 id="客户端程序功能："><a href="#客户端程序功能：" class="headerlink" title="客户端程序功能："></a>客户端程序功能：</h3><ul><li>接收用户控制台输入</li><li>判断输入内容是否合法</li><li>按照协议格式生成发送数据</li><li>发送数据</li><li>接收服务器端反馈</li><li>解析服务器端反馈信息，并输出</li></ul><h3 id="服务器端程序功能："><a href="#服务器端程序功能：" class="headerlink" title="服务器端程序功能："></a>服务器端程序功能：</h3><ul><li>接收客户端发送数据</li><li>按照协议格式解析数据</li><li>判断数字是否是质数</li><li>根据判断结果，生成协议数据</li><li>将数据反馈给客户端</li></ul><p>分解好了网络程序的功能以后，就可以设计网络协议格式了，如果该程序的功能比较简单，所以设计出的协议格式也不复杂。</p><h3 id="客户端发送协议格式："><a href="#客户端发送协议格式：" class="headerlink" title="客户端发送协议格式："></a>客户端发送协议格式：</h3><ul><li>将用户输入的数字转换为字符串，再将字符串转换为byte数组即可。</li><li>例如用户输入16，则转换为字符串“16”，使用getBytes转换为byte数组。</li><li>客户端发送“quit”字符串代表结束连接<h3 id="服务器端发送协议格式："><a href="#服务器端发送协议格式：" class="headerlink" title="服务器端发送协议格式："></a>服务器端发送协议格式：</h3></li><li>反馈数据长度为1个字节。数字0代表是质数，1代表不是质数，2代表协议格式错误。</li><li>例如客户端发送数字12，则反馈1，发送13则反馈0，发送0则反馈2。</li></ul><p>功能设计完成以后，就可以分别进行客户端和服务器端程序的编写了，在编写完成以后联合起来进行调试即可。</p><p>下面分别以TCP方式和UDP方式实现该程序，注意其实现上的差异。不管使用哪种方式实现，客户端都可以多次输入数据进行判断。对于UDP方式来说，不需要向服务器端发送quit字符串。</p><h3 id="以TCP方式实现"><a href="#以TCP方式实现" class="headerlink" title="以TCP方式实现"></a>以TCP方式实现</h3><h4 id="客户端程序"><a href="#客户端程序" class="headerlink" title="客户端程序"></a>客户端程序</h4><p>以TCP方式实现的客户端程序代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> example1;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 以TCP方式实现的质数判断客户端程序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPPrimeClient</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> BufferedReader br;</span><br><span class="line">    <span class="keyword">static</span> Socket socket;</span><br><span class="line">    <span class="keyword">static</span> InputStream is;</span><br><span class="line">    <span class="keyword">static</span> OutputStream os;</span><br><span class="line">    <span class="comment">/**服务器IP*/</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> String HOST = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">    <span class="comment">/**服务器端端口*/</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> PORT = <span class="number">10005</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        init(); <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"请输入数字："</span>);</span><br><span class="line">            String input = readInput(); <span class="comment">//读取输入</span></span><br><span class="line">            <span class="keyword">if</span>(isQuit(input))</span><br><span class="line">            &#123; <span class="comment">//判读是否结束</span></span><br><span class="line">                <span class="keyword">byte</span>[] b = <span class="string">"quit"</span>.getBytes();</span><br><span class="line">                send(b);</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//结束程序</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(checkInput(input))</span><br><span class="line">            &#123; <span class="comment">//校验合法</span></span><br><span class="line">                <span class="comment">//发送数据</span></span><br><span class="line">                send(input.getBytes());</span><br><span class="line">                <span class="comment">//接收数据</span></span><br><span class="line">                <span class="keyword">byte</span>[] data = receive();</span><br><span class="line">                <span class="comment">//解析反馈数据</span></span><br><span class="line">                parse(data);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"输入不合法，请重新输入！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        close(); <span class="comment">//关闭流和连接</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 初始化</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            br = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">            <span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">            socket = <span class="keyword">new</span> Socket(HOST,PORT);</span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 读取客户端输入</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">readInput</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> br.readLine();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 判断是否输入quit</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> input 输入内容</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> true代表结束，false代表不结束</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isQuit</span><span class="params">(String input)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(input == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"quit"</span>.equalsIgnoreCase(input))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 校验输入</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> input 用户输入内容</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> true代表输入符合要求，false代表不符合</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkInput</span><span class="params">(String input)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(input == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> n = Integer.parseInt(input);</span><br><span class="line">            <span class="keyword">if</span>(n &gt;= <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//输入不是整数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 向服务器端发送数据</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> data 数据内容</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">byte</span>[] data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            os.write(data);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 接收服务器端反馈</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 反馈数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] receive()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> n = is.read(b);</span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[n];</span><br><span class="line">            <span class="comment">//复制有效数据</span></span><br><span class="line">            System.arraycopy(b, <span class="number">0</span>, data, <span class="number">0</span>, n);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 解析协议数据</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> data 协议数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(<span class="keyword">byte</span>[] data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"服务器端反馈数据不正确！"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span> value = data[<span class="number">0</span>]; <span class="comment">//取第一个byte</span></span><br><span class="line">        <span class="comment">//按照协议格式解析</span></span><br><span class="line">        <span class="keyword">switch</span>(value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            System.out.println(<span class="string">"质数"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">"不是质数"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            System.out.println(<span class="string">"协议格式错误"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 关闭流和连接</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            br.close();</span><br><span class="line">            is.close();</span><br><span class="line">            os.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该代码中，将程序的功能使用方法进行组织，使得结构比较清晰，核心的逻辑流程在main方法中实现。</p><h3 id="服务器端实现"><a href="#服务器端实现" class="headerlink" title="服务器端实现"></a>服务器端实现</h3><p>以TCP方式实现的服务器端的代码如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> example1;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 以TCP方式实现的质数判别服务器端</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPPrimeServer</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">10005</span>;</span><br><span class="line">        ServerSocket ss = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            ss = <span class="keyword">new</span> ServerSocket(PORT);</span><br><span class="line">            System.out.println(<span class="string">"服务器端已启动："</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Socket s = ss.accept();</span><br><span class="line">                <span class="keyword">new</span> PrimeLogicThread(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                ss.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e2) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="服务器逻辑线程"><a href="#服务器逻辑线程" class="headerlink" title="服务器逻辑线程"></a>服务器逻辑线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">package example1;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.net.*;</span><br><span class="line">/**</span><br><span class="line">* 实现质数判别逻辑的线程</span><br><span class="line">*/</span><br><span class="line">public class PrimeLogicThread extends Thread </span><br><span class="line">&#123;</span><br><span class="line">    Socket socket;</span><br><span class="line">    InputStream is;</span><br><span class="line">    OutputStream os;</span><br><span class="line">    public PrimeLogicThread(Socket socket)</span><br><span class="line">    &#123;</span><br><span class="line">        this.socket = socket;</span><br><span class="line">        init();</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">    * 初始化</span><br><span class="line">    */</span><br><span class="line">    private void init()</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">        &#125;catch(Exception e)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        while(true)</span><br><span class="line">        &#123;</span><br><span class="line">            //接收客户端反馈</span><br><span class="line">            byte[] data = receive();</span><br><span class="line">            //判断是否是退出</span><br><span class="line">            if(isQuit(data))</span><br><span class="line">            &#123;</span><br><span class="line">                break; //结束循环</span><br><span class="line">            &#125;</span><br><span class="line">            //逻辑处理</span><br><span class="line">            byte[] b = logic(data);</span><br><span class="line">            //反馈数据</span><br><span class="line">            send(b);</span><br><span class="line">        &#125;</span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">    * 接收客户端数据</span><br><span class="line">    * @return 客户端发送的数据</span><br><span class="line">    */</span><br><span class="line">    private byte[] receive()</span><br><span class="line">    &#123;</span><br><span class="line">        byte[] b = new byte[1024];</span><br><span class="line">        try </span><br><span class="line">        &#123;</span><br><span class="line">            int n = is.read(b);</span><br><span class="line">            byte[] data = new byte[n];</span><br><span class="line">            //复制有效数据</span><br><span class="line">            System.arraycopy(b, 0, data, 0, n);</span><br><span class="line">            return data;</span><br><span class="line">        &#125; catch (Exception e)&#123;&#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">    * 向客户端发送数据</span><br><span class="line">    * @param data 数据内容</span><br><span class="line">    */</span><br><span class="line">    private void send(byte[] data)</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            os.write(data);</span><br><span class="line">        &#125;catch(Exception e)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">    * 判断是否是quit</span><br><span class="line">    * @return 是返回true，否则返回false</span><br><span class="line">    */</span><br><span class="line">    private boolean isQuit(byte[] data)</span><br><span class="line">    &#123;</span><br><span class="line">        if(data == null)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            String s = new String(data);</span><br><span class="line">            if(s.equalsIgnoreCase(&quot;quit&quot;))</span><br><span class="line">            &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private byte[] logic(byte[] data)</span><br><span class="line">    &#123;</span><br><span class="line">        //反馈数组</span><br><span class="line">        byte[] b = new byte[1];</span><br><span class="line">        //校验参数</span><br><span class="line">        if(data == null)</span><br><span class="line">        &#123;</span><br><span class="line">            b[0] = 2;</span><br><span class="line">            return b;</span><br><span class="line">        &#125;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            //转换为数字</span><br><span class="line">            String s = new String(data);</span><br><span class="line">            int n = Integer.parseInt(s);</span><br><span class="line">            //判断是否是质数</span><br><span class="line">            if(n &gt;= 2)</span><br><span class="line">            &#123;</span><br><span class="line">                boolean flag = isPrime(n);</span><br><span class="line">                if(flag)</span><br><span class="line">                &#123;</span><br><span class="line">                    b[0] = 0;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    b[0] = 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                b[0] = 2; //格式错误</span><br><span class="line">                System.out.println(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            b[0] = 2;</span><br><span class="line">        &#125;</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">    *</span><br><span class="line">    * @param n</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">    private boolean isPrime(int n)</span><br><span class="line">    &#123;</span><br><span class="line">        boolean b = true;</span><br><span class="line">        for(int i = 2;i &lt;= Math.sqrt(n);i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(n % i == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                b = false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">    * 关闭连接</span><br><span class="line">    */</span><br><span class="line">    private void close()</span><br><span class="line">    &#123;</span><br><span class="line">        try </span><br><span class="line">        &#123;</span><br><span class="line">            is.close();</span><br><span class="line">            os.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; catch (Exception e)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本示例使用的服务器端的结构和前面示例中的结构一致，只是逻辑线程的实现相对来说要复杂一些，在线程类中的logic方法中实现了服务器端逻辑，根据客户端发送过来的数据，判断是否是质数，然后根据判断结果按照协议格式要求，生成客户端反馈数据，实现服务器端要求的功能。</p><h3 id="运行结果如下"><a href="#运行结果如下" class="headerlink" title="运行结果如下"></a>运行结果如下</h3><p><img src="https://i.imgur.com/FPsEGIo.png" alt="运行结果"></p><h2 id="猜数字小游戏"><a href="#猜数字小游戏" class="headerlink" title="猜数字小游戏"></a>猜数字小游戏</h2><p>下面这个示例是一个猜数字的控制台小游戏。该游戏的规则是：<strong>当客户端第一次连接到服务器端时，服务器端生产一个【0，50】之间的随机数字，然后客户端输入数字来猜该数字，每次客户端输入数字以后，发送给服务器端，服务器端判断该客户端发送的数字和随机数字的关系，并反馈比较结果，客户端总共有5次猜的机会，猜中时提示猜中，当输入”quit”时结束程序。</strong></p><p>和前面的示例类似，在进行网络程序开发时，首先需要分解一下功能的实现，觉得功能是在客户端程序中实现还是在服务器端程序中实现。区分的规则一般是：</p><ul><li>客户端 程序实现接收用户输入等界面功能，并实现一些基础的校验降低服务器端的压力，</li><li>而将程序核心的逻辑以及数据存储等功能放在服务器端进行实现。<br>遵循该原则划分 的客户端和服务器端功能如下所示。</li></ul><h3 id="客户端程序功能列表："><a href="#客户端程序功能列表：" class="headerlink" title="客户端程序功能列表："></a>客户端程序功能列表：</h3><ul><li>接收用户控制台输入</li><li>判断输入内容是否合法</li><li>按照协议格式发送数据</li><li>根据服务器端的反馈给出相应提示</li></ul><h3 id="服务器端程序功能列表："><a href="#服务器端程序功能列表：" class="headerlink" title="服务器端程序功能列表："></a>服务器端程序功能列表：</h3><ul><li>接收客户端发送数据</li><li>按照协议格式解析数据</li><li>判断发送过来的数字和随机数字的关系</li><li>根据判断结果生产协议数据</li><li>将生产的数据反馈给客户端</li></ul><p>在该示例中，实际使用的网络命令也只有两条，所以显得协议的格式比较简单。</p><h3 id="其中客户端程序协议格式如下："><a href="#其中客户端程序协议格式如下：" class="headerlink" title="其中客户端程序协议格式如下："></a>其中客户端程序协议格式如下：</h3><ul><li>将用户输入的数字转换为字符串，然后转换为byte数组</li><li>发送“quit”字符串代表退出<h3 id="其中服务器端程序协议格式如下："><a href="#其中服务器端程序协议格式如下：" class="headerlink" title="其中服务器端程序协议格式如下："></a>其中服务器端程序协议格式如下：</h3><code>反馈长度为1个字节，数字0代表相等(猜中)，1代表大了，2代表小了，其它数字代表错误。</code></li></ul><p>实现该程序的代码比较多，下面分为客户端程序实现和服务器端程序实现分别进行列举。</p><h3 id="客户端程序实现代码如下："><a href="#客户端程序实现代码如下：" class="headerlink" title="客户端程序实现代码如下："></a>客户端程序实现代码如下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">package guess;</span><br><span class="line"></span><br><span class="line">import java.net.*;</span><br><span class="line">import java.io.*;</span><br><span class="line">/**</span><br><span class="line"> * 猜数字客户端</span><br><span class="line"> */</span><br><span class="line">public class TCPClient</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">Socket socket = null;</span><br><span class="line">OutputStream os = null;</span><br><span class="line">InputStream is = null;</span><br><span class="line">BufferedReader br = null;</span><br><span class="line">byte[] data = new byte[2];</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">// 建立连接</span><br><span class="line">socket = new Socket(&quot;127.0.0.1&quot;, 10001);</span><br><span class="line">// 发送数据</span><br><span class="line">os = socket.getOutputStream();</span><br><span class="line">// 读取反馈数据</span><br><span class="line">is = socket.getInputStream();</span><br><span class="line">// 键盘输入流</span><br><span class="line">br = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">// 多次输入</span><br><span class="line">while (true)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;请输入数字：&quot;);</span><br><span class="line">// 接收输入</span><br><span class="line">String s = br.readLine();</span><br><span class="line">// 结束条件</span><br><span class="line">if (s.equals(&quot;quit&quot;))</span><br><span class="line">&#123;</span><br><span class="line">os.write(&quot;quit&quot;.getBytes());</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">// 校验输入是否合法</span><br><span class="line">boolean b = true;</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">Integer.parseInt(s);</span><br><span class="line">&#125; catch (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">b = false;</span><br><span class="line">&#125;</span><br><span class="line">if (b)</span><br><span class="line">&#123; // 输入合法</span><br><span class="line">// 发送数据</span><br><span class="line">os.write(s.getBytes());</span><br><span class="line">// 接收反馈</span><br><span class="line">is.read(data);</span><br><span class="line">// 判断</span><br><span class="line">switch (data[0])</span><br><span class="line">&#123;</span><br><span class="line">case 0 :</span><br><span class="line">System.out.println(&quot;相等！祝贺你！&quot;);</span><br><span class="line">break;</span><br><span class="line">case 1 :</span><br><span class="line">System.out.println(&quot;大了！&quot;);</span><br><span class="line">break;</span><br><span class="line">case 2 :</span><br><span class="line">System.out.println(&quot;小了！&quot;);</span><br><span class="line">break;</span><br><span class="line">default :</span><br><span class="line">System.out.println(&quot;其它错误！&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 提示猜的次数</span><br><span class="line">System.out.println(&quot;你已经猜了&quot; + data[1] + &quot;次！&quot;);</span><br><span class="line">// 判断次数是否达到5次</span><br><span class="line">if (data[1] &gt;= 5)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;你挂了！&quot;);</span><br><span class="line">// 给服务器端线程关闭的机会</span><br><span class="line">os.write(&quot;quit&quot;.getBytes());</span><br><span class="line">// 结束客户端程序</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else</span><br><span class="line">&#123; // 输入错误</span><br><span class="line">System.out.println(&quot;输入错误！&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; finally</span><br><span class="line">&#123;</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">// 关闭连接</span><br><span class="line">br.close();</span><br><span class="line">is.close();</span><br><span class="line">os.close();</span><br><span class="line">socket.close();</span><br><span class="line">&#125; catch (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该示例中，首先建立一个到<code>IP</code>地址为<code>127.0.0.1</code>的端口为<code>10001</code>的连接，然后进行各个流的初始化工作，将逻辑控制的代码放入在一个<code>while</code>循环中，这样可以在客户端多次进行输入。在循环内部，首先判断用户输入的是否为<code>quit</code>字符串，如果是则结束程序，如果输入不是<code>quit</code>，则首先校验输入的是否是数字，如果不是数字则直接输出“输入错误！”并继续接收用户输入，如果是数字则发送给服务器端，并根据服务器端的反馈显示相应的提示信息。最后关闭流和连接，结束客户端程序。</p><p>服务器端程序的实现还是分为服务器控制程序和逻辑线程，实现的代码分别如下：</p><h3 id="服务器控制程序"><a href="#服务器控制程序" class="headerlink" title="服务器控制程序"></a>服务器控制程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> guess;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* TCP连接方式的服务器端</span></span><br><span class="line"><span class="comment">* 实现功能：接收客户端的数据，判断数字关系</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//监听端口</span></span><br><span class="line">            ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">10001</span>);</span><br><span class="line">            System.out.println(<span class="string">"服务器已启动："</span>);</span><br><span class="line">            <span class="comment">//逻辑处理</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//获得连接</span></span><br><span class="line">                Socket s = ss.accept();</span><br><span class="line">                <span class="comment">//启动线程处理</span></span><br><span class="line">                <span class="keyword">new</span> LogicThread(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逻辑线程"><a href="#逻辑线程" class="headerlink" title="逻辑线程"></a>逻辑线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">package guess;</span><br><span class="line">import java.net.*;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.util.*;</span><br><span class="line">/**</span><br><span class="line">* 逻辑处理线程</span><br><span class="line">*/</span><br><span class="line">public class LogicThread extends Thread </span><br><span class="line">&#123;</span><br><span class="line">    Socket s;</span><br><span class="line">    static Random r = new Random();</span><br><span class="line">    public LogicThread(Socket s)</span><br><span class="line">    &#123;</span><br><span class="line">        this.s = s;</span><br><span class="line">        start(); //启动线程</span><br><span class="line">    &#125;</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        //生成一个[0，50]的随机数</span><br><span class="line">        int randomNumber = Math.abs(r.nextInt() % 51);</span><br><span class="line">        //用户猜的次数</span><br><span class="line">        int guessNumber = 0;</span><br><span class="line">        InputStream is = null;</span><br><span class="line">        OutputStream os = null;</span><br><span class="line">        byte[] data = new byte[2];</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            //获得输入流</span><br><span class="line">            is = s.getInputStream();</span><br><span class="line">            //获得输出流</span><br><span class="line">            os = s.getOutputStream();</span><br><span class="line">            while(true)</span><br><span class="line">            &#123; //多次处理</span><br><span class="line">                //读取客户端发送的数据</span><br><span class="line">                byte[] b = new byte[1024];</span><br><span class="line">                int n = is.read(b);</span><br><span class="line">                String send = new String(b,0,n);</span><br><span class="line">                //结束判别</span><br><span class="line">                if(send.equals(&quot;quit&quot;))</span><br><span class="line">                &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                //解析、判断</span><br><span class="line">                try</span><br><span class="line">                &#123;</span><br><span class="line">                    int num = Integer.parseInt(send);</span><br><span class="line">                    //处理</span><br><span class="line">                    guessNumber++; //猜的次数增加1</span><br><span class="line">                    data[1] = (byte)guessNumber;</span><br><span class="line">                    //判断</span><br><span class="line">                    if(num &gt; randomNumber)</span><br><span class="line">                    &#123;</span><br><span class="line">                        data[0] = 1;</span><br><span class="line">                    &#125;else if(num &lt; randomNumber)&#123;</span><br><span class="line">                        data[0] = 2;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        data[0] = 0;</span><br><span class="line">                        //如果猜对</span><br><span class="line">                        guessNumber = 0; //清零</span><br><span class="line">                        randomNumber = Math.abs(r.nextInt() % 51);</span><br><span class="line">                    &#125;</span><br><span class="line">                    //反馈给客户端</span><br><span class="line">                    os.write(data);</span><br><span class="line">                &#125;catch(Exception e)&#123; //数据格式错误</span><br><span class="line">                    data[0] = 3;</span><br><span class="line">                    data[1] = (byte)guessNumber;</span><br><span class="line">                    os.write(data); //发送错误标识</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                os.flush();   //强制发送</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                is.close();</span><br><span class="line">                os.close();</span><br><span class="line">                s.close();</span><br><span class="line">            &#125;catch(Exception e)&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文链接: <a href="https://www.lansheng.net.cn/blog/12786bb5/">7网络协议</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> java 网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>UDP网络编程</title>
      <link href="/blog/b6cecc51/"/>
      <url>/blog/b6cecc51/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>参考：<a href="https://blog.csdn.net/sihai12345/article/details/79334299" target="_blank" rel="noopener">https://blog.csdn.net/sihai12345/article/details/79334299</a></p><p>网络通讯的方式除了<code>TCP</code>方式以外，还有一种实现的方式就是<code>UDP</code>方式。<code>UDP(User Datagram Protocol)</code>，中文意思是<strong>用户数据报协议</strong>，方式类似于发短信息，是一种物美价廉的通讯方式，使用<strong>该种方式无需建立专用的虚拟连接</strong>，由于无需建立专用的连接，所以<strong>对于服务器的压力要比<code>TCP</code>小很多</strong>，所以也是一种常见的网络编程方式。但是使用<strong>该种方式最大的不足是传输不可靠</strong>，当然也不是说经常丢失，就像大家发短信息一样，理论上存在收不到的可能，这种可能性可能是<code>1%</code>，反正比较小，但是由于这种可能的存在，所以平时我们都觉得重要的事情还是打个电话吧(类似<code>TCP</code>方式)，一般的事情才发短信息(类似<code>UDP</code>方式)。网络编程中也是这样，<strong>必须要求可靠传输的信息一般使用<code>TCP</code>方式实现，一般的数据才使用<code>UDP</code>方式实现。</strong></p><p><code>UDP</code>方式的网络编程也在<code>Java</code>语言中获得了良好的支持，由于其在传输数据的过程中不需要建立专用的连接等特点，所以在<code>Java API</code>中设计的实现结构和<code>TCP</code>方式不太一样。当然，需要使用的类还是包含在<code>java.net</code>包中。</p><h2 id="Java-UDP网络编程相关类"><a href="#Java-UDP网络编程相关类" class="headerlink" title="Java UDP网络编程相关类"></a>Java UDP网络编程相关类</h2><p>在<code>Java API</code>中，实现<code>UDP</code>方式的编程，包含<code>客户端网络编程</code>和<code>服务器端网络编程</code>，主要由两个类实现，分别是：</p><h3 id="DatagramSocket类"><a href="#DatagramSocket类" class="headerlink" title="DatagramSocket类"></a>DatagramSocket类</h3><p><code>DatagramSocket</code>类实现“<strong>网络连接</strong>”，包括客户端网络连接和服务器端网络连接。虽然UDP方式的网络通讯不需要建立专用的网络连接，但是毕竟还是需要发送和接收数据，<strong><code>DatagramSocket</code>实现的就是发送数据时的发射器，以及接收数据时的监听器的角色。</strong>类比于TCP中的网络连接，该类既可以用于实现客户端连接，也可以用于实现服务器端连接。</p><h3 id="DatagramPacket类"><a href="#DatagramPacket类" class="headerlink" title="DatagramPacket类"></a><code>DatagramPacket</code>类</h3><p><strong><code>DatagramPacket</code>类实现对于网络中传输的数据封装</strong>，也就是说，<strong>该类的对象代表网络中交换的<code>数据</code></strong>。<br><strong>在<code>UDP</code>方式的网络编程中，无论是需要发送的数据还是需要接收的数据，都必须被处理成<code>DatagramPacket</code>类型的对象</strong>，该对象中包含<code>发送到的地址</code>、<code>发送到的端口号</code>以及<code>发送的内容</code>等。其实<code>DatagramPacket</code>类的作用类似于现实中的信件，在信件中包含信件发送到的地址以及接收人，还有发送的内容等，邮局只需要按照地址传递即可。在接收数据时，接收到的数据也必须被处理成<code>DatagramPacket</code>类型的对象，在该对象中包含发送方的地址、端口号等信息，也包含数据的内容。和<code>TCP</code>方式的网络传输相比，<strong><code>IO</code>编程在<code>UDP</code>方式的网络编程中变得不是必须的内容</strong>，结构也要比<code>TCP</code>方式的网络编程简单一些。</p><p>下面介绍一下UDP方式的网络编程中，客户端和服务器端的实现步骤，以及通过基础的示例演示UDP方式的网络编程在Java语言中的实现方式。</p><p>UDP方式的网络编程，编程的步骤和TCP方式类似，只是使用的类和方法存在比较大的区别，下面首先介绍一下UDP方式的网络编程客户端实现过程。</p><h2 id="UDP客户端编程步骤"><a href="#UDP客户端编程步骤" class="headerlink" title="UDP客户端编程步骤"></a>UDP客户端编程步骤</h2><p>UDP客户端编程涉及的步骤也是4个部分：<strong>建立连接</strong>、<strong>发送数据</strong>、<strong>接收数据</strong>和<strong>关闭连接</strong>。</p><h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p>首先介绍UDP方式的网络编程中建立连接的实现。其中<strong>UDP方式的建立连接和TCP方式不同，只需要建立一个连接对象即可，不需要指定服务器的IP和端口号码</strong>。实现的代码为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DatagramSocket ds = new DatagramSocket();</span><br></pre></td></tr></table></figure><p></p><p>这样就建立了一个客户端连接，<strong>该客户端连接使用系统随机分配的一个本地计算机的未用端口号</strong>。在该连接中，不指定服务器端的IP和端口，所以UDP方式的网络连接更像一个发射器，而不是一个具体的连接。<br>当然，可以通过制定连接使用的端口号来创建客户端连接。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DatagramSocket ds = new DatagramSocket(5000);</span><br></pre></td></tr></table></figure><p></p><p>这样就是使用本地计算机的<code>5000</code>号端口建立了一个连接。<strong>一般在建立客户端连接时没有必要指定端口号码。</strong></p><h3 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h3><p>接着，介绍一下UDP客户端编程中发送数据的实现。<strong>在UDP方式的网络编程中，IO技术不是必须的</strong>，<strong>发送数据步骤：</strong></p><ul><li>需要将需要发送的数据内容首先转换为<code>byte</code>数组，</li><li>然后将<code>数据内容</code>、<code>服务器IP</code>和<code>服务器端口号</code>一起构造成一个<code>DatagramPacket</code>类型的对象，这样数据的准备就完成了，</li><li>发送时调用网络连接对象中的send方法发送该对象即可。</li></ul><p>例如将字符串“<code>Hello</code>”发送到IP是<code>127.0.0.1</code>，端口号是<code>10001</code>的服务器，则实现发送数据的代码如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String s = “Hello”;</span><br><span class="line">String host = “<span class="number">127.0</span>.0.1”;</span><br><span class="line"><span class="keyword">int</span> port = <span class="number">10001</span>;</span><br><span class="line"><span class="comment">//将发送的内容转换为byte数组</span></span><br><span class="line"><span class="keyword">byte</span>[] byteToSend = s.getBytes();</span><br><span class="line"><span class="comment">//将服务器IP转换为InetAddress对象</span></span><br><span class="line">InetAddress serverIP = InetAddress.getByName(host);</span><br><span class="line"><span class="comment">//构造发送的数据包对象,数据包中放入数据，目的地址，目的端口号</span></span><br><span class="line">DatagramPacket sendDp = <span class="keyword">new</span> DatagramPacket(byteToSend,byteToSend.length,serverIP,port);</span><br><span class="line"><span class="comment">//发送数据</span></span><br><span class="line">ds.send(sendDp);</span><br></pre></td></tr></table></figure><p></p><p>在该示例代码中，不管发送的数据内容是什么，都需要转换为byte数组，然后将服务器端的IP地址构造成InetAddress类型的对象，在准备完成以后，将这些信息构造成一个DatagramPacket类型的对象，发送的数据内容、服务器端的IP和端口号，都包含在DatagramPacket对象中。在准备完成以后，调用连接对象ds的send方法把DatagramPacket对象发送出去即可。</p><p>按照UDP协议的约定，在进行数据传输时，系统只是尽全力传输数据，但是并不保证数据一定被正确传输，<strong>如果数据在传输过程中丢失，那就丢失了。</strong></p><p>UDP方式在进行网络通讯时，也遵循“<strong>请求-响应</strong>”模型，<strong>在发送数据完成以后，就可以接收服务器端的反馈数据了。</strong></p><h3 id="客户端接收数据"><a href="#客户端接收数据" class="headerlink" title="客户端接收数据"></a>客户端接收数据</h3><p>下面介绍一下UDP客户端编程中接收数据的实现。当数据发送出去以后，就可以接收服务器端的反馈信息了。<strong>接收数据在Java语言中的实现是这样的：</strong></p><ul><li>首先构造一个数据缓冲数组，该数组用于存储接收的服务器端反馈数据，该数组的长度必须大于或等于服务器端反馈的实际有效数据的长度。</li><li>然后以该缓冲数组为基础构造一个DatagramPacket数据包对象，</li><li>最后调用连接对象的receive方法接收数据即可。</li></ul><p>接收到的服务器端反馈数据存储在DatagramPacket类型的对象内部。实现接收数据以及显示服务器端反馈内容的示例代码如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步,构造缓冲数组用于接收数据</span></span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">//第二步,构造数据包对象</span></span><br><span class="line">DatagramPacket received = <span class="keyword">new</span> DatagramPacket(data,data.length);</span><br><span class="line"><span class="comment">//接收数据</span></span><br><span class="line">ds.receive(receiveDp);</span><br><span class="line"><span class="comment">//输出数据内容</span></span><br><span class="line"><span class="keyword">byte</span>[] b = receiveDp.getData(); <span class="comment">//获得缓冲数组</span></span><br><span class="line"><span class="keyword">int</span> len = receiveDp.getLength(); <span class="comment">//获得有效数据长度</span></span><br><span class="line">String s = <span class="keyword">new</span> String(b,<span class="number">0</span>,len);</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure><p></p><p>在该代码中，首先构造缓冲数组<code>data</code>，这里设置的长度<code>1024</code>是预估的接收到的数据长度，要求该长度必须大于或等于接收到的数据长度，然后以该缓冲数组为基础，构造数据包对象，使用连接对象<code>ds</code>的<code>receive</code>方法接收反馈数据，由于在<code>Java</code>语言中，除<code>String</code>以外的其它对象都是按照地址传递，所以在<code>receive</code>方法内部可以改变数据包对象<code>receiveDp</code>的内容，这里的<code>receiveDp</code>的功能和返回值类似。数据接收到以后，只需要从数据包对象中读取出来就可以了，使用<code>DatagramPacket</code>对象中的<code>getData</code>方法可以获得数据包对象的缓冲区数组，但是缓冲区数组的长度一般大于有效数据的长度，换句话说，也就是缓冲区数组中只有一部分数据是反馈数据，所以需要使用<code>DatagramPacket</code>对象中的<code>getLength</code>方法获得有效数据的长度，则有效数据就是缓冲数组中的前有效数据长度个内容，这些才是真正的服务器端反馈的数据的内容。</p><h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><p>UDP方式客户端网络编程的最后一个步骤就是关闭连接。虽然UDP方式不建立专用的虚拟连接，但是连接对象还是需要占用系统资源，所以在使用完成以后必须关闭连接。关闭连接使用连接对象中的close方法即可，实现的代码如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ds.close();</span><br></pre></td></tr></table></figure><p></p><p>需要说明的是，和TCP建立连接的方式不同，UDP方式的同一个网络连接对象，可以发送到达不同服务器端IP或端口的数据包，这点是TCP方式无法做到的。</p><h2 id="UDP服务端网络编程"><a href="#UDP服务端网络编程" class="headerlink" title="UDP服务端网络编程"></a>UDP服务端网络编程</h2><p>介绍完了<code>UDP</code>方式客户端网络编程的基础知识以后，下面再来介绍一下<code>UDP</code>方式服务器端网络编程的基础知识。</p><p><code>UDP</code>方式网络编程的服务器端实现和<code>TCP</code>方式的服务器端实现类似，也是服务器端监听某个端口，然后获得数据包，进行逻辑处理以后将处理以后的结果反馈给客户端，最后关闭网络连接，下面依次进行介绍。</p><h3 id="第一步监听窗口，建立连接"><a href="#第一步监听窗口，建立连接" class="headerlink" title="第一步监听窗口，建立连接"></a>第一步监听窗口，建立连接</h3><p>首先<code>UDP</code>方式服务器端网络编程需要建立一个连接，该连接监听某个端口，实现的代码为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DatagramSocket ds = new DatagramSocket(10010);</span><br></pre></td></tr></table></figure><p></p><p>由于<strong>服务器端的端口需要固定，所以一般在建立服务器端连接时，都指定端口号。</strong>例如该示例代码中指定10010端口为服务器端使用的端口号，客户端端在连接服务器端时连接该端口号即可。</p><h3 id="第二步：接收客户端的数据"><a href="#第二步：接收客户端的数据" class="headerlink" title="第二步：接收客户端的数据"></a>第二步：接收客户端的数据</h3><p>接着服务器端就开始接收客户端发送过来的数据，其接收的方法和客户端接收的方法一直，其中<code>receive</code>方法的作用类似于<code>TCP</code>方式中<code>accept</code>方法的作用，该方法也是一个阻塞方法，其作用是接收数据。</p><h3 id="第三步：处理接收的数据，给出响应"><a href="#第三步：处理接收的数据，给出响应" class="headerlink" title="第三步：处理接收的数据，给出响应"></a>第三步：处理接收的数据，给出响应</h3><p>接收到客户端发送过来的数据以后，服务器端对该数据进行逻辑处理，然后将处理以后的结果再发送给客户端，<strong>在这里发送时就比客户端要麻烦一些，因为服务器端需要获得客户端的IP和客户端使用的端口号</strong>，这个都可以<code>从接收到的数据包中获得</code>。示例代码如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得客户端的IP</span></span><br><span class="line">InetAddress clientIP = receiveDp.getAddress();</span><br><span class="line"><span class="comment">//获得客户端的端口号</span></span><br><span class="line">Int clientPort = receiveDp.getPort();</span><br></pre></td></tr></table></figure><p></p><p>使用以上代码，就可以从接收到的数据包对象<code>receiveDp</code>中获得客户端的<code>IP</code>地址和客户端的端口号，这样就可以在服务器端中将处理以后的数据构造成数据包对象，然后将处理以后的数据内容反馈给客户端了。</p><p>最后，当服务器端实现完成以后，关闭服务器端连接，实现的方式为调用连接对象的<code>close</code>方法，示例代码如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ds.close();</span><br></pre></td></tr></table></figure><p></p><p>介绍完了<code>UDP</code>方式下的客户端编程和服务器端编程的基础知识以后，下面通过一个简单的示例演示<code>UDP</code>网络编程的基本使用。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>该实例的功能是实现<strong>将客户端程序的系统时间发送给服务器端，服务器端接收到时间以后，向客户端反馈字符串“<code>OK</code>”。</strong>实现该功能的客户端代码如下所示：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> udp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单的UDP客户端，实现向服务器端发生系统时间功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleUDPClient</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DatagramSocket ds = <span class="keyword">null</span>; <span class="comment">// 连接对象</span></span><br><span class="line">DatagramPacket sendDp; <span class="comment">// 发送数据包对象</span></span><br><span class="line">DatagramPacket receiveDp; <span class="comment">// 接收数据包对象</span></span><br><span class="line">String serverHost = <span class="string">"127.0.0.1"</span>; <span class="comment">// 服务器IP</span></span><br><span class="line"><span class="keyword">int</span> serverPort = <span class="number">10010</span>; <span class="comment">// 服务器端口号</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 建立连接,自动分配一个空闲端口</span></span><br><span class="line">ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line"><span class="comment">// 初始化发送数据</span></span><br><span class="line">Date d = <span class="keyword">new</span> Date(); <span class="comment">// 当前时间</span></span><br><span class="line">String content = d.toString(); <span class="comment">// 转换为字符串</span></span><br><span class="line"><span class="keyword">byte</span>[] data = content.getBytes();</span><br><span class="line"><span class="comment">// 初始化IP地址</span></span><br><span class="line">InetAddress address = InetAddress.getByName(serverHost);</span><br><span class="line"><span class="comment">// 初始化发送包对象 数据,数据的长度,IP地址,端口号</span></span><br><span class="line">sendDp = <span class="keyword">new</span> DatagramPacket(data, data.length, address, serverPort);</span><br><span class="line"><span class="comment">// 发送这个数据包</span></span><br><span class="line">ds.send(sendDp);</span><br><span class="line"><span class="comment">// 初始化接收数据</span></span><br><span class="line"><span class="keyword">byte</span>[] receive = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">receiveDp = <span class="keyword">new</span> DatagramPacket(receive, receive.length);</span><br><span class="line"><span class="comment">// 从服务器接收数据包,</span></span><br><span class="line">ds.receive(receiveDp);</span><br><span class="line"><span class="comment">// 读取反馈内容，并输出</span></span><br><span class="line"><span class="keyword">byte</span>[] response = receiveDp.getData();</span><br><span class="line"><span class="keyword">int</span> len = receiveDp.getLength();</span><br><span class="line">String s = <span class="keyword">new</span> String(response, <span class="number">0</span>, len);</span><br><span class="line">System.out.println(<span class="string">"服务器端反馈为："</span> + s);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 关闭连接</span></span><br><span class="line">ds.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在该示例代码中，首先建立<code>UDP</code>方式的网络连接，然后获得当前系统时间，这里获得的系统时间是客户端程序运行的本地计算机的时间，然后将时间字符串以及服务器端的<code>IP</code>和端口，构造成发送数据包对象，调用连接对象<code>ds</code>的<code>send</code>方法发送出去。在数据发送出去以后，构造接收数据的数据包对象，调用连接对象<code>ds</code>的<code>receive</code>方法接收服务器端的反馈，并输出在控制台。最后在<code>finally</code>语句块中关闭客户端网络连接。</p><p>和下面将要介绍的服务器端一起运行时，客户端程序的输出结果为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">服务器端反馈为：OK</span><br></pre></td></tr></table></figure><p></p><p>下面是该示例程序的服务器端代码实现：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> udp;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 简单UDP服务器端，实现功能是输出客户端发送数据，</span></span><br><span class="line"><span class="comment">并反馈字符串“OK"给客户端</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleUDPServer</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DatagramSocket ds = <span class="keyword">null</span>; <span class="comment">//连接对象</span></span><br><span class="line">        DatagramPacket sendDp; <span class="comment">//发送数据包对象</span></span><br><span class="line">        DatagramPacket receiveDp; <span class="comment">//接收数据包对象</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">10010</span>; <span class="comment">//端口</span></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//建立连接，监听端口</span></span><br><span class="line">            ds = <span class="keyword">new</span> DatagramSocket(PORT);</span><br><span class="line">            System.out.println(<span class="string">"服务器端已启动："</span>);</span><br><span class="line">            <span class="comment">//初始化接收数据</span></span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            receiveDp = <span class="keyword">new</span> DatagramPacket(b,b.length);</span><br><span class="line">            <span class="comment">//接收</span></span><br><span class="line">            ds.receive(receiveDp);</span><br><span class="line">            <span class="comment">//读取反馈内容，并输出</span></span><br><span class="line">            InetAddress clientIP = receiveDp.getAddress();</span><br><span class="line">            <span class="keyword">int</span> clientPort = receiveDp.getPort();</span><br><span class="line">            <span class="keyword">byte</span>[] data = receiveDp.getData();</span><br><span class="line">            <span class="keyword">int</span> len = receiveDp.getLength();</span><br><span class="line">            System.out.println(<span class="string">"客户端IP："</span> + clientIP.getHostAddress());</span><br><span class="line">            System.out.println(<span class="string">"客户端端口："</span> + clientPort);</span><br><span class="line">            System.out.println(<span class="string">"客户端发送内容："</span> + <span class="keyword">new</span> String(data,<span class="number">0</span>,len));</span><br><span class="line">            <span class="comment">//发送反馈</span></span><br><span class="line">            String response = <span class="string">"OK"</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] bData = response.getBytes();</span><br><span class="line">            sendDp = <span class="keyword">new</span> DatagramPacket(bData,bData.length,clientIP,clientPort);</span><br><span class="line">            <span class="comment">//发送</span></span><br><span class="line">            ds.send(sendDp);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//关闭连接,释放占用的端口</span></span><br><span class="line">                ds.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在该服务器端实现中，首先监听<code>10010</code>号端口，和<code>TCP</code>方式的网络编程类似，服务器端的<code>receive</code>方法是阻塞方法，如果客户端不发送数据，则程序会在该方法处阻塞。</p><p>当客户端发送数据到达服务器端时，则接收客户端发送过来的数据，然后将客户端发送的数据内容读取出来，并在服务器端程序中打印客户端的相关信息，<strong>从客户端发送过来的数据包中可以读取出客户端的<code>IP</code>以及客户端端口号</strong>，将反馈数据字符串“<code>OK</code>”发送给客户端，最后关闭服务器端连接，释放占用的系统资源，完成程序功能示例。</p><p>运行结果：<br><img src="https://i.imgur.com/fzgDZkV.png" alt=""></p><p>和前面<code>TCP</code>方式中的网络编程类似，这个示例也仅仅是网络编程的功能示例，也存在前面介绍的客户端无法进行多次数据交换，以及服务器端不支持多个客户端的问题，这两个问题也需要对于代码进行处理才可以很方便的进行解决。</p><p>在解决该问题以前，需要特别指出的是<code>UDP</code>方式的网络编程由于不建立虚拟的连接，所以在实际使用时和<code>TCP</code>方式存在很多的不同，最大的一个不同就是“<code>无状态</code>”。该特点指每次服务器端都收到信息，但是这些信息和连接无关，换句话说，也就是服务器端只是从信息是无法识别出是谁发送的，这样就要求发送信息时的内容需要多一些，这个在后续的示例中可以看到。</p><h2 id="多次发送多次接收"><a href="#多次发送多次接收" class="headerlink" title="多次发送多次接收"></a>多次发送多次接收</h2><p>下面是实现客户端多次发送以及服务器端支持多个数据包同时处理的程序结构，实现的原理和<code>TCP</code>方式类似，在<strong>客户端将数据的发送和接收放入循环中，而服务器端则将接收到的每个数据包启动一个专门的线程进行处理。</strong>实现的代码如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> udp;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 简单的UDP客户端，实现向服务器端发生系统时间功能</span></span><br><span class="line"><span class="comment">* 该程序发送3次数据到服务器端</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MulUDPClient</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DatagramSocket ds = <span class="keyword">null</span>; <span class="comment">//连接对象</span></span><br><span class="line">        DatagramPacket sendDp; <span class="comment">//发送数据包对象</span></span><br><span class="line">        DatagramPacket receiveDp; <span class="comment">//接收数据包对象</span></span><br><span class="line">        String serverHost = <span class="string">"127.0.0.1"</span>; <span class="comment">//服务器IP</span></span><br><span class="line">        <span class="keyword">int</span> serverPort = <span class="number">10012</span>; <span class="comment">//服务器端口号</span></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//建立连接</span></span><br><span class="line">            ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">            <span class="comment">//初始化</span></span><br><span class="line">            InetAddress address = InetAddress.getByName(serverHost);</span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            receiveDp = <span class="keyword">new</span> DatagramPacket(b,b.length);</span><br><span class="line">            System.out.println(<span class="string">"客户端准备完成"</span>);</span><br><span class="line">            <span class="comment">//循环10次，每次间隔0.01秒</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//初始化发送数据</span></span><br><span class="line">                Date d = <span class="keyword">new</span> Date(); <span class="comment">//当前时间</span></span><br><span class="line">                String content = d.toString(); <span class="comment">//转换为字符串</span></span><br><span class="line">                <span class="keyword">byte</span>[] data = content.getBytes();</span><br><span class="line">                <span class="comment">//初始化发送包对象</span></span><br><span class="line">                sendDp = <span class="keyword">new</span> DatagramPacket(data,data.length,address, serverPort);</span><br><span class="line">                <span class="comment">//发送</span></span><br><span class="line">                ds.send(sendDp);</span><br><span class="line">                <span class="comment">//延迟</span></span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                <span class="comment">//接收</span></span><br><span class="line">                ds.receive(receiveDp);</span><br><span class="line">                <span class="comment">//读取反馈内容，并输出</span></span><br><span class="line">                <span class="keyword">byte</span>[] response = receiveDp.getData();</span><br><span class="line">                <span class="keyword">int</span> len = receiveDp.getLength();</span><br><span class="line">                String s = <span class="keyword">new</span> String(response,<span class="number">0</span>,len);</span><br><span class="line">                System.out.println(<span class="string">"服务器端反馈为："</span> + s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//关闭连接</span></span><br><span class="line">                ds.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在该示例中，将和服务器端进行数<strong>据交换的逻辑写在一个for循环的内部，这样就可以实现和服务器端的多次交换了</strong>，考虑到服务器端的响应速度，在每次发送之间加入0.01秒的时间间隔。最后当数据交换完成以后关闭连接，结束程序。</p><p>实现该逻辑的服务器端程序代码如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> udp;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 可以并发处理数据包的服务器端</span></span><br><span class="line"><span class="comment">* 功能为：显示客户端发送的内容，并向客户端反馈字符串“OK”</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MulUDPServer</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DatagramSocket ds = <span class="keyword">null</span>; <span class="comment">//连接对象</span></span><br><span class="line">        DatagramPacket receiveDp; <span class="comment">//接收数据包对象</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">10012</span>; <span class="comment">//端口</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        receiveDp = <span class="keyword">new</span> DatagramPacket(b,b.length);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//建立连接，监听端口</span></span><br><span class="line">            ds = <span class="keyword">new</span> DatagramSocket(PORT);</span><br><span class="line">            System.out.println(<span class="string">"服务器端已启动："</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//接收</span></span><br><span class="line">                ds.receive(receiveDp);</span><br><span class="line">                <span class="comment">//启动线程处理数据包</span></span><br><span class="line">                <span class="keyword">new</span> LogicThread(ds,receiveDp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//关闭连接</span></span><br><span class="line">                ds.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>该代码实现了服务器端的接收逻辑，使用一个循环来接收客户端发送过来的数据包，当接收到数据包以后启动一个LogicThread线程处理该数据包。这样服务器端就可以实现同时处理多个数据包了。</p><p>实现逻辑处理的线程代码如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> udp;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 逻辑处理线程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogicThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**连接对象*/</span></span><br><span class="line">    DatagramSocket ds;</span><br><span class="line">    <span class="comment">/**接收到的数据包*/</span></span><br><span class="line">    DatagramPacket dp;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogicThread</span><span class="params">(DatagramSocket ds,DatagramPacket dp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ds = ds;</span><br><span class="line">        <span class="keyword">this</span>.dp = dp;</span><br><span class="line">        start(); <span class="comment">//启动线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//获得缓冲数组</span></span><br><span class="line">            <span class="keyword">byte</span>[] data = dp.getData();</span><br><span class="line">            <span class="comment">//获得有效数据长度</span></span><br><span class="line">            <span class="keyword">int</span> len = dp.getLength();</span><br><span class="line">            <span class="comment">//客户端IP</span></span><br><span class="line">            InetAddress clientAddress = dp.getAddress();</span><br><span class="line">            <span class="comment">//客户端端口</span></span><br><span class="line">            <span class="keyword">int</span> clientPort = dp.getPort();</span><br><span class="line">            <span class="comment">//输出</span></span><br><span class="line">            System.out.println(<span class="string">"客户端IP："</span> + clientAddress.getHostAddress());</span><br><span class="line">            System.out.println(<span class="string">"客户端端口号："</span> + clientPort);</span><br><span class="line">            System.out.println(<span class="string">"客户端发送内容："</span> + <span class="keyword">new</span> String(data,<span class="number">0</span>,len));</span><br><span class="line">            <span class="comment">//反馈到客户端</span></span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="string">"OK"</span>.getBytes();</span><br><span class="line">            DatagramPacket sendDp = <span class="keyword">new</span> DatagramPacket(b,b.length,clientAddress,clientPort);</span><br><span class="line">            <span class="comment">//发送</span></span><br><span class="line">            ds.send(sendDp);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在该线程中，只处理一次UDP通讯，当通讯结束以后线程死亡，在线程内部，每次获得客户端发送过来的信息，将获得的信息输出到服务器端程序的控制台，然后向客户端反馈字符串“OK”。</p><p><strong>由于UDP数据传输过程中可能存在丢失，所以在运行该程序时可能会出现程序阻塞的情况。</strong>如果需要避免该问题，可以<strong>将客户端的网络发送部分也修改成线程实现</strong>。</p><h3 id="情况：得不到服务器的响应，一直阻塞"><a href="#情况：得不到服务器的响应，一直阻塞" class="headerlink" title="情况：得不到服务器的响应，一直阻塞"></a>情况：得不到服务器的响应，一直阻塞</h3><p><img src="https://i.imgur.com/ONgEpnm.png" alt=""><br>正常运行的情况：<br><img src="https://i.imgur.com/gPAL9qU.png" alt=""><br>客户端接收响应的时候，设置超时时间，超时的时候停止等待接收。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0;i &lt; 10;i++)</span><br><span class="line">&#123;</span><br><span class="line">    //初始化发送数据</span><br><span class="line">    Date d = new Date(); //当前时间</span><br><span class="line">    String content = d.toString(); //转换为字符串</span><br><span class="line">    byte[] data = content.getBytes();</span><br><span class="line">    //初始化发送包对象</span><br><span class="line">    sendDp = new DatagramPacket(data,data.length,address, serverPort);</span><br><span class="line">    //发送</span><br><span class="line">    ds.send(sendDp);</span><br><span class="line">    //设置接收的延时如果超过这个时间就不在等待接收</span><br><span class="line">    ds.setSoTimeout(3000);</span><br><span class="line">    //接收</span><br><span class="line">    ds.receive(receiveDp);</span><br><span class="line">    //读取反馈内容，并输出</span><br><span class="line">    byte[] response = receiveDp.getData();</span><br><span class="line">    int len = receiveDp.getLength();</span><br><span class="line">    String s = new String(response,0,len);</span><br><span class="line">    System.out.println(&quot;服务器端反馈为：&quot; + s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这样当客户端长时间接收不到服务器的响应的时候，就会抛出<code>java.net.SocketTimeoutException</code>异常，客户端被终止运行。<br>超时的运行效果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">客户端准备完成</span><br><span class="line">服务器端反馈为：OK</span><br><span class="line">java.net.SocketTimeoutException: Receive timed out</span><br><span class="line">        at java.net.DualStackPlainDatagramSocketImpl.socketReceiveOrPeekData(Native Method)</span><br><span class="line">        at java.net.DualStackPlainDatagramSocketImpl.receive0(DualStackPlainDatagramSocketImpl.java:124)</span><br><span class="line">        at java.net.AbstractPlainDatagramSocketImpl.receive(AbstractPlainDatagramSocketImpl.java:143)</span><br><span class="line">        at java.net.DatagramSocket.receive(DatagramSocket.java:812)</span><br><span class="line">        at udp.MulUDPClient.main(MulUDPClient.java:40)</span><br></pre></td></tr></table></figure><p></p><p>关于基础的UDP网络编程就介绍这么多了，下面将介绍一下网络协议的概念。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/b6cecc51/">UDP网络编程</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> java 网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>5TCP编程优化</title>
      <link href="/blog/5eef6183/"/>
      <url>/blog/5eef6183/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>在前面的示例中，客户端中建立了一次连接，只发送一次数据就关闭了，这就相当于拨打电话时，电话打通了只对话一次就关闭了，其实更加常用的应该是拨通一次电话以后多次对话，这就是<strong>复用客户端连接</strong>。</p><h2 id="把客户端交换的逻辑写到循环中"><a href="#把客户端交换的逻辑写到循环中" class="headerlink" title="把客户端交换的逻辑写到循环中"></a>把客户端交换的逻辑写到循环中</h2><p>那 么<strong>如何实现建立一次连接，进行多次数据交换呢？其实很简单，建立连接以后，将数据交换的逻辑写到一个循环中就可以了</strong>。这样只要循环不结束则连接就不会被关 闭。按照这种思路，可以改造一下上面的代码，让该程序可以在建立连接一次以后，发送三次数据，当然这里的次数也可以是多次，示例代码如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tcp;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 复用连接的Socket客户端</span></span><br><span class="line"><span class="comment">* 功能为：发送字符串“Hello”到服务器端，并打印出服务器端的反馈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MulSocketClient</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//服务器端IP地址</span></span><br><span class="line">        String serverIP = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">        <span class="comment">//服务器端端口号</span></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">10000</span>;</span><br><span class="line">        <span class="comment">//发送内容</span></span><br><span class="line">        String data[] =&#123;<span class="string">"First"</span>,<span class="string">"Second"</span>,<span class="string">"Third"</span>&#125;;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//建立连接</span></span><br><span class="line">            socket = <span class="keyword">new</span> Socket(serverIP,port);</span><br><span class="line">            <span class="comment">//初始化流</span></span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//输出全部的数据</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; data.length;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//发送数据</span></span><br><span class="line">                os.write(data[i].getBytes());</span><br><span class="line">                <span class="comment">//接收数据</span></span><br><span class="line">                <span class="keyword">int</span> n = is.read(b);</span><br><span class="line">                <span class="comment">//输出反馈数据</span></span><br><span class="line">                System.out.println(<span class="string">"服务器反馈："</span> + <span class="keyword">new</span> String(b,<span class="number">0</span>,n));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace(); <span class="comment">//打印异常信息</span></span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//关闭流和连接</span></span><br><span class="line">                is.close();</span><br><span class="line">                os.close();</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e2) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>该示例程序和前面的代码相比，将数据交换部分的逻辑写在一个for循环的内容，这样就可以建立一次连接，依次将data数组中的数据按照顺序发送给服务器端了。</p><p>如果还是使用前面示例代码中的服务器端程序运行该程序，则该程序的结果是：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">服务器反馈：First</span><br><span class="line">java.net.SocketException: Software caused connection abort: recv failed</span><br><span class="line">        at java.net.SocketInputStream.socketRead0(Native Method)</span><br><span class="line">        at java.net.SocketInputStream.socketRead(SocketInputStream.java:116)</span><br><span class="line">        at java.net.SocketInputStream.read(SocketInputStream.java:170)</span><br><span class="line">        at java.net.SocketInputStream.read(SocketInputStream.java:141)</span><br><span class="line">        at java.net.SocketInputStream.read(SocketInputStream.java:127)</span><br><span class="line">        at tcp.MulSocketClient.main(MulSocketClient.java:35)</span><br></pre></td></tr></table></figure><p></p><p>显然，客户端在实际运行时出现了异常，出现异常的原因是什么呢？如果仔细阅读前面的代码，应该还记得前面示例代码中的服务器端是对话一次数据以后就关闭了连接<strong>，如果服务器端程序关闭了，客户端继续发送数据肯定会出现异常</strong>，这就是出现该问题的原因。</p><p>按照客户端实现的逻辑，也可以复用服务器端的连接，实现的原理也是将服务器端的数据交换逻辑写在循环中即可，按照该种思路改造以后的服务器端代码为：</p><h2 id="把服务器端的数据交换逻辑写在循环"><a href="#把服务器端的数据交换逻辑写在循环" class="headerlink" title="把服务器端的数据交换逻辑写在循环"></a>把服务器端的数据交换逻辑写在循环</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tcp;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 复用连接的echo服务器</span></span><br><span class="line"><span class="comment">* 功能：将客户端发送的内容反馈给客户端</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MulSocketServer</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//监听端口号</span></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//建立连接</span></span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">            System.out.println(<span class="string">"服务器已启动："</span>);</span><br><span class="line">            <span class="comment">//获得连接</span></span><br><span class="line">            socket = serverSocket.accept();</span><br><span class="line">            <span class="comment">//初始化流</span></span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> n = is.read(b);</span><br><span class="line">                <span class="comment">//输出</span></span><br><span class="line">                System.out.println(<span class="string">"客户端发送内容为："</span> + <span class="keyword">new</span> String(b,<span class="number">0</span>,n));</span><br><span class="line">                <span class="comment">//向客户端发送反馈内容</span></span><br><span class="line">                os.write(b, <span class="number">0</span>, n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//关闭流和连接</span></span><br><span class="line">                os.close();</span><br><span class="line">                is.close();</span><br><span class="line">                socket.close();</span><br><span class="line">                serverSocket.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该示例代码中，也将数据发送和接收的逻辑写在了一个for循环内部，只是在实现时硬性的将循环次数规定成了<code>3</code>次，这样代码虽然比较简单，但是通用性比较差。</p><p>服务器端程序的输出结果为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">服务器已启动：</span><br><span class="line">客户端发送内容为：First</span><br><span class="line">客户端发送内容为：Second</span><br><span class="line">客户端发送内容为：Third</span><br></pre></td></tr></table></figure><p></p><p>客户端的输出结果为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">服务器反馈：First</span><br><span class="line">服务器反馈：Second</span><br><span class="line">服务器反馈：Third</span><br></pre></td></tr></table></figure><p></p><p>在该程序中，比较明显的体现出了“<code>请求-响应</code>”模型，也就是在客户端发起连接以后，</p><p>首先发送字符串“<code>First</code>”给服务器端，服务器端输出客户端发送的内容“<code>First</code>”，然后将客户端发送的内容再反馈给客户端，这样客户端也输出服务器反馈“<code>First</code>”，这样就完成了客户端和服务器端的一次对话，</p><p>紧接着客户端发送“<code>Second</code>”给服务器端，服务端输出“<code>Second</code>”，然后将“<code>Second</code>”再反馈给客户端，客户端再输出“<code>Second</code>”，从而完成第二次对话，第三次会话的过程和这个一样。</p><p>在这个过程中，<strong>每次都是客户端程序首先发送数据给服务器端，服务器接收数据以后，将结果反馈给客户端，客户端接收到服务器端的反馈，从而完成一次通讯过程。</strong></p><p>在该示例中，虽然解决了多次发送的问题，但是客户端和服务器端的次数控制还不够灵活，如果客户端的次数不固定怎么办呢？是否可以使用某个特殊的字符串，例如quit，表示客户端退出呢,这就涉及到网络协议的内容了，会在后续的网络应用示例部分详细介绍。下面开始介绍另外一个网络编程的突出问题。</p><h1 id="如何使服务器端支持多个客户端同时工作"><a href="#如何使服务器端支持多个客户端同时工作" class="headerlink" title="如何使服务器端支持多个客户端同时工作"></a>如何使服务器端支持多个客户端同时工作</h1><p>前面介绍的服务器端程序，只是实现了概念上的服务器端，离实际的服务器端程序结构距离还很遥远，如果需要让服务器端能够实际使用，那么最需要解决的问题就是——如何支持多个客户端同时工作。</p><p><strong>一个服务器端一般都需要同时为多个客户端提供通讯，如果需要同时支持多个客户端，则必须使用前面介绍的线程的概念</strong>。简单来说，也就是<strong>当服务器端接收到一个连接时，启动一个专门的线程处理和该客户端的通讯。</strong></p><p>按照这个思路改写的服务端示例程序将由两个部分组成，<code>MulThreadSocketServer</code>类实现服务器端控制，实现<strong>接收客户端连接，然后开启专门的逻辑线程处理该连接</strong>，<code>LogicThread</code>类实现对于一个客户端连接的逻辑处理，<strong>将处理的逻辑放置在该类的<code>run</code>方法中</strong>。该示例的代码实现为：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tcp;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 支持多客户端的服务器端实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MulThreadSocketServer</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//监听端口号</span></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//建立连接</span></span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">            System.out.println(<span class="string">"服务器已启动："</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//获得连接</span></span><br><span class="line">                socket = serverSocket.accept();</span><br><span class="line">                <span class="comment">//启动线程处理连接</span></span><br><span class="line">                <span class="keyword">new</span> LogicThread(socket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//关闭连接</span></span><br><span class="line">                serverSocket.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在该示例代码中，实现了一个<code>while</code>形式的死循环，由于<code>accept</code>方法是阻塞方法，所以当客户端连接未到达时，将阻塞该程序的执行，当客户端到达时接收该连接，并启动一个新的<code>ResponseThread</code>线程处理该连接，然后按照循环的执行流程，继续等待下一个客户端连接。这样当任何一个客户端连接到达时，都开启一个专门的线程处理，通过多个线程支持多个客户端同时处理。<br>下面再看一下<code>ResponseThread</code>线程类的源代码实现：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">package tcp;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.net.*;</span><br><span class="line">/**</span><br><span class="line">* 服务器端逻辑线程</span><br><span class="line">*/</span><br><span class="line">public class ResponseThread extends Thread </span><br><span class="line">&#123;</span><br><span class="line">    Socket socket;</span><br><span class="line">    InputStream in;</span><br><span class="line">    OutputStream out;</span><br><span class="line">    public ResponseThread(Socket socket)</span><br><span class="line">    &#123;</span><br><span class="line">        this.socket = socket;</span><br><span class="line">        start(); //启动线程</span><br><span class="line">    &#125;</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        byte[] receive = new byte[1024];</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            response(receive);</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">/**   </span><br><span class="line"> * @param receive 接收到的数据</span><br><span class="line"> * @throws IOException  </span><br><span class="line"> */  </span><br><span class="line">public void response(byte[] receive) throws IOException</span><br><span class="line">&#123;</span><br><span class="line">//初始化流</span><br><span class="line">out = socket.getOutputStream();</span><br><span class="line">in = socket.getInputStream();</span><br><span class="line">for(int i = 0;i &lt; 3;i++)</span><br><span class="line">&#123;</span><br><span class="line">    //读取数据</span><br><span class="line">    int n = in.read(receive);</span><br><span class="line">    //反馈数据</span><br><span class="line">    out.write(receive,0,n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    /**</span><br><span class="line">    * 关闭流和连接</span><br><span class="line">    */</span><br><span class="line">    private void close()</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            //关闭流和连接</span><br><span class="line">            out.close();</span><br><span class="line">            in.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;catch(Exception e)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在该示例代码中，每次使用一个连接对象构造一个处理线程，该连接对象就是该线程需要处理的连接，在线程构造完成以后，该线程就被启动起来了，然后<strong>在<code>run</code>方法内部对客户端连接进行处理</strong>，数据交换的逻辑和前面的示例代码一致，只是这里将接收到客户端发送过来的数据并进行处理的逻辑封装成了<code>response</code>方法，实现的是<code>echo</code>服务的逻辑。</p><h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h3><h4 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -d . MulThreadSocketServer.java</span><br></pre></td></tr></table></figure><p>编译结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MulThreadSocketServer.java:26: 错误: 找不到符号</span><br><span class="line">                new ResponseThread(socket);</span><br><span class="line">                    ^</span><br><span class="line">  符号:   类 ResponseThread</span><br><span class="line">  位置: 类 MulThreadSocketServer</span><br><span class="line">1 个错误</span><br></pre></td></tr></table></figure><p></p><p>换到IDE中运行，运行起来是好好的，但是CMD中却报这样的错误。<br>这是怎么回事呢，这个其实是因为<code>ResponseThread.class</code>没有，所以应该先编译<code>ResponseThread</code>,然后再编译<code>MulThreadSocketServer</code><br>编译响应逻辑线程：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -d . ResponseThread.java</span><br></pre></td></tr></table></figure><p></p><p>编译服务器：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -d . MulThreadSocketServer.java</span><br></pre></td></tr></table></figure><p></p><p>运行服务器：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java tcp.MulThreadSocketServer</span><br></pre></td></tr></table></figure><p></p><p>运行客户端1：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java tcp.MulSocketClient</span><br></pre></td></tr></table></figure><p></p><p>运行客户端2：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java tcp.MulSocketClient</span><br></pre></td></tr></table></figure><p></p><p>两个客户端的响应效果如下所示：</p><p><img src="https://i.imgur.com/DjjkjBK.png" alt="两个服务器的响应效果"></p><p>这里的示例还只是基础的服务器端实现，在实际的服务器端实现中，由于硬件和端口数的限制，所以不能无限制的创建线程对象，而且频繁的创建线程对象效率也比较低，所以程序中都实现了线程池来提高程序的执行效率。</p><h2 id="使用线程池"><a href="#使用线程池" class="headerlink" title="使用线程池"></a>使用线程池</h2><p>这里简单介绍一下线程池的概念，<strong>线程池(<code>Thread pool)</code>是池技术的一种，就是在程序启动时首先把需要的线程对象创建好</strong>，例如创建<code>5000</code>个线程对象，<strong>然后当客户端连接到达时从线程池中取出一个已经创建完成的线程对象使用即可</strong>。<strong>当客户端连接关闭以后，将该线程对象重新放入到线程池中供其它的客户端重复使用</strong>，这样可以提高程序的执行速度，优化程序对于内存的占用等。</p><p>关于基础的<code>TCP</code>方式的网络编程就介绍这么多，下面介绍<code>UDP</code>方式的网络编程在<code>Java</code>语言中的实现。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/5eef6183/">5TCP编程优化</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> java 网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>4TCP编程</title>
      <link href="/blog/dfafaccc/"/>
      <url>/blog/dfafaccc/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>按照前面的介绍，<strong>网络通讯的方式有<code>TCP</code>和<code>UDP</code>两种</strong>，其中<code>TCP</code>方式的网络通讯是指在通讯的过程中保持连接，有点类似于打电话，只需要拨打一次号码(建立一次网络连接)，就可以多次通话(多次传输数据)。这样方式在实际的网络编程中，由于传输可靠，类似于打电话，如果甲给乙打电话，乙说没有听清楚让甲重复一遍，直到乙听清楚为止，实际的网络传输也是这样，如果发送的一方发送的数据接收方觉得有问题，则网络底层会自动要求发送方重发，直到接收方收到为止。</p><p>在<code>Java</code>语言中，对于<code>TCP</code>方式的网络编程提供了良好的支持，在实际实现时，<strong>以<code>java.net.Socket</code>类代表客户端连接，以<code>java.net.ServerSocket</code>类代表服务器端连接</strong>。在进行网络编程时，底层网络通讯的细节已经实现了比较高的封装，所以在程序员实际编程时，只需要指定<code>IP</code>地址和<code>端口号码</code>就可以建立连接了。正是由于这种高度的封装，一方面简化了<code>Java</code>语言网络编程的难度，另外也使得使用<code>Java</code>语言进行网络编程时无法深入到网络的底层，所以使用<code>Java</code>语言进行网络底层系统编程很困难，具体点说，<code>Java</code>语言无法实现底层的网络嗅探以及获得<code>IP</code>包结构等信息。但是由于<code>Java</code>语言的网络编程比较简单，所以还是获得了广泛的使用。</p><p>在使用<code>TCP</code>方式进行网络编程时，需要按照前面介绍的网络编程的步骤进行，下面分别介绍一下<strong>在<code>Java</code>语言中客户端和服务器端的实现步骤。</strong></p><h2 id="客户端网络编程"><a href="#客户端网络编程" class="headerlink" title="客户端网络编程"></a>客户端网络编程</h2><h3 id="第一步：建立连接"><a href="#第一步：建立连接" class="headerlink" title="第一步：建立连接"></a>第一步：建立连接</h3><p>在客户端网络编程中，首先需要建立连接，在<code>Java API</code>中以<code>java.net.Socket</code>类的对象代表网络连接，<strong>所以建立客户端网络连接，也就是创建<code>Socket</code>类型的对象</strong>，该对象代表网络连接，示例如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Socket socket1 = <span class="keyword">new</span> Socket(“<span class="number">192.168</span>.1.103”,<span class="number">10000</span>);</span><br><span class="line">Socket socket2 = <span class="keyword">new</span> Socket(“github.com”,<span class="number">80</span>);</span><br></pre></td></tr></table></figure><p></p><p>上面的代码中，<code>socket1</code>实现的是连接到<code>IP</code>地址是<code>192.168.1.103</code>的计算机的<code>10000</code>号端口，而<code>socket2</code>实现的是连接到域名是<code>www.sohu.com</code>的计算机的<code>80</code>号端口，至于底层网络如何实现建立连接，对于程序员来说是完全透明的。如果建立连接时，本机网络不通，或服务器端程序未开启，则会抛出异常。</p><h3 id="第二步-交换数据"><a href="#第二步-交换数据" class="headerlink" title="第二步: 交换数据"></a>第二步: 交换数据</h3><p>连接一旦建立，则完成了客户端编程的第一步，紧接着的步骤就是按照“请求-响应”模型进行网络数据交换，在<code>Java</code>语言中，<strong>数据传输功能由<code>Java IO</code>实现，也就是说只需要从连接中获得<code>输入流</code>和<code>输出流</code>即可</strong>，然后<code>将需要发送的数据写入连接对象的输出流</code>中，在发送完成以后<code>从输入流中读取数据</code>即可。示例代码如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OutputStream os = socket1.getOutputStream(); //获得输出流，用来想服务发送请求</span><br><span class="line">InputStream is = socket1.getInputStream();     //获得输入流,用来读取服务器的响应</span><br></pre></td></tr></table></figure><p></p><p>上面的代码中，分别从<code>socket1</code>这个连接对象获得了输出流和输入流对象，在整个网络编程中，后续的数据交换就变成了<code>IO</code>操作，也就是遵循“<code>请求-响应</code>”模型的规定，<strong>先向输出流中写入数据</strong>，这些数据会被系统发送出去，<strong>然后再从输入流中读取服务器端的反馈信息，这样就完成了一次数据交换过程</strong>，当然这个数据交换过程可以多次进行。</p><p>这里获得的只是最基本的输出流和输入流对象，还可以根据前面学习到的<code>IO</code>知识，<strong>使用流的嵌套将这些获得到的基本流对象转换成需要的装饰流对象，从而方便数据的操作。</strong></p><h3 id="第三步：关闭网络连接"><a href="#第三步：关闭网络连接" class="headerlink" title="第三步：关闭网络连接"></a>第三步：关闭网络连接</h3><p>最后当数据交换完成以后，关闭网络连接，释放网络连接占用的系统端口和内存等资源，完成网络操作，示例代码如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket1.close();</span><br></pre></td></tr></table></figure><p></p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>这就是最基本的网络编程功能介绍。下面是一个简单的网络客户端程序示例，该程序的作用是向服务器端发送一个字符串“Hello”，并将服务器端的响应显示到控制台，数据交换只进行一次，当数据交换进行完成以后关闭网络连接，程序结束。实现的代码如下：<br>实例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">package tcp;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.net.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 简单的Socket客户端</span><br><span class="line"> * 功能为：发送字符串“Hello”到服务器端，并打印出服务器端的响应</span><br><span class="line"> */</span><br><span class="line">public class SimpleSocketClient</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">Socket socket = null;</span><br><span class="line">InputStream is = null;</span><br><span class="line">OutputStream os = null;</span><br><span class="line">// 服务器端IP地址</span><br><span class="line">String serverIP = &quot;127.0.0.1&quot;;</span><br><span class="line">// 服务器端端口号</span><br><span class="line">int serverPort = 10000;</span><br><span class="line">// 发送内容</span><br><span class="line">String request = &quot;Hello&quot;;</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">// 第一步:建立连接</span><br><span class="line">socket = new Socket(serverIP, serverPort);</span><br><span class="line"></span><br><span class="line">// 第二步:交换数据</span><br><span class="line">// 获取输出流</span><br><span class="line">os = socket.getOutputStream();</span><br><span class="line">// 发送数据给服务器</span><br><span class="line">os.write(request.getBytes());</span><br><span class="line">// 接收服务器的数据</span><br><span class="line">is = socket.getInputStream();</span><br><span class="line">byte[] response = new byte[1024];</span><br><span class="line">int size = is.read(response);</span><br><span class="line">// 输出反馈数据</span><br><span class="line">System.out.println(&quot;服务器响应：&quot; + new String(response, 0, size));</span><br><span class="line">&#125; catch (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">e.printStackTrace(); // 打印异常信息</span><br><span class="line">&#125; finally</span><br><span class="line">&#123;</span><br><span class="line">if(os!=null)</span><br><span class="line">&#123;</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">os.close();</span><br><span class="line">&#125; catch (IOException e)</span><br><span class="line">&#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(is!=null)</span><br><span class="line">&#123;</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">is.close();</span><br><span class="line">&#125; catch (IOException e)</span><br><span class="line">&#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(socket!=null)</span><br><span class="line">&#123;</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">socket.close();</span><br><span class="line">&#125; catch (IOException e)</span><br><span class="line">&#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在该示例代码中<code>建立了一个连接到</code>IP<code>地址为</code>127.0.0.1<code>，端口号码为</code>10000<code>的</code>TCP<code>类型的网络连接</code>，然后获得连接的输出流对象，将需要发送的字符串“<code>Hello</code>”转换为<code>byte</code>数组写入到输出流中，由系统自动完成将输出流中的数据发送出去，如果需要强制发送，可以调用输出流对象中的<code>flush</code>方法实现。在数据发送出去以后，从连接对象的输入流中读取服务器端的反馈信息，读取时可以使用<code>IO</code>中的各种读取方法进行读取，这里使用最简单的方法进行读取，<strong>从输入流中读取到的内容就是服务器端的响应</strong>，并将读取到的内容在客户端的控制台进行输出，最后依次关闭打开的流对象和网络连接对象。</p><p>这是一个简单的功能示例，在该示例中演示了<code>TCP</code>类型的<code>网络客户端</code>基本方法的使用，该代码只起演示目的，还无法达到实用的级别。</p><h2 id="TCP客户端编程"><a href="#TCP客户端编程" class="headerlink" title="TCP客户端编程"></a>TCP客户端编程</h2><p>介绍完一个简单的客户端编程的示例，下面接着介绍一下<code>TCP</code>类型的服务器端的编写。首先需要说明的是，<strong>客户端的步骤和服务器端的编写步骤不同</strong>，所以在学习服务器端编程时注意不要和客户端混淆起来。</p><h3 id="第一步：监听窗口"><a href="#第一步：监听窗口" class="headerlink" title="第一步：监听窗口"></a>第一步：监听窗口</h3><p>在服务器端程序编程中，由于服务器端实现的是被动等待连接，所以服<strong>务器端编程的第一个步骤是监听端口</strong>，也就是监听是否有客户端连接到达。实现服务器端监听的代码为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket ss = new ServerSocket(10000);</span><br></pre></td></tr></table></figure><p></p><p>该代码实现的功能是监听当前计算机的<code>10000</code>号端口，如果在执行该代码时，<code>10000</code>号端口已经被别的程序占用，那么将抛出异常。否则将实现监听。</p><h3 id="第二步：建立连接"><a href="#第二步：建立连接" class="headerlink" title="第二步：建立连接"></a>第二步：建立连接</h3><p>服务器端编程的第二个步骤是获得连接<strong>。该步骤的作用是当有客户端连接到达时，建立一个和客户端连接对应的<code>Socket</code>连 接对象，从而释放客户端连接对于服务器端端口的占用</strong>。实现功能就像公司的前台一样，当一个客户到达公司时，会告诉前台我找某某某，然后前台就通知某某某， 然后就可以继续接待其它客户了。通过获得连接，使得客户端的连接在服务器端获得了保持，另外使得服务器端的端口释放出来，可以继续等待其它的客户端连接。 实现获得连接的代码是：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socket socket = ss.accept();</span><br></pre></td></tr></table></figure><p></p><p>该代码实现的功能是<strong>获得当前连接到服务器端的客户端连接</strong>。需要说明的是<strong><code>accept</code>和<code>IO</code>部分介绍的<code>read</code>方法一样，都是一个阻塞方法，也就是当无连接时，该方法将阻塞程序的执行，直到连接到达时才执行该行代码。</strong>另外获得的连接会在服务器端的该端口注册，这样以后就可以通过在服务器端的注册信息直接通信，而注册以后服务器端的端口就被释放出来，又可以继续接受其它的连接了。</p><h3 id="第三步：交换数据"><a href="#第三步：交换数据" class="headerlink" title="第三步：交换数据"></a>第三步：交换数据</h3><p>连接获得以后，后续的编程就和客户端的网络编程类似了，这里获得的Socket类型的连接就和客户端的网络连接一样了，只是<strong>服务器端需要首先读取发送过来的数据，然后进行逻辑处理以后再发送给客户端，也就是交换数据的顺序和客户端交换数据的步骤刚好相反。</strong>这部分的内容和客户端很类似，所以就不重复了，如果还不熟悉，可以参看下面的示例代码。</p><h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h3><p>最后，在服务器端通信完成以后，关闭服务器端连接。实现的代码为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss.close();</span><br></pre></td></tr></table></figure><p></p><p>这就是基本的<code>TCP</code>类型的服务器端编程步骤。下面以一个简单的<code>echo</code>服务实现为例子，介绍综合使用示例。<code>echo</code>的意思就是“回声”，<strong><code>echo</code>服务器端实现的功能就是将客户端发送的内容再原封不动的反馈给客户端。</strong>实现的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tcp;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * echo服务器 功能：将客户端发送的内容反馈给客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSocketServer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">Socket socket = <span class="keyword">null</span>;</span><br><span class="line">OutputStream out = <span class="keyword">null</span>;</span><br><span class="line">InputStream in = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 监听端口号</span></span><br><span class="line"><span class="keyword">int</span> port = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 建立连接</span></span><br><span class="line">serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line"><span class="comment">// 获得连接</span></span><br><span class="line">socket = serverSocket.accept();</span><br><span class="line"><span class="comment">// 接收客户端发送内容</span></span><br><span class="line">in = socket.getInputStream();</span><br><span class="line"><span class="keyword">byte</span>[] recive = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> size = in.read(recive);</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">System.out.println(<span class="string">"客户端发送内容为："</span> + <span class="keyword">new</span> String(recive, <span class="number">0</span>, size));</span><br><span class="line"><span class="comment">// 向客户端发送反馈内容</span></span><br><span class="line">out = socket.getOutputStream();</span><br><span class="line">out.write(recive, <span class="number">0</span>, size);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 关闭流和连接</span></span><br><span class="line">out.close();</span><br><span class="line">in.close();</span><br><span class="line">socket.close();</span><br><span class="line">serverSocket.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该示例代码中建立了一个监听当前计算机<code>10000</code>号端口的服务器端<code>Socket</code>连接，然后获得客户端发送过来的连接，如果有连接到达时，读取连接中发送过来的内容，并将发送的内容在控制台进行输出，输出完成以后将客户端发送的内容再反馈给客户端。最后关闭流和连接对象，结束程序。</p><h3 id="运行客户端和服务端-："><a href="#运行客户端和服务端-：" class="headerlink" title="运行客户端和服务端 ###："></a>运行客户端和服务端 ###：</h3><p>因为在IDE中只有一个控制台窗口，所以运行效果不明显，所以这里再cmd命令行中编译运行简单点。</p><ul><li>编译运行服务器<br>在cmd中编译服务器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -d . SimpleSocketServer.java</span><br></pre></td></tr></table></figure></li></ul><p>在cmd中运行服务器<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java tcp.SimpleSocketServer</span><br></pre></td></tr></table></figure><p></p><p>此时，服务器端将阻塞，等待客户端的连接。<br><img src="https://i.imgur.com/VcFSVEN.png" alt="服务器等待客户端的连接"></p><ul><li>编译运行客户端<br>在cmd中编译客户端<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -d . SimpleSocketClient.java</span><br></pre></td></tr></table></figure></li></ul><p>在cmd中运行客户端<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java tcp.SimpleSocketClient</span><br></pre></td></tr></table></figure><p></p><p><img src="https://i.imgur.com/SV1h4R1.png" alt="编译运行客户端"><br>运行结果：<br><img src="https://i.imgur.com/mEFqwtO.png" alt=""></p><p>这样，就以一个很简单的示例演示了<code>TCP</code>类型的网络编程在<code>Java</code>语言中的基本实现，这个示例只是演示了网络编程的基本步骤以及各个功能方法的基本使用，只是为网络编程打下了一个基础，下面将就几个问题来深入介绍网络编程深层次的一些知识。<br>为了一步一步的掌握网络编程，下面再研究网络编程中的两个基本问题，通过解决这两个问题将对网络编程的认识深入一层。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/dfafaccc/">4TCP编程</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> java 网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>3Java网络编程技术</title>
      <link href="/blog/eadab85c/"/>
      <url>/blog/eadab85c/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p><code>Java</code>语言是在网络环境下诞生的，所以<code>Java</code>语言虽然不能说是对于网络编程的支持最好的语言，但是必须说是一种对于网络编程提供良好支持的语言，使用<code>Java</code>语言进行网络编程将是一件比较轻松的工作。</p><p><strong>和网络编程有关的基本<code>API</code>位于<code>java.net</code>包中</strong>，该包中包含了基本的网络编程实现，该包是网络编程的基础。该包中既包含基础的网络编程类，也包含封装后的专门处理<code>WEB</code>相关的处理类。在本章中，将只介绍基础的网络编程类。</p><p>首先来介绍一个基础的网络类——<code>InetAddress</code>类。该类的功能是代表一个<code>IP</code>地址，是<code>ip</code>地址的<code>java</code>表示方式。并且将<code>IP</code>地址和域名相关的操作方法包含在该类的内部。</p><h2 id="InetAddress类–代表一个IP地址"><a href="#InetAddress类–代表一个IP地址" class="headerlink" title="InetAddress类–代表一个IP地址"></a><code>InetAddress</code>类–代表一个<code>IP</code>地址</h2><h3 id="创建InetAddress类实例的方法"><a href="#创建InetAddress类实例的方法" class="headerlink" title="创建InetAddress类实例的方法"></a>创建InetAddress类实例的方法</h3><p><strong><code>InetAddress</code>没有<code>public</code>构造器，必须通过一系列的静态方法获取实例。</strong>如下表所示。</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>static InetAddress[] getAllByName(String host)</code></td><td style="text-align:left">在给定主机名的情况下，根据系统上配置的名称服务返回其 IP 地址所组成的数组。</td></tr><tr><td style="text-align:left"><code>static InetAddress getByAddress(byte[] addr)</code></td><td style="text-align:left">在给定原始 IP 地址的情况下，返回 InetAddress 对象。</td></tr><tr><td style="text-align:left"><code>static InetAddress getByAddress(String host, byte[] addr)</code></td><td style="text-align:left">根据提供的主机名和 IP 地址创建 InetAddress。</td></tr><tr><td style="text-align:left"><code>static InetAddress getByName(String host)</code></td><td style="text-align:left">在给定主机名的情况下确定主机的 IP 地址。</td></tr><tr><td style="text-align:left"><code>static InetAddress getLocalHost()</code></td><td style="text-align:left">返回本地主机。</td></tr></tbody></table><p>在这些静态方法中，最为常用的应该是<code>getByName(String host)</code>方法，只需要传入目标主机的名字，</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>通过域名获取<code>InetAddress</code>对象：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用域名创建InetAddress对象</span></span><br><span class="line">InetAddress inetAddr = InetAddress.getByName(<span class="string">"github.com"</span>);</span><br></pre></td></tr></table></figure><p></p><p>通过IP地址获取InetAddress对象:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用点分十进制IP地址创建InetAddress对象</span></span><br><span class="line">InetAddress inetAddr = InetAddress.getByName(<span class="string">"52.74.223.119"</span>);</span><br></pre></td></tr></table></figure><p></p><p>获取本机的InetAddress对象:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InetAddress address = InetAddress.getLocalHost();</span><br></pre></td></tr></table></figure><p></p><h3 id="重写Object类的方法："><a href="#重写Object类的方法：" class="headerlink" title="重写Object类的方法："></a>重写Object类的方法：</h3><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>boolean equals(Object obj)</code></td><td style="text-align:left">将此对象与指定对象比较。</td></tr><tr><td style="text-align:left"><code>int hashCode()</code></td><td style="text-align:left">返回此 IP 地址的哈希码。</td></tr><tr><td style="text-align:left"><code>String toString()</code></td><td style="text-align:left">将此 IP 地址转换为 String。</td></tr></tbody></table><p>实例：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据域名生成实例</span></span><br><span class="line">InetAddress inetAddr=InetAddress.getByName(<span class="string">"github.com"</span>);</span><br><span class="line">System.out.println(inetAddr.toString());</span><br><span class="line"><span class="comment">//根据IP地址生产实例</span></span><br><span class="line">inetAddr=InetAddress.getByName(<span class="string">"13.250.177.223"</span>);</span><br><span class="line">System.out.println(inetAddr.toString());</span><br><span class="line"><span class="comment">//获取本机</span></span><br><span class="line">inetAddr=InetAddress.getLocalHost();</span><br><span class="line">System.out.println(inetAddr.toString());</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">github.com/13.250.177.223</span><br><span class="line">/13.250.177.223</span><br><span class="line">DESKTOP-9H231R6/192.168.233.233</span><br></pre></td></tr></table></figure><p></p><h3 id="获取IP地址相关信息的方法"><a href="#获取IP地址相关信息的方法" class="headerlink" title="获取IP地址相关信息的方法"></a>获取IP地址相关信息的方法</h3><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>String getCanonicalHostName()</code></td><td style="text-align:left">获取此 IP 地址的完全限定域名。</td></tr><tr><td style="text-align:left"><code>String getHostAddress()</code></td><td style="text-align:left">获取点分十进制表示的ip地址</td></tr><tr><td style="text-align:left"><code>byte[] getAddress()</code></td><td style="text-align:left">获取字节数组表示的ip地址</td></tr><tr><td style="text-align:left"><code>String getHostName()</code></td><td style="text-align:left">获取此 IP 地址的主机名。</td></tr></tbody></table><p>实例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">// 使用域名创建对象</span><br><span class="line">InetAddress inetAddr = InetAddress.getByName(&quot;github.com&quot;);</span><br><span class="line">System.out.println(&quot;IP地址的完全限定域名：&quot; + inetAddr.getCanonicalHostName());</span><br><span class="line">System.out.println(&quot;主机IP地址为：&quot; + inetAddr.getHostAddress());</span><br><span class="line">System.out.println(&quot;主机名称为：&quot; + inetAddr.getHostName());</span><br><span class="line"></span><br><span class="line">// byte[] getAddress() 返回此 InetAddress 对象的原始 IP 地址。</span><br><span class="line">byte[] ipbyte = inetAddr.getAddress();// 获取原始IP地址</span><br><span class="line">System.out.println(&quot;字节数组表示的ip地址：&quot; + Arrays.toString(ipbyte));</span><br><span class="line">System.out.print(&quot;字节地址转为点分十进制表示:&quot;);</span><br><span class="line">for (int i = 0; i &lt; ipbyte.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">if (i != 0)</span><br><span class="line">System.out.print(&quot;.&quot;);</span><br><span class="line">System.out.print(Byte.toUnsignedInt(ipbyte[i]));</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125; catch (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IP地址的完全限定域名：ec2-52-74-223-119.ap-southeast-1.compute.amazonaws.com</span><br><span class="line">主机IP地址为：52.74.223.119</span><br><span class="line">主机名称为：github.com</span><br><span class="line">字节数组表示的ip地址：[52, 74, -33, 119]</span><br><span class="line">字节地址转为点分十进制表示:52.74.223.119</span><br></pre></td></tr></table></figure><p></p><p>从运行结果中可以看到<code>getHostAddress()</code>方法获取的是字符串表示的IP地址(点分十进制)，而<code>getAddress()</code>获取的是字节数组表示的IP地址，这两者只是表示方式不同而已，两者之间可以相互转化。</p><h3 id="判断方法："><a href="#判断方法：" class="headerlink" title="判断方法："></a>判断方法：</h3><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>boolean isAnyLocalAddress()</code></td><td style="text-align:left">检查 InetAddress 是否是通配符地址的实用例行程序。</td></tr><tr><td style="text-align:left"><code>boolean isLinkLocalAddress()</code></td><td style="text-align:left">检查 InetAddress 是否是链接本地地址的实用例行程序。</td></tr><tr><td style="text-align:left"><code>boolean isLoopbackAddress()</code></td><td style="text-align:left">检查 InetAddress 是否是回送地址的实用例行程序。</td></tr><tr><td style="text-align:left"><code>boolean isMCGlobal()</code></td><td style="text-align:left">检查多播地址是否具有全局域的实用例行程序。</td></tr><tr><td style="text-align:left"><code>boolean isMCLinkLocal()</code></td><td style="text-align:left">检查多播地址是否具有链接范围的实用例行程序。</td></tr><tr><td style="text-align:left"><code>boolean isMCNodeLocal()</code></td><td style="text-align:left">检查多播地址是否具有节点范围的实用例行程序。</td></tr><tr><td style="text-align:left"><code>boolean isMCOrgLocal()</code></td><td style="text-align:left">检查多播地址是否具有组织范围的实用例行程序。</td></tr><tr><td style="text-align:left"><code>boolean isMCSiteLocal()</code></td><td style="text-align:left">检查多播地址是否具有站点范围的实用例行程序。</td></tr><tr><td style="text-align:left"><code>boolean isMulticastAddress()</code></td><td style="text-align:left">检查 InetAddress 是否是 IP 多播地址的实用例行程序。</td></tr><tr><td style="text-align:left"><code>boolean isReachable(int timeout)</code></td><td style="text-align:left">测试是否可以达到该地址。</td></tr><tr><td style="text-align:left"><code>boolean isReachable(NetworkInterface netif,int ttl, int timeout)</code></td><td style="text-align:left">测试是否可以达到该地址。</td></tr><tr><td style="text-align:left"><code>boolean isSiteLocalAddress()</code></td><td style="text-align:left">检查 InetAddress 是否是站点本地地址的实用例行程序。</td></tr></tbody></table><p>本文链接: <a href="https://www.lansheng.net.cn/blog/eadab85c/">3Java网络编程技术</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> java 网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>2网络编程技术</title>
      <link href="/blog/20535608/"/>
      <url>/blog/20535608/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>原文:<a href="https://blog.csdn.net/sihai12345/article/details/79334299" target="_blank" rel="noopener">https://blog.csdn.net/sihai12345/article/details/79334299</a></p><p>前面介绍了网络编程的相关基础知识，初步建立了网络编程的概念，但是实际学习网络编程还必须使用某种程序设计语言进行代码实现，下面就介绍一下网络编程的代码实现。</p><h2 id="网络编程步骤"><a href="#网络编程步骤" class="headerlink" title="网络编程步骤"></a>网络编程步骤</h2><p>按照前面的基础知识介绍，<strong>无论使用TCP方式还是UDP方式进行网络通讯，网络编程都是由客户端和服务器端组成。</strong>当然<strong>，B/S结构的编程中只需要实现服务器端即可</strong>。所以，下面介绍网络编程的步骤时，均以C/S结构为基础进行介绍。</p><p>说明：这里的步骤实现和语言无关，也就是说，这个步骤适用于各种语言实现，不局限于Java语言。</p><h3 id="客户端网络编程步骤"><a href="#客户端网络编程步骤" class="headerlink" title="客户端网络编程步骤"></a>客户端网络编程步骤</h3><p><strong>客户端(Client)是指网络编程中首先发起连接的程序</strong>，客户端一般实现程序界面和基本逻辑实现，在进行实际的客户端编程时，无论客户端复杂还是简单，以及客户端实现的方式，客户端的编程主要由三个步骤实现：</p><h4 id="建立网络连接"><a href="#建立网络连接" class="headerlink" title="建立网络连接"></a>建立网络连接</h4><p><strong>客户端网络编程的第一步都是建立网络连接</strong>。<strong>在建立网络连接时需要指定连接到的服务器的IP地址和端口号</strong>，建立完成以后，会形成一条虚拟的连接，后续的操作就可以通过该连接实现数据交换了。</p><h4 id="交换数据"><a href="#交换数据" class="headerlink" title="交换数据"></a>交换数据</h4><p>连接建立以后，就可以通过这个连接交换数据了。<strong>交换数据严格按照请求响应模型进行，由客户端发送一个请求数据到服务器，服务器反馈一个响应数据给客户端</strong>，如果客户端不发送请求则服务器端就不响应。</p><p>根据逻辑需要，可以多次交换数据，但是还是必须遵循请求响应模型。</p><h4 id="关闭网络连接"><a href="#关闭网络连接" class="headerlink" title="关闭网络连接"></a>关闭网络连接</h4><p>在数据交换完成以后，关闭网络连接，释放程序占用的端口、内存等系统资源，结束网络编程。</p><p>最基本的步骤一般都是这三个步骤，在实际实现时，步骤2会出现重复，在进行代码组织时，由于网络编程是比较耗时的操作，所以一般开启专门的现场进行网络通讯。</p><h2 id="服务器端网络编程步骤"><a href="#服务器端网络编程步骤" class="headerlink" title="服务器端网络编程步骤"></a>服务器端网络编程步骤</h2><p><strong>服务器端(Server)是指在网络编程中被动等待连接的程序</strong>，服务器端一般实现程序的核心逻辑以及数据存储等核心功能。服务器端的编程步骤和客户端不同，是<strong>由四个步骤实现</strong>，依次是：</p><h3 id="监听端口"><a href="#监听端口" class="headerlink" title="监听端口"></a>监听端口</h3><p>服务器端属于被动等待连接，所以服务器端启动以后，不需要发起连接，而只需要监听本地计算机的某个固定端口即可。</p><p>这个端口就是服务器端开放给客户端的端口，服务器端程序运行的本地计算机的IP地址就是服务器端程序的IP地址。</p><h3 id="获得连接"><a href="#获得连接" class="headerlink" title="获得连接"></a>获得连接</h3><p>当客户端连接到服务器端时，服务器端就可以获得一个连接，这个连接包含客户端的信息，例如客户端IP地址等等，服务器端和客户端也通过该连接进行数据交换。</p><p>一般在服务器端编程中，当获得连接时，需要开启专门的线程处理该连接，每个连接都由独立的线程实现。</p><h3 id="交换数据-1"><a href="#交换数据-1" class="headerlink" title="交换数据"></a>交换数据</h3><p>服务器端通过获得的连接进行数据交换。<strong>服务器端的数据交换步骤是首先接收客户端发送过来的数据，然后进行逻辑处理，再把处理以后的结果数据发送给客户端</strong>。简单来说，就是<strong>先接收请求再发送处理结果(响应)</strong>，这个和客户端的数据交换数序不同。</p><p>其实，服务器端获得的连接和客户端连接是一样的，只是数据交换的步骤不同。</p><p>当然，服务器端的数据交换也是可以多次进行的。</p><p>在数据交换完成以后，关闭和客户端的连接。</p><h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h3><p>当服务器程序关闭时，需要关闭服务器端，通过关闭服务器端使得服务器监听的端口以及占用的内存可以释放出来，实现了连接的关闭。</p><h3 id="现实的例子"><a href="#现实的例子" class="headerlink" title="现实的例子"></a>现实的例子</h3><p>其实<strong>服务器端编程的模型和呼叫中心的实现是类似的</strong>，例如移动的客服电话10086就是典型的呼叫中心，当一个用户拨打10086时，转接给一个专门的客服人员，由该客服实现和该用户的问题解决，当另外一个用户拨打10086时，则转接给另一个客服，实现问题解决，依次类推。</p><p>在服务器端编程时，10086这个电话号码就类似于服务器端的端口号码，每个用户就相当于一个客户端程序，每个客服人员就相当于服务器端启动的专门和客户端连接的线程，每个线程都是独立进行交互的。</p><p>这就是服务器端编程的模型，<strong>只是TCP方式是需要建立连接的，对于服务器端的压力比较大，而UDP是不需要建立连接的，对于服务器端的压力比较小罢了</strong>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总之，<strong>无论使用任何语言，任何方式进行基础的网络编程，都必须遵循固定的步骤进行操作</strong>，在熟悉了这些步骤以后，可以根据需要进行逻辑上的处理，但是还是必须遵循固定的步骤进行。</p><p>其实，基础的网络编程本身不难，也不需要很多的基础网络知识，只是由于编程的基础功能都已经由API实现，而且需要按照固定的步骤进行，所以在入门时有一定的门槛，希望下面的内容能够将你快速的带入网络编程技术的大门。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/&#39;20535608&#39;/">2网络编程技术</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> java 网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>1网络概述</title>
      <link href="/blog/d9a41e7d/"/>
      <url>/blog/d9a41e7d/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>原文:<a href="https://blog.csdn.net/sihai12345/article/details/79334299" target="_blank" rel="noopener">https://blog.csdn.net/sihai12345/article/details/79334299</a></p><p><strong>网络编程就是在两个或两个以上的设备(例如计算机)之间传输数据。</strong><br><strong>程序员所作的事情就是把数据发送到指定的位置，或者接收到指定的数据，这个就是狭义的网络编程范畴。</strong><br>在发送和接收数据时，大部分的程序设计语言都设计了专门的API实现这些功能，程序员只需要调用即可。所以，基础的网络编程可以和打电话一样简单。</p><h2 id="网络概述"><a href="#网络概述" class="headerlink" title="网络概述"></a>网络概述</h2><h3 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h3><p><strong>网络编程的实质就是两个(或多个)设备(例如计算机)之间的数据传输。</strong></p><p><strong>网络最主要的优势在于共享</strong>：共享设备和数据，现在共享设备最常见的是打印机，一个公司一般一个打印机即可，共享数据就是将大量的数据存储在一组机器中，其它的计算机通过网络访问这些数据，例如网站、银行服务器等等。</p><p><strong>对于网络编程来说，最主要的是计算机和计算机之间的通信</strong>，这样首要的问题就是如何找到网络上的计算机呢？这就需要了解IP地址的概念。</p><h4 id="从网络中找到一个计算机–IP地址"><a href="#从网络中找到一个计算机–IP地址" class="headerlink" title="从网络中找到一个计算机–IP地址"></a>从网络中找到一个计算机–IP地址</h4><p><strong>为了能够方便的识别网络上的每个设备，网络中的每个设备都会有一个唯一的数字标识，这个就是IP地址。</strong>在计算机网络中,现在命名IP地址的规定是IPv4协议，该协议规定每个IP地址由4个0-255之间的数字组成，例如10.0.120.34。每个接入网络的计算机都拥有唯一的IP地址，这个IP地址可能是固定的，例如网络上各种各样的服务器，也可以是动态的，例如使用ADSL拨号上网的宽带用户，无论以何种方式获得或是否是固定的，<strong>每个计算机在联网以后都拥有一个唯一的合法IP地址</strong>，就像每个手机号码一样。</p><h4 id="域名–方便记忆"><a href="#域名–方便记忆" class="headerlink" title="域名–方便记忆"></a>域名–方便记忆</h4><p>但是由于IP地址不容易记忆，所以为了方便记忆，有创造了另外一个概念——域名(Domain Name)，例如sohu.com等。<strong>一个IP地址可以对应多个域名，一个域名只能对应一个IP地址。</strong>域名的概念可以类比手机中的通讯簿，由于手机号码不方便记忆，所以添加一个姓名标识号码，在实际拨打电话时可以选择该姓名，然后拨打即可。</p><p><strong>在网络中传输的数据，全部是以IP地址作为地址标识，所以在实际传输数据以前需要将域名转换为IP地址，实现这种功能的服务器称之为DNS服务器</strong>，也就是通俗的说法叫做域名解析。例如当用户在浏览器输入域名时，浏览器首先请求DNS服务器，将域名转换为IP地址，然后将转换后的IP地址反馈给浏览器，然后再进行实际的数据传输。</p><h4 id="域名和IP地址的区别"><a href="#域名和IP地址的区别" class="headerlink" title="域名和IP地址的区别"></a>域名和IP地址的区别</h4><p>当DNS服务器正常工作时，使用IP地址或域名都可以很方便的找到计算机网络中的某个设备，例如服务器计算机。<strong>当DNS不正常工作时，只能通过IP地址访问该设备。所以IP地址的使用要比域名通用一些。</strong></p><h4 id="在一个计算机中找到一个程序–端口"><a href="#在一个计算机中找到一个程序–端口" class="headerlink" title="在一个计算机中找到一个程序–端口"></a>在一个计算机中找到一个程序–端口</h4><p><strong>IP地址和域名很好的解决了在网络中找到一个计算机的问题</strong>，但是为了让一个计算机可以同时运行多个网络程序，就引入了另外一个概念——端口(port)。</p><p>在介绍端口的概念以前，首先来看一个例子，一般一个公司前台会有一个电话，每个员工会有一个分机，这样如果需要找到这个员工的话，需要首先拨打前台总机，然后转该分机号即可。这样减少了公司的开销，也方便了每个员工。在该示例中<strong>前台总机的电话号码就相当于IP地址，而每个员工的分机号就相当于端口。</strong></p><p>有了端口的概念以后，<strong>在同一个计算机中每个程序对应唯一的端口，这样一个计算机上就可以通过端口区分发送给每个端口的数据了</strong>，换句话说，也就是一个计算机上可以并发运行多个网络程序，而不会在互相之间产生干扰。</p><p>在硬件上规定<strong>，端口的号码必须位于0-65535之间，每个端口唯一的对应一个网络程序，一个网络程序可以使用多个端口。</strong>这样一个网络程序运行在一台计算上时，不管是客户端还是服务器，都是至少占用一个端口进行网络通讯。<strong>在接收数据时，首先发送给对应的计算机，然后计算机根据端口把数据转发给对应的程序。</strong></p><h4 id="在网络上找到一个程序：IP地址-端口号"><a href="#在网络上找到一个程序：IP地址-端口号" class="headerlink" title="在网络上找到一个程序：IP地址+端口号"></a>在网络上找到一个程序：IP地址+端口号</h4><p>有了IP地址和端口的概念以后，<strong>在进行网络通讯交换时，就可以通过IP地址查找到该台计算机，然后通过端口标识这台计算机上的一个唯一的程序</strong>。这样就可以进行网络数据的交换了。</p><p>但是，进行网络编程时，只有IP地址和端口的概念还是不够的，下面就介绍一下基础的网络编程相关的软件基础知识。</p><h1 id="网络编程概述"><a href="#网络编程概述" class="headerlink" title="网络编程概述"></a>网络编程概述</h1><p>按照前面的介绍，<strong>网络编程就是两个或多个设备之间的数据交换</strong>，<strong>其实更具体的说，网络编程就是两个或多个程序之间的数据交换</strong>，和普通的单机程序相比，网络程序最大的不同就是需要交换数据的程序运行在不同的计算机上，这样就造成了数据交换的复杂。虽然通过IP地址和端口可以找到网络上运行的一个程序，但是如果需要进行网络编程，则还需要了解网络通讯的过程。</p><h2 id="请求响应模型"><a href="#请求响应模型" class="headerlink" title="请求响应模型"></a>请求响应模型</h2><p>网络通讯基于“请求-响应”模型。为了理解这个模型，先来看一个例子，经常看电视的人肯定见过审讯的场面吧，一般是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">警察：姓名</span><br><span class="line">嫌疑犯：XXX</span><br><span class="line">警察：性别</span><br><span class="line">嫌疑犯：男</span><br><span class="line">警察：年龄</span><br><span class="line">嫌疑犯：29</span><br><span class="line">……</span><br></pre></td></tr></table></figure><h2 id="请求响应模型-1"><a href="#请求响应模型-1" class="headerlink" title="请求响应模型"></a>请求响应模型</h2><p>在这个例子中，警察问一句，嫌疑犯回答一句，如果警察不问，则嫌疑犯保持沉默。<strong>这种一问一答的形式就是网络中的“请求-响应”模型</strong>。也就是通讯的一端发送数据，另外一端反馈数据，网络通讯都基于该模型。</p><p>在网络通讯中，<strong>第一次主动发起通讯的程序被称作客户端(Client)程序，简称客户端</strong>，而<strong>在第一次通讯中等待连接的程序被称作服务器端(Server)程序，简称服务器</strong>。<strong>一旦通讯建立，则客户端和服务器端完全一样，没有本质的区别。</strong></p><h2 id="客户端-服务器结构"><a href="#客户端-服务器结构" class="headerlink" title="客户端/服务器结构"></a>客户端/服务器结构</h2><p>由此<strong>，网络编程中的两种程序就分别是客户端和服务器端</strong>，例如QQ程序，每个QQ用户安装的都是QQ客户端程序，而QQ服务器端程序则运行在腾讯公司的机房中，为大量的QQ用户提供服务。这种网络编程的结构被称作<strong>客户端/服务器结构</strong>，也叫做Client/Server结构，简称<strong>C/S结构</strong>。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>使用C/S结 构的程序，在开发时需要分别开发客户端和服务器端，这种结构的优势在于由于客户端是专门开发的，所以根据需要实现各种效果，专业点说就是表现力丰富，而服 务器端也需要专门进行开发。但是这种结构也存在着很多不足，例如通用性差，几乎不能通用等，也就是说<strong>一种程序的客户端只能和对应的服务器端通讯，而不能和 其它服务器端通讯，在实际维护时，也需要维护专门的客户端和服务器端，维护的压力比较大。</strong></p><h2 id="浏览器-服务器结构"><a href="#浏览器-服务器结构" class="headerlink" title="浏览器/服务器结构"></a>浏览器/服务器结构</h2><p>其实在运行很多程序时，没有必要使用专用的客户端，而需要使用通用的客户端，例如浏览器，使用<strong>浏览器作为客户端的结构被称作浏览器/服务器结构，也叫做Browser/Server结构，简称为B/S结构。</strong></p><p><strong>使用B/S结构的程序，在开发时只需要开发服务器端即可</strong></p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>这种结构的优势在于开发的压力比较小，不需要维护客户端。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>但是这种结构也存在着很多不足，例如浏览器的限制比较大，表现力不强，无法进行系统级操作等。</p><p>总之C/S结构和B/S结构是现在网络编程中常见的两种结构，B/S结构其实也就是一种特殊的C/S结构。</p><h2 id="P2P-Point-to-Point-程序"><a href="#P2P-Point-to-Point-程序" class="headerlink" title="P2P(Point to Point)程序"></a>P2P(Point to Point)程序</h2><p>另外简单的介绍一下P2P(Point to Point)程序，常见的如BT、电驴等。<strong>P2P程序是一种特殊的程序，应该一个P2P程序中既包含客户端程序，也包含服务器端程序</strong>，例如BT，使用客户端程序部分连接其它的种子(服务器端)，而使用服务器端向其它的BT客户端传输数据。如果这个还不是很清楚，其实P2P程序和手机是一样的，当手机拨打电话时就是使用客户端的作用，而手机处于待机状态时，可以接收到其它用户拨打的电话则起的就是服务器端的功能，只是一般的手机不能同时使用拨打电话和接听电话的功能，而P2P程序实现了该功能。</p><h2 id="协议-Protocol"><a href="#协议-Protocol" class="headerlink" title="协议(Protocol)"></a>协议(Protocol)</h2><p>最后再介绍一个网络编程中最重要，也是最复杂的概念——协议(Protocol)。按照前面的介绍，<strong>网络编程就是运行在不同计算机中两个程序之间的数据交换</strong>。在实际进行数据交换时，<strong>为了让接收端理解该数据</strong>，计算机比较笨，什么都不懂的，那么<strong>就需要规定该数据的格式，这个数据的格式就是协议。</strong></p><h3 id="协议的列子"><a href="#协议的列子" class="headerlink" title="协议的列子"></a>协议的列子</h3><p>如 果没有理解协议的概念，那么再举一个例子，记得有个电影叫《永不消逝的电波》，讲述的是地下党通过电台发送情报的故事，这里我们不探讨电影的剧情，而只关 心电台发送的数据。在<strong>实际发报时，需要首先将需要发送的内容转换为电报编码，然后将电报编码发送出去，而接收端接收的是电报编码，如果需要理解电报的内容 则需要根据密码本翻译出该电报的内容</strong>。<strong>这里的密码本就规定了一种数据格式，这种对于网络中传输的数据格式在网络编程中就被称作协议。</strong></p><p>那么如何来编写协议格式呢？答案是随意。只要按照这种协议格式能够生成唯一的编码，按照该编码可以唯一的解析出发送数据的内容即可。也正因为各个网络程序之间协议格式的不同，所以才导致了客户端程序都是专用的结构。</p><p>在实际的网络程序编程中，最麻烦的内容不是数据的发送和接收，因为这个功能在几乎所有的程序语言中都提供了封装好的API进行调用，最麻烦的内容就是协议的设计以及协议的生产和解析，这个才是网络编程中最核心的内容。</p><p>关于网络编程的基础知识，就介绍这里，深刻理解IP地址、端口和协议等概念，将会极大的有助于后续知识的学习。</p><h1 id="网络通讯方式"><a href="#网络通讯方式" class="headerlink" title="网络通讯方式"></a>网络通讯方式</h1><p>在现有的网络中，网络通讯的方式主要有两种：</p><ul><li>TCP(传输控制协议)方式</li><li>UDP(用户数据报协议)方式</li></ul><p>为 了方便理解这两种方式，还是先来看一个例子。大家使用手机时，向别人传递信息时有两种方式：拨打电话和发送短信。使用拨打电话的方式可以保证将信息传递给 别人，因为别人接听电话时本身就确认接收到了该信息。而发送短信的方式价格低廉，使用方便，但是接收人有可能接收不到。</p><p>在网络通讯中，<strong>TCP方式就类似于拨打电话</strong>，使用该种方式进行网络通讯时，<strong>需要建立专门的虚拟连接，然后进行可靠的数据传输，如果数据发送失败，则客户端会自动重发该数据。</strong></p><p>而<strong>UDP方式就类似于发送短信</strong>，使用这种方式进行网络通讯时，不需要建立专门的虚拟连接，传输也不是很可靠，如果发送失败则客户端无法获得。</p><p>这两种传输方式都是实际的网络编程中进行使用，<strong>重要的数据一般使用TCP方式进行数据传输</strong>，而大量的<strong>非核心数据则都通过UDP方式进行传递</strong>，在一些程序中甚至结合使用这两种方式进行数据的传递。</p><p>由于TCP需要建立专用的虚拟连接以及确认传输是否正确，所以使用TCP方式的速度稍微慢一些，而且传输时产生的数据量要比UDP稍微大一些。</p><p>关于网络编程的基础知识就介绍这么多，如果需要深入了解相关知识请阅读专门的计算机网络书籍，下面开始介绍Java语言中网络编程的相关技术。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/d9a41e7d/">1网络概述</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> java 网络编程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>markdown表格支持单元格合并</title>
      <link href="/blog/9d21d6ad/"/>
      <url>/blog/9d21d6ad/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>MarkDown语法并不支持表格单元格合并，不过可以插入html表格标签来实现。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;th&gt;序号</span><br><span class="line">&lt;/td&gt;</span><br><span class="line">&lt;th&gt;OSI的体系结构</span><br><span class="line">&lt;/td&gt;</span><br><span class="line">&lt;th&gt;TCP/IP的体系结构</span><br><span class="line">&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;7&lt;/td&gt;</span><br><span class="line">&lt;td&gt;应用层&lt;/td&gt;</span><br><span class="line">&lt;td rowspan=&quot;3&quot;&gt;应用层 (各种应用层协议如 TELNET, FTP, SMTP 等)&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;6&lt;/td&gt;</span><br><span class="line">&lt;td&gt;表示层&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;5&lt;/td&gt;</span><br><span class="line">&lt;td&gt;会话层&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;4&lt;/td&gt;</span><br><span class="line">&lt;td&gt;传输层&lt;/td&gt;</span><br><span class="line">&lt;td&gt;传输层&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;3&lt;/td&gt;</span><br><span class="line">&lt;td&gt;网络层&lt;/td&gt;</span><br><span class="line">&lt;td&gt;互连网络层&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;2&lt;/td&gt;</span><br><span class="line">&lt;td&gt;数据链路层&lt;/td&gt;</span><br><span class="line">&lt;td rowspan=&quot;2&quot;&gt;网络接入层&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;1&lt;/td&gt;</span><br><span class="line">&lt;td&gt;物理层&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><p></p><p>效果如下：</p><table><br><tr><br><th>序号<br></th><br><th>OSI的体系结构<br></th><br><th>TCP/IP的体系结构<br></th><br></tr><br><tr><br><td>7</td><br><td>应用层</td><br><td rowspan="3">应用层 (各种应用层协议如 TELNET, FTP, SMTP 等)</td><br></tr><br><tr><br><td>6</td><br><td>表示层</td><br></tr><br><tr><br><td>5</td><br><td>会话层</td><br></tr><br><tr><br><td>4</td><br><td>传输层</td><br><td>传输层</td><br></tr><br><tr><br><td>3</td><br><td>网络层</td><br><td>互连网络层</td><br></tr><br><tr><br><td>2</td><br><td>数据链路层</td><br><td rowspan="2">网络接入层</td><br></tr><br><tr><br><td>1</td><br><td>物理层</td><br></tr><br></table><br>是不是看起很奇怪，表格跟上面的文字隔了这么多行这是<code>&lt;table&gt;&lt;/table&gt;</code>标签之间有回车符造成的,删除这些回车符，这样就显示正常了，不过这样的坏处就是看起来很凌乱不好修改。<br>当然要是自己一行一行的删的话那得删到什么时候，最好使用正则表达式进行删除。我这里用的editplus这个编辑器。<br>把上面的代码粘贴到文件找那个，然后打开替换,使用正则表达式<code>\n\s+</code>进行替换即可。<br><img src="https://i.imgur.com/SeKfPU3.png" alt=""><br>点击Find按钮可以看到匹配的结果。<br><img src="https://i.imgur.com/A9GkZ8h.png" alt=""><br>可以看到已经匹配到换行符合多余的空格了，点击ReplaceAll按钮全部替换即可。<br>替换后的效果为：<br><img src="https://i.imgur.com/bGCze8K.png" alt=""><br>替换后的标签为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;&lt;tr&gt;&lt;th&gt;序号&lt;/th&gt;&lt;th&gt;OSI的体系结构&lt;/th&gt; &lt;th&gt;TCP/IP的体系结构&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;7&lt;/td&gt;&lt;td&gt;应用层&lt;/td&gt;&lt;td rowspan=&quot;3&quot;&gt;应用层  (各种应用层协议如 TELNET, FTP, SMTP 等)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;表示层&lt;/td&gt; &lt;/tr&gt;&lt;tr&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;会话层&lt;/td&gt; &lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4&lt;/td&gt; &lt;td&gt;传输层&lt;/td&gt;</span><br><span class="line">&lt;td&gt;传输层&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;网络层&lt;/td&gt;&lt;td&gt;互连网络层&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;数据链路层&lt;/td&gt;&lt;td rowspan=&quot;2&quot;&gt;网络接入层&lt;/td&gt; &lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt; &lt;td&gt;物理层&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</span><br></pre></td></tr></table></figure><br><br>显示效果：<table><tr><th>序号</th><th>OSI的体系结构</th><th>TCP/IP的体系结构</th></tr><tr><td>7</td><td>应用层</td><td rowspan="3">应用层 (各种应用层协议如 TELNET, FTP, SMTP 等)</td></tr><tr><td>6</td><td>表示层</td></tr><tr><td>5</td><td>会话层</td></tr><tr><td>4</td><td>传输层</td><br><td>传输层</td></tr><tr><td>3</td><td>网络层</td><td>互连网络层</td></tr><tr><td>2</td><td>数据链路层</td><td rowspan="2">网络接入层</td></tr><tr><td>1</td><td>物理层</td></tr></table><p>本文链接: <a href="https://www.lansheng.net.cn/blog/9d21d6ad/">markdown表格支持单元格合并</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> markdown使用 </category>
          
          <category> markdown语法 </category>
          
          <category> 使用html标签 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java IO流 PrintStream类</title>
      <link href="/blog/82040860/"/>
      <url>/blog/82040860/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object</span><br><span class="line">  |----&gt; java.io.OutputStream</span><br><span class="line">      |----&gt; java.io.FilterOutputStream</span><br><span class="line">          |----&gt; java.io.PrintStream</span><br></pre></td></tr></table></figure><p><code>public class PrintStream extends FilterOutputStream implements Appendable</code>, <code>Closeable</code><br><strong><code>PrintStream</code> 为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。</strong>它还提供其他两项功能。与其他输出流不同，<code>PrintStream</code> 永远不会抛出 <code>IOException</code>；而是，异常情况仅设置可通过 <code>checkError</code> 方法测试的内部标志。另外，为了自动刷新，可以创建一个 <code>PrintStream</code>；这意味着可在写入 <code>byte</code> 数组之后自动调用 <code>flush</code> 方法，可调用其中一个 <code>println</code> 方法，或写入一个换行符或字节 (‘<code>\n</code>‘)。</p><p><code>PrintStream</code> 打印的所有字符都使用平台的默认字符编码转换为字节。在需要写入字符而不是写入字节的情况下，应该使用 <code>PrintWriter</code> 类。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>PrintStream(File file)</code></td><td style="text-align:left">创建具有指定文件且不带自动行刷新的新打印流。</td></tr><tr><td style="text-align:left"><code>PrintStream(File file, String csn)</code></td><td style="text-align:left">创建具有指定文件名称和字符集且不带自动行刷新的新打印流。</td></tr><tr><td style="text-align:left"><code>PrintStream(OutputStream out)</code></td><td style="text-align:left">创建新的打印流。</td></tr><tr><td style="text-align:left"><code>PrintStream(OutputStream out, boolean autoFlush)</code></td><td style="text-align:left">创建新的打印流。</td></tr><tr><td style="text-align:left"><code>PrintStream(OutputStream out, boolean autoFlush, String encoding)</code></td><td style="text-align:left">创建新的打印流。</td></tr><tr><td style="text-align:left"><code>PrintStream(String fileName)</code></td><td style="text-align:left">创建具有指定文件名称且不带自动行刷新的新打印流。</td></tr><tr><td style="text-align:left"><code>PrintStream(String fileName, String csn)</code></td><td style="text-align:left">创建具有指定文件名称和字符集且不带自动行刷新的新打印流。</td></tr></tbody></table><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><h3 id="write-…-方法"><a href="#write-…-方法" class="headerlink" title="write(…)方法"></a>write(…)方法</h3><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>void write(byte[] buf, int off, int len)</code></td><td style="text-align:left">将 len 字节从指定的初始偏移量为 off 的 byte 数组写入此流。</td></tr><tr><td style="text-align:left"><code>void write(int b)</code></td><td style="text-align:left">将指定的字节写入此流。</td></tr></tbody></table><h4 id="write-int-b-源码："><a href="#write-int-b-源码：" class="headerlink" title="write(int b)源码："></a>write(int b)源码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void write(int b) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            ensureOpen();</span><br><span class="line">            out.write(b);</span><br><span class="line">            //如果这个字符是换行符,而且开启了自动刷新的话</span><br><span class="line">            if ((b == &apos;\n&apos;) &amp;&amp; autoFlush)</span><br><span class="line">                out.flush();//调用flush()方法</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (InterruptedIOException x) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (IOException x) &#123;</span><br><span class="line">        trouble = true;//设置标志</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="write-int-b-详细描述"><a href="#write-int-b-详细描述" class="headerlink" title="write(int b)详细描述"></a>write(int b)详细描述</h4><blockquote><p>将指定的字节写入此流，如果这个字节是换行符而且开启了自动刷新的话，就会调用flush()方法<br>注意，字节是按给定的方式写入的。 要根据平台的默认字符编码编写一个字符，请使用print(char)或println(char)方法。<br>参数: b 将要写入的字节<br>覆盖：类 FilterOutputStream 中的 write</p></blockquote><h4 id="关于自动刷新"><a href="#关于自动刷新" class="headerlink" title="关于自动刷新"></a>关于自动刷新</h4><p>所以如果开启了自动刷新，write(int b)方法在写入回车符的时候会调用flush()方法</p><h4 id="write-byte-buf-int-off-int-len-源码"><a href="#write-byte-buf-int-off-int-len-源码" class="headerlink" title="write(byte buf[], int off, int len)源码"></a>write(byte buf[], int off, int len)源码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void write(byte buf[], int off, int len) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            ensureOpen();</span><br><span class="line">            out.write(buf, off, len);</span><br><span class="line">            if (autoFlush)</span><br><span class="line">                out.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (InterruptedIOException x) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (IOException x) &#123;</span><br><span class="line">        trouble = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="write-byte-buf-int-off-int-len-详细描述"><a href="#write-byte-buf-int-off-int-len-详细描述" class="headerlink" title="write(byte buf[], int off, int len)详细描述"></a>write(byte buf[], int off, int len)详细描述</h4><p>将 len 字节从指定的初始偏移量为 off 的 byte 数组写入此流。如果启用自动刷新，则调用 flush 方法。<br>注意，字节将按给定的方式写入；<br>要根据平台的默认字符编码来写入，请使用<code>print(char)</code>或<code>println(char)</code>方法。<br>参数: buf 字节数组<br>参数: off 相对于字节数组开始位置的偏移量<br>参数: len 需要写入的字节数</p><h4 id="print-char-c-方法源码"><a href="#print-char-c-方法源码" class="headerlink" title="print(char c)方法源码"></a>print(char c)方法源码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void print(char c) &#123;</span><br><span class="line">    write(String.valueOf(c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="print-char-c-方法详细描述"><a href="#print-char-c-方法详细描述" class="headerlink" title="print(char c)方法详细描述"></a>print(char c)方法详细描述</h4><p>打印一个字符，根据平台默认字符编码把这个字符转换为一个或者多个字节,然后这些字节完全以<code>write(int)</code>方法的方式进行写入。</p><div></div><h4 id="print-int-i-方法源码"><a href="#print-int-i-方法源码" class="headerlink" title="print(int i)方法源码"></a>print(int i)方法源码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void print(int i) &#123;</span><br><span class="line">    write(String.valueOf(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="print-int-i-方法详细描述"><a href="#print-int-i-方法详细描述" class="headerlink" title="print(int i)方法详细描述"></a>print(int i)方法详细描述</h4><p>打印整数。按照平台的默认字节编码将 <code>String.valueOf(i)</code> 生成的字符串转换为字节，并完全以 <code>write(int)</code> 方法的方式写入这些字节。</p><p>参数：<br>i - 要打印的 int</p><div></div><h4 id="print-long-l-方法源码"><a href="#print-long-l-方法源码" class="headerlink" title="print(long l)方法源码"></a>print(long l)方法源码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void print(long l) &#123;</span><br><span class="line">    write(String.valueOf(l));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>打印<code>long</code>整数，按照平台默认字节编码将<code>String.valueOf(l)</code>生成的字符串转换为字节，并完全以<code>write(int)</code>方法的方式写入这些字节</p></blockquote><div></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void print(float f) &#123;</span><br><span class="line">    write(String.valueOf(f));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div></div><h4 id="其他print-…-方法源码"><a href="#其他print-…-方法源码" class="headerlink" title="其他print(…)方法源码"></a>其他print(…)方法源码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void print(double d) &#123;</span><br><span class="line">    write(String.valueOf(d));</span><br><span class="line">&#125;</span><br><span class="line">public void print(char s[]) &#123;</span><br><span class="line">    write(s);</span><br><span class="line">&#125;</span><br><span class="line">public void print(String s) &#123;</span><br><span class="line">    if (s == null) &#123;</span><br><span class="line">        s = &quot;null&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    write(s);</span><br><span class="line">&#125;</span><br><span class="line">public void print(Object obj) &#123;</span><br><span class="line">    write(String.valueOf(obj));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="println-…-方法"><a href="#println-…-方法" class="headerlink" title="println(…)方法"></a>println(…)方法</h3><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>void println()</code></td><td style="text-align:left">通过写入行分隔符字符串终止当前行。</td></tr><tr><td style="text-align:left"><code>void println(boolean x)</code></td><td style="text-align:left">打印 boolean 值，然后终止行。</td></tr><tr><td style="text-align:left"><code>void println(char x)</code></td><td style="text-align:left">打印字符，然后终止该行。</td></tr><tr><td style="text-align:left"><code>void println(char[] x)</code></td><td style="text-align:left">打印字符数组，然后终止该行。</td></tr><tr><td style="text-align:left"><code>void println(double x)</code></td><td style="text-align:left">打印 double，然后终止该行。</td></tr><tr><td style="text-align:left"><code>void println(float x)</code></td><td style="text-align:left">打印 float，然后终止该行。</td></tr><tr><td style="text-align:left"><code>void println(int x)</code></td><td style="text-align:left">打印整数，然后终止该行。</td></tr><tr><td style="text-align:left"><code>void println(long x)</code></td><td style="text-align:left">打印 long，然后终止该行。</td></tr><tr><td style="text-align:left"><code>void println(Object x)</code></td><td style="text-align:left">打印 Object，然后终止该行。</td></tr><tr><td style="text-align:left"><code>void println(String x)</code></td><td style="text-align:left">打印 String，然后终止该行。</td></tr></tbody></table><h4 id="println-…-方法源码"><a href="#println-…-方法源码" class="headerlink" title="println(…)方法源码"></a>println(…)方法源码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* Methods that do terminate lines */</span><br><span class="line"></span><br><span class="line">public void println() &#123;</span><br><span class="line">    newLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过写入行分隔符字符串终止当前行。行分隔符字符串由系统属性<code>line.separator</code> 定义，不一定是单个换行符 (‘<code>\n</code>‘)。</p><div></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void println(boolean x) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        newLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印 boolean 值，然后终止行。此方法的行为就像先调用 print(boolean) 然后调用 println() 一样。</p><p>参数：<br>x - 要打印的 boolean</p><div></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void println(char x) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        newLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印字符，然后终止该行。此方法的行为就像先调用 print(char) 然后调用 println() 一样。</p><p>参数：<br>x - 要打印的 char。</p><div></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void println(int x) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        newLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印整数，然后终止该行。此方法的行为就像先调用 print(int) 然后调用 println() 一样。</p><p>参数：<br>x - 要打印的 int。</p><div></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void println(long x) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        newLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印 long，然后终止该行。此方法的行为就像先调用 print(long) 然后调用 println() 一样。</p><p>参数：<br>x - 要打印的 long。</p><div></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void println(float x) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        newLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印 float，然后终止该行。此方法的行为就像先调用 print(float) 然后调用 println() 一样。<br>参数：<br>x - 要打印的 float。</p><div></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void println(double x) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        newLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印 double，然后终止该行。此方法的行为就像先调用 print(double) 然后调用 println() 一样。</p><p>参数：<br>x - 要打印的 double。</p><div></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void println(char x[]) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        newLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印字符数组，然后终止该行。此方法的行为就像先调用 print(char[]) 然后调用 println() 一样。<br>参数：<br>x - 要打印的字符数组。</p><div></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void println(String x) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        newLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印 String，然后终止该行。此方法的行为就像先调用 print(String) 然后调用 println() 一样。<br>参数：<br>x - 要打印的 String。</p><div></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void println(Object x) &#123;</span><br><span class="line">    String s = String.valueOf(x);</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        print(s);</span><br><span class="line">        newLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印 Object，然后终止该行。此方法首先调用 String.valueOf(x) 获取打印对象的字符串值，然后的行为如同先调用 print(String) 再调用 println() 一样。<br>参数：<br>x - 要打印的 Object。</p><div></div><h3 id="format-…-方法"><a href="#format-…-方法" class="headerlink" title="format(…)方法"></a>format(…)方法</h3><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>PrintStream format(Locale l, String format, Object... args)</code></td><td style="text-align:left">使用指定格式字符串和参数将格式化字符串写入此输出流中。</td></tr><tr><td style="text-align:left"><code>PrintStream format(String format, Object... args)</code></td><td style="text-align:left">使用指定格式字符串和参数将格式化字符串写入此输出流中。</td></tr><tr><td style="text-align:left"><code>PrintStream printf(Locale l, String format, Object... args)</code></td><td style="text-align:left">使用指定格式字符串和参数将格式化的字符串写入此输出流的便捷方法。</td></tr><tr><td style="text-align:left"><code>PrintStream printf(String format, Object... args)</code></td><td style="text-align:left">使用指定格式字符串和参数将格式化的字符串写入此输出流的便捷方法。</td></tr></tbody></table><h4 id="format-…-方法源码"><a href="#format-…-方法源码" class="headerlink" title="format(…)方法源码"></a>format(…)方法源码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public PrintStream format(String format, Object ... args) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            ensureOpen();</span><br><span class="line">            if ((formatter == null)</span><br><span class="line">                || (formatter.locale() != Locale.getDefault()))</span><br><span class="line">                formatter = new Formatter((Appendable) this);</span><br><span class="line">            formatter.format(Locale.getDefault(), format, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (InterruptedIOException x) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125; catch (IOException x) &#123;</span><br><span class="line">        trouble = true;</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用指定格式字符串和参数将格式化字符串写入此输出流中。<br>始终使用的语言环境是由 Locale.getDefault() 返回的语言环境，不管以前在此对象上调用了其他什么样的格式化方法。</p><div></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public PrintStream format(Locale l, String format, Object ... args) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            ensureOpen();</span><br><span class="line">            if ((formatter == null)</span><br><span class="line">                || (formatter.locale() != l))</span><br><span class="line">                formatter = new Formatter(this, l);</span><br><span class="line">            formatter.format(l, format, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (InterruptedIOException x) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125; catch (IOException x) &#123;</span><br><span class="line">        trouble = true;</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用指定格式字符串和参数将格式化字符串写入此输出流中。<br>参数：</p><ul><li>l 格式化过程中应用的 locale。如果 l 为 null，则不应用本地化。</li><li>format 在格式字符串的语法中描述的格式字符串</li><li>args 格式字符串中的格式说明符引用的参数。如果参数多于格式说明符，则忽略额外的参数。参数的数量是可变的，并且可以为零。参数的最大数量受到 Java Virtual Machine Specification 定义的 Ja</li><li></li><li>va 数组的最大维数的限制。针对 null 参数的行为依赖于 conversion。<br>返回： 此输出流<br>抛出：</li><li>IllegalFormatException 如果格式字符串包含非法语法、与给定参数不兼容的格式说明符、对给定格式字符串而言不够充足的参数或其他非法条件。有关所有可能的格式错误的规范，请参阅 formatter 类规范的详细信息部分。</li><li>NullPointerException 如果 format 为 null<br>从以下版本开始：<br>1.5</li></ul><div></div><h3 id="append-…-方法"><a href="#append-…-方法" class="headerlink" title="append(…)方法"></a>append(…)方法</h3><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>PrintStream append(char c)</code></td><td style="text-align:left">将指定字符添加到此输出流。</td></tr><tr><td style="text-align:left"><code>PrintStream append(CharSequence csq)</code></td><td style="text-align:left">将指定字符序列添加到此输出流。</td></tr><tr><td style="text-align:left"><code>PrintStream append(CharSequence csq, int start, int end)</code></td><td style="text-align:left">将指定字符序列的子序列添加到此输出流。</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public PrintStream append(CharSequence csq, int start, int end) &#123;</span><br><span class="line">    CharSequence cs = (csq == null ? &quot;null&quot; : csq);</span><br><span class="line">    write(cs.subSequence(start, end).toString());</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>将指定字符序列添加到此输出流。<br>此方法调用 out.append(csq) 的行为与调用下列方法完全相同：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; out.print(csq.toString()) </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>可能不添加整个序列，也可能添加，具体取决于字符序列 csq 的 toString 规范。例如，调用一个字符缓冲区的 toString 方法将返回一个子序列，其内容取决于缓冲区的位置和限制。<br>指定者：接口 Appendable 中的 append<br>参数：csq - 要添加的字符序列。如果 csq 为 null，则向此输出流添加四个字符 “null”。<br>返回：此输出流<br>从以下版本开始： 1.5</p></blockquote><div></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Appends the specified character to this output stream.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; An invocation of this method of the form &lt;tt&gt;out.append(c)&lt;/tt&gt;</span><br><span class="line"> * behaves in exactly the same way as the invocation</span><br><span class="line"> *</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> *     out.print(c) &lt;/pre&gt;</span><br><span class="line"> *</span><br><span class="line"> * @param  c</span><br><span class="line"> *         The 16-bit character to append</span><br><span class="line"> *</span><br><span class="line"> * @return  This output stream</span><br><span class="line"> *</span><br><span class="line"> * @since  1.5</span><br><span class="line"> */</span><br><span class="line">public PrintStream append(char c) &#123;</span><br><span class="line">    print(c);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="错误相关方法"><a href="#错误相关方法" class="headerlink" title="错误相关方法"></a>错误相关方法</h3><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>boolean checkError()</code></td><td style="text-align:left">刷新流并检查其错误状态。</td></tr><tr><td style="text-align:left"><code>protected void clearError()</code></td><td style="text-align:left">清除此流的内部错误状态。</td></tr><tr><td style="text-align:left"><code>void close()</code></td><td style="text-align:left">关闭流。</td></tr><tr><td style="text-align:left"><code>void flush()</code></td><td style="text-align:left">刷新该流的缓冲。</td></tr><tr><td style="text-align:left"><code>protected void setError()</code></td><td style="text-align:left">将该流的错误状态设置为 true。</td></tr></tbody></table><p>本文链接: <a href="https://www.lansheng.net.cn/blog/&#39;82040860&#39;/">Java IO流 PrintStream类</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java IO流 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>README_AddHTMLComments类说明</title>
      <link href="/blog/2e8beac0/"/>
      <url>/blog/2e8beac0/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>AddHTMLComments这个类把剪贴板中的内容加上html注释</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/2e8beac0/">README_AddHTMLComments类说明</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 我的软件 </category>
          
          <category> 自己写的工具说明 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java IO流 PrintWriter类</title>
      <link href="/blog/492ea8e8/"/>
      <url>/blog/492ea8e8/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object</span><br><span class="line">  |----&gt; java.io.Writer</span><br><span class="line">      |----&gt; java.io.PrintWriter</span><br></pre></td></tr></table></figure><p><code>public class PrintWriter extends Writer</code>向文本输出流打印对象的格式化表示形式。此类实现在 <code>PrintStream</code> 中的所有 <code>print</code> 方法。它不包含用于写入原始字节的方法，对于这些字节，程序应该使用未编码的字节流进行写入。</p><p>与 <code>PrintStream</code> 类不同，如果<strong>启用了自动刷新，则只有在调用 <code>println</code>、<code>printf</code> 或 <code>format</code> 的其中一个方法时才可能完成此操作</strong>，而不是每当正好输出换行符时才完成。这些方法使用平台自有的行分隔符概念，而不是换行符。</p><p>此类中的方法不会抛出 <code>I/O</code> 异常，尽管其某些构造方法可能抛出异常。客户端可能会查询调用 <code>checkError()</code> 是否出现错误。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>PrintWriter(File file)</code></td><td style="text-align:left">打印到文件中,不自动刷新</td></tr><tr><td style="text-align:left"><code>PrintWriter(File file, String csn)</code></td><td style="text-align:left">打印到文件中，指定字符集，自动刷新</td></tr><tr><td style="text-align:left"><code>PrintWriter(OutputStream out)</code></td><td style="text-align:left">打印到OutputStream中，不自动刷新</td></tr><tr><td style="text-align:left"><code>PrintWriter(OutputStream out, boolean autoFlush)</code></td><td style="text-align:left">打印到输出流中,autoFlush为true就自动刷新</td></tr><tr><td style="text-align:left"><code>PrintWriter(String fileName)</code></td><td style="text-align:left">打印到文件名为fileName的文件中</td></tr><tr><td style="text-align:left"><code>PrintWriter(String fileName, String csn)</code></td><td style="text-align:left">打印到文件名为fileName的文件中，指定字符编码</td></tr><tr><td style="text-align:left"><code>PrintWriter(Writer out)</code></td><td style="text-align:left">打印到字符输出流中</td></tr><tr><td style="text-align:left"><code>PrintWriter(Writer out, boolean autoFlush)</code></td><td style="text-align:left">打印到字符输出流中,autoFlush为true时自动刷新</td></tr></tbody></table><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><p>这个方法有点多，分开写比较好。</p><h3 id="可以自动刷新的方法"><a href="#可以自动刷新的方法" class="headerlink" title="可以自动刷新的方法"></a>可以自动刷新的方法</h3><p>注意了，只有下表的方法可以自动刷新，其他方法是不会自动刷新的。<br>自动刷新的情况：</p><ul><li>调用println()方法</li><li>调用printf()方法</li><li>调用format()方法</li></ul><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>PrintWriter format(Locale l, String format, Object... args)</code></td><td style="text-align:left">使用指定格式字符串和参数将一个格式化字符串写入此 writer 中。</td></tr><tr><td style="text-align:left"><code>PrintWriter format(String format, Object... args)</code></td><td style="text-align:left">使用指定格式字符串和参数将一个格式化字符串写入此 writer 中。</td></tr><tr><td style="text-align:left"><code>PrintWriter printf(Locale l, String format, Object... args)</code></td><td style="text-align:left">使用指定格式字符串和参数将格式化的字符串写入此 writer 的便捷方法。</td></tr><tr><td style="text-align:left"><code>PrintWriter printf(String format, Object... args)</code></td><td style="text-align:left">使用指定格式字符串和参数将格式化的字符串写入此 writer 的便捷方法。</td></tr><tr><td style="text-align:left"><code>void println()</code></td><td style="text-align:left">通过写入行分隔符字符串终止当前行。</td></tr><tr><td style="text-align:left"><code>void println(boolean x)</code></td><td style="text-align:left">打印 boolean 值，然后终止该行。</td></tr><tr><td style="text-align:left"><code>void println(char x)</code></td><td style="text-align:left">打印字符，然后终止该行。</td></tr><tr><td style="text-align:left"><code>void println(char[] x)</code></td><td style="text-align:left">打印字符数组，然后终止该行。</td></tr><tr><td style="text-align:left"><code>void println(double x)</code></td><td style="text-align:left">打印双精度浮点数，然后终止该行。</td></tr><tr><td style="text-align:left"><code>void println(float x)</code></td><td style="text-align:left">打印浮点数，然后终止该行。</td></tr><tr><td style="text-align:left"><code>void println(int x)</code></td><td style="text-align:left">打印整数，然后终止该行。</td></tr><tr><td style="text-align:left"><code>void println(long x)</code></td><td style="text-align:left">打印 long 整数，然后终止该行。</td></tr><tr><td style="text-align:left"><code>void println(Object x)</code></td><td style="text-align:left">打印 Object，然后终止该行。</td></tr><tr><td style="text-align:left"><code>void println(String x)</code></td><td style="text-align:left">打印 String，然后终止该行。</td></tr></tbody></table><h3 id="追加方法"><a href="#追加方法" class="headerlink" title="追加方法"></a>追加方法</h3><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>PrintWriter append(char c)</code></td><td style="text-align:left">将指定字符添加到此 writer。</td></tr><tr><td style="text-align:left"><code>PrintWriter append(CharSequence csq)</code></td><td style="text-align:left">将指定的字符序列添加到此 writer。</td></tr><tr><td style="text-align:left"><code>PrintWriter append(CharSequence csq, int start, int end)</code></td><td style="text-align:left">将指定字符序列的子序列添加到此 writer。</td></tr></tbody></table><h3 id="print-…-方法"><a href="#print-…-方法" class="headerlink" title="print(…)方法"></a>print(…)方法</h3><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>void print(boolean b)</code></td><td style="text-align:left">打印 boolean 值。</td></tr><tr><td style="text-align:left"><code>void print(char c)</code></td><td style="text-align:left">打印字符。</td></tr><tr><td style="text-align:left"><code>void print(char[] s)</code></td><td style="text-align:left">打印字符数组。</td></tr><tr><td style="text-align:left"><code>void print(double d)</code></td><td style="text-align:left">打印 double 精度浮点数。</td></tr><tr><td style="text-align:left"><code>void print(float f)</code></td><td style="text-align:left">打印一个浮点数。</td></tr><tr><td style="text-align:left"><code>void print(int i)</code></td><td style="text-align:left">打印整数。</td></tr><tr><td style="text-align:left"><code>void print(long l)</code></td><td style="text-align:left">打印 long 整数。</td></tr><tr><td style="text-align:left"><code>void print(Object obj)</code></td><td style="text-align:left">打印对象。</td></tr><tr><td style="text-align:left"><code>void print(String s)</code></td><td style="text-align:left">打印字符串。</td></tr></tbody></table><h3 id="write-…-方法"><a href="#write-…-方法" class="headerlink" title="write(…)方法"></a>write(…)方法</h3><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>void write(char[] buf)</code></td><td style="text-align:left">写入字符数组。</td></tr><tr><td style="text-align:left"><code>void write(char[] buf, int off, int len)</code></td><td style="text-align:left">写入字符数组的某一部分。</td></tr><tr><td style="text-align:left"><code>void write(int c)</code></td><td style="text-align:left">写入单个字符。</td></tr><tr><td style="text-align:left"><code>void write(String s)</code></td><td style="text-align:left">写入字符串。</td></tr><tr><td style="text-align:left"><code>void write(String s, int off, int len)</code></td><td style="text-align:left">写入字符串的某一部分。</td></tr></tbody></table><h3 id="错误相关方法"><a href="#错误相关方法" class="headerlink" title="错误相关方法"></a>错误相关方法</h3><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>boolean checkError()</code></td><td style="text-align:left">如果流没有关闭，则刷新流且检查其错误状态。</td></tr><tr><td style="text-align:left"><code>protected void clearError()</code></td><td style="text-align:left">清除此流的错误状态。</td></tr><tr><td style="text-align:left"><code>protected void setError()</code></td><td style="text-align:left">指示已发生错误。</td></tr></tbody></table><h3 id="刷新方法"><a href="#刷新方法" class="headerlink" title="刷新方法"></a>刷新方法</h3><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>void close()</code></td><td style="text-align:left">关闭该流并释放与之关联的所有系统资源。</td></tr><tr><td style="text-align:left"><code>void flush()</code></td><td style="text-align:left">刷新该流的缓冲。</td></tr></tbody></table><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="不自动刷新的例子"><a href="#不自动刷新的例子" class="headerlink" title="不自动刷新的例子"></a>不自动刷新的例子</h3><p>来看一个不自动刷新的例子<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException</span><br><span class="line">&#123;</span><br><span class="line">BufferedWriter writer=new BufferedWriter(new FileWriter(&quot;xiaoming.txt&quot;));</span><br><span class="line">writer.write(&quot;小明&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这样会不会在<code>xiaoming.txt</code>文件中写入“小明”这个字符串呢？答案是不会，因为，现在写的这个<code>小明</code>保存在<code>BufferedWriter</code>的内部字符数组中，并没有写到本地，想写到本地的话需要调用<code>flush()</code>方法刷新内部字符数组，把放在内部字符数组中的“小明”这个字符串写到本地中去。BufferedWriter内部缓存放满了，或者放不下了，会自动把内部缓存刷到本地中去。或者调用<code>close()</code>方法的时候也会刷新一下内部缓存。<br>现在小明两个字符没有充满内部缓存，<code>BufferedWriter</code>不会自动刷新内部缓存。而我们没有调用<code>flush()</code>方法，也没有关闭<code>BufferdWriter</code>。所以文件不会写入数据,<code>main()</code>方法结束后数据丢失。</p><h3 id="PrintWriter自动刷新实例"><a href="#PrintWriter自动刷新实例" class="headerlink" title="PrintWriter自动刷新实例"></a>PrintWriter自动刷新实例</h3><p>使用<code>PrintWriter</code>并使用自动刷新刷新：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="comment">//自动刷新到文件xiaoming.txt中</span></span><br><span class="line">PrintWriter writer=<span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(<span class="string">"xiaoming.txt"</span>),<span class="keyword">true</span>);</span><br><span class="line">       <span class="comment">//使用下面三个方法会自动刷新</span></span><br><span class="line">writer.println(<span class="string">"小明"</span>);</span><br><span class="line">writer.printf(<span class="string">"%-10s#\n"</span>,<span class="string">"小明"</span>);</span><br><span class="line">writer.format(<span class="string">"%-10d#"</span>, <span class="number">12345</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果，<code>xiaoming.txt</code>文件中的内容：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">小明</span><br><span class="line">小明        #</span><br><span class="line">12345     #</span><br></pre></td></tr></table></figure><p></p><h3 id="PrintWriter不会自动刷新的方法"><a href="#PrintWriter不会自动刷新的方法" class="headerlink" title="PrintWriter不会自动刷新的方法"></a>PrintWriter不会自动刷新的方法</h3><p><code>PrintWriter</code>的其他不会自动刷新的方法：</p><ul><li>write()方法</li><li>print()方法</li><li>append()方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PrintWriter writer=<span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(<span class="string">"xiaoming.txt"</span>),<span class="keyword">true</span>);</span><br><span class="line">writer.println(<span class="string">"小明"</span>);</span><br><span class="line">writer.printf(<span class="string">"%-10s#\n"</span>,<span class="string">"小明"</span>);</span><br><span class="line">writer.format(<span class="string">"%-10d#\n"</span>, <span class="number">12345</span>);</span><br><span class="line">writer.write(<span class="string">"我是不会写到文件中去的"</span>);</span><br><span class="line">writer.print(<span class="string">"我也不会自动写到文件中去的"</span>);</span><br><span class="line">writer.append(<span class="string">"我也一样不会写到文件中去的"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后，<code>xiaoming.txt</code>中的内容如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">小明</span><br><span class="line">小明        #</span><br><span class="line">12345     #</span><br></pre></td></tr></table></figure><p></p><p>可以看到这三个方法是不会自动刷新的，需要显示调用flush()方法进行写入,或者在写文件最后调用close()写入文件。这里调用close()方法在最后关闭文件，close()方法会把缓存的字符刷新到文件中去。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PrintWriter writer=<span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(<span class="string">"xiaoming.txt"</span>),<span class="keyword">true</span>);</span><br><span class="line">writer.println(<span class="string">"小明"</span>);</span><br><span class="line">writer.printf(<span class="string">"%-10s#\n"</span>,<span class="string">"小明"</span>);</span><br><span class="line">writer.format(<span class="string">"%-10d#\n"</span>, <span class="number">12345</span>);</span><br><span class="line">writer.write(<span class="string">"我是不会写到文件中去的\n"</span>);</span><br><span class="line">writer.print(<span class="string">"我也不会自动写到文件中去的\n"</span>);</span><br><span class="line">writer.append(<span class="string">"我也一样不会写到文件中去的\n"</span>);</span><br><span class="line">writer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行上面代码后，<code>xiaoming.txt</code>文件中的内容如下<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">小明</span><br><span class="line">小明        #</span><br><span class="line">12345     #</span><br><span class="line">我是不会写到文件中去的</span><br><span class="line">我也不会自动写到文件中去的</span><br><span class="line">我也一样不会写到文件中去的</span><br></pre></td></tr></table></figure><p></p><h2 id="疑惑的地方write-方法和print-方法append-方法的区别？"><a href="#疑惑的地方write-方法和print-方法append-方法的区别？" class="headerlink" title="疑惑的地方write()方法和print(...)方法append()方法的区别？"></a>疑惑的地方<code>write()</code>方法和<code>print(...)</code>方法<code>append()</code>方法的区别？</h2><h3 id="write-方法和print-方法的区别"><a href="#write-方法和print-方法的区别" class="headerlink" title="write()方法和print(...)方法的区别"></a><code>write()</code>方法和<code>print(...)</code>方法的区别</h3><ul><li>共同点：两者都不刷新页面，只在原来的页面写数据.最终都是重写了抽象类Writer里面的write方法.</li><li>不同点：print方法可以将各种类型的数据转换成字符串的形式输出。重载的write方法只能输出字符、字符数组、字符串等与字符相关的数据。</li></ul><p>这些疑惑看下面的源码就知道了。</p><h2 id="看源码"><a href="#看源码" class="headerlink" title="看源码"></a>看源码</h2><h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Writer out;<span class="comment">//字符输出流</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> autoFlush;<span class="comment">//自动刷新</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> trouble = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">private</span> Formatter formatter;</span><br><span class="line"><span class="keyword">private</span> PrintStream psOut = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String lineSeparator;<span class="comment">//换行符</span></span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span> <span class="params">(Writer out)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用另一个:PrintWriter(Writer out, boolean autoFlush)</span></span><br><span class="line">    <span class="keyword">this</span>(out, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(Writer out, <span class="keyword">boolean</span> autoFlush)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(out);</span><br><span class="line">    <span class="comment">//设置字符输出流</span></span><br><span class="line">    <span class="keyword">this</span>.out = out;</span><br><span class="line">    <span class="comment">//设置自动刷新标志</span></span><br><span class="line">    <span class="keyword">this</span>.autoFlush = autoFlush;</span><br><span class="line">    <span class="comment">//设置换行符</span></span><br><span class="line">    lineSeparator = java.security.AccessController.doPrivileged(</span><br><span class="line">        <span class="keyword">new</span> sun.security.action.GetPropertyAction(<span class="string">"line.separator"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(OutputStream out)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用另一个构造方法:PrintWriter(OutputStream out, boolean autoFlush) </span></span><br><span class="line">    <span class="keyword">this</span>(out, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(OutputStream out, <span class="keyword">boolean</span> autoFlush)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//把字节流封装成字符流：BufferedWriter后,</span></span><br><span class="line">    <span class="comment">//调用:PrintWriter(OutputStream out, boolean autoFlush)</span></span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(out)), autoFlush);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save print stream for error propagation</span></span><br><span class="line">    <span class="keyword">if</span> (out <span class="keyword">instanceof</span> java.io.PrintStream) &#123;</span><br><span class="line">        psOut = (PrintStream) out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">//包装后调用：PrintWriter(OutputStream out, boolean autoFlush)</span></span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(fileName))),</span><br><span class="line">         <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//搞不懂为什么这里要颠倒一下参数的顺序?</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">PrintWriter</span><span class="params">(Charset charset, File file)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> FileNotFoundException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//包装后调用:PrintWriter(OutputStream out, boolean autoFlush)</span></span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(file), charset)),</span><br><span class="line">         <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(String fileName, String csn)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> FileNotFoundException, UnsupportedEncodingException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用:PrintWriter(Charset charset, File file)</span></span><br><span class="line">    <span class="keyword">this</span>(toCharset(csn), <span class="keyword">new</span> File(fileName));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">//调用：PrintWriter(OutputStream out, boolean autoFlush)</span></span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(file))),</span><br><span class="line">         <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(File file, String csn)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> FileNotFoundException, UnsupportedEncodingException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用：PrintWriter(Charset charset, File file)</span></span><br><span class="line">    <span class="keyword">this</span>(toCharset(csn), file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看源码就知道了：</p><h3 id="print-…-方法源码"><a href="#print-…-方法源码" class="headerlink" title="print(…)方法源码"></a>print(…)方法源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    write(b ? <span class="string">"true"</span> : <span class="string">"false"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    write(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    write(String.valueOf(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">    write(String.valueOf(l));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">    write(String.valueOf(f));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">    write(String.valueOf(d));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> s[])</span> </span>&#123;</span><br><span class="line">    write(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">        s = <span class="string">"null"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    write(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    write(String.valueOf(obj));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="write-…-方法源码"><a href="#write-…-方法源码" class="headerlink" title="write(…)方法源码"></a>write(…)方法源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Writer out;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            ensureOpen();</span><br><span class="line">            <span class="comment">//调用低层Writer的write(int)方法</span></span><br><span class="line">            out.write(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InterruptedIOException x) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">        trouble = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> buf[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            ensureOpen();</span><br><span class="line">            <span class="comment">//调用低层writer的写字符数组方法</span></span><br><span class="line">            out.write(buf, off, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InterruptedIOException x) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">        trouble = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> buf[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用自己的write(char buf[], int off, int len)</span></span><br><span class="line">    write(buf, <span class="number">0</span>, buf.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String s, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            ensureOpen();</span><br><span class="line">            <span class="comment">//调用低层得写字符串方法</span></span><br><span class="line">            out.write(s, off, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InterruptedIOException x) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">        trouble = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用自己的写字符串方法</span></span><br><span class="line">    write(s, <span class="number">0</span>, s.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到PrintWriter的writer(…)方法最终调用低层流的writer(..)来实现的。</p><h3 id="append-…-方法源码"><a href="#append-…-方法源码" class="headerlink" title="append(…)方法源码"></a>append(…)方法源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PrintWriter <span class="title">append</span><span class="params">(CharSequence csq)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (csq == <span class="keyword">null</span>)</span><br><span class="line">        write(<span class="string">"null"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        write(csq.toString());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> PrintWriter <span class="title">append</span><span class="params">(CharSequence csq, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    CharSequence cs = (csq == <span class="keyword">null</span> ? <span class="string">"null"</span> : csq);</span><br><span class="line">    write(cs.subSequence(start, end).toString());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> PrintWriter <span class="title">append</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    write(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到<code>append</code>方法最终也是调用<code>PrintWriter</code>的<code>write()</code>方法来实现的，<code>write()</code>方法和<code>append</code>方法不同的地方在于返回值吧，<code>append</code>返回值为<code>PrintWriter</code>,而<code>write()</code>返回值为<code>void</code><br><code>print()</code>方法和<code>append()</code>方法相同的地方是它们都通过<code>write()</code>方法实现。</p><h3 id="println-…-方法源码"><a href="#println-…-方法源码" class="headerlink" title="println(…)方法源码"></a>println(…)方法源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">newLine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            ensureOpen();</span><br><span class="line">            out.write(lineSeparator);</span><br><span class="line">            <span class="keyword">if</span> (autoFlush)</span><br><span class="line">                out.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InterruptedIOException x) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">        trouble = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    newLine();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">boolean</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">char</span> x[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">    String s = String.valueOf(x);</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        print(s);</span><br><span class="line">        println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到println(…)最终调用print(…)和println()方法事项，print(…)方法前面已经说了。<br>而println()方法，调用newLine()这私有的方法来进行换行和刷新操作：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">newLine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            ensureOpen();</span><br><span class="line">            <span class="comment">//写换行符</span></span><br><span class="line">            out.write(lineSeparator);</span><br><span class="line">            <span class="keyword">if</span> (autoFlush)</span><br><span class="line">                out.flush();<span class="comment">//刷新缓存</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InterruptedIOException x) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">        trouble = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>因为println()方法提供和换行和自动刷新功能，所以其他println(…)调用了该方法也就能实现自动刷新的功能了。</p><h3 id="format-方法源码"><a href="#format-方法源码" class="headerlink" title="format()方法源码"></a>format()方法源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式化类：java.util.Formatter</span></span><br><span class="line"><span class="keyword">private</span> Formatter formatter;</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="keyword">public</span> PrintWriter <span class="title">format</span><span class="params">(String format, Object ... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            ensureOpen();</span><br><span class="line">            <span class="keyword">if</span> ((formatter == <span class="keyword">null</span>)</span><br><span class="line">                || (formatter.locale() != Locale.getDefault()))</span><br><span class="line">                formatter = <span class="keyword">new</span> Formatter(<span class="keyword">this</span>);</span><br><span class="line">            formatter.format(Locale.getDefault(), format, args);</span><br><span class="line">            <span class="keyword">if</span> (autoFlush)</span><br><span class="line">                out.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedIOException x) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">        trouble = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> PrintWriter <span class="title">format</span><span class="params">(Locale l, String format, Object ... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            ensureOpen();</span><br><span class="line">            <span class="keyword">if</span> ((formatter == <span class="keyword">null</span>) || (formatter.locale() != l))</span><br><span class="line">                formatter = <span class="keyword">new</span> Formatter(<span class="keyword">this</span>, l);</span><br><span class="line">            formatter.format(l, format, args);</span><br><span class="line">            <span class="keyword">if</span> (autoFlush)</span><br><span class="line">                out.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedIOException x) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">        trouble = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>format()</code>方法其实就<code>java.util.Formatter</code>类的<code>format()</code>方法实现的。而且<code>format()</code>方法调用了<code>out.flush()</code>来实现自动刷新。</p><h3 id="printf-方法源码"><a href="#printf-方法源码" class="headerlink" title="printf()方法源码"></a>printf()方法源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PrintWriter <span class="title">printf</span><span class="params">(String format, Object ... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> format(format, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> PrintWriter <span class="title">printf</span><span class="params">(Locale l, String format, Object ... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> format(l, format, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里的<code>printf()</code>方法最终是调用了<code>format(`</code>.<code></code>.)<code>方法来实现的。因为</code>format()<code>方法中调用了</code>out.flush()<code>来自动刷新,所以</code>printf()`方法也就跟着实现了自动刷新功能。<br>这些自动刷新功能说的很玄乎,其实不过就是下面两句话：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">            <span class="keyword">if</span> (autoFlush)</span><br><span class="line">                out.flush();<span class="comment">//刷新缓存</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p></p><p>其他方法如write()方法，print()方法，append()方法没有上面这句话所以就没了自动刷新功能。</p><p>就这样吧</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/492ea8e8/">Java IO流 PrintWriter类</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java IO流 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java IO流 接口</title>
      <link href="/blog/df6c2340/"/>
      <url>/blog/df6c2340/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>Java IO流 接口</p><h1 id="Closeable接口"><a href="#Closeable接口" class="headerlink" title="Closeable接口"></a>Closeable接口</h1><p><code>public interface Closeable</code><br><code>Closeable</code>是可以关闭的数据源或目标。调用 <code>close</code> 方法可释放对象保存的资源（如打开文件）。<br>Closeable接口</p><blockquote><p><code>void close() throws IOException</code>关闭此流,并释放与此流关联的所有系统资源。如果已经关闭该流，则调用此方法无效。<br>抛出：<br>&emsp;&emsp;&emsp;&emsp;<code>IOException</code> - 如果发生 I/O 错误</p></blockquote><h1 id="Flushable接口"><a href="#Flushable接口" class="headerlink" title="Flushable接口"></a>Flushable接口</h1><blockquote><p><code>public interface Flushable</code></p><p><code>Flushable</code>是可刷新数据的目标地。<strong>调用 <code>flush</code> 方法将所有已缓冲输出写入底层流。</strong></p><p>方法详细信息<br><code>void flush() throws IOException</code>通过将所有已缓冲输出写入底层流来刷新此流。</p><p>抛出：<br>&emsp;&emsp;&emsp;&emsp; <code>IOException</code> - 如果发生 <code>I/O</code> 错误</p></blockquote><h1 id="Appendable接口"><a href="#Appendable接口" class="headerlink" title="Appendable接口"></a>Appendable接口</h1><p><code>public interface Appendable</code>能够被添加 <code>char</code> 序列和值的对象。</p><p><strong>如果某个类的实例打算接收取自 <code>Formatter</code> 的格式化输出，那么该类必须实现 <code>Appendable</code> 接口。</strong></p><p>要添加的字符应该是有效的 <code>Unicode</code> 字符，正如 <code>Unicode Character Representation</code> 中描述的那样。注意，增补字符可能由多个 16 位 <code>char</code> 值组成。</p><p><code>Appendable</code> 对于多线程访问而言没必要是安全的。线程安全由扩展和实现此接口的类负责。</p><p>由于此接口可能由具有不同的错误处理风格的现有类实现，所以无法保证错误不会传播给调用者。</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>Appendable append(char c)</code></td><td style="text-align:left">向此 Appendable 添加指定字符。</td></tr><tr><td style="text-align:left"><code>Appendable append(CharSequence csq)</code></td><td style="text-align:left">向此 Appendable 添加指定的字符序列。</td></tr><tr><td style="text-align:left"><code>Appendable append(CharSequence csq, int start, int end)</code></td><td style="text-align:left">向此 Appendable 添加指定字符序列的子序列。</td></tr></tbody></table><p>本文链接: <a href="https://www.lansheng.net.cn/blog/df6c2340/">Java IO流 接口</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java IO流 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>新文档</title>
      <link href="/blog/ddc6695c/"/>
      <url>/blog/ddc6695c/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>本文链接: <a href="https://www.lansheng.net.cn/blog/ddc6695c/">新文档</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> java_util </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java_util_Formatter类</title>
      <link href="/blog/7906d867/"/>
      <url>/blog/7906d867/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>void close()</code></td><td style="text-align:left">关闭此 formatter。</td></tr><tr><td style="text-align:left"><code>void flush()</code></td><td style="text-align:left">刷新此 formatter。</td></tr><tr><td style="text-align:left"><code>Formatter format(Locale l, String format, Object... args)</code></td><td style="text-align:left">使用指定的语言环境、格式字符串和参数，将一个格式化字符串写入此对象的目标文件中。</td></tr><tr><td style="text-align:left"><code>Formatter format(String format, Object... args)</code></td><td style="text-align:left">使用指定格式字符串和参数将一个格式化字符串写入此对象的目标文件中。</td></tr><tr><td style="text-align:left"><code>IOException ioException()</code></td><td style="text-align:left">返回由此 formatter 的 Appendable 方法上次抛出的 IOException 异常。</td></tr><tr><td style="text-align:left"><code>Locale locale()</code></td><td style="text-align:left">返回构造此 formatter 时设置的语言环境。</td></tr><tr><td style="text-align:left"><code>Appendable out()</code></td><td style="text-align:left">返回输出的目标文件。</td></tr><tr><td style="text-align:left"><code>String toString()</code></td><td style="text-align:left">返回对输出的目标文件调用 toString() 的结果。</td></tr></tbody></table><p><code>Formatter</code>是广泛被用到的格式化方法，它能让一些东西变得更加有规范，例如：超市小票，信息单，用这个方法来格式化就显得很不错。</p><p>参考：<a href="https://blog.csdn.net/ouyang_peng/article/details/16355237" target="_blank" rel="noopener">https://blog.csdn.net/ouyang_peng/article/details/16355237</a></p><p>有时会想把数字，日期，字符串<code>按照给定规则给格式化</code>。<code>SUN JDK</code>为我们提供了这个<code>API</code>，它是<code>java.util.Formatter</code>。</p><p><code>Formatter</code>提供了对布局对齐和排列的支持，以及对数值、字符串和日期/时间数据的常规格式和特定于语言环境的输出的支持。</p><h1 id="格式化规则"><a href="#格式化规则" class="headerlink" title="格式化规则"></a>格式化规则</h1><p>要想按照自己的想法格式化必须事先编写一个规则。这个规则的语法如下。</p><p>##<code>常规类型</code>、<code>字符类型</code>和<code>数值类型</code>的<code>格式说明符语法</code> ##<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[argument_index$][flags][width][.precision]conversion</span><br></pre></td></tr></table></figure><p></p><h2 id="用来表示日期和时间类型的格式说明符语法"><a href="#用来表示日期和时间类型的格式说明符语法" class="headerlink" title="用来表示日期和时间类型的格式说明符语法"></a>用来表示<code>日期和时间类型</code>的格式说明符语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[argument_index$][flags][width]conversion</span><br></pre></td></tr></table></figure><h2 id="与参数不对应的格式说明符语法"><a href="#与参数不对应的格式说明符语法" class="headerlink" title="与参数不对应的格式说明符语法"></a>与参数不对应的格式说明符语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[flags][width]conversion</span><br></pre></td></tr></table></figure><p><code>API</code>中有这样三种规则，很显然第一个规则的内容是最全面的。其它规则的内容和第一规则的内容有重复，那单说第一规则内容，其它规则依次类推。</p><p>注意：规则一中的<code>precision</code>前面要加英文句号“<code>.</code>”</p><h1 id="语法规则详细说明"><a href="#语法规则详细说明" class="headerlink" title="语法规则详细说明"></a>语法规则详细说明</h1><h2 id="可选项-argument-index"><a href="#可选项-argument-index" class="headerlink" title="可选项[argument_index$]"></a>可选项<code>[argument_index$]</code></h2><ul><li>可选的 <code>argument_index</code> 是一个<code>十进制整数</code>，<strong>用于表明参数在参数列表中的位置</strong>。</li><li>第一个参数由 “1$”引用，第二个参数由”2$”引用，依此类推。<br><code>argument_index</code>很好理解，就是一参数占位符，用来表示要被格式化的参数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str1=&quot;hello&quot;;</span><br><span class="line">String str2=&quot;world&quot;;</span><br><span class="line">Formatter formatter=new Formatter();</span><br><span class="line">formatter.format(&quot;%2$s,%1$s&quot;, str1,str2);</span><br><span class="line">System.out.println(formatter);</span><br></pre></td></tr></table></figure><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">world,hello</span><br></pre></td></tr></table></figure><p></p><p>上面的<code>%2$s</code>,中的<code>s</code>表示这个参数字符串。详细往后看</p><h2 id="必选项conversion"><a href="#必选项conversion" class="headerlink" title="必选项conversion"></a>必选项<code>conversion</code></h2><p>注意：<code>conversion</code>和前面的<code>%</code>是格式化规则中必须要有的,这两者是必选项。其他的都是可以选项。</p><p><code>conversion</code> 是一个表明应该如何格式化参数的字符。用这个来确定被格式内容的类型，如果类型不匹配会报错。</p><h3 id="conversion分类："><a href="#conversion分类：" class="headerlink" title="conversion分类："></a><code>conversion</code>分类：</h3><ul><li><p><strong>常规</strong>-可应用于任何参数类型</p></li><li><p><strong>字符</strong>-可应用于表示Unicode字符的基本类型：char、Character、byte、Byte、short和Short。当Character.isValidCodePoint(int) 返回 true时，可将此转换应用于 int和Integer 类型</p></li><li><strong>数值</strong><ul><li><strong>整数</strong>-可应用于Java的整数类型：byte、Byte、short、Short、int、Integer、long、Long 和 BigInteger</li><li><strong>浮点数</strong>-可用于Java的浮点数类型：float、Float、double、Double 和 BigDecimal</li></ul></li><li><p><strong>日期/时间</strong>-可应用于Java的、能够对日期或时间进行编码的类型：long、Long、Calendar 和 Date。</p></li><li><p><strong>百分比</strong>-产生字面值’%’ (‘\u0025’)</p></li><li><strong>行分隔符</strong>-产生特定于平台的行分隔符</li></ul><h3 id="常规格式符"><a href="#常规格式符" class="headerlink" title="常规格式符"></a>常规格式符</h3><table><thead><tr><th style="text-align:left">常规格式符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>B b</code></td><td style="text-align:left">格式化为布尔字符串，如果参数arg 为 null，则结果为 “false”。如果arg 是一个 boolean 值或Boolean，则结果为String.valueOf() 返回的字符串。否则结果为 “true”。</td></tr><tr><td style="text-align:left"><code>H h</code></td><td style="text-align:left">格式化为哈希码，如果参数arg 为 null，则结果为 “null”。否则，结果为调用Integer.toHexString(arg.hashCode()) 得到的结果。</td></tr><tr><td style="text-align:left"><code>S s</code></td><td style="text-align:left">格式化为字符串，如果参数arg 为 null，则结果为 “null”。如果arg 实现 Formattable，则调用arg.formatTo。否则，结果为调用 arg.toString() 得到的结果。</td></tr></tbody></table><p>实例：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_conversion_s</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Formatter formatter=<span class="keyword">new</span> Formatter();</span><br><span class="line">String name = <span class="string">"World"</span>;</span><br><span class="line">formatter.format(<span class="string">"Hello %s !"</span>, name);</span><br><span class="line">System.out.println(formatter.toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_conversion_S</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Formatter formatter=<span class="keyword">new</span> Formatter();</span><br><span class="line">String name = <span class="string">"World"</span>;</span><br><span class="line">formatter.format(<span class="string">"Hello %S !"</span>, name);</span><br><span class="line">System.out.println(formatter.toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_conversion_b</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Formatter formatter=<span class="keyword">new</span> Formatter();</span><br><span class="line">String name = <span class="string">"World"</span>;</span><br><span class="line">formatter.format(<span class="string">"Hello %b !"</span>, name);</span><br><span class="line">System.out.println(formatter.toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_conversion_B</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Formatter formatter=<span class="keyword">new</span> Formatter();</span><br><span class="line">String name = <span class="string">"World"</span>;</span><br><span class="line">formatter.format(<span class="string">"Hello %B !"</span>, name);</span><br><span class="line">System.out.println(formatter.toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_conversion_h</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Formatter formatter=<span class="keyword">new</span> Formatter();</span><br><span class="line">String name = <span class="string">"World"</span>;</span><br><span class="line">formatter.format(<span class="string">"Hello %h !"</span>, name);</span><br><span class="line">System.out.println(formatter.toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_conversion_H</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Formatter formatter=<span class="keyword">new</span> Formatter();</span><br><span class="line">String name = <span class="string">"World"</span>;</span><br><span class="line">formatter.format(<span class="string">"Hello %H !"</span>, name);</span><br><span class="line">System.out.println(formatter.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Hello World !</span><br><span class="line">Hello WORLD !</span><br><span class="line">Hello <span class="keyword">true</span> !</span><br><span class="line">Hello TRUE !</span><br><span class="line">Hello <span class="number">4f</span>e2b72 !</span><br><span class="line">Hello <span class="number">4F</span>E2B72 !</span><br></pre></td></tr></table></figure><p></p><p>从结果中我们可以看出：大写<code>%S</code>就会格式化为大写的字符串，小写的<code>%s</code>就会格式化成小写的字符串。大写的<code>%B</code>就会格式化为大写的布尔字符串，小写的<code>%b</code>就格式化为小写的。<code>%H</code>格式化为大写的哈希码，<code>%h</code>格式化为小写的哈希码</p><h3 id="Unicode字符"><a href="#Unicode字符" class="headerlink" title="Unicode字符"></a>Unicode字符</h3><table><thead><tr><th style="text-align:left">字符格式符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>C c</code></td><td style="text-align:left">结果是一个 Unicode字符</td></tr></tbody></table><p>实例：中文对应的Unicode字符(Utf-16be)为<code>\u4E2D\u6587</code><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_conversion_c</span><span class="params">(Formatter formatter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span>[] chs=&#123;<span class="string">'\u4E2D'</span>,<span class="string">'\u6587'</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c : chs)</span><br><span class="line">&#123;</span><br><span class="line">formatter.format(<span class="string">"%c"</span>, c);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(formatter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">中文</span><br></pre></td></tr></table></figure><p></p><p>这里提一下，中文转为Unicode字符这个我还没去研究，暂时想到下面这种方式实现：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"中文"</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">String encodeStr = URLEncoder.encode(str, <span class="string">"utf-16be"</span>);</span><br><span class="line">encodeStr = encodeStr.replaceAll(<span class="string">"%(.&#123;2&#125;)%(.&#123;2&#125;)"</span>, <span class="string">"\\\\u$1$2"</span>);</span><br><span class="line">System.out.println(encodeStr);</span><br><span class="line">&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\u4E2D\u6587</span><br></pre></td></tr></table></figure><p></p><h3 id="整数格式符"><a href="#整数格式符" class="headerlink" title="整数格式符"></a>整数格式符</h3><table><thead><tr><th style="text-align:left">整数格式符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>d</code></td><td style="text-align:left">结果被格式化为十进制整数</td></tr><tr><td style="text-align:left"><code>o</code></td><td style="text-align:left">结果被格式化为八进制整数</td></tr><tr><td style="text-align:left"><code>X x</code></td><td style="text-align:left">结果被格式化为十六进制整数</td></tr></tbody></table><p>实例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Formatter formatter=new Formatter();</span><br><span class="line">int value=233;</span><br><span class="line">formatter.format(&quot;十进制:%d\n&quot;, value);</span><br><span class="line">formatter.format(&quot;八进制:%o\n&quot;, value);</span><br><span class="line">formatter.format(&quot;小写十六进制:%x\n&quot;, value);</span><br><span class="line">formatter.format(&quot;大写十六进制:%X\n&quot;, value);</span><br><span class="line">System.out.println(formatter);</span><br></pre></td></tr></table></figure><p></p><p>运行结果:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">十进制:233</span><br><span class="line">八进制:351</span><br><span class="line">小写十六进制:e9</span><br><span class="line">大写十六进制:E9</span><br></pre></td></tr></table></figure><p></p><table><thead><tr><th style="text-align:left">浮点数格式符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>f</code></td><td style="text-align:left">结果被格式化为十进制数</td></tr><tr><td style="text-align:left"><code>E e</code></td><td style="text-align:left">结果被格式化为用计算机科学记数法表示的十进制数</td></tr><tr><td style="text-align:left"><code>G g</code></td><td style="text-align:left">根据精度和舍入运算后的值，使用计算机科学记数形式或十进制格式对结果进行格式化。</td></tr><tr><td style="text-align:left"><code>A a</code></td><td style="text-align:left">结果被格式化为带有效位数和指数的十六进制浮点数</td></tr></tbody></table><p>实例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Formatter formatter=new Formatter();</span><br><span class="line">double value=1230000.45678;</span><br><span class="line">formatter.format(&quot;十进制浮点数:%f\n&quot;, value);</span><br><span class="line">formatter.format(&quot;科学计数法十进制浮点数:%e\n&quot;, value);</span><br><span class="line">formatter.format(&quot;科学计数法十进制浮点数:%E\n&quot;, value);</span><br><span class="line">formatter.format(&quot;根据精度和舍入运算后的值:%g\n&quot;, value);</span><br><span class="line">formatter.format(&quot;根据进度和舍入运算后的值:%G\n&quot;, value);</span><br><span class="line">value=12345.456789;</span><br><span class="line">formatter.format(&quot;根据精度和舍入运算后的值:%g\n&quot;, value);</span><br><span class="line">formatter.format(&quot;根据进度和舍入运算后的值:%G\n&quot;, value);</span><br><span class="line">formatter.format(&quot;带有效位数和指数的十六进制浮点数:%a\n&quot;, value);</span><br><span class="line">formatter.format(&quot;带有效位数和指数的十六进制浮点数:%A\n&quot;, value);</span><br><span class="line">System.out.println(formatter);</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">十进制浮点数:1230000.456780</span><br><span class="line">科学计数法十进制浮点数:1.230000e+06</span><br><span class="line">科学计数法十进制浮点数:1.230000E+06</span><br><span class="line">根据精度和舍入运算后的值:1.23000e+06</span><br><span class="line">根据进度和舍入运算后的值:1.23000E+06</span><br><span class="line">根据精度和舍入运算后的值:12345.5</span><br><span class="line">根据进度和舍入运算后的值:12345.5</span><br><span class="line">带有效位数和指数的十六进制浮点数:0x1.81cba780fdc16p13</span><br><span class="line">带有效位数和指数的十六进制浮点数:0X1.81CBA780FDC16P13</span><br></pre></td></tr></table></figure><p></p><h3 id="日期-时间转换前缀"><a href="#日期-时间转换前缀" class="headerlink" title="日期/时间转换前缀"></a>日期/时间转换前缀</h3><table><thead><tr><th style="text-align:left">日期格式符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>T t</code></td><td style="text-align:left">日期和时间转换字符的<code>前缀</code></td></tr></tbody></table><p>注意这里的<code>t/T</code>只是一个缀，它必须加上后缀才起作用。</p><h3 id="日期-时间转换后缀"><a href="#日期-时间转换后缀" class="headerlink" title="日期/时间转换后缀"></a>日期/时间转换后缀</h3><p>后缀如下</p><p>以下日期和时间转换的后缀字符是为 ‘t’ 和 ‘T’ 转换定义的。这些类型相似于但不完全等同于那些由 GNU date 和 POSIX strftime(3c) 定义的类型。提供其他转换类型是为了访问特定于 Java 的功能（如将 ‘L’ 用作秒中的毫秒）。</p><h4 id="格式化时间后缀"><a href="#格式化时间后缀" class="headerlink" title="格式化时间后缀"></a>格式化时间后缀</h4><p>以下转换字符用来<code>格式化时间</code>：</p><table><thead><tr><th style="text-align:left">时间后缀</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">‘<code>H</code>‘</td><td style="text-align:left"><code>24 小时制的小时</code>，被格式化<code>为必要时带前导零的两位数</code>，即 00 - 23。</td></tr><tr><td style="text-align:left">‘<code>I</code>‘</td><td style="text-align:left"><code>12 小时制的小时</code>，被格式化为<code>必要时带前导零的两位数</code>，即 01 - 12。</td></tr><tr><td style="text-align:left">‘<code>k</code>‘</td><td style="text-align:left"><code>24 小时制的小时</code>，即 0 - 23。</td></tr><tr><td style="text-align:left">‘<code>l</code>‘</td><td style="text-align:left"><code>12 小时制的小时</code>，即 1 - 12。</td></tr><tr><td style="text-align:left">‘<code>M</code>‘`</td><td style="text-align:left">小时中的分钟<code>，被格式化为</code>必要时带前导零的两位数`，即 00 - 59。</td></tr><tr><td style="text-align:left">‘<code>S</code>‘</td><td style="text-align:left"><code>分钟中的秒</code>，被格式化为<code>必要时带前导零的两位数</code>，即 00 - 60 （”60” 是支持闰秒所需的一个特殊值）。</td></tr><tr><td style="text-align:left">‘<code>L</code>‘</td><td style="text-align:left"><code>秒中的毫秒</code>，被格式化为<code>必要时带前导零的三位数</code>，即 000 - 999。</td></tr><tr><td style="text-align:left">‘<code>N</code>‘</td><td style="text-align:left">秒中的<code>毫微秒</code>，被格式化为<code>必要时带前导零的九位数</code>，即 000000000 - 999999999。</td></tr><tr><td style="text-align:left">‘<code>p</code>‘</td><td style="text-align:left">特定于语言环境的 <code>上午或下午</code> 标记以小写形式表示，例如 “am” 或 “pm”。使用转换前缀 ‘T’ 可以强行将此输出转换为大写形式。</td></tr><tr><td style="text-align:left">‘<code>z</code>‘</td><td style="text-align:left">相对于 GMT 的 RFC 822 格式的数字时区偏移量，例如 -0800。</td></tr><tr><td style="text-align:left">‘<code>Z</code>‘</td><td style="text-align:left">表示<code>时区缩写形式</code>的字符串。Formatter 的语言环境将取代参数的语言环境（如果有）。</td></tr><tr><td style="text-align:left">‘<code>s</code>‘</td><td style="text-align:left">自<code>协调世界时</code> (UTC) 1970 年 1 月 1 日 00:00:00 <code>至现在所经过的秒数</code>，即 Long.MIN_VALUE/1000 与 Long.MAX_VALUE/1000 之间的差值。</td></tr><tr><td style="text-align:left">‘<code>Q</code>‘</td><td style="text-align:left">自<code>协调世界时</code> (UTC) 1970 年 1 月 1 日 00:00:00 <code>至现在所经过的毫秒数</code>，即 Long.MIN_VALUE 与 Long.MAX_VALUE 之间的差值。</td></tr></tbody></table><h4 id="格式化日期后缀"><a href="#格式化日期后缀" class="headerlink" title="格式化日期后缀"></a>格式化日期后缀</h4><p>以下转换字符用来<code>格式化日期</code>：</p><p><strong>大写表示全称，小写表示简称</strong></p><table><thead><tr><th style="text-align:left">日期后缀</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">‘<code>B</code>‘</td><td style="text-align:left">特定于语言环境的<code>月份全称</code>，例如 “January” 和 “February”。</td></tr><tr><td style="text-align:left">‘<code>b</code>‘</td><td style="text-align:left">特定于语言环境的<code>月份简称</code>，例如 “Jan” 和 “Feb”。</td></tr><tr><td style="text-align:left">‘<code>h</code>‘</td><td style="text-align:left">与 ‘<code>b</code>‘ 相同。也就是月份的简称</td></tr><tr><td style="text-align:left">‘<code>A</code>‘</td><td style="text-align:left">特定于语言环境的<code>星期几全称</code>，例如 “Sunday” 和 “Monday”</td></tr><tr><td style="text-align:left">‘<code>a</code>‘</td><td style="text-align:left">特定于语言环境的<code>星期几简称</code>，例如 “Sun” 和 “Mon”</td></tr><tr><td style="text-align:left">‘<code>C</code>‘</td><td style="text-align:left"><code>除以 100 的四位数表示的年份</code>，被格式化为必要时带前导零的两位数，即 00 - 99</td></tr><tr><td style="text-align:left">‘<code>Y</code>‘</td><td style="text-align:left"><code>年份</code>，被格式化为<code>必要时带前导零的四位数</code>（至少），例如，0092 等于格里高利历的 92 CE。</td></tr><tr><td style="text-align:left">‘<code>y</code>‘</td><td style="text-align:left"><code>年份的最后两位数</code>，被格式化为<code>必要时带前导零的两位数</code>，即 00 - 99。</td></tr><tr><td style="text-align:left">‘<code>j</code>‘</td><td style="text-align:left"><code>一年中的天数</code>，被格式化为必要时带前导零的三位数，例如，对于格里高利历是 001 - 366。</td></tr><tr><td style="text-align:left">‘<code>m</code>‘</td><td style="text-align:left"><code>月份</code>，被格式化为<code>必要时带前导零的两位数</code>，即 01 - 13。</td></tr><tr><td style="text-align:left">‘<code>d</code>‘</td><td style="text-align:left"><code>一个月中的天数</code>，被格式化为<code>必要时带前导零两位数</code>，即 01 - 31</td></tr><tr><td style="text-align:left">‘<code>e</code>‘</td><td style="text-align:left"><code>一个月中的天数</code>，被格式化为两位数，即 1 - 31。</td></tr></tbody></table><h4 id="常见的日期-时间组合简写"><a href="#常见的日期-时间组合简写" class="headerlink" title="常见的日期/时间组合简写"></a>常见的日期/时间组合简写</h4><p>以下转换字符用于格式化<code>常见的日期/时间组合</code>。</p><table><thead><tr><th style="text-align:left">日期/时间组合</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">‘<code>R</code>‘</td><td style="text-align:left"><code>24 小时制的时间</code>，被格式化为 “<code>%tH:%tM</code>“</td></tr><tr><td style="text-align:left">‘<code>T</code>‘</td><td style="text-align:left"><code>24 小时制的时间</code>，被格式化为 “<code>%tH:%tM:%tS</code>“。</td></tr><tr><td style="text-align:left">‘<code>r</code>‘</td><td style="text-align:left"><code>12 小时制的时间</code>，被格式化为 “<code>%tI:%tM:%tS %Tp</code>“。上午或下午标记 (‘%Tp’) 的位置可能与语言环境有关。</td></tr><tr><td style="text-align:left">‘<code>D</code>‘</td><td style="text-align:left"><code>日期</code>，被格式化为 “<code>%tm/%td/%ty</code>“。</td></tr><tr><td style="text-align:left">‘<code>F</code>‘</td><td style="text-align:left"><code>ISO 8601 格式的完整日期</code>，被格式化为 “<code>%tY-%tm-%td</code>“。</td></tr><tr><td style="text-align:left">‘<code>c</code>‘</td><td style="text-align:left"><code>日期和时间</code>，被格式化为 “<code>%ta %tb %td %tT %tZ %tY</code>“，例如 “<code>Sun Jul 20 16:17:00 EDT 1969</code>“。</td></tr></tbody></table><p>任何未明确定义为转换的字符都是非法字符，并且都被保留，以供将来扩展使用。</p><p>实例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Formatter formatter = new Formatter();</span><br><span class="line">Date date = new Date();</span><br><span class="line">formatter.format(&quot;年月日:%1$tY-%1$tm-%1$td\n&quot;, date);</span><br><span class="line">formatter.format(&quot;时分秒:%1$tH:%1$tM:%1$tS\n&quot;, date);</span><br><span class="line">formatter.format(&quot;月份    :%1$tB 星期:%1$tA\n&quot;, date);</span><br><span class="line">formatter.format(&quot;年月日时分秒:%1$tY-%1$tm-%1$td %1$tH:%1$tM:%1$tS\n&quot;, date);</span><br><span class="line">formatter.format(&quot;日期年份        :%1$tc\n&quot;, date);</span><br><span class="line">formatter.format(&quot;年月日时分    简写:%1$tF %1$tR\n&quot;, date);</span><br><span class="line">formatter.format(&quot;年月日时分秒简写:%1$tF %1$tT\n&quot;, date);</span><br><span class="line">System.out.println(formatter);</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">年月日:2018-08-12</span><br><span class="line">时分秒:19:02:20</span><br><span class="line">月份    :八月 星期:星期日</span><br><span class="line">年月日时分秒:2018-08-12 19:02:20</span><br><span class="line">日期年份        :星期日 八月 12 19:02:20 CST 2018</span><br><span class="line">年月日时分    简写:2018-08-12 19:02</span><br><span class="line">年月日时分秒简写:2018-08-12 19:02:20</span><br></pre></td></tr></table></figure><p></p><h3 id="格式化百分号"><a href="#格式化百分号" class="headerlink" title="格式化百分号"></a>格式化百分号</h3><table><thead><tr><th style="text-align:left">百分号</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>%</code></td><td style="text-align:left">结果为字面值 ‘<code>%</code>‘</td></tr></tbody></table><p>这是因为<code>%</code>在格式语法中是必选项，<code>%</code>有特殊含义所以在格式的时候，使用<code>%%</code>来表示<code>%</code>这个符号本身。</p><p>实例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void testFormatPercent()</span><br><span class="line">&#123;</span><br><span class="line">Formatter formatter = new Formatter();</span><br><span class="line">String string=&quot;Hello World!&quot;;</span><br><span class="line">formatter.format(&quot;%% %s %%&quot;, string);</span><br><span class="line">System.out.println(formatter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% Hello World! %</span><br></pre></td></tr></table></figure><p></p><h3 id="格式化行分隔符"><a href="#格式化行分隔符" class="headerlink" title="格式化行分隔符"></a>格式化行分隔符</h3><table><thead><tr><th style="text-align:left">行分隔符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>n</code></td><td style="text-align:left">结果为特定于平台的行分隔符</td></tr></tbody></table><p>实例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Formatter formatter = new Formatter();</span><br><span class="line">String string=&quot;Hello%nWorld!&quot;;</span><br><span class="line">formatter.format(string);</span><br><span class="line">System.out.println(formatter);</span><br></pre></td></tr></table></figure><p></p><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br><span class="line">World!</span><br></pre></td></tr></table></figure><h3 id="可选项-width"><a href="#可选项-width" class="headerlink" title="可选项[width]"></a>可选项<code>[width]</code></h3><p>可选项<code>width</code> 是一个非负十进制整数，表明要向输出中写入的最少字符<br><code>width</code> 就表示一最少字符数，被格式化参数字符个数如果小于<code>width</code> ，则补上字符让字符宽度等于<code>width</code> 。如果被格式化字符宽度大于<code>width</code>则不用补齐，<code>width</code>不起作用。所以<code>width</code> 的作用就是<code>为少补齐</code><br>实例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void testWidth()</span><br><span class="line">&#123;</span><br><span class="line">int value = 123;</span><br><span class="line">Formatter formatter = new Formatter();</span><br><span class="line">formatter.format(&quot;%4d%6d%10d\n&quot;, value,value,value);</span><br><span class="line">formatter.format(&quot;%1$4d%1$6d%1$10d&quot;, value);</span><br><span class="line">System.out.println(formatter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">123   123       123</span><br><span class="line">123   123       123</span><br></pre></td></tr></table></figure><p></p><h3 id="可选项-precision"><a href="#可选项-precision" class="headerlink" title="可选项[.precision]"></a>可选项<code>[.precision]</code></h3><p>可选 <code>precision</code> 是一个非负十进制整数，通常用来限制字符数。特定行为取决于转换类型。<br><code>precision</code> 是一个截取器，用于截取被格式化参数。被格式化参数用<code>precision</code> 截取器截取后与<code>width</code> 相比，<br>实例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">double value=321.123456789;</span><br><span class="line">Formatter formatter=new Formatter();</span><br><span class="line">formatter.format(&quot;只精确到小数点后三位:%1$.3f\n&quot;, value);</span><br><span class="line">formatter.format(&quot;总共占10位,只精确到小数点后三位:%10.3f\n&quot;, value);</span><br><span class="line">System.out.println(formatter);</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">只精确到小数点后三位:321.123</span><br><span class="line">总共占10位,只精确到小数点后三位:   321.123</span><br></pre></td></tr></table></figure><p></p><p>要注意的是<code>[width]</code>选项掌管的是整个格式化字符串的宽度，<code>[.precision]</code>设置的是小数点后面能显示几位。小数点和小数点后面的宽度都在都包含在width宽度之内，例如上面的<code>321.123</code>占7个字符，而<strong><code>%10.3f</code>表示整个占<code>10</code>个字符，这十个字符里面小数点后面占<code>3</code></strong>位，所以会在<code>321.123</code>前面补上三个空格占满10个字符。如果设置为<code>%6.3f</code>则真正的宽度为<code>7</code>大于<code>6</code>，<code>width</code>属性失效。</p><h2 id="可选项-flags"><a href="#可选项-flags" class="headerlink" title="可选项[flags]"></a>可选项<code>[flags]</code></h2><p>可选项<code>flags</code> 是修改输出格式的字符集。有效标志集取决于转换类型。</p><table><thead><tr><th>标记</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td><code>-</code></td><td>结果将是<code>左对齐</code>的。</td><td><code>%-4d</code> 宽度最小为四位并且左对齐</td></tr><tr><td><code>0</code></td><td>结果将用<code>零来填充</code></td><td><code>%010d</code> 所有宽度不满10位的数字填充前导0</td></tr><tr><td><code>#</code></td><td>如果是浮点数则结果加小数点，十六进制和八进制分别加<code>0x</code>和<code>0</code></td><td><code>%#x</code> 最后输出结果变为16进制并且加0x</td></tr><tr><td><code>,</code></td><td>结果将包括特定于语言环境的<code>组分隔符</code></td><td><code>%，d</code> 每三位数字来个逗号，看起来清晰</td></tr><tr><td><code>+</code></td><td>正数数字会额外显示一个<code>+</code>号</td><td><code>%+d</code> 结果如果是正数则显示＋号</td></tr><tr><td><code>一个空格</code></td><td>对于正值，结果中将包括一个前导空格</td><td><code>% d</code> 如果结果是正数则在前面加个空格</td></tr><tr><td><code>(</code></td><td>结果将是用圆括号括起来的负数</td><td><code>%（d</code> 如果结果是负数，不写符号而是用（）括起来</td></tr></tbody></table><p>注意支持的类型：</p><p>下表总结了受支持的标志。<code>y</code> 表示该标志受指示参数类型支持。</p><table><thead><tr><th>标志</th><th>常规</th><th>字符</th><th>整数</th><th>浮点</th><th>日期/时间</th><th>说明</th></tr></thead><tbody><tr><td>‘<code>-</code>‘</td><td>y</td><td>y</td><td>y</td><td>y</td><td>y</td><td>结果将是左对齐的。</td></tr><tr><td>‘<code>#</code>‘</td><td>y1</td><td>-</td><td>y3</td><td>y</td><td>-</td><td>结果应该使用依赖于转换类型的替换形式</td></tr><tr><td>‘<code>+</code>‘</td><td>-</td><td>-</td><td>y4</td><td>y</td><td>-</td><td>结果总是包括一个符号</td></tr><tr><td>‘<code></code>‘</td><td>-</td><td>-</td><td>y4</td><td>y</td><td>-</td><td>对于正值，结果中将包括一个前导空格</td></tr><tr><td>‘<code>0</code>‘</td><td>-</td><td>-</td><td>y</td><td>y</td><td>-</td><td>结果将用零来填充</td></tr><tr><td>‘<code>,</code>‘</td><td>-</td><td>-</td><td>y2</td><td>y5</td><td>-</td><td>结果将包括特定于语言环境的组分隔符</td></tr><tr><td>‘<code>(</code>‘</td><td>-</td><td>-</td><td>y4</td><td>y5</td><td>-</td><td>结果将是用圆括号括起来的负数</td></tr></tbody></table><h3 id="设置左右对齐-0补齐"><a href="#设置左右对齐-0补齐" class="headerlink" title="设置左右对齐,0补齐"></a>设置左右对齐,0补齐</h3><table><thead><tr><th>标记</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td><code>-</code></td><td>结果将是左对齐的。</td><td><code>%-4d</code> 宽度最小为四位并且左对齐</td></tr><tr><td><code>0</code></td><td>结果将用零来填充</td><td><code>%010d</code> 所有宽度不满10位的数字填充前导0</td></tr></tbody></table><p>实例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void testAlign()</span><br><span class="line">&#123;</span><br><span class="line">double value=321.123456789;</span><br><span class="line">Formatter formatter=new Formatter();</span><br><span class="line">formatter.format(&quot;总共占10位,只精确到小数点后三位:%10.3f##\n&quot;, value);</span><br><span class="line">formatter.format(&quot;左对齐,总共占10位,不足0填充,只精确到小数点后三位:%010.3f##\n&quot;, value);</span><br><span class="line">formatter.format(&quot;左对齐,总共占10位,只精确到小数点后三位:%-10.3f##\n&quot;, value);</span><br><span class="line">System.out.println(formatter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">总共占10位,只精确到小数点后三位:   321.123##</span><br><span class="line">左对齐,总共占10位,不足0填充,只精确到小数点后三位:000321.123##</span><br><span class="line">左对齐,总共占10位,只精确到小数点后三位:321.123   ##</span><br></pre></td></tr></table></figure><p></p><h3 id="正负数符号表示"><a href="#正负数符号表示" class="headerlink" title="正负数符号表示"></a>正负数符号表示</h3><table><thead><tr><th>标记</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td><code>+</code></td><td>正数数字会额外显示一个<code>+</code>号</td><td><code>%+d</code> 结果如果是正数则显示＋号</td></tr><tr><td><code>一个空格</code></td><td>对于正值，结果中将包括一个前导空格</td><td><code>% d</code> 如果结果是正数则在前面加个空格</td></tr><tr><td><code>(</code></td><td>结果将是用圆括号括起来的负数</td><td><code>%（d</code> 如果结果是负数，不写符号而是用（）括起来</td></tr></tbody></table><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">double value=321.123456789;</span><br><span class="line"></span><br><span class="line">StringBuilder builder=new StringBuilder();</span><br><span class="line">//格式化结果输出到StringBuilder中</span><br><span class="line">Formatter formatter = new Formatter(builder);</span><br><span class="line"></span><br><span class="line">formatter.format(&quot;显示正负号        ,左对齐,总共占10位,只精确到小数点后三位:%+-10.3f##\n&quot;, value);</span><br><span class="line">formatter.format(&quot;用空格表示正数,左对齐,总共占10位,只精确到小数点后三位:% -10.3f##\n&quot;, value);</span><br><span class="line">formatter.format(&quot;用空格表示正数,左对齐,总共占10位,只精确到小数点后三位:%(-10.3f##\n&quot;, value);</span><br><span class="line">value=-value;</span><br><span class="line">formatter.format(&quot;显示正负号        ,左对齐,总共占10位,只精确到小数点后三位:%+-10.3f##\n&quot;, value);</span><br><span class="line">formatter.format(&quot;用空格表示正数,左对齐,总共占10位,只精确到小数点后三位:% -10.3f##\n&quot;, value);</span><br><span class="line">formatter.format(&quot;用空格表示正数,左对齐,总共占10位,只精确到小数点后三位:%(-10.3f##\n&quot;, value);</span><br><span class="line">formatter.close();</span><br><span class="line">System.out.println(builder);</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://i.imgur.com/m6maPtX.png" alt=""></p><h3 id="加进制标志加小数点"><a href="#加进制标志加小数点" class="headerlink" title="加进制标志加小数点"></a>加进制标志加小数点</h3><table><thead><tr><th>标记</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td><code>#</code></td><td>如果是浮点数则结果加小数点，十六进制和八进制分别加<code>0x</code>和<code>0</code></td><td><code>%#x</code> 最后输出结果变为16进制并且加0x</td></tr></tbody></table><p>先来回顾一下java，二进制，八进制，十六进制整数的静态初始化：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a=0123;//8进制数</span><br><span class="line">int b=0xAA;//16进制数</span><br><span class="line">int c=0b1010;//二进制数</span><br></pre></td></tr></table></figure><p></p><p>也可以使用：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//解析16进制数为十进制数</span><br><span class="line">int x=Integer.parseInt(&quot;FF&quot;, 16);</span><br></pre></td></tr></table></figure><p></p><p>这种方式来把其他进制转成10进制。<br>实例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int a = 0123;// 8进制数</span><br><span class="line">int b = 0xAA;// 16进制数</span><br><span class="line">int c = 0b1010;// 二进制数</span><br><span class="line">StringBuilder builder=new StringBuilder();</span><br><span class="line">//格式化结果输出到StringBuilder中</span><br><span class="line">Formatter formatter = new Formatter(builder);</span><br><span class="line">// 解析16进制数为十进制数</span><br><span class="line">int x = Integer.parseInt(&quot;FF&quot;, 16);</span><br><span class="line">formatter.format(&quot;十进制:%1$-4d 等于%2$-3d进制:%1$#o\n&quot;, a, 8);</span><br><span class="line">formatter.format(&quot;十进制:%1$-4d 等于%2$-3d进制:%1$#x\n&quot;, a, 16);</span><br><span class="line">formatter.format(&quot;十进制:%1$-4d 等于%2$-3d进制:%1$#o\n&quot;, b, 8);</span><br><span class="line">formatter.format(&quot;十进制:%1$-4d 等于%2$-3d进制:%1$#x\n&quot;, b, 16);</span><br><span class="line">formatter.format(&quot;十进制:%1$-4d 等于%2$-3d进制:%1$#o\n&quot;, c, 8);</span><br><span class="line">formatter.format(&quot;十进制:%1$-4d 等于%2$-3d进制:%1$#x\n&quot;, c, 16);</span><br><span class="line">formatter.format(&quot;十进制:%1$-4d 等于%2$-3d进制:%1$#o\n&quot;, x, 8);</span><br><span class="line">formatter.format(&quot;十进制:%1$-4d 等于%2$-3d进制:%1$#x\n&quot;, x, 16);</span><br><span class="line">// formatter.format(&quot;%#b\n&quot;,c);</span><br><span class="line">formatter.close();</span><br><span class="line">System.out.println(builder.toString());</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">十进制:83   等于8  进制:0123</span><br><span class="line">十进制:83   等于16 进制:0x53</span><br><span class="line">十进制:170  等于8  进制:0252</span><br><span class="line">十进制:170  等于16 进制:0xaa</span><br><span class="line">十进制:10   等于8  进制:012</span><br><span class="line">十进制:10   等于16 进制:0xa</span><br><span class="line">十进制:255  等于8  进制:0377</span><br><span class="line">十进制:255  等于16 进制:0xff</span><br></pre></td></tr></table></figure><p></p><p>中英文混合输出的情况下英文应该使用左对齐，这样排列起来才整齐，还有就是使用等宽字体。</p><h3 id="组分隔符"><a href="#组分隔符" class="headerlink" title="组分隔符"></a>组分隔符</h3><table><thead><tr><th>标记</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td><code>,</code></td><td>结果将包括特定于语言环境的<code>组分隔符</code></td><td><code>%，d</code> 每三位数字来个逗号，看起来清晰</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder builder=new StringBuilder();</span><br><span class="line">//格式化结果输出到StringBuilder中</span><br><span class="line">Formatter formatter = new Formatter(builder);</span><br><span class="line">//formatter.close();</span><br><span class="line">//System.out.println(builder);</span><br><span class="line">int value=123456789;</span><br><span class="line">formatter.format(&quot;%,d\n&quot;,value);</span><br><span class="line">formatter.close();</span><br><span class="line">System.out.println(builder);</span><br></pre></td></tr></table></figure><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123,456,789</span><br></pre></td></tr></table></figure><p></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/7906d867/">java_util_Formatter类</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> java_util </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>FormatterAPI介绍</title>
      <link href="/blog/bac4a0b7/"/>
      <url>/blog/bac4a0b7/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p><code>public final class Formatter extends Object implements Closeable, Flushable</code></p><p><code>printf</code> 风格的格式字符串的解释程序。此类<strong>提供了对布局对齐和排列的支持</strong>，<strong>以及对数值、字符串和日期/时间数据的常规格式和特定于语言环境的输出的支持。</strong>支持诸如 <code>byte</code>、<code>BigDecimal</code> 和 <code>Calendar</code> 等常见 <code>Java</code> 类型。</p><p>任意用户类型的受限格式化定制都是通过 <code>Formattable</code> 接口提供的。</p><p><code>Formatter</code> 对于多线程访问而言没必要是安全的。线程安全是可选的，它对此类中的方法用户负责。</p><h2 id="Java-语言的格式化与C语言的区别"><a href="#Java-语言的格式化与C语言的区别" class="headerlink" title="Java 语言的格式化与C语言的区别"></a><code>Java</code> 语言的格式化与<code>C</code>语言的区别</h2><p><code>Java</code> 语言的格式化输出在<strong>很大程度上受到 <code>C</code> 语言 <code>printf</code> 的启发</strong>。虽然一些格式字符串与 <code>C</code> 类似，但已进行了某些定制，以适应 <code>Java</code> 语言，并且利用了其中一些特性。此外，<strong><code>Java</code> 的格式比 <code>C</code> 的格式更严格</strong>；例如，如果转换与标志不兼容，则会抛出异常。在 <code>C</code> 中，不适用的标志会被忽略。这样，便于 <code>C</code> 程序员识别这些格式字符串，而又不必与 <code>C</code> 中的那些标志完全兼容。</p><h2 id="推荐写法"><a href="#推荐写法" class="headerlink" title="推荐写法"></a>推荐写法</h2><p>所期望用法的示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = new StringBuilder();</span><br><span class="line">//把所有的输出结果输出到可以追加的StringBuilder对象中</span><br><span class="line">Formatter formatter = new Formatter(sb, Locale.US);</span><br><span class="line">//使用参数索引可以对输出顺序进行排列</span><br><span class="line">formatter.format(&quot;%4$2s %3$2s %2$2s %1$2s&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)</span><br><span class="line">// -&quot; d  c  b  a&quot;</span><br><span class="line">//可以选择地区作为第一个参数以便使用本地的方式来格式化数字</span><br><span class="line">//宽度可以设置这个值占多少个字符</span><br><span class="line">//精度可以设置小数点后面显示的精度</span><br><span class="line">formatter.format(Locale.FRANCE, &quot;e = %+10.4f&quot;, Math.E);</span><br><span class="line">// -&quot;e =    +2,7183&quot;</span><br></pre></td></tr></table></figure><p></p><p>常见格式化请求的便捷方法是按照如下调用格式来阐明的：</p><h2 id="使用System-out-format"><a href="#使用System-out-format" class="headerlink" title="使用System.out.format()"></a>使用System.out.format()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 格式化字符串到System.out。</span><br><span class="line">System.out.format(&quot;Local time: %tT&quot;, Calendar.getInstance());</span><br><span class="line">// -&gt; &quot;Local time: 13:34:18&quot;</span><br><span class="line"></span><br><span class="line">//将格式化输出写入Simult.err。</span><br><span class="line">System.err.printf(&quot;Unable to open file &apos;%1$s&apos;: %2$s&quot;,fileName, exception.getMessage());</span><br><span class="line">// -&gt; &quot;Unable to open file &apos;food&apos;: No such file or directory&quot;</span><br></pre></td></tr></table></figure><h2 id="使用String-format-方法"><a href="#使用String-format-方法" class="headerlink" title="使用String.format()方法"></a>使用String.format()方法</h2><p>与 <code>C</code> 语言的 <code>sprintf(3)</code> 类似，可以<strong>使用静态方法 <code>String.format(String</code>,<code>Object...)String.format</code></strong> 来格式化 <code>Strings</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 格式化包含日期的字符串。</span><br><span class="line">import java.util.Calendar;</span><br><span class="line">import java.util.GregorianCalendar;</span><br><span class="line">import static java.util.Calendar.*;</span><br><span class="line">......</span><br><span class="line">Calendar c = new GregorianCalendar(1995, MAY, 23);</span><br><span class="line">String s = String.format(&quot;Duke&apos;s Birthday: %1$tm %1$te,%1$tY&quot;, c);</span><br><span class="line">// -&gt; s == &quot;Duke&apos;s Birthday: May 23, 1995&quot;</span><br></pre></td></tr></table></figure><h1 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h1><p>此规范分为两部分。</p><ul><li>第一部分是<a href="#abstract">摘要</a>，包括基本的格式概念。这一部分是为那些想要快速入门并熟悉其他编程语言的格式化输出的用户准备的。</li><li>第二部分是<a href="#detailed_information">详细信息</a>，包括具体的实现细节。它是为那些需要更精确格式化行为规范的用户准备的。</li></ul><p></p><div id="abstract"></div><p></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>这一部分将提供对格式概念的简单概述。有关精确的行为细节，请参阅<a href="#detailed_information">详细信息</a>部分。</p><h2 id="格式字符串语法"><a href="#格式字符串语法" class="headerlink" title="格式字符串语法"></a>格式字符串语法</h2><p>产生格式化输出的每个方法都需要<strong>格式字符串</strong> 和<strong>参数列表</strong>。格式字符串是一个 <code>String</code>，它可以包含固定文本以及一个或多个嵌入的格式说明符。请考虑以下示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Calendar c = ...;</span><br><span class="line">String s = String.format(<span class="string">"Duke's Birthday: %1$tm %1$te,%1$tY"</span>, c);</span><br></pre></td></tr></table></figure><h3 id="格式字符串："><a href="#格式字符串：" class="headerlink" title="格式字符串："></a>格式字符串：</h3><p>此<strong>格式字符串是 <code>format</code> 方法的第一个参数</strong>。它包含三个格式说明符 “<code>%1$tm</code>“、”<code>%1$te</code>“ 和 “<code>%1$tY</code>“，<strong>它们指出应该如何处理参数以及在文本的什么地方插入它们</strong>。格式字符串的其余部分是包括 “Dukes Birthday: “ 和其他任何空格或标点符号的固定文本。</p><h3 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h3><p>参数列表由传递给位于格式字符串之后的方法的所有参数组成。在上述示例中，参数列表的大小为<code>1</code>，由对象 <code>Calendar c</code> 组成。</p><h2 id="格式说明符语法"><a href="#格式说明符语法" class="headerlink" title="格式说明符语法"></a>格式说明符语法</h2><h3 id="常规类型、字符类型和数值类型的格式说明符"><a href="#常规类型、字符类型和数值类型的格式说明符" class="headerlink" title="常规类型、字符类型和数值类型的格式说明符"></a>常规类型、字符类型和数值类型的格式说明符</h3><p>常规类型、字符类型和数值类型的格式说明符的语法如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[argument_index$][flags][width][.precision]conversion</span><br></pre></td></tr></table></figure><p></p><ul><li>可选的<code>argument_index</code> 是一个十进制整数，用于表明参数在参数列表中的位置。第一个参数由 “<code>1$</code>“ 引用，第二个参数由 “<code>2$</code>“ 引用，依此类推。</li><li>可选 <code>flags</code> 是修改输出格式的字符集。有效标志集取决于转换类型。</li><li>可选 <code>width</code> 是一个非负十进制整数，表明要向输出中写入的最少字符数。</li><li>可选 <code>precision</code> 是一个非负十进制整数，通常用来限制字符数。特定行为取决于转换类型。</li><li>所需 <code>conversion</code> 是一个表明应该如何格式化参数的字符。给定参数的有效转换集取决于参数的数据类型。</li></ul><h3 id="表示日期和时间类型的格式说明符"><a href="#表示日期和时间类型的格式说明符" class="headerlink" title="表示日期和时间类型的格式说明符"></a>表示日期和时间类型的格式说明符</h3><p>用来表示日期和时间类型的格式说明符的语法如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[argument_index$][flags][width]conversion</span><br></pre></td></tr></table></figure><p></p><p>可选的 <code>argument_index</code>、<code>flags</code> 和 <code>width</code> 的定义同上。</p><p>所需的 <code>conversion</code> 是一个由两字符组成的序列。第一个字符是 ‘<code>t</code>‘ 或 ‘<code>T</code>‘。第二个字符表明所使用的格式。这些字符类似于但不完全等同于那些由 <code>GNU date</code> 和 <code>POSIX strftime(3c)</code> 定义的字符。</p><h3 id="参数不对应的格式说明符"><a href="#参数不对应的格式说明符" class="headerlink" title="参数不对应的格式说明符"></a>参数不对应的格式说明符</h3><p>与参数不对应的格式说明符的语法如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[flags][width]conversion</span><br></pre></td></tr></table></figure><p></p><p>可选 <code>flags</code> 和 <code>width</code> 的定义同上。<br>所需的 <code>conversion</code> 是一个表明要在输出中所插内容的字符。</p><h2 id="转换符conversion"><a href="#转换符conversion" class="headerlink" title="转换符conversion"></a>转换符<code>conversion</code></h2><p>转换符<code>conversion</code>可分为以下几类：</p><ul><li>常规 可应用于任何参数类型</li><li>字符 可应用于表示 <code>Unicode</code> 字符的基本类型：<code>char</code>、<code>Character</code>、<code>byte</code>、<code>Byte</code>、<code>short</code> 和 <code>Short</code>。当 <code>Character.isValidCodePoint(int)</code> 返回 <code>true</code> 时，可将此转换应用于 <code>int</code> 和 <code>Integer</code> 类型</li><li>数值<ul><li>整数 可应用于 <code>Java</code> 的整数类型：<code>byte</code>、<code>Byte</code>、<code>short</code>、<code>Short</code>、<code>int</code>、<code>Integer</code>、<code>long</code>、<code>Long</code> 和 <code>BigInteger</code></li><li>浮点 可用于 <code>Java</code> 的浮点类型：<code>float</code>、<code>Float</code>、<code>double</code>、<code>Double</code> 和 <code>BigDecimal</code></li></ul></li><li>日期/时间 可应用于 <code>Java</code> 的、能够对日期或时间进行编码的类型：<code>long</code>、<code>Long</code>、<code>Calendar</code> 和 <code>Date</code>。</li><li>百分比 产生字面值 ‘<code>%</code>‘ (‘<code>\u0025</code>‘)</li><li>行分隔符 产生特定于平台的行分隔符</li></ul><p>下表总结了受支持的转换。由大写字符（如 ‘<code>B</code>‘、’<code>H</code>‘、’<code>S</code>‘、’<code>C</code>‘、’<code>X</code>‘、’<code>E</code>‘、’<code>G</code>‘、’<code>A</code>‘ 和 ‘<code>T</code>‘）表示的转换与由相应的小写字符的转换等同，根据流行的 <code>Locale</code> 规则将结果转换为大写形式除外。后者等同于 <code>String.toUpperCase()</code> 的以下调用 <code>out.toUpperCase()</code></p><p>表在上面了。</p><h2 id="宽度-width"><a href="#宽度-width" class="headerlink" title="宽度[width]"></a>宽度[width]</h2><p><strong>宽度是将向输出中写入的最少字符数</strong>。对于行分隔符转换，不适用宽度，如果提供宽度，则会抛出异常。</p><h2 id="精度-precision"><a href="#精度-precision" class="headerlink" title="精度[.precision]"></a>精度[.precision]</h2><ul><li>对于常规参数类型，精度是将向输出中写入的最多字符数。</li><li>对于浮点转换 ‘e’、’E’ 和 ‘f’，精度是小数点分隔符后的位数。如果转换是 ‘g’ 或 ‘G’，那么精度是舍入计算后所得数值的所有位数。如果转换是 ‘a’ 或 ‘A’，则不必指定精度。</li><li>对于字符、整数和日期/时间参数类型转换，以及百分比和行分隔符转换，精度是不适用的；如果提供精度，则会抛出异常。</li></ul><h2 id="参数索引-argument-index"><a href="#参数索引-argument-index" class="headerlink" title="参数索引[argument_index$]"></a>参数索引[argument_index$]</h2><p>参数索引是一个十进制整数，<strong>用于表明参数在参数列表中的位置</strong>。第一个参数由 “1$” 引用，第二个参数由 “2$” 引用，依此类推。</p><p>根据位<strong>置引用参数的另一种方法</strong>是使用 ‘<code>&lt;</code>‘ (‘<code>\u003c</code>‘) 标志，<strong>这将会重用以前格式说明符的参数</strong>。例如，以下两条语句产生的字符相同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Calendar c = ...;</span><br><span class="line">String s1 = String.format(&quot;Duke&apos;s Birthday: %1$tm %1$te,%1$tY&quot;, c);</span><br><span class="line">String s2 = String.format(&quot;Duke&apos;s Birthday: %1$tm %&lt;te,%&lt;tY&quot;, c);</span><br></pre></td></tr></table></figure><p><code>%&lt;te</code>中的<code>&lt;</code>重用前面的<code>%1$tm</code>参数，也是<code>1$</code>，也就是参数<code>c</code></p><p></p><div id="detailed_information"></div><p></p><h1 id="详细信息"><a href="#详细信息" class="headerlink" title="详细信息"></a>详细信息</h1><p>这一部分将提供格式化行为规范方面的细节，其中包括条件和异常、受支持的数据类型、本地化以及标志、转换和数据类型之间的交互。有关格式化概念的概述，请参阅<a href="#abstract">摘要</a>。</p><p>任何未明确定义为转换、日期/时间转换前缀或标志的字符都是非法字符，并且这些字符都被保留，以供未来扩展使用。在格式字符串中使用这样的字符会导致抛出 <code>UnknownFormatConversionException</code> 或 <code>UnknownFormatFlagsException</code>。</p><p>如果格式说明符包含带有无效值或不受支持的其他值的宽度或精度，则将分别抛出 <code>IllegalFormatWidthException</code> 或 <code>IllegalFormatPrecisionException</code>。</p><p>如果格式说明符包含不适用于对应参数的转换字符，则将抛出 <code>IllegalFormatConversionException</code>。</p><p>所有指定异常都可能被 <code>Formatter</code> 的任何 <code>format</code> 方法以及任何 <code>format</code> 的便捷方法抛出，比如 <code>String.format(String,Object...)</code> 和 <code>java.io.PrintStream.printf(String,Object...)</code></p><p>由大写字符（如 ‘<code>B</code>‘、’<code>H</code>‘、’<code>S</code>‘、’<code>C</code>‘、’<code>X</code>‘、’<code>E</code>‘、’<code>G</code>‘、’<code>A</code>‘ 和 ‘<code>T</code>‘）表示的转换与那些相应的小写字符表示的转换相同，根据流行的 <code>Locale</code> 规则将结果转换成大写形式除外。结果等同于 <code>String.toUpperCase()</code> 的以下调用 <code>out.toUpperCase()</code></p><h2 id="常规"><a href="#常规" class="headerlink" title="常规"></a>常规</h2><h3 id="常规转换符说明"><a href="#常规转换符说明" class="headerlink" title="常规转换符说明"></a>常规转换符说明</h3><p>以下常规转换可应用于任何参数类型：</p><table><thead><tr><th style="text-align:left">格式符</th><th style="text-align:left">生成结果</th><th style="text-align:left">生成过程</th></tr></thead><tbody><tr><td style="text-align:left">‘<code>b</code>‘</td><td style="text-align:left">‘<code>\u0062</code>‘ <code>将生成 &quot;true&quot; 或 &quot;false&quot;</code></td><td style="text-align:left">由 Boolean.toString(boolean) 返回。如果参数为 null，则结果为 “false”。如果参数是一个 boolean 值或 Boolean，那么结果是由 String.valueOf() 返回的字符串。否则结果为 “true”。如果给出 ‘#’ 标志，则将抛出 FormatFlagsConversionMismatchException。</td></tr><tr><td style="text-align:left">‘<code>B</code>‘</td><td style="text-align:left">‘<code>\u0042</code>‘ ‘<code>b</code>‘ 的大写形式。</td><td style="text-align:left">同上</td></tr><tr><td style="text-align:left">‘<code>h</code>‘</td><td style="text-align:left">‘<code>\u0068</code>‘ <code>生成一个表示对象的哈希码值的字符串</code></td><td style="text-align:left">如果参数 arg 为 null，则结果为 “null”。否则，结果为调用 Integer.toHexString(arg.hashCode()) 得到的结果。如果给出 ‘#’ 标志，则将抛出 FormatFlagsConversionMismatchException。</td></tr><tr><td style="text-align:left">‘<code>H</code>‘</td><td style="text-align:left">‘<code>\u0048</code>‘ ‘<code>h</code>‘ 的大写形式。</td><td style="text-align:left">同上</td></tr><tr><td style="text-align:left">‘<code>s</code>‘</td><td style="text-align:left">‘<code>\u0073</code>‘ <code>生成一个字符串</code></td><td style="text-align:left">如果参数为 null，则结果为 “null”。如果参数实现了 Formattable，则调用其 formatTo 方法。否则，结果为调用参数的 toString() 方法得到的结果。如果给出 ‘#’ 标志，且参数不是 Formattable，则将抛出FormatFlagsConversionMismatchException。</td></tr><tr><td style="text-align:left">‘<code>S</code>‘</td><td style="text-align:left">‘<code>\u0053</code>‘ ‘<code>s</code>‘ 的大写形式。</td><td style="text-align:left">同上</td></tr></tbody></table><h3 id="用于常规转换的标志"><a href="#用于常规转换的标志" class="headerlink" title="用于常规转换的标志"></a>用于常规转换的标志</h3><p>以下 标志 应用于常规转换：</p><table><thead><tr><th style="text-align:left">标志</th><th style="text-align:left">对应Unicode值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">‘<code>-</code>‘</td><td style="text-align:left">‘\u002d’</td><td style="text-align:left"><code>将输出左对齐</code>。根据需要在转换值结尾处添加空格 (‘\u0020’)，以满足字段的最小宽度要求。如果没有提供宽度，则将抛出 MissingFormatWidthException。如果没有给出此标志，则输出将是右对齐的。</td></tr><tr><td style="text-align:left">‘<code>#</code>‘</td><td style="text-align:left">‘\u0023’</td><td style="text-align:left"><code>要求输出使用替换形式</code>。此形式的定义通过转换指定。</td></tr></tbody></table><h3 id="常规下的宽度"><a href="#常规下的宽度" class="headerlink" title="常规下的宽度"></a>常规下的宽度</h3><p><strong>常规下的宽度 是将向输出中写入的最少字符数</strong>。如果转换值的长度小于宽度，则用 ‘<code></code>‘ (\u0020’) 填充输出，直到字符总数等于宽度为止。默认情况下，是在左边进行填充。如果给出 ‘<code>-</code>‘ 标志，则在右边进行填充。如果没有指定宽度，则没有最小宽度。</p><h3 id="常规下的精度"><a href="#常规下的精度" class="headerlink" title="常规下的精度"></a>常规下的精度</h3><p><strong>常规下的精度 是将向输出中写入的最多字符数。</strong><code>精度的应用优先级要高于宽度</code>，因此，即使宽度大于精度，输出也将被截取为 <code>precision个字符</code>。如果没有指定精度，则对字符数没有明确限制。</p><h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><p>此转换可应用于 <code>char</code> 和 <code>Character</code>。它还可应用于类型 <code>byte</code>、<code>Byte</code>、<code>short</code> 和 <code>Short</code>、 <code>int</code> 和 <code>Integer</code>。<br>当 <code>Character.isValidCodePoint(int)</code> 返回 <code>true</code> 时，此转换也可应用于 <code>int</code> 和 <code>Integer</code>。如果返回 <code>false</code>，则将抛出 <code>IllegalFormatCodePointException</code>。</p><h3 id="字符转换符说明"><a href="#字符转换符说明" class="headerlink" title="字符转换符说明"></a>字符转换符说明</h3><table><thead><tr><th>格式符</th><th>对应Unicode值</th><th>描述</th></tr></thead><tbody><tr><td>‘<code>c</code>‘</td><td>‘`u0063`’</td><td>将参数格式化为 <code>Unicode Character Representation</code> 中描述的 <code>Unicode</code> 字符。在该参数表示增补字符的情况下，它可能是多个 16 位 <code>char</code>。如果给出 ‘#’ 标志，则将抛出 FormatFlagsConversionMismatchException。</td></tr><tr><td>‘<code>C</code>‘</td><td>‘<code>\u0043</code>‘</td><td>结果是使用’<code>c</code>‘的格式化结果的大写形式。</td></tr></tbody></table><h3 id="字符的标志"><a href="#字符的标志" class="headerlink" title="字符的标志"></a>字符的标志</h3><ul><li>‘<code>-</code>‘ 标志是为应用常规转换而定义的,不适用与字符转换。</li><li>如果给出 ‘<code>#</code>‘ 标志，则将抛出 <code>FormatFlagsConversionMismatchException</code>。</li></ul><h3 id="字符转换符下宽度不适用"><a href="#字符转换符下宽度不适用" class="headerlink" title="字符转换符下宽度不适用"></a>字符转换符下宽度不适用</h3><p>宽度是为了实现常规转换而定义的。</p><h3 id="字符转换符下精度不适用"><a href="#字符转换符下精度不适用" class="headerlink" title="字符转换符下精度不适用"></a>字符转换符下精度不适用</h3><p>精度不适用。如果指定精度，则将抛出 <code>IllegalFormatPrecisionException</code>。</p><h2 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h2><p>数值转换分为以下几类：</p><ul><li><code>Byte</code>、<code>Short</code>、<code>Integer</code> 和 <code>Long</code></li><li><code>BigInteger</code></li><li><code>Float</code> 和 <code>Double</code></li><li><code>BigDecimal</code><br>将根据以下算法对数值类型进行格式化：</li></ul><h3 id="数字本地化算法"><a href="#数字本地化算法" class="headerlink" title="数字本地化算法"></a>数字本地化算法</h3><p>在获得数字的整数部分、小数部分和指数（适用于数据类型）之后，将应用以下转换：</p><ul><li>将字符串中的每个数字字符 d 都替换为特定于语言环境的数字，该数字是相对于当前语言环境的零数字 z 来计算的；即 d ‘0’ + z。</li><li>如果存在小数点分隔符，则用特定于语言环境的小数点分隔符替换。</li><li>如果给出 ‘<code>,</code>‘ (‘\u002c’) flag 标志，则插入特定于语言环境的组分隔符，这是通过从最低位到最高位浏览字符串的整数部分并不时插入该语言环境组大小定义的分隔符来实现的。</li><li>如果给出 ‘<code>0</code>‘ 标志，则在符号字符（如果有的话）之后、第一个非零数字前插入特定于语言环境的零数字，直到字符串长度等于所要求的字段宽度。</li><li>如果该值为负，并且给出了 ‘<code>(</code>‘ 标志，那么预先考虑 ‘<code>(</code>‘ (‘\u0028’)，并追加一个 ‘)’ (‘\u0029’)。</li><li>如果该值为负（或者为浮点负零），并且没有给出 ‘<code>(</code>‘ 标志，那么预先考虑 ‘-‘ (‘\u002d’)。</li><li>如果给出 ‘<code>+</code>‘ 标志，并且该值为正或零（或者为浮点正零），那么将预先考虑 ‘+’ (‘\u002b’)。</li></ul><p>如果该值为 NaN 或正无穷大，则分别输出文本字符串 “NaN” 或 “Infinity”。如果该值为负无穷大，那么输出将是 “(Infinity)”；否则如果给出 ‘(‘ 标志，那么输出将是 “-Infinity”。这些值都没有被本地化。</p><p>太多了，限于篇幅，想了解详细的过程的话还是看API吧</p><h2 id="日期-时间"><a href="#日期-时间" class="headerlink" title="日期/时间"></a>日期/时间</h2><p>此转换可应用于 <code>long</code>、<code>Long</code>、<code>Calendar</code> 和 <code>Date</code>。</p><h3 id="前缀"><a href="#前缀" class="headerlink" title="前缀"></a>前缀</h3><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">Unicode值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">‘<code>t</code>‘</td><td style="text-align:left">‘<code>\u0074</code>‘</td><td style="text-align:left">日期和时间转换字符的前缀。</td></tr><tr><td style="text-align:left">‘<code>T</code>‘</td><td style="text-align:left">‘<code>\u0054</code>‘</td><td style="text-align:left">‘<code>t</code>‘ 的大写形式。</td></tr></tbody></table><h3 id="后缀"><a href="#后缀" class="headerlink" title="后缀"></a>后缀</h3><p>以下日期和时间转换字符后缀是为 ‘<code>t</code>‘ 和 ‘<code>T</code>‘ 转换定义的。这些类型类似于但不完全等同于 <code>GNU date</code> 和 <code>POSIX strftime(</code>3<code>c)</code> 定义的那些类型。提供其他转换类型是为了访问特定于 <code>Java</code> 的功能（例如，’<code>L</code>‘ 用于秒中的毫秒）。<br>以下转换字符用来格式化时间：</p><h4 id="格式化时间"><a href="#格式化时间" class="headerlink" title="格式化时间"></a>格式化时间</h4><table><thead><tr><th>后缀</th><th>Unicode值</th><th>描述</th></tr></thead><tbody><tr><td>‘<code>H</code>‘</td><td>‘\u0048’</td><td><code>24 小时制的小时</code>，被格式化为必要时带前导零的两位数，即 00 - 23。00 对应午夜。</td></tr><tr><td>‘<code>I</code>‘</td><td>‘\u0049’</td><td><code>12 小时制的小时</code>，被格式化为必要时带前导零的两位数，即 01 - 12。01 对应于 1 点钟（上午或下午）。</td></tr><tr><td>‘<code>k</code>‘</td><td>‘\u006b’</td><td><code>24 小时制的小时</code>，即 0 - 23。0 对应于午夜。</td></tr><tr><td>‘<code>l</code>‘</td><td>‘\u006c’</td><td><code>12 小时制的小时</code>，即 1 - 12。1 对应于上午或下午的一点钟。</td></tr><tr><td>‘<code>M</code>‘</td><td>‘\u004d’</td><td><code>小时中的分钟</code>，被格式化为必要时带前导零的两位数，即 00 - 59。</td></tr><tr><td>‘<code>S</code>‘</td><td>‘\u0053’</td><td><code>分钟中的秒</code>，被格式化为必要时带前导零的两位数，即 00 - 60（”60” 是支持闰秒所需的一个特殊值）。</td></tr><tr><td>‘<code>L</code>‘</td><td>‘\u004c’</td><td><code>秒中的毫秒</code>，被格式化为必要时带前导零的三位数，即 000 - 999。</td></tr><tr><td>‘<code>N</code>‘</td><td>‘\u004e’</td><td><code>秒中的毫微秒</code>，被格式化为必要时带前导零的九位数，即 000000000 - 999999999。此值的精度受底层操作系统或硬件解析的限制。</td></tr><tr><td>‘<code>p</code>‘</td><td>‘\u0070’</td><td>特定于语言环境的<code>上午或下午标记以小写形式表示</code>，例如 “am” 或 “pm”。使用转换前缀 ‘T’ 可以强行将此输出转换为大写形式。（注意，’p’ 产生的输出是小写的。而 GNU date 和 POSIX strftime(3c) 产生的输出是大写的。）</td></tr><tr><td>‘<code>z</code>‘</td><td>‘\u007a’</td><td>相对于 GMT 的 RFC 822 格式的<code>数字时区偏移量</code>，例如 -0800。</td></tr><tr><td>‘<code>Z</code>‘</td><td>‘\u005a’</td><td>表示时区的缩写形式的字符串。</td></tr><tr><td>‘<code>s</code>‘</td><td>‘\u0073’</td><td><code>自协调世界时 (UTC) 1970 年 1 月 1 日 00:00:00 至现在所经过的秒数</code>，也就是 Long.MIN_VALUE/1000 与 Long.MAX_VALUE/1000 之间的差值。</td></tr><tr><td>‘<code>Q</code>‘</td><td>‘\u004f’</td><td><code>自协调世界时 (UTC) 1970 年 1 月 1 日 00:00:00 至现在所经过的毫秒数</code>，即 Long.MIN_VALUE 与 Long.MAX_VALUE 之间的差值。此值的精度受底层操作系统或硬件解析的限制。</td></tr></tbody></table><h4 id="格式化日期"><a href="#格式化日期" class="headerlink" title="格式化日期"></a>格式化日期</h4><p>以下转换字符用来格式化日期：</p><table><thead><tr><th>后缀</th><th>Unicode值</th><th>描述</th></tr></thead><tbody><tr><td>‘<code>B</code>‘</td><td>‘\u0042’</td><td>特定于语言环境的<code>完整月份名称</code>，例如 “January” 和 “February”。</td></tr><tr><td>‘<code>b</code>‘</td><td>‘\u0062’</td><td>特定于语言环境的<code>月份简称</code>，例如 “Jan” 和 “Feb”。</td></tr><tr><td>‘<code>h</code>‘</td><td>‘\u0068’</td><td>与 ‘b’ 相同。</td></tr><tr><td>‘<code>A</code>‘</td><td>‘\u0041’</td><td>特定于语言环境的<code>星期几的全称</code>，例如 “Sunday” 和 “Monday”</td></tr><tr><td>‘<code>a</code>‘</td><td>‘\u0061’</td><td>特定于语言环境的<code>星期几的简称</code>，例如 “Sun” 和 “Mon”</td></tr><tr><td>‘<code>C</code>‘</td><td>‘\u0043’</td><td><code>除以 100 的四位数表示的年份</code>，被格式化为必要时带前导零的<code>两位数</code>，即 00 - 99</td></tr><tr><td>‘<code>Y</code>‘</td><td>‘\u0059’</td><td><code>年份</code>，被格式化为必要时带前导零的<code>四位数（至少）</code>，例如 0092 等于格里高利历的 92 CE。</td></tr><tr><td>‘<code>y</code>‘</td><td>‘\u0079’</td><td><code>年份的最后两位数</code>，被格式化为必要时带前导零的两位数，即 00 - 99。</td></tr><tr><td>‘<code>j</code>‘</td><td>‘\u006a’</td><td><code>一年中的天数</code>，被格式化为必要时带前导零的三位数，例如，对于格里高利历是 001 - 366。001 对应于一年中的第一天。</td></tr><tr><td>‘<code>m</code>‘</td><td>‘\u006d’</td><td><code>月份</code>，被格式化为必要时带前导零的两位数，即 01 - 13，其中 “01” 是一年的第一个月，(“13” 是支持阴历所需的一个特殊值）。</td></tr><tr><td>‘<code>d</code>‘</td><td>‘\u0064’</td><td><code>一个月中的天数</code>，被格式化为必要时带前导零的两位数，即 01 - 31，其中 “01” 是一个月的第一天。</td></tr><tr><td>‘<code>e</code>‘</td><td>‘\u0065’</td><td><code>一个月中的天数</code>，被格式化为两位数，即 1 - 31，其中 “1” 是一个月中的第一天。</td></tr></tbody></table><h4 id="日期-时间组合"><a href="#日期-时间组合" class="headerlink" title="日期/时间组合"></a>日期/时间组合</h4><p>以下转换字符用于格式化常见的日期/时间组合。</p><table><thead><tr><th>后缀</th><th>Unicode值</th><th>描述</th></tr></thead><tbody><tr><td>‘<code>R</code>‘</td><td>‘\u0052’</td><td><code>24 小时制的时间</code>，被格式化为 “<code>%tH:%tM</code>“</td></tr><tr><td>‘<code>T</code>‘</td><td>‘\u0054’</td><td><code>24 小时制的时间</code>，被格式化为 “<code>%tH:%tM:%tS</code>“。</td></tr><tr><td>‘<code>r</code>‘</td><td>‘\u0072’</td><td><code>12 小时制的时间</code>，被格式化为 “<code>%tI:%tM:%tS %Tp</code>“。上午或下午标记 (‘%Tp’) 的位置可能与地区有关。</td></tr><tr><td>‘<code>D</code>‘</td><td>‘\u0044’</td><td><code>日期</code>，被格式化为 “<code>%tm/%td/%ty</code>“。</td></tr><tr><td>‘<code>F</code>‘</td><td>‘\u0046’</td><td>ISO 8601 格式的完整日期，被格式化为 “<code>%tY-%tm-%td</code>“。</td></tr><tr><td>‘<code>c</code>‘</td><td>‘\u0063’</td><td><code>日期和时间</code>，被格式化为 “<code>%ta %tb %td %tT %tZ %tY</code>“，例如 “Sun Jul 20 16:17:00 EDT 1969”。</td></tr></tbody></table><h3 id="对应的标志"><a href="#对应的标志" class="headerlink" title="对应的标志"></a>对应的标志</h3><ul><li>应用为常规转换而定义的 ‘<code>-</code>‘ 标志。</li><li>如果给出 ‘#’ 标志，则将抛出 <code>FormatFlagsConversionMismatchException</code>。</li></ul><h3 id="宽度的要求"><a href="#宽度的要求" class="headerlink" title="宽度的要求"></a>宽度的要求</h3><p>宽度 是将向输出中写入的最少字符数。如果转换值的长度小于 width，则用空格(‘\u0020’) 来填充输出，直到总字符数等于宽度。默认情况下，在左边进行填充。如果给出 ‘-‘ 标志，则在右边进行填充。如果没有指定宽度，则没有最小宽度。</p><h3 id="精度不适用"><a href="#精度不适用" class="headerlink" title="精度不适用"></a>精度不适用</h3><p>精度不适用。如果指定了精度，则将抛出 IllegalFormatPrecisionException。</p><h2 id="百分比"><a href="#百分比" class="headerlink" title="百分比"></a>百分比</h2><p>该转换不对应于任何参数。 ‘<code>%</code>‘ 结果是一个字面值 ‘<code>%</code>‘ (‘\u0025’)</p><h3 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h3><p>应用为常规转换而定义的 ‘-‘ 标志。如果提供其他任何标志，则将抛出 FormatFlagsConversionMismatchException。</p><h3 id="宽度"><a href="#宽度" class="headerlink" title="宽度"></a>宽度</h3><p>宽度 是将向输出中写入的最少字符数，包括 ‘%’。如果转换值的长度小于 width，则用空格 (‘\u0020’) 来填充输出，直到总字符数等于宽度。在左边进行填充。如果没有指定宽度，则只输出 ‘%’。</p><h3 id="精度不适用-1"><a href="#精度不适用-1" class="headerlink" title="精度不适用"></a>精度不适用</h3><p>精度不适用。如果指定精度，则将抛出 IllegalFormatPrecisionException。</p><h2 id="行分隔符"><a href="#行分隔符" class="headerlink" title="行分隔符"></a>行分隔符</h2><p>该转换不对应于任何参数。 ‘<code>n</code>‘ 由 <code>System.getProperty(</code>“<code>line.separator</code>“) 返回的特定于平台的行分隔符。</p><h3 id="标志，宽度，精度都不可用"><a href="#标志，宽度，精度都不可用" class="headerlink" title="标志，宽度，精度都不可用"></a>标志，宽度，精度都不可用</h3><p>标志、宽度和精度都不可用。如果提供这三者，则会分别抛出 <code>IllegalFormatFlagsException</code>、<code>IllegalFormatWidthException</code> 和 <code>IllegalFormatPrecisionException</code>。</p><h2 id="参数索引"><a href="#参数索引" class="headerlink" title="参数索引"></a>参数索引</h2><p>格式说明符可以通过三种方式引用参数：</p><p>-<strong> 显式索引 </strong>是在格式说明符中包含参数索引时使用。参数索引是一个十进制整数，用于指示参数在参数列表中的位置。第一个参数由 “<code>1$</code>“ 引用，第二个参数由 “<code>2$</code>“ 引用，依此类推。可以多次引用任何一个参数。<br>例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">formatter.format(&quot;%4$s %3$s %2$s %1$s %4$s %3$s %2$s %1$s&quot;,</span><br><span class="line">                 &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)</span><br><span class="line">// -&gt; &quot;d c b a d c b a&quot;</span><br></pre></td></tr></table></figure><p></p><ul><li><p><strong>相对索引</strong> 是在格式说明符中包含 ‘<code>&lt;</code>‘ (‘\u003c’) 标志时使用，该标志将导致重用以前格式说明符的参数。如果不存在以前的参数，则抛出 MissingFormatArgumentException。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> formatter.format(&quot;%s %s %&lt;s %&lt;s&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)</span><br><span class="line">// -&gt; &quot;b a a b&quot;</span><br><span class="line"> // &quot;c&quot; and &quot;d&quot; are ignored because they are not referenced</span><br></pre></td></tr></table></figure></li><li><p>普通索引 在格式说明符中既不包含参数索引也不包含 ‘<code>&lt;</code>‘ 标志时使用。每个使用普通索引的格式说明符都分配了一个连续隐式索引，分配在独立于显式索引或相对索引使用的参数列表中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">formatter.format(&quot;%s %s %s %s&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)</span><br><span class="line">// -&gt; &quot;a b c d&quot;</span><br></pre></td></tr></table></figure></li></ul><p><strong>混合使用</strong><br>可能有一个使用所有索引形式的格式字符串，例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">formatter.format(&quot;%2$s %s %&lt;s %s&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)</span><br><span class="line">// -&gt; &quot;b a a b&quot;</span><br><span class="line">// &quot;c&quot; and &quot;d&quot; are ignored because they are not referenced</span><br></pre></td></tr></table></figure><p></p><p>参数的最大数量受到 <code>Java Machine Specification</code> 定义的 <code>Java</code> 数组 的最大维数的限制。如果参数索引与可用参数不对应，则抛出 <code>MissingFormatArgumentException</code>。</p><p>如果参数多于格式说明符，则忽略额外的参数。</p><p>除非另行指定，否则向此类中的任何方法或构造方法传递 <code>null</code> 参数都将抛出 <code>NullPointerException</code>。</p><h1 id="Formatter类方法"><a href="#Formatter类方法" class="headerlink" title="Formatter类方法"></a>Formatter类方法</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>Formatter()</code></td><td style="text-align:left">构造一个新 formatter。</td></tr><tr><td style="text-align:left"><code>Formatter(Appendable a)</code></td><td style="text-align:left">构造一个带指定目标文件的新 formatter。</td></tr><tr><td style="text-align:left"><code>Formatter(Appendable a, Locale l)</code></td><td style="text-align:left">构造一个带指定目标文件和语言环境的新 formatter。</td></tr><tr><td style="text-align:left"><code>Formatter(File file)</code></td><td style="text-align:left">构造一个带指定文件的新 formatter。</td></tr><tr><td style="text-align:left"><code>Formatter(File file, String csn)</code></td><td style="text-align:left">构造一个带指定文件和字符集的新 formatter。</td></tr><tr><td style="text-align:left"><code>Formatter(File file, String csn, Locale l)</code></td><td style="text-align:left">构造一个带指定文件、字符集和语言环境的新 formatter。</td></tr><tr><td style="text-align:left"><code>Formatter(Locale l)</code></td><td style="text-align:left">构造一个带指定语言环境的新 formatter。</td></tr><tr><td style="text-align:left"><code>Formatter(OutputStream os)</code></td><td style="text-align:left">构造一个带指定输出流的新 formatter。</td></tr><tr><td style="text-align:left"><code>Formatter(OutputStream os, String csn)</code></td><td style="text-align:left">构造一个带指定输出流和字符集的新 formatter。</td></tr><tr><td style="text-align:left"><code>Formatter(OutputStream os, String csn, Locale l)</code></td><td style="text-align:left">构造一个带指定输出流、字符集和语言环境的新 formatter。</td></tr><tr><td style="text-align:left"><code>Formatter(PrintStream ps)</code></td><td style="text-align:left">构造一个带指定输出流的新 formatter。</td></tr><tr><td style="text-align:left"><code>Formatter(String fileName)</code></td><td style="text-align:left">构造一个带指定文件名的新 formatter。</td></tr><tr><td style="text-align:left"><code>Formatter(String fileName, String csn)</code></td><td style="text-align:left">构造一个带指定文件名和字符集的新 formatter。</td></tr><tr><td style="text-align:left"><code>Formatter(String fileName, String csn, Locale l)</code></td><td style="text-align:left">构造一个带指定文件名、字符集和语言环境的新 formatter。</td></tr></tbody></table><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>void close()</code></td><td style="text-align:left">关闭此 formatter。</td></tr><tr><td style="text-align:left"><code>void flush()</code></td><td style="text-align:left">刷新此 formatter。</td></tr><tr><td style="text-align:left"><code>Formatter format(Locale l, String format, Object... args)</code></td><td style="text-align:left">使用指定的语言环境、格式字符串和参数，将一个格式化字符串写入此对象的目标文件中。</td></tr><tr><td style="text-align:left"><code>Formatter format(String format, Object... args)</code></td><td style="text-align:left">使用指定格式字符串和参数将一个格式化字符串写入此对象的目标文件中。</td></tr><tr><td style="text-align:left"><code>IOException ioException()</code></td><td style="text-align:left">返回由此 formatter 的 Appendable 方法上次抛出的 IOException 异常。</td></tr><tr><td style="text-align:left"><code>Locale locale()</code></td><td style="text-align:left">返回构造此 formatter 时设置的语言环境。</td></tr><tr><td style="text-align:left"><code>Appendable out()</code></td><td style="text-align:left">返回输出的目标文件。</td></tr><tr><td style="text-align:left"><code>String toString()</code></td><td style="text-align:left">返回对输出的目标文件调用 toString() 的结果。</td></tr></tbody></table><p>本文链接: <a href="https://www.lansheng.net.cn/blog/bac4a0b7/">FormatterAPI介绍</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> java_util </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>正则应用 复制表格按行分隔的</title>
      <link href="/blog/2467f613/"/>
      <url>/blog/2467f613/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>把上面的文字转成markdown表格<br><img src="https://i.imgur.com/685NBV5.png" alt=""></p><h2 id="处理的文本："><a href="#处理的文本：" class="headerlink" title="处理的文本："></a>处理的文本：</h2><p>复制上面的表格中的文字,然后粘贴，看看复制到的文本有什么规律：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">B b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果参数arg 为 null，则结果为 &quot;false&quot;。如果arg 是一个 boolean 值或Boolean，则结果为String.valueOf() 返回的字符串。否则结果为 &quot;true&quot;。</span><br><span class="line"></span><br><span class="line">H h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果参数arg 为 null，则结果为 &quot;null&quot;。否则，结果为调用Integer.toHexString(arg.hashCode()) 得到的结果。</span><br><span class="line"></span><br><span class="line">S s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果参数arg 为 null，则结果为 &quot;null&quot;。如果arg 实现 Formattable，则调用arg.formatTo。否则，结果为调用 arg.toString() 得到的结果。</span><br></pre></td></tr></table></figure><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h3 id="使用正则表达式删除空白行"><a href="#使用正则表达式删除空白行" class="headerlink" title="使用正则表达式删除空白行"></a>使用正则表达式删除空白行</h3><p>可以看到复制到的表格是一行一行的，而且还有多个空白行分隔开了，先来去除掉这些空白行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//删除空白行</span><br><span class="line">body=body.replaceAll(&quot;(?m)^\\s*$(\\n|\\r\\n)&quot;, &quot;&quot;);</span><br></pre></td></tr></table></figure><p>处理后的结果如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">B b</span><br><span class="line">如果参数arg 为 null，则结果为 &quot;false&quot;。如果arg 是一个 boolean 值或Boolean，则结果为String.valueOf() 返回的字符串。否则结果为 &quot;true&quot;。</span><br><span class="line">H h</span><br><span class="line">如果参数arg 为 null，则结果为 &quot;null&quot;。否则，结果为调用Integer.toHexString(arg.hashCode()) 得到的结果。</span><br><span class="line">S s</span><br><span class="line">如果参数arg 为 null，则结果为 &quot;null&quot;。如果arg 实现 Formattable，则调用arg.formatTo。否则，结果为调用 arg.toString() 得到的结果。</span><br></pre></td></tr></table></figure><p></p><h3 id="使用正则表达式把两行合并为一行"><a href="#使用正则表达式把两行合并为一行" class="headerlink" title="使用正则表达式把两行合并为一行"></a>使用正则表达式把两行合并为一行</h3><p>空白行去掉了，来把两行合并为一行：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//两行合并为一行，中间用表格分隔符分隔开</span><br><span class="line">body=body.replaceAll(&quot;(.+)\\n(.+)(\\n)?&quot;, &quot;$1|$2\n&quot;);</span><br></pre></td></tr></table></figure><p></p><p>运行结果为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B b|如果参数arg 为 null，则结果为 &quot;false&quot;。如果arg 是一个 boolean 值或Boolean，则结果为String.valueOf() 返回的字符串。否则结果为 &quot;true&quot;。</span><br><span class="line">H h|如果参数arg 为 null，则结果为 &quot;null&quot;。否则，结果为调用Integer.toHexString(arg.hashCode()) 得到的结果。</span><br><span class="line">S s|如果参数arg 为 null，则结果为 &quot;null&quot;。如果arg 实现 Formattable，则调用arg.formatTo。否则，结果为调用 arg.toString() 得到的结果。</span><br></pre></td></tr></table></figure><p></p><h3 id="使用正则表达式分别在行首和行尾加上分割符"><a href="#使用正则表达式分别在行首和行尾加上分割符" class="headerlink" title="使用正则表达式分别在行首和行尾加上分割符"></a>使用正则表达式分别在行首和行尾加上分割符</h3><p>然后在每行头尾加上表格分隔符：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//行首和行尾加入结束符</span><br><span class="line">body=body.replaceAll(&quot;(?m)(?:^|$)&quot;, &quot;|&quot;);</span><br></pre></td></tr></table></figure><p></p><p>运行结果为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|B b|如果参数arg 为 null，则结果为 &quot;false&quot;。如果arg 是一个 boolean 值或Boolean，则结果为String.valueOf() 返回的字符串。否则结果为 &quot;true&quot;。|</span><br><span class="line">|H h|如果参数arg 为 null，则结果为 &quot;null&quot;。否则，结果为调用Integer.toHexString(arg.hashCode()) 得到的结果。|</span><br><span class="line">|S s|如果参数arg 为 null，则结果为 &quot;null&quot;。如果arg 实现 Formattable，则调用arg.formatTo。否则，结果为调用 arg.toString() 得到的结果。|</span><br><span class="line">|</span><br></pre></td></tr></table></figure><p></p><h3 id="删除多加入的分割符"><a href="#删除多加入的分割符" class="headerlink" title="删除多加入的分割符"></a>删除多加入的分割符</h3><p>这里多加上了一个分隔符，删掉这个分隔符：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 去掉多加入无用的分界符</span><br><span class="line">body = body.replaceAll(&quot;(?m)^\\|$&quot;, &quot;&quot;);</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|B b|如果参数arg 为 null，则结果为 &quot;false&quot;。如果arg 是一个 boolean 值或Boolean，则结果为String.valueOf() 返回的字符串。否则结果为 &quot;true&quot;。|</span><br><span class="line">|H h|如果参数arg 为 null，则结果为 &quot;null&quot;。否则，结果为调用Integer.toHexString(arg.hashCode()) 得到的结果。|</span><br><span class="line">|S s|如果参数arg 为 null，则结果为 &quot;null&quot;。如果arg 实现 Formattable，则调用arg.formatTo。否则，结果为调用 arg.toString() 得到的结果。|</span><br></pre></td></tr></table></figure><p></p><h3 id="加上表格头部"><a href="#加上表格头部" class="headerlink" title="加上表格头部"></a>加上表格头部</h3><p>可以看到，到这里表体已经生成完毕，加上表格头就行了。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 定义表格头部和对齐方式</span><br><span class="line">String head = &quot;|方法|描述|\n|:-|:-|\n&quot;;</span><br><span class="line">// 拼接成完整的markdown表格代码</span><br><span class="line">body = head + body;</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|方法|描述|</span><br><span class="line">|:-|:-|</span><br><span class="line">|B b|如果参数arg 为 null，则结果为 &quot;false&quot;。如果arg 是一个 boolean 值或Boolean，则结果为String.valueOf() 返回的字符串。否则结果为 &quot;true&quot;。|</span><br><span class="line">|H h|如果参数arg 为 null，则结果为 &quot;null&quot;。否则，结果为调用Integer.toHexString(arg.hashCode()) 得到的结果。|</span><br><span class="line">|S s|如果参数arg 为 null，则结果为 &quot;null&quot;。如果arg 实现 Formattable，则调用arg.formatTo。否则，结果为调用 arg.toString() 得到的结果。|</span><br></pre></td></tr></table></figure><p></p><p>可以看到到这里就处理完毕了，把生成的markdown表格粘贴到markdown文档中，就可以显示，显示效果如下:</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">B b</td><td style="text-align:left">如果参数arg 为 null，则结果为 “false”。如果arg 是一个 boolean 值或Boolean，则结果为String.valueOf() 返回的字符串。否则结果为 “true”。</td></tr><tr><td style="text-align:left">H h</td><td style="text-align:left">如果参数arg 为 null，则结果为 “null”。否则，结果为调用Integer.toHexString(arg.hashCode()) 得到的结果。</td></tr><tr><td style="text-align:left">S s</td><td style="text-align:left">如果参数arg 为 null，则结果为 “null”。如果arg 实现 Formattable，则调用arg.formatTo。否则，结果为调用 arg.toString() 得到的结果。</td></tr></tbody></table><h2 id="表格的每一行的第一个单元格都设置为代码块"><a href="#表格的每一行的第一个单元格都设置为代码块" class="headerlink" title="表格的每一行的第一个单元格都设置为代码块"></a>表格的每一行的第一个单元格都设置为代码块</h2><p>在表格头定义语句之前加上：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//注意了使用正则表达式匹配|一定要转义啊!,错误的时候对元字符转义一下!</span><br><span class="line">body=body.replaceAll(&quot;(?m)^\\|(.+)\\|(.+)\\|$&quot;, &quot;|`$1`|$2|&quot;);</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|方法|描述|</span><br><span class="line">|:-|:-|</span><br><span class="line">|`B b`|如果参数arg 为 null，则结果为 &quot;false&quot;。如果arg 是一个 boolean 值或Boolean，则结果为String.valueOf() 返回的字符串。否则结果为 &quot;true&quot;。|</span><br><span class="line">|`H h`|如果参数arg 为 null，则结果为 &quot;null&quot;。否则，结果为调用Integer.toHexString(arg.hashCode()) 得到的结果。|</span><br><span class="line">|`S s`|如果参数arg 为 null，则结果为 &quot;null&quot;。如果arg 实现 Formattable，则调用arg.formatTo。否则，结果为调用 arg.toString() 得到的结果。|</span><br></pre></td></tr></table></figure><p></p><p>显示效果：</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>B b</code></td><td style="text-align:left">如果参数arg 为 null，则结果为 “false”。如果arg 是一个 boolean 值或Boolean，则结果为String.valueOf() 返回的字符串。否则结果为 “true”。</td></tr><tr><td style="text-align:left"><code>H h</code></td><td style="text-align:left">如果参数arg 为 null，则结果为 “null”。否则，结果为调用Integer.toHexString(arg.hashCode()) 得到的结果。</td></tr><tr><td style="text-align:left"><code>S s</code></td><td style="text-align:left">如果参数arg 为 null，则结果为 “null”。如果arg 实现 Formattable，则调用arg.formatTo。否则，结果为调用 arg.toString() 得到的结果。</td></tr></tbody></table><h2 id="完整的代码"><a href="#完整的代码" class="headerlink" title="完整的代码"></a>完整的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> markdowntools.table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="keyword">import</span> clipboard.util.SysClipboardUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MDTableCopyByLine</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">String body=SysClipboardUtil.getSysClipboardText();</span><br><span class="line"><span class="comment">//删除空白行</span></span><br><span class="line">body=body.replaceAll(<span class="string">"(?m)^\\s*$(\\n|\\r\\n)"</span>, <span class="string">""</span>);</span><br><span class="line"><span class="comment">//两行合并为一行，中间用表格分隔符分隔开</span></span><br><span class="line">body=body.replaceAll(<span class="string">"(.+)\\n(.+)(\\n)?"</span>, <span class="string">"$1|$2\n"</span>);</span><br><span class="line"><span class="comment">//行首和行尾加入结束符</span></span><br><span class="line">body=body.replaceAll(<span class="string">"(?m)(?:^|$)"</span>, <span class="string">"|"</span>);</span><br><span class="line"><span class="comment">// 去掉多加入无用的分界符</span></span><br><span class="line">body = body.replaceAll(<span class="string">"(?m)^\\|$"</span>, <span class="string">""</span>);</span><br><span class="line"><span class="comment">//注意了使用正则表达式匹配|一定要转义啊!,错误的时候对元字符转义一下!</span></span><br><span class="line">body=body.replaceAll(<span class="string">"(?m)^\\|(.+)\\|(.+)\\|$"</span>, <span class="string">"|`$1`|$2|"</span>);</span><br><span class="line"><span class="comment">// 定义表格头部和对齐方式</span></span><br><span class="line">String head = <span class="string">"|方法|描述|\n|:-|:-|\n"</span>;</span><br><span class="line"><span class="comment">// 拼接成完整的markdown表格代码</span></span><br><span class="line">body = head + body;</span><br><span class="line"><span class="comment">// 处理好的文本写入剪贴板中</span></span><br><span class="line"> SysClipboardUtil.setSysClipboardText(body);</span><br><span class="line">System.out.println(body);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依赖：<a href="https://blog.csdn.net/qq_21808961/article/details/80671259" target="_blank" rel="noopener">clipboard.util.SysClipboardUtil</a></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/2467f613/">正则应用 复制表格按行分隔的</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 正则表达式 </category>
          
          <category> 实例 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java IO流 Console类</title>
      <link href="/blog/eaae884d/"/>
      <url>/blog/eaae884d/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>Console类</p><h1 id="Java中Console类的用法"><a href="#Java中Console类的用法" class="headerlink" title="Java中Console类的用法"></a>Java中Console类的用法</h1><p>参考1:<a href="https://blog.csdn.net/ChengXuYuanXingCheng/article/details/71430068、" target="_blank" rel="noopener">https://blog.csdn.net/ChengXuYuanXingCheng/article/details/71430068、</a><br>参考2：<a href="https://www.jb51.net/article/118527.htm" target="_blank" rel="noopener">https://www.jb51.net/article/118527.htm</a></p><p><code>java</code>的<code>Console</code>类的使用方法及实例</p><p><code>JDK</code> 6中提供了<code>java.io.Console</code>类专用来访问基于字符的控制台设备。如果你的<code>Java</code>程序要与<code>Windows</code>下的<code>cmd</code>或者<code>Linux</code>下的<code>Terminal</code>交互，就可以用这个<code>Java Console</code>类代劳。由于<code>Scanner</code>类输入是可见的，故<code>Scanner</code>类不适用于从控制台读取密码。从<code>Java se 6</code>开始加入了<code>Console</code>类来解决此问题。</p><p>要注意的是，<strong>以<code>javaw</code>所执行的应用程序，没有主控台（<code>Console</code>），也就取不到<code>Console</code>对象（例如在<code>Eclipse</code>中）。</strong></p><h2 id="读控制台方法"><a href="#读控制台方法" class="headerlink" title="读控制台方法"></a>读控制台方法</h2><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>String readLine()</code></td><td style="text-align:left">从控制台读取单行文本。</td></tr><tr><td style="text-align:left"><code>String readLine(String fmt, Object... args)</code></td><td style="text-align:left">提供一个格式化提示，然后从控制台读取单行文本。</td></tr><tr><td style="text-align:left"><code>char[] readPassword()</code></td><td style="text-align:left">从控制台读取密码，禁用回显。</td></tr><tr><td style="text-align:left"><code>char[] readPassword(String fmt, Object... args)</code></td><td style="text-align:left">提供一个格式化提示，然后从控制台读取密码，禁用回显。</td></tr></tbody></table><p><code>Console</code>类也提供有<code>reader()</code>与<code>writer()</code>方法，可以传回 <code>Reader</code>、 <code>Writer</code> 对象，以便进行其它的<code>IO</code>处理，例如结合<code>Scanner</code>一同使用：</p><p><code>Scanner scanner = new Scanner(System.console().reader());</code></p><h3 id="实例：读密码不回显"><a href="#实例：读密码不回显" class="headerlink" title="实例：读密码不回显"></a>实例：读密码不回显</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package study.news;</span><br><span class="line"></span><br><span class="line">import java.io.Console;</span><br><span class="line">public class TestConsole</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">Console console = System.console();</span><br><span class="line">//读入用户名</span><br><span class="line">String username = console.readLine(&quot;User name:&quot;);</span><br><span class="line">//读入密码</span><br><span class="line">char[] passwd = console.readPassword(&quot;Password:&quot;);</span><br><span class="line">console.printf(&quot;user:&quot; + username + &quot;\n&quot;);</span><br><span class="line">console.printf(String.valueOf(passwd));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>因为<code>Java.io.Console</code> 只能用在标准输入、输出流未被重定向的原始控制台中使用，在 <code>Eclipse</code> 或者其他 <code>IDE</code> 的控制台是用不了的。</strong><br>所以我们到cmd控制台中来编译运行这个实例：<br>编译:<code>javac -d . TestConsole.java</code><br>运行:<code>study.news.TestConsole</code><br>输入密码：<code>123456</code>，可以看到密码<code>123456</code>没有显示在控制台上。<br><img src="https://i.imgur.com/w4pe1YY.png" alt=""></p><p>运行结果：</p><p><img src="https://i.imgur.com/PH5Eyc1.png" alt=""></p><p>readLine()和readPassword()方法，还可以像c语言中的printf,使用变参和格式符那样打印输出信息。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Console console = System.console();</span><br><span class="line">String username = console.readLine(&quot;%s&quot;, &quot;你是谁:&quot;);</span><br><span class="line">char[] password = console.readPassword(&quot;%s!请输入口令:&quot;, username);</span><br><span class="line">System.out.println(&quot;username:&quot;+username);</span><br><span class="line">System.out.println(&quot;password:&quot;+new String(password));</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">你是谁:xiaoming</span><br><span class="line">xiaoming!请输入口令:</span><br><span class="line">username:xiaoming</span><br><span class="line">password:qunide</span><br></pre></td></tr></table></figure><p></p><h2 id="获取控制台的输入输出流"><a href="#获取控制台的输入输出流" class="headerlink" title="获取控制台的输入输出流"></a>获取控制台的输入输出流</h2><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>Reader reader()</code></td><td style="text-align:left">获取与此控制台关联的唯一 Reader 对象。</td></tr><tr><td style="text-align:left"><code>PrintWriter writer()</code></td><td style="text-align:left">获取与此控制台关联的唯一 PrintWriter 对象。</td></tr><tr><td style="text-align:left"><code>void flush()</code></td><td style="text-align:left">刷新控制台，并强制立即写入所有缓冲的输出。</td></tr></tbody></table><h3 id="获取来自控制台的输入流"><a href="#获取来自控制台的输入流" class="headerlink" title="获取来自控制台的输入流"></a>获取来自控制台的输入流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testConsoleReader</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Console console = System.console();</span><br><span class="line"><span class="keyword">if</span> (console != <span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">System.out.print(<span class="string">"输入以#结束"</span>);</span><br><span class="line">Pattern endRegex = Pattern.compile(<span class="string">"([^#]*)#"</span>);</span><br><span class="line">Matcher isEnd;</span><br><span class="line"><span class="comment">// 获取控制台的字符输入流,这样可以读取到我们在控制台上打的字</span></span><br><span class="line">Scanner scan = <span class="keyword">new</span> Scanner(console.reader());</span><br><span class="line">String str;</span><br><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">while</span> (scan.hasNext())</span><br><span class="line">&#123;</span><br><span class="line">str = scan.next();</span><br><span class="line">isEnd = endRegex.matcher(str);</span><br><span class="line"><span class="comment">// matches()会匹配整个字符串匹配后匹配的下表</span></span><br><span class="line"><span class="keyword">if</span> (isEnd.matches())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 使用group()进行捕获的前提一定要是在匹配的情况下</span></span><br><span class="line"><span class="comment">// 可以在matches(),find(),lonkingAt()返回true的时候调用</span></span><br><span class="line">builder.append(isEnd.group(<span class="number">1</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">builder.append(str);</span><br><span class="line"><span class="comment">// System.out.println(str);</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"接收到控制台输入："</span>);</span><br><span class="line">System.out.println(builder.toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://i.imgur.com/F8tFJ50.png" alt=""><br>使用这种方式，可以一次读入多行字符。不过这样其实和new Scanner(System.in)没啥区别了。<br>也可以使用<code>BufferedReader</code>类包装<code>console.reader()</code><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testConsoleReader2</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Console console = System.console();</span><br><span class="line"><span class="keyword">if</span> (console != <span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">System.out.print(<span class="string">"输入以#结束"</span>);</span><br><span class="line">Pattern endRegex = Pattern.compile(<span class="string">"([^#]*)#"</span>);</span><br><span class="line">Matcher isEnd;</span><br><span class="line"><span class="comment">// 获取控制台的字符输入流,这样可以读取到我们在控制台上打的字</span></span><br><span class="line"><span class="comment">//Scanner scan = new Scanner(console.reader());</span></span><br><span class="line"></span><br><span class="line">BufferedReader reader=<span class="keyword">new</span> BufferedReader(console.reader());</span><br><span class="line">String line;</span><br><span class="line"><span class="comment">//设置默认大小为100,面输入字符过多使得StringBuilder频繁扩容,每次扩容的长度是当前长度(length*2+2)</span></span><br><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">while</span> ((line=reader.readLine())!=<span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">isEnd = endRegex.matcher(line);</span><br><span class="line"><span class="comment">// matches()会匹配整个字符串匹配后匹配的下表</span></span><br><span class="line"><span class="keyword">if</span> (isEnd.matches())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 使用group()进行捕获的前提一定要是在匹配的情况下</span></span><br><span class="line"><span class="comment">// 可以在matches(),find(),lonkingAt()返回true的时候调用</span></span><br><span class="line">builder.append(isEnd.group(<span class="number">1</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">builder.append(line);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"接收到控制台输入："</span>);</span><br><span class="line">System.out.println(builder.toString());</span><br><span class="line">reader.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="获取对控制台的输出流"><a href="#获取对控制台的输出流" class="headerlink" title="获取对控制台的输出流"></a>获取对控制台的输出流</h3><p>console.writer()可以获取对控制台的输出流(PrintWriter)<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testConsoleWriter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Console console = <span class="keyword">null</span>;</span><br><span class="line">PrintWriter out = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">console = System.console();</span><br><span class="line"><span class="keyword">if</span> (console != <span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 获取控制台的PrintWriter实例，也就是对控制台的输出</span></span><br><span class="line">out = console.writer();</span><br><span class="line">out.println(<span class="string">"这句话将输出到控制台中"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">&#123;</span><br><span class="line">ex.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br><img src="https://i.imgur.com/NnYKwnM.png" alt=""></p><h3 id="使用Console类自己的控制台输入和输出方法"><a href="#使用Console类自己的控制台输入和输出方法" class="headerlink" title="使用Console类自己的控制台输入和输出方法"></a>使用Console类自己的控制台输入和输出方法</h3><p>上面的控制台输出，我们借助于System.out.prinln()方法实现的。既然讲Console类，那就使用Console类自己的方式来进行输入和输出。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testReaderWriter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Console console =<span class="keyword">null</span>;</span><br><span class="line">console=System.console();</span><br><span class="line"><span class="keyword">if</span>(console!=<span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">PrintWriter consoleOut=console.writer();</span><br><span class="line">BufferedReader consoleIn=<span class="keyword">new</span> BufferedReader(console.reader());</span><br><span class="line">String line=<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>((line=consoleIn.readLine())!=<span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(line.equals(<span class="string">"exit"</span>))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">consoleOut.println(<span class="string">"你输入了："</span>+line);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="控制台格式化输出方法"><a href="#控制台格式化输出方法" class="headerlink" title="控制台格式化输出方法"></a>控制台格式化输出方法</h2><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>Console format(String fmt, Object... args)</code></td><td style="text-align:left">使用指定格式字符串和参数将格式化字符串写入此控制台的输出流中。</td></tr><tr><td style="text-align:left"><code>Console printf(String format, Object... args)</code></td><td style="text-align:left">使用指定格式字符串和参数将格式化字符串写入此控制台输出流的便捷方法。</td></tr></tbody></table><p>printf()源码：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Console <span class="title">printf</span><span class="params">(String format, Object ... args)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> format(format, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>可以看到<code>printf()</code>方法还是原封不动的调用<code>format</code>方法来实现<br><code>format</code>源码：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Formatter formatter;</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="keyword">public</span> Console <span class="title">format</span><span class="params">(String fmt, Object ...args)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    formatter.format(fmt, args).flush();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>可以看到这里的<code>format</code>方法是使用<code>Formatter</code>类的<code>formatter</code>方法来实现的。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/eaae884d/">Java IO流 Console类</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java IO流 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java IO流 File类</title>
      <link href="/blog/833486b4/"/>
      <url>/blog/833486b4/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>Java IO流 File类</p><h1 id="File类简介"><a href="#File类简介" class="headerlink" title="File类简介"></a>File类简介</h1><p><code>File</code>是<code>java.io</code>包下面的一个类，代表与平台无关的文件或者目录。<code>Java</code>中，无论文件还是目录，都可以看作<code>File</code>类的一个对象。<code>File</code>类能对文件或目录新建，删除，获取属性等操作，但是不能直接操作文件内容（文件内容需要用数据流访问）。也就是<code>File</code>类只用于表示文件(目录)的信息(名称、大小等),不能用于文件内容的访问。</p><p><code>JVM</code>默认会将<code>workspace</code>作为相对路径，即<code>user.dir</code>系统变量所指路径, 即如果这样初始化<code>file</code>对象，<code>File file = new File(&quot;.&quot;);</code> 就是获取了<code>user.dir</code>路径。</p><h1 id="File类方法"><a href="#File类方法" class="headerlink" title="File类方法"></a>File类方法</h1><h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object</span><br><span class="line">  |----&gt; java.io.File</span><br></pre></td></tr></table></figure><h2 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h2><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>static String pathSeparator</code></td><td style="text-align:left">与系统有关的路径分隔符，为了方便，它被表示为一个字符串。</td></tr><tr><td style="text-align:left"><code>static char pathSeparatorChar</code></td><td style="text-align:left">与系统有关的路径分隔符。</td></tr><tr><td style="text-align:left"><code>static String separator</code></td><td style="text-align:left">与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串。</td></tr><tr><td style="text-align:left"><code>static char separatorChar</code></td><td style="text-align:left">与系统有关的默认名称分隔符。</td></tr></tbody></table><p>其中常用的是第三个<code>File.separator</code>,这个表示与系统相关的路径分隔符，因为在Windows下的路径分隔符为:<code>\</code>而在Linux下的路径分隔符为:<code>/</code>，所以当直接使用”<code>\</code>“或者”<code>/</code>“时作为路径分隔符时，在跨平台使用时会报<code>No Such file or diretory</code>异常。<br>所以需要跨平台使用时，应该使用<code>File.separator</code>作为路径分隔符。</p><p>例如window下平常使用路径为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File file=new File(&quot;.\\test\\demo.txt&quot;);</span><br></pre></td></tr></table></figure><p></p><p>应该改为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File file = new File(&quot;.&quot;+ File.separator +&quot;demo.txt&quot;);</span><br></pre></td></tr></table></figure><p></p><p>这样编译好的代码可以在linux中正常运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test.before;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFile</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                File file=<span class="keyword">new</span> File(<span class="string">"."</span>+File.separator+<span class="string">"gbk.txt"</span>);</span><br><span class="line"><span class="comment">//              File file=new File(".\\gbk.txt");</span></span><br><span class="line">                System.out.println(file.getAbsolutePath());</span><br><span class="line">                System.out.println(file.isFile());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先在工程目录下创建以名为<code>gbk.txt</code>的文件<br>Window中的输出结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\dev\workspace\IO\.\gbk.txt</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p></p><p>Linux中的输出结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/home/lan/桌面/java/test/./gbk.txt</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p></p><p>可以看到虽然文件分隔符都不一样的使用了<code>File.separator</code>可以跨平台。如果改成<code>File file=new File(&quot;.\\gbk.txt&quot;);</code>将在Linux中运行出错。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/home/lan/桌面/java/test/.\gbk.txt</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p></p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>File(String pathname);</code></td><td style="text-align:left">根据字符串路径来创建File对象</td></tr><tr><td style="text-align:left"><code>File(String parent, String child) ;</code></td><td style="text-align:left">根据父路径字符串，和文件或者目录名来创建File对象</td></tr><tr><td style="text-align:left"><code>File(File parent, String child);</code></td><td style="text-align:left">根据父路径的File对象，和子文件(子目录)的名称来创建File对象</td></tr></tbody></table><h2 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h2><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>public boolean exists()</code></td><td style="text-align:left">判断文件或目录是否存在</td></tr><tr><td style="text-align:left"><code>public boolean isFile()</code></td><td style="text-align:left">判断该File对象是不是一个文件</td></tr><tr><td style="text-align:left"><code>public boolean isDirectory()</code></td><td style="text-align:left">判断该File对象是不是目录</td></tr><tr><td style="text-align:left"><code>public boolean isAbsolute()</code></td><td style="text-align:left">判断该File对象是不是绝对路径</td></tr><tr><td style="text-align:left"><code>public boolean canRead()</code></td><td style="text-align:left">判断程序是否可读该文件</td></tr><tr><td style="text-align:left"><code>public boolean canWrite()</code></td><td style="text-align:left">判断程序是否可写该文件</td></tr><tr><td style="text-align:left"><code>public boolean isHidden()</code></td><td style="text-align:left">判断该文件是不是隐藏文件</td></tr></tbody></table><h3 id="详细说明："><a href="#详细说明：" class="headerlink" title="详细说明："></a>详细说明：</h3><blockquote><ul><li><code>public boolean exists()</code>测试此抽象路径名表示的文件或目录是否存在。<br>返回：<br>&emsp;&emsp;&emsp;&emsp;当且仅当此抽象路径名表示的<code>文件或目录存在时，返回 true</code>；否则返回 false</li><li><code>public boolean isFile()</code> 测试此抽象路径名表示的文件<code>是否是一个标准文件</code>。如果该文件不是一个目录，并且满足其他与系统有关的标准，那么该文件是标准 文件。由 Java 应用程序创建的所有非目录文件一定是标准文件。<br>返回：<br>&emsp;&emsp;&emsp;&emsp;当且仅当此抽象路径名表示的<code>文件存在且 是一个标准文件时，返回 true</code>；否则返回 false 。</li><li><code>public boolean isDirectory()</code> 测试此抽象路径名表示的文件<code>是否是一个目录</code>。<br>返回：<br>&emsp;&emsp;&emsp;&emsp;当且仅当此抽象路径名表示的文件<code>存在且 是一个目录时，返回 true</code>；否则返回 false</li></ul></blockquote><p>所以,这三个方法都会去判断文件是否存在，isFile()和isDirectory()会在文件存在的基础之上判断该文件是标准文件还是目录</p><blockquote><ul><li><code>public boolean isAbsolute()</code> 测试此抽象路径名是否为绝对路径名。绝对路径名的定义与系统有关。<ul><li>在 UNIX 系统上，如果路径名的前缀是 “/“，那么该路径名是绝对路径名。</li><li>在 Microsoft Windows 系统上，如果路径名的前缀是后跟 “\\” 的盘符，或者是 “\\\\”，那么该路径名是绝对路径名。</li></ul></li></ul><p>返回：<br>&emsp;&emsp;&emsp;&emsp;如果此抽象路径名是绝对路径名，则返回 true；否则返回 false</p></blockquote><blockquote><ul><li><code>public boolean canRead()</code> 测试应用程序是否可以读取此抽象路径名表示的文件。<br>返回：<br>&emsp;&emsp;&emsp;&emsp;当且仅当此抽象路径名指定的文件存在且 可被应用程序读取时，返回 true；否则返回 false</li></ul></blockquote><blockquote><ul><li><p><code>public boolean isHidden()</code>测试此抽象路径名指定的文件是否是一个隐藏文件。隐藏 的具体定义与系统有关</p><ul><li>在 UNIX 系统上，如果文件名以句点字符 (‘.’) 开头，则认为该文件被隐藏。</li><li>在 Microsoft Windows 系统上，如果在文件系统中文件被标记为隐藏，则认为该文件被隐藏。</li></ul><p>返回：<br>&emsp;&emsp;&emsp;&emsp;当且仅当此抽象路径名表示的文件根据底层平台约定是隐藏文件时，返回 true</p></li></ul></blockquote><p><strong>总结：我还是应该多看看API</strong></p><h2 id="创建文件或目录方法"><a href="#创建文件或目录方法" class="headerlink" title="创建文件或目录方法"></a>创建文件或目录方法</h2><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>boolean createNewFile()</code></td><td style="text-align:left">当文件不存在的时候创建一个文件。如果指定的文件不存在则创建，则返回 true；如果指定的文件已经存在，则返回 false</td></tr><tr><td style="text-align:left"><code>boolean mkdir();</code></td><td style="text-align:left">创建一个该抽象路径对应的目录，如果新建的目录的上级目录不存在则mkdir()回报异常，创建文件夹</td></tr><tr><td style="text-align:left"><code>boolean mkdirs();</code></td><td style="text-align:left">创建多级目录，创建此抽象路径名指定的目录，包括所有必需但不存在的父目录。注意，此操作失败时也可能已经成功地创建了一部分必需的父目录。</td></tr></tbody></table><p><strong>实例：</strong></p><h3 id="当文件不存在时创建该文件"><a href="#当文件不存在时创建该文件" class="headerlink" title="当文件不存在时创建该文件"></a>当文件不存在时创建该文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">File file=new File(&quot;file2.txt&quot;);</span><br><span class="line">if(!file.exists())</span><br><span class="line">&#123;</span><br><span class="line">    file.createNewFile();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="当目录不存在时创建该目录"><a href="#当目录不存在时创建该目录" class="headerlink" title="当目录不存在时创建该目录:"></a>当目录不存在时创建该目录:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">File file=new File(&quot;file2.txt&quot;);</span><br><span class="line">if(!file.exists())</span><br><span class="line">&#123;</span><br><span class="line">    file. mkdir();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除文件或目录"><a href="#删除文件或目录" class="headerlink" title="删除文件或目录"></a>删除文件或目录</h2><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>boolean delete();</code></td><td style="text-align:left">删除此抽象路径名表示的文件或目录。<strong>如果此路径名表示一个目录，则该目录必须为空才能删除。</strong></td></tr></tbody></table><h2 id="获取文件信息方法"><a href="#获取文件信息方法" class="headerlink" title="获取文件信息方法"></a>获取文件信息方法</h2><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>public long length()</code></td><td style="text-align:left">返回文件的大小 以字节为单位；如果文件不存在，则返回 0L。对于表示特定于系统的实体比如设备或管道）的路径名，某些操作系统可能返回0L</td></tr><tr><td style="text-align:left"><code>public String getName()</code></td><td style="text-align:left">返回由此File对象表示的文件或目录的名称。该名称是路径名名称序列中的最后一个名称。如果路径名名称序列为空，则返回空字符串。</td></tr><tr><td style="text-align:left"><code>public long lastModified()</code></td><td style="text-align:left">返回文件最后一次被修改的时间,用与时间点（1970 年 1 月 1 日，00:00:00 GMT）之间的毫秒数表示；</td></tr><tr><td style="text-align:left"><code>public boolean renameTo(File dest)</code></td><td style="text-align:left">重命名该文件为dest.如果文件名为dest的文件不存在</td></tr></tbody></table><h2 id="路径相关方法"><a href="#路径相关方法" class="headerlink" title="路径相关方法"></a>路径相关方法</h2><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>public String getParent()</code></td><td style="text-align:left">返回父路径名称字符串</td></tr><tr><td style="text-align:left"><code>public File getParentFile()</code></td><td style="text-align:left">返回父路径的File对象</td></tr><tr><td style="text-align:left"><code>public String getPath();</code></td><td style="text-align:left">获取相对路径字符串</td></tr><tr><td style="text-align:left"><code>public String getAbsolutePath();</code></td><td style="text-align:left">获取绝对路径字符串。</td></tr><tr><td style="text-align:left"><code>public String getCanonicalPath();</code></td><td style="text-align:left">返回规范化路径字符串</td></tr><tr><td style="text-align:left"><code>public File getAbsoluteFile();</code></td><td style="text-align:left">返回此File对象的副本？等同于new File(this.getAbsolutePath())</td></tr></tbody></table><h3 id="返回目录列表"><a href="#返回目录列表" class="headerlink" title="返回目录列表"></a>返回目录列表</h3><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>public String[] list()</code></td><td style="text-align:left">获取该目录下的文件或目录名的字符串列表，如果此抽象路径名不表示一个目录，那么此方法将返回 null。否则返回一个字符串数组，每个数组元素对应目录中的每个文件名或目录名</td></tr><tr><td style="text-align:left"><code>public File[] listFiles()</code></td><td style="text-align:left">获取该目录下面的所有文件或者目录的File对象列表，如果此抽象路径名不表示一个目录，那么此方法将返回 null。否则返回一个File对象数组，每个数组元素对应目录中的每个文件或目录的File对象</td></tr></tbody></table><p>6.代码实例</p><p>(1) 构造函数实例：</p><pre><code>public static void main(String[] args) {        //构造函数File（String pathname）        File f1 = new File(&quot;D:\\a\\1.txt&quot;);        System.out.println(f1);        //File(String parent,String child)        File f2 = new File(&quot;D:\\a&quot;, &quot;2.txt&quot;);        System.out.println(f2);        //File(File parent,String child)        //File.separactor:表示路径分割符，在Windows系统中是&quot;\&quot;,在Linux系统中是&quot;/&quot;        File f3 = new File(&quot;D:&quot;+File.separator+&quot;a&quot;);        System.out.println(f3);        File f4 = new File(f3,&quot;3.txt&quot;);        System.out.println(f4);}</code></pre><p>运行结果：</p><pre><code>D:\a\1.txtD:\a\2.txtD:\aD:\a\3.txt</code></pre><p>(2) 创建文件或目录实例：</p><pre><code>public class FileDemo1{    public static void main(String[] args) throws IOException    {        File file = new File(&quot;D:\\a\\file.txt&quot;);        File directory = new File(&quot;D:\\a&quot;);        File dir = new File(&quot;D:\\a\\test1\\test2&quot;);        if (!directory.exists()) {            //创建目录            System.out.println(&quot;创建目录-&quot;+directory);            System.out.println(directory.mkdir());        }        else {            System.out.println(&quot;删除目录-&quot;+dir);            System.out.println(directory.delete());//删除目录            //删除此抽象路径名表示的文件或目录。如果此路径名表示一个目录，则该目录必须为空才能删除。        }        if (!dir.exists()) {            //创建多级目录            System.out.println(&quot;创建多级目录-&quot;+dir);            System.out.println(dir.mkdirs());        }        else {            System.out.println(&quot;删除多级目录-&quot;+dir);            System.out.println(dir.delete());//        }        if (!file.exists()) {            //创建文件            System.out.println(&quot;创建文件-&quot;+file);            System.out.println(file.createNewFile());        }        else {            System.out.println(&quot;删除文件-&quot;+file);            System.out.println(file.delete());//删除文件        }    }}</code></pre><p>结果：</p><p>1) 第一次运行的时候，尚未创建文件或目录。</p><pre><code>创建目录-D:\atrue创建多级目录-D:\a\test1\test2true创建文件-D:\a\file.txttrue</code></pre><p>分析：全部创建成功</p><p>2) 第2次运行，文件和目录以及多级目录都创建成功了。</p><pre><code>删除目录-D:\a\test1\test2false删除多级目录-D:\a\test1\test2true删除文件-D:\a\file.txttrue</code></pre><p>分析：</p><pre><code>文件file可以删除掉,而目录directory(D:\a)不是空目录，无法删除。目录dir(D:\a\test1\test2) test2下面没有目录和文件，可以删除掉目录test2,delete()函数只能删除掉最下面的目录test2,不会删除掉test2的父目录test1.这与mkdirs()函数不是互逆操作。</code></pre><p>(3) 判断文件函数：exists(),isFile(),isAbsolute(),isDirectory(),canRead(),canWrite(),isHidden()</p><p>代码验证：</p><pre><code>public class FileDemo2{    public static void main(String[] args)    {        File file=new File(&quot;D:\\a\\file.txt&quot;);        File noAbsolute=new File(&quot;我当然不是绝对路径啦&quot;);        File dir=new File(&quot;D:\\a&quot;);        System.out.println(&quot;file对象是否是文件：&quot;+file.isFile());        System.out.println(&quot;dir对象是否是目录：&quot;+dir.isDirectory());        System.out.println(&quot;file对象的路径是否是绝对路径: &quot;+file.isAbsolute());        System.out.println(&quot;noAbsolute对象的路径是否是绝对路径: &quot;+noAbsolute.isAbsolute());        System.out.println(&quot;file.txt是否存在：&quot;+file.exists());        System.out.println(&quot;file.txt是否可读：&quot;+file.canRead());        System.out.println(&quot;file.txt是否可写：&quot;+file.canWrite());        System.out.println(&quot;file.txt是否是隐藏文件：&quot;+file.isHidden());    }}</code></pre><p>运行结果：</p><pre><code>file对象是否是文件：truedir对象是否是目录：truefile对象的路径是否是绝对路径: truenoAbsolute对象的路径是否是绝对路径: falsefile.txt是否存在：truefile.txt是否可读：truefile.txt是否可写：truefile.txt是否是隐藏文件：false</code></pre><p>(4)获取，操作文件属性函数</p><p>lastModified(),length()，getName(),getParent(),getPath(),getAbsolutePath():</p><pre><code>public class FileAPIDemo1{    public static void main(String[] args)    {        File file=new File(&quot;D:\\a\\file.txt&quot;);        System.out.println(&quot;file.txt最后一次修改的时间：&quot;+timeStampToDate(file.lastModified()));        System.out.println(&quot;file.txt长度(字节)：&quot;+file.length()+&quot;B&quot;);        System.out.println(&quot;file的文件名：&quot;+file.getName());        System.out.println(&quot;file.txt的父路径字符串：&quot;+file.getParent());        File fileParent=file.getParentFile();//获取父路径的File对象。        System.out.println(&quot;父路径File对象fileParent的目录名：&quot;+fileParent.getName());        System.out.println(&quot;file对象的抽象路径字符串：&quot;+file.getPath());        System.out.println(&quot;file对象的绝对路径字符串：&quot;+file.getAbsolutePath());        File AbsolutePathFile=file.getAbsoluteFile();//获取绝对路径的File对象        System.out.println(&quot;AbsolutePathFile的名字：&quot;+file.getName());        System.out.println(&quot;file和AbsolutePathFile引用的是相同的文件？：&quot;+file.equals(AbsolutePathFile));    }    //把时间戳转换成格式化时间字符串    static String timeStampToDate(long timeStamp)    {        Date date =new Date(timeStamp);        SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);        return format.format(date);    }}</code></pre><p>运行结果：</p><pre><code>file.txt最后一次修改的时间：2018-05-03 16:15:00file.txt长度(字节)：15Bfile的文件名：file.txtfile.txt的父路径字符串：D:\a父路径File对象fileParent的目录名：afile对象的抽象路径字符串：D:\a\file.txtfile对象的绝对路径字符串：D:\a\file.txtAbsolutePathFile的名字：file.txtfile和AbsolutePathFile引用的是相同的文件？：true</code></pre><p>7.有些困惑的地方</p><p>(1)getAbsoluteFile()函数其实就是获取当前File对象的一个副本？</p><p>(2)规范化路径getCanonicalPath()，相对路径getPath()，绝对路径getAbsolutePath()三者的区别：</p><p>1)当输入为绝对路径时，3个方法返回的都是绝对路径。<br>2)当输入为相对路径时：<br>getPath() 返回的是File构造方法里的路径<br>getAbsolutePath() 返回的其实是user.dir+getPath()的内容<br>getCanonicalPath() 返回的是去掉多余点号(.)等的规范化路径</p><p>测试代码：</p><pre><code>public class FileDemo3{    public static void main(String[] args) throws IOException    {        // 打印当前工程的父路径        // System.out.println(System.getProperty(&quot;user.dir&quot;));        File file = new File(&quot;D:\\a\\file.txt&quot;);        System.out.println(&quot;相对路径    :&quot; + file.getPath());        System.out.println(&quot;绝对路径    :&quot; + file.getAbsolutePath());        System.out.println(&quot;规范化路径    :&quot; + file.getCanonicalPath());        System.out.println(&quot;-----------------------------&quot;);        File file2 = new File(&quot;.\\file.txt&quot;);        System.out.println(&quot;user.dir:&quot; + System.getProperty(&quot;user.dir&quot;));        System.out.println(&quot;相对路径    :&quot; + file2.getPath());        System.out.println(&quot;绝对路径    :&quot; + file2.getAbsolutePath());        System.out.println(&quot;规范化路径    :&quot; + file2.getCanonicalPath());        // 当输入为绝对路径时，3个方法返回的都是绝对路径。        // 当输入为相对路径时：        // getPath()返回的是File构造方法里的路径        // getAbsolutePath()返回的其实是user.dir+getPath()的内容        // getCanonicalPath()返回的就是标准的将符号完全解析的路径    }}</code></pre><p>(3) list()和listFile()的区别</p><p>看返回类型就知道了：</p><pre><code>list()函数获取的是当前目录下的所有文件和目录的名字列表(String数组)listFiles()获取的是当前目录下面的所有文件和目录的File对象列表(File数组)。</code></pre><p>测试代码：</p><pre><code>public class FileAPIDemo2{    public static void main(String[] args)    {        //工程路径        File dir=new File(System.getProperty(&quot;user.dir&quot;));        String[] list=dir.list();//返回当前目录下的所有文件和目录的名字        for (String string : list)        {            System.out.println(string);        }        System.out.println(&quot;--------------------&quot;);        File[] fileList=dir.listFiles();//获取当前下所有目录和文件的File对象        for (File file : fileList)        {            System.out.println(file.getName());        }    }}</code></pre><p>运行结果:</p><pre><code>.classpath.project.settingsbindemodemo1src--------------------.classpath.project.settingsbindemodemo1src</code></pre><p>(4)使用listFiles()函数,递归遍历所有的目录：</p><pre><code>public class FileAPIDemo4{    // 递归遍历所有的子目录和文件    static void forEachAllDir(File dir)    {        if (dir == null)        {            System.out.println(dir + &quot; 不是File对象&quot;);            return;        }        if (!dir.isDirectory())        {            System.out.println(dir + &quot; 不是目录&quot;);        }        File[] lists = dir.listFiles();// 获取当前目录下子文件和子目录的File对象        for (File file : lists)        {            if (file.isDirectory())// 如果是目录的话            {                System.out.println(file);//输出目录的绝对路径                // 递归调用                forEachAllDir(file);//继续显示子目录            }                         else//如果是文件的话，就直接输出文件的绝对路径            {                System.out.println(file);            }        }    }    public static void main(String[] args)    {        File dir = new File(System.getProperty(&quot;user.dir&quot;));        forEachAllDir(dir);    }}</code></pre><p>运行结果：</p><pre><code>D:\dev\workspace\TestLearned\.classpathD:\dev\workspace\TestLearned\.projectD:\dev\workspace\TestLearned\.settingsD:\dev\workspace\TestLearned\.settings\org.eclipse.jdt.core.prefsD:\dev\workspace\TestLearned\binD:\dev\workspace\TestLearned\bin\lanD:\dev\workspace\TestLearned\bin\lan\csdnD:\dev\workspace\TestLearned\bin\lan\csdn\cD:\dev\workspace\TestLearned\bin\lan\csdn\c\javaD:\dev\workspace\TestLearned\bin\lan\csdn\c\java\Myint.class......D:\dev\workspace\TestLearned\src\stringD:\dev\workspace\TestLearned\src\string\Test_IndexOf.javaD:\dev\workspace\TestLearned\src\string\Test_LastIndexOf.javaD:\dev\workspace\TestLearned\src\string\Test_Substring.java</code></pre><p>分析：可以看到当前工程下的所有目录中的文件和目录都已经遍历了一遍，通过这样递归遍历整个目录可以用来拷贝整个目录</p><p>8.文件过滤器FilenameFilter接口</p><p>看下面的File类的方法：</p><p>[java] view plain copy</p><pre><code>&lt;code class=&quot;language-java&quot;&gt;public String[] list(FilenameFilter filter) ;   //返回一个字符串数组，这些字符串是目录中满足指定过滤器的文件和目录名字符串。  public File[] listFiles(FilenameFilter filter);                                               //返回File数组，数组中的元素是该目录下的所有满足指定过滤器filter的文件和目录的File对象&lt;/code&gt;  </code></pre><p>上述方法可以实现文件过滤，返回符合条件的文件，过滤掉不符合条件的文件(不返回)</p><p>一、FilenameFilter介绍</p><p>java.io.FilenameFilter是文件名过滤器，用来过滤不符合规格的文件名，并返回合格的文件;</p><p>一般地：</p><p>(1)String[] fs = f.list();</p><p>(2)File[] fs = f.listFiles();</p><p>这两个方法返回f下的所有文件或目录；</p><p>FilenameFilter用来返回符合要求的文件或目录,不符合的文件的目录不返回(过滤掉)；</p><p>因此可以调用：</p><p>(1)String []fs = f.list(FilenameFilter filter);</p><p>(2)File[]fs = f.listFiles(FilenameFilter filter);</p><p>FilenameFilter中有一个方法：</p><p>boolean accept(File dir,String name); //dir表示文件的当前目录，name表示文件名；</p><p>实现该方法即可对文件进行过滤：</p><p>使用方式：</p><p>(1)使用匿名内部类</p><p>(2)实现FilenameFilter</p><p>代码实现：</p><p>(1)匿名内部类方式实现文件过滤：</p><pre><code>public static void printAllFile(File dir,final String ends){    String[] listStr=dir.list(new FilenameFilter()    {        @Override        // dir表示文件的当前目录，name表示当前文件的文件名；        public boolean accept(File dir, String name)        {            //该目录是文件，而且文件以.java结尾            return new File(dir, name).isFile() &amp;&amp; name.endsWith(ends);        }    });    for (String string : listStr)    {        System.out.println(string);    }}</code></pre><p>(2)实现FilenameFilter方式实现文件过滤：</p><pre><code>//静态内部类可以直接new不用加上外部类的类名//实现FilenameFilterstatic class MyFilenameFilter implements FilenameFilter{    String ends;    public MyFilenameFilter(){}    public MyFilenameFilter(String ends)    {        this.ends=ends;    }    @Override    public boolean accept(File dir, String name)    {        return new File(dir, name).isFile() &amp;&amp; name.endsWith(ends);    }}public static void printAllFile2(File dir, String ends){    String[] listStr=dir.list(new MyFilenameFilter(ends));    for (String string : listStr)    {        System.out.println(string);    }}</code></pre><p>完整代码：</p><pre><code>import java.io.File;import java.io.FilenameFilter;import java.io.IOException;import com.lan.filepath.FilePath;public class FilenameFilterTest{    public static void printAllFile(File dir, final String ends)    {        String[] listStr = dir.list(new FilenameFilter()        {            @Override            // dir表示文件的当前目录，name表示当前文件的文件名；            public boolean accept(File dir, String name)            {                // 该目录是文件，而且文件以.java结尾                return new File(dir, name).isFile() &amp;&amp; name.endsWith(ends);            }        });        for (String string : listStr)        {            System.out.println(string);        }    }    // 静态内部类可以直接new不用加上外部类的类名    // 实现FilenameFilter    static class MyFilenameFilter implements FilenameFilter    {        String ends;        public MyFilenameFilter()        {        }        public MyFilenameFilter(String ends)        {            this.ends = ends;        }        @Override        public boolean accept(File dir, String name)        {            return new File(dir, name).isFile() &amp;&amp; name.endsWith(ends);        }    }    public static void printAllFile2(File dir, String ends)    {        String[] listStr = dir.list(new MyFilenameFilter(ends));        for (String string : listStr)        {            System.out.println(string);        }    }    public static void main(String[] args) throws IOException    {        // 获得当前的包路径        String packagePath = FilePath                .getSrcPackagePath(FilenameFilterTest.class);        File dir = new File(packagePath);        System.out.println(&quot;当前目录下的所有java文件：&quot;);        printAllFile(dir, &quot;.java&quot;);        System.out.println(&quot;-----------------------------------------------&quot;);        System.out.println(&quot;当前目录下的所有txt文件：&quot;);        printAllFile(dir, &quot;.txt&quot;);        System.out.println(&quot;-----------------------------------------------&quot;);        System.out.println(&quot;当前目录下的所有txt文件：&quot;);        printAllFile2(dir, &quot;.txt&quot;);    }}</code></pre><p>运行结果：</p><pre><code>当前目录下的所有java文件：FileAPIDemo1.javaFileAPIDemo2.javaFileAPIDemo4.javaFileDemo.javaFileDemo1.javaFileDemo2.javaFileDemo3.javaFilenameFilterTest.javaTestFile.javaTestGBK.java-----------------------------------------------当前目录下的所有txt文件：Test.txt-----------------------------------------------当前目录下的所有txt文件：Test.txt</code></pre><p>可以看到上面两种方式都能实现根据后缀名来过滤目录下面的文件，匿名内部类的方式比较适合于临时使用的情况，实现接口的方式比较适合于多次重复使用的情况。</p><p>参考：</p><p>JAVA基础知识之IO-File类</p><p>FilenameFilter总结</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/833486b4/">Java IO流 File类</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java IO流 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Linux 常用环境变量及作用和环境变量文件的详细介绍及其加载执行顺序</title>
      <link href="/blog/6249459e/"/>
      <url>/blog/6249459e/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>Linux 常用环境变量及作用和环境变量文件的详细介绍及其加载执行顺序<br>原文：</p><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><ol><li><p>环境变量是操作系统环境设置的变量，适用于整个系统的用户进程；</p></li><li><p>环境变量可以在命令中设置，但是用户注销的时候将会丢失这些设置值；</p></li><li><p>若要重复适用，则<strong>最好在.profile中定义</strong>；环境变量的使用与本地变量的使用方法相同，</p></li><li><p>但是在使用之前，必须用export命令导出。</p></li></ol><h2 id="一、环境变量文件介绍"><a href="#一、环境变量文件介绍" class="headerlink" title="一、环境变量文件介绍"></a>一、环境变量文件介绍</h2><p>Linux中环境变量包括<code>系统级</code>和<code>用户级</code>。</p><ul><li>系统级的环境变量是每个登录到系统的用户都要读取的系统变量，</li><li>而用户级的环境变量则是该用户使用系统时加载的环境变量，<br>所以管理环境变量的文件也分为系统级和用户级的。</li></ul><h2 id="二、Linux的变量种类"><a href="#二、Linux的变量种类" class="headerlink" title="二、Linux的变量种类"></a>二、Linux的变量种类</h2><p>按变量的生存周期来划分，Linux变量可分为两类：</p><ul><li>永久的：需要修改配置文件，变量永久生效</li><li>临时的：使用export命令声明即可，变量在关闭shell时失效</li></ul><h2 id="三、Linux-环境变量文件"><a href="#三、Linux-环境变量文件" class="headerlink" title="三、Linux 环境变量文件"></a>三、Linux 环境变量文件</h2><p>linux变量文件有</p><ul><li><code>/etc/environment</code></li><li><code>/etc/profile</code></li><li><code>~/.profile</code></li><li><code>/etc/bash.bashrc</code></li><li><code>~/.bashrc</code></li><li><code>~/.bash_profile(一般是用户在自己目录下新建的</code>）</li><li><code>~/.bash_logout.</code></li></ul><h3 id="系统级："><a href="#系统级：" class="headerlink" title="系统级："></a>系统级：</h3><h4 id="etc-environment"><a href="#etc-environment" class="headerlink" title="/etc/environment"></a>/etc/environment</h4><ul><li>该文件是<strong>系统在登录时读取的第一个文件</strong>，该文件设置的是整个系统的环境变量，只要启动系统就会读取该文件，用于为所有进程设置环境变量。</li><li>系统使用此文件时<strong>并不是执行此文件中的命令</strong>，而是根据而是根据KEY=VALUE模式的代码，对KEY赋值以VALUE，因此文件中如果要定义PATH环境变量，只需加入一行形如 PATH=$PATH:/xxx/bin的代码即可<br>例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games&quot;</span><br></pre></td></tr></table></figure></li></ul><h4 id="etc-profile"><a href="#etc-profile" class="headerlink" title="/etc/profile"></a>/etc/profile</h4><ul><li>此文件是系统登录时执行的第二个文件。 为系统的每个用户设置环境信息，当用户第一次登录时，该文件被执行。并从<code>/etc/profile.d</code>目录的配置文件中搜集shell的设置。</li><li>/etc/profile可以用于设定针对全系统所有用户的环境变量，环境变量周期是永久性，例如如果需要让所有用户可以使用java,把Java环境变量写在该文件中。</li></ul><h3 id="etc-bashrc"><a href="#etc-bashrc" class="headerlink" title="/etc/bashrc"></a>/etc/bashrc</h3><ul><li>是针对所有用户的bash初始化文件，在此中设定的环境变量将应用于所有用户的shell中，此文件会在用户每次打开shell时执行一次。</li><li>即每次新开一个终端，都会执行/etc/bashrc</li></ul><h2 id="用户级："><a href="#用户级：" class="headerlink" title="用户级："></a>用户级：</h2><p>这些文件处于(Home)家目录下<code>~</code>,用于定制<code>该用户的专属环境变量</code>。</p><h3 id="profile"><a href="#profile" class="headerlink" title="~/.profile"></a><code>~/.profile</code></h3><p>对应当前登录用户的profile文件，用于定制当前用户的个人工作环境(变量是永久性)，每个用户都可使用该文件输入专用于自己使用的shell信息,<strong>当用户登录时,该文件仅仅执行一次</strong>!默认情况下,他设置一些环境变量,执行用户的.bashrc文件。这里是推荐放置个人设置的地方</p><h3 id="bashrc"><a href="#bashrc" class="headerlink" title="~/.bashrc"></a>~/.bashrc</h3><p>该文件包含专用于你的bash shell的bash信息，当登录时以及<strong>每次打开新的shell时，该文件被读取</strong>。(~/.bashrc只针对当前用户，变量的生命周期是永久的)，所以不推荐在这里设置常用的变量，因为每开一个shell，这个文件会读取一次，效率肯定有影响。</p><p>暂时整理到这里，我看作者写的有点乱。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/6249459e/">Linux 常用环境变量及作用和环境变量文件的详细介绍及其加载执行顺序</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Linux系统上java使用 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Linux中Java环境变量配置的几种方式</title>
      <link href="/blog/73224a52/"/>
      <url>/blog/73224a52/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>$vi /etc/profile<br>在<code>/etc/profile</code>文件<code>最后</code>添加下面的内容:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#set Java environment</span><br><span class="line">export JAVA_HOME=/usr/lib/java/jdk1.8.0_171</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br></pre></td></tr></table></figure><p></p><p>修改文件后如果想马上生效，执行命令：<code>source /etc/profile</code><br>最后重启：<code>shutdown -r -t 0</code></p><h2 id="永久修改，对单一用户有效"><a href="#永久修改，对单一用户有效" class="headerlink" title="永久修改，对单一用户有效"></a>永久修改，对单一用户有效</h2><p>修改用户目录下的<code>.bash_profile</code>文件<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">vi .bash_profile</span><br></pre></td></tr></table></figure><p></p><p>在文件<code>最后</code>添加下面的内容<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#set Java environment</span><br><span class="line">export JAVA_HOME=/usr/lib/java/jdk1.8.0_171</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br></pre></td></tr></table></figure><p></p><p>此时如果想要马上生效执命令：<code>source .bash_profile</code><br>最后重启：<code>shutdown -r -t 0</code></p><h2 id="只对当前bash-shell-生效"><a href="#只对当前bash-shell-生效" class="headerlink" title="只对当前bash /shell 生效"></a>只对当前bash /shell 生效</h2><p>直接在<code>shell</code>中输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/lib/java/jdk1.8.0_171</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br></pre></td></tr></table></figure><p>这个只对当前<code>shell/bash</code>有效重新打开一个<code>shell</code>就没有用了。</p><p>参考：<a href="https://blog.csdn.net/jillliang/article/details/8216308" target="_blank" rel="noopener">https://blog.csdn.net/jillliang/article/details/8216308</a></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/73224a52/">Linux中Java环境变量配置的几种方式</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Linux系统上java使用 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Ubuntu16_04中安装Java配置环境变量</title>
      <link href="/blog/36bd33ee/"/>
      <url>/blog/36bd33ee/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>Ubuntu 16.04中安装Java,配置环境变量。<br>参考：<a href="https://www.linuxidc.com/Linux/2017-02/140908.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2017-02/140908.htm</a><br>参考：<a href="https://www.linuxidc.com/Linux/2017-06/144732.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2017-06/144732.htm</a><br>参考：<a href="https://www.linuxidc.com/Linux/2017-01/139212.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2017-01/139212.htm</a><br>下载路径：<a href="http://www.oracle.com/technetwork/cn/java/javase/downloads/jdk8-downloads-2133151-zhs.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/cn/java/javase/downloads/jdk8-downloads-2133151-zhs.html</a><br>参考：<a href="https://www.linuxidc.com/Linux/2017-02/140908.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2017-02/140908.htm</a></p><h2 id="下载Oracle-JDK"><a href="#下载Oracle-JDK" class="headerlink" title="下载Oracle JDK"></a>下载<code>Oracle JDK</code></h2><p>系统版本：<code>Ubuntu 16.04</code>，VMware虚拟机<br>JDK版本：<code>jdk-8u171-linux-x64.tar.gz</code><br><a href="http://www.oracle.com/technetwork/cn/java/javase/downloads/jdk8-downloads-2133151-zhs.html" target="_blank" rel="noopener">Oracle JDK 下载</a><br><img src="https://i.imgur.com/4twgwHl.png" alt=""><br><a href="http://download.oracle.com/otn-pub/java/jdk/8u171-b11/512cd62ec5174c3487ac17c61aaa89e8/jdk-8u171-linux-x64.tar.gz" target="_blank" rel="noopener">jdk-8u171-linux-x64.tar.gz</a></p><p>下载最新版的就行了，下载后复制粘贴到虚拟机桌面中。</p><h2 id="粘贴到虚拟机中"><a href="#粘贴到虚拟机中" class="headerlink" title="粘贴到虚拟机中"></a>粘贴到虚拟机中</h2><p><img src="https://i.imgur.com/BYrwf9T.png" alt=""></p><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><p>然后登录root用户<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$su root</span><br></pre></td></tr></table></figure><p></p><p>新建文件夹：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$mkdir /usr/lib/java</span><br></pre></td></tr></table></figure><p></p><p>把粘贴到虚拟机中<code>jdk-8u171-linux-x64.tar.gz</code>复制到<code>/usr/lib/java</code>中：<br><img src="https://i.imgur.com/CpHgcew.png" alt=""><br>进入该文件夹：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/lib/java</span><br></pre></td></tr></table></figure><p></p><p>然后解压<code>jdk-8u171-linux-x64.tar.gz</code>：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf jdk-8u171-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><p></p><p>解压后的效果如下：<br><img src="https://i.imgur.com/vb1S6PY.png" alt=""></p><h2 id="配置所有用户的环境变量"><a href="#配置所有用户的环境变量" class="headerlink" title="配置所有用户的环境变量"></a>配置所有用户的环境变量</h2><p>但是还没有结束！现在我们设置的环境只是在会话里面，退出会话环境变量就没了，所以我们要把环境变量设置到 <code>/etc/profile</code>文件里<br>输入命令：<code>vi /etc/profile</code>，编辑该文件,在文件最后面写入下面的几句话：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#set Java environment</span><br><span class="line">export JAVA_HOME=/usr/lib/java/jdk1.8.0_171</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br></pre></td></tr></table></figure><p></p><p><img src="https://i.imgur.com/AbD846T.png" alt=""><br>保存</p><p>输入命令<code>source /etc/profile</code>，让设置生效<br>现在输入<code>java -version</code>就可以看到运行效果了。<br><img src="https://i.imgur.com/t5vY443.png" alt=""><br>最后重启系统<br><img src="https://i.imgur.com/t5vY443.png" alt=""></p><h2 id="正确切换用户的命令"><a href="#正确切换用户的命令" class="headerlink" title="正确切换用户的命令"></a>正确切换用户的命令</h2><p>注意：切换用户的时候，要用<code>su -l 用户B</code>进行登录，不然不会切换环境变量这样造成用户B无法使用<code>java</code><br>错误的切换用户的方式：<code>su root</code><br><img src="https://i.imgur.com/FbL7Q39.png" alt=""><br>可以看到这样切换用户<code>root</code>用户无法使用<code>java</code><br>正确的登录方法：<code>su -l root</code><br><img src="https://i.imgur.com/J3vsp9M.png" alt=""><br>这样其他用户(<code>root</code>)用户就可以使用<code>java</code>了。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/36bd33ee/">Ubuntu16_04中安装Java配置环境变量</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java IO流 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java IO流 目录</title>
      <link href="/blog/49fbaefe/"/>
      <url>/blog/49fbaefe/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><h2 id="各个类介绍"><a href="#各个类介绍" class="headerlink" title="各个类介绍"></a>各个类介绍</h2><p><a href="https://blog.csdn.net/qq_21808961/article/details/80113925" target="_blank" rel="noopener">java IO流 编码</a></p><p><a href="https://blog.csdn.net/qq_21808961/article/details/80171354" target="_blank" rel="noopener">Java IO流 File类</a></p><p><a href="https://blog.csdn.net/qq_21808961/article/details/81260228" target="_blank" rel="noopener">JavaIO FilenameFilter接口</a></p><p><a href="https://blog.csdn.net/qq_21808961/article/details/80348024" target="_blank" rel="noopener">JavaIO Java IO体系及常用类</a></p><p><a href="https://blog.csdn.net/qq_21808961/article/details/80187662" target="_blank" rel="noopener">javaIO RandomAccessFile类随机读写</a></p><p><a href="https://blog.csdn.net/qq_21808961/article/details/80199368" target="_blank" rel="noopener">JavaIO RandomAccessFile 借助ArrayList方便的操作文件</a></p><p><a href="https://blog.csdn.net/qq_21808961/article/details/80205875" target="_blank" rel="noopener">JavaIO RandomAccessFile乱码问题</a></p><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p><a href="https://blog.csdn.net/qq_21808961/article/details/80219705" target="_blank" rel="noopener">javaIO FileInputStream</a></p><p><a href="https://blog.csdn.net/qq_21808961/article/details/80286564" target="_blank" rel="noopener">javaIO FileOutputStream</a></p><p><a href="https://blog.csdn.net/qq_21808961/article/details/80298660" target="_blank" rel="noopener">javaIO DataOutputStream 读写字符串</a></p><p><a href="https://blog.csdn.net/qq_21808961/article/details/80294246" target="_blank" rel="noopener">JavaIO DataOutputStream数据输出流类</a></p><p><a href="https://blog.csdn.net/qq_21808961/article/details/80302135" target="_blank" rel="noopener">javaIO BufferedOutputStream和BufferedInputStream</a></p><h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p><a href="https://blog.csdn.net/qq_21808961/article/details/81543235" target="_blank" rel="noopener">JavaIO InputStreamReader和OutputStreamWriter介绍</a></p><p><a href="https://blog.csdn.net/qq_21808961/article/details/80324951" target="_blank" rel="noopener">JavaIO FileReader和FileWriter</a></p><p><a href="https://blog.csdn.net/qq_21808961/article/details/81561464" target="_blank" rel="noopener">JavaIO BufferedReader和BufferedWriter介绍和实例</a></p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p><a href="https://blog.csdn.net/qq_21808961/article/details/80349643" target="_blank" rel="noopener">JavaIO ObjectOutputStream和ObjectInputStream 对象的序列化</a></p><p><a href="https://blog.csdn.net/qq_21808961/article/details/80356848" target="_blank" rel="noopener">Java对象序列化详解</a></p><p><a href="https://blog.csdn.net/qq_21808961/article/details/80356659" target="_blank" rel="noopener">JavaIO 对象序列化和反序列化</a></p><h2 id="其他相关类"><a href="#其他相关类" class="headerlink" title="其他相关类"></a>其他相关类</h2><p><a href="https://blog.csdn.net/qq_21808961/article/details/80292219" target="_blank" rel="noopener">javaIO 输出重定向</a></p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h3><p><a href="https://blog.csdn.net/qq_21808961/article/details/80308228" target="_blank" rel="noopener">JavaIO 使用缓冲字节流和文件字节流拷贝文件</a></p><h3 id="复制目录"><a href="#复制目录" class="headerlink" title="复制目录"></a>复制目录</h3><p><a href="https://blog.csdn.net/qq_21808961/article/details/81571283" target="_blank" rel="noopener">Java IO流 复制一个目录</a></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/49fbaefe/">Java IO流 目录</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java IO流 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java IO流 复制一个目录</title>
      <link href="/blog/bda55058/"/>
      <url>/blog/bda55058/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>实现把一个目录中的所有内容复制到一个目录中去</p><h2 id="实现文件复制"><a href="#实现文件复制" class="headerlink" title="实现文件复制"></a>实现文件复制</h2><p>因为一个目录下的文件可能是字符文件，也可能是二进制文件，所以使用字节流来进行复制,这样能复制所有类型的文件。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 复制一个文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> srcFile 源文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> destFile 目的文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFile</span><span class="params">(String srcFile, String destFile)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FileInputStream in = <span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line">FileOutputStream out = <span class="keyword">new</span> FileOutputStream(destFile);</span><br><span class="line"><span class="comment">// 2097152(Byte)=2048(KB)=2M</span></span><br><span class="line"><span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2097152</span>];</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//每次读取一个字节数组</span></span><br><span class="line"><span class="keyword">while</span> ((size = in.read(buffer)) != -<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//读到多少写入多少</span></span><br><span class="line">out.write(buffer, <span class="number">0</span>, size);</span><br><span class="line">&#125;</span><br><span class="line">in.close();</span><br><span class="line">out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上述方法可以复制一个文件，我们可以在这个方法的基础之上实现目录的复制。</p><h2 id="复制目录的算法"><a href="#复制目录的算法" class="headerlink" title="复制目录的算法"></a>复制目录的算法</h2><ul><li>遍历该目录列表，如果列表项是文件就调用上面的copyFile()方法复制该文件</li><li>如果是该列表项是一个目录的话，就递归调用自己，复制该子目录。</li></ul><h3 id="复制目录的实现代码"><a href="#复制目录的实现代码" class="headerlink" title="复制目录的实现代码"></a>复制目录的实现代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 使用递归复制目录,</span><br><span class="line"> * @param FromDir 源目录的路径名称</span><br><span class="line"> * @param ToDir 目的目录的路径名称</span><br><span class="line"> * @throws IOException</span><br><span class="line"> */</span><br><span class="line">public static void copyDir(String FromDir, String ToDir) throws IOException</span><br><span class="line">&#123;</span><br><span class="line">// 创建目录的File对象</span><br><span class="line">File srcDir = new File(FromDir);</span><br><span class="line">// 判断源目录是不是一个目录</span><br><span class="line">if (!srcDir.isDirectory())</span><br><span class="line">&#123;</span><br><span class="line">//如果不是目录那就不复制</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">//创建目的目录的File对象</span><br><span class="line">File destDir = new File(ToDir);</span><br><span class="line">// 如果目的目录不存在</span><br><span class="line">if (!destDir.exists())</span><br><span class="line">&#123;</span><br><span class="line">// 创建目的目录</span><br><span class="line">destDir.mkdir();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取源目录下的File对象列表,每一个对象代表一个目录或者文件</span><br><span class="line">File[] srcDirList = srcDir.listFiles();</span><br><span class="line">// 遍历源目录File对象列表</span><br><span class="line">for (int i = 0; i &lt; srcDirList.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">// 如果是目录的话</span><br><span class="line">if (srcDirList[i].isDirectory())</span><br><span class="line">&#123;</span><br><span class="line">// 递归调用复制该目录</span><br><span class="line">copyDir(FromDir + File.separator + srcDirList[i].getName(),</span><br><span class="line">ToDir + File.separator + srcDirList[i].getName());</span><br><span class="line">&#125;</span><br><span class="line">// 如果是文件的话</span><br><span class="line">if (srcDirList[i].isFile())</span><br><span class="line">&#123;</span><br><span class="line">// 调用复制文件的方法</span><br><span class="line">copyFile(FromDir + File.separator + srcDirList[i].getName(),</span><br><span class="line">ToDir + File.separator + srcDirList[i].getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main方法中调用：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException</span><br><span class="line">&#123;</span><br><span class="line">copyDir(&quot;FromDir&quot;, &quot;ToDir&quot;);//复制当前工程下的FromDir目录中的内容到ToDir目录中。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>当前eclipse中的目录结构如下：<br><img src="https://i.imgur.com/WWYtG31.png" alt=""></p><p>运行后的目录结构：</p><p><img src="https://i.imgur.com/Amy5dyL.png" alt=""></p><p>可以看到整个目录复制成功了。</p><h2 id="完整代码如下："><a href="#完整代码如下：" class="headerlink" title="完整代码如下："></a>完整代码如下：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">package copy.file;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class CopyDir</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args) throws IOException</span><br><span class="line">&#123;</span><br><span class="line">copyDir(&quot;FromDir&quot;, &quot;ToDir&quot;);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 使用递归复制目录,</span><br><span class="line"> * </span><br><span class="line"> * @param FromDir</span><br><span class="line"> *            源目录的路径名称</span><br><span class="line"> * @param ToDir</span><br><span class="line"> *            目的目录的路径名称</span><br><span class="line"> * @throws IOException</span><br><span class="line"> */</span><br><span class="line">public static void copyDir(String FromDir, String ToDir) throws IOException</span><br><span class="line">&#123;</span><br><span class="line">// 创建目录的File对象</span><br><span class="line">File srcDir = new File(FromDir);</span><br><span class="line">// 判断源目录是不是一个目录</span><br><span class="line">if (!srcDir.isDirectory())</span><br><span class="line">&#123;</span><br><span class="line">// 如果不是目录那就不复制</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">// 创建目的目录的File对象</span><br><span class="line">File destDir = new File(ToDir);</span><br><span class="line">// 如果目的目录不存在</span><br><span class="line">if (!destDir.exists())</span><br><span class="line">&#123;</span><br><span class="line">// 创建目的目录</span><br><span class="line">destDir.mkdir();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取源目录下的File对象列表,每一个对象代表一个目录或者文件</span><br><span class="line">File[] srcDirList = srcDir.listFiles();</span><br><span class="line">// 遍历源目录File对象列表</span><br><span class="line">for (int i = 0; i &lt; srcDirList.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">// 如果是目录的话</span><br><span class="line">if (srcDirList[i].isDirectory())</span><br><span class="line">&#123;</span><br><span class="line">// 递归调用复制该目录</span><br><span class="line">copyDir(FromDir + File.separator + srcDirList[i].getName(),</span><br><span class="line">ToDir + File.separator + srcDirList[i].getName());</span><br><span class="line">&#125;</span><br><span class="line">// 如果是文件的话</span><br><span class="line">if (srcDirList[i].isFile())</span><br><span class="line">&#123;</span><br><span class="line">// 调用复制文件的方法</span><br><span class="line">copyFile(FromDir + File.separator + srcDirList[i].getName(),</span><br><span class="line">ToDir + File.separator + srcDirList[i].getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 复制一个文件</span><br><span class="line"> * </span><br><span class="line"> * @param srcFile</span><br><span class="line"> *            源文件</span><br><span class="line"> * @param destFile</span><br><span class="line"> *            目的文件</span><br><span class="line"> * @throws IOException</span><br><span class="line"> */</span><br><span class="line">public static void copyFile(String srcFile, String destFile)</span><br><span class="line">throws IOException</span><br><span class="line">&#123;</span><br><span class="line">FileInputStream in = new FileInputStream(srcFile);</span><br><span class="line">FileOutputStream out = new FileOutputStream(destFile);</span><br><span class="line">// 2097152(Byte)=2048(KB)=2M</span><br><span class="line">byte[] buffer = new byte[2097152];</span><br><span class="line">int size = 0;</span><br><span class="line">// 每次读取一个字节数组</span><br><span class="line">while ((size = in.read(buffer)) != -1)</span><br><span class="line">&#123;</span><br><span class="line">// 读到多少写入多少</span><br><span class="line">out.write(buffer, 0, size);</span><br><span class="line">&#125;</span><br><span class="line">in.close();</span><br><span class="line">out.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文链接: <a href="https://www.lansheng.net.cn/blog/bda55058/">Java IO流 复制一个目录</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java IO流 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Editplus格式化html代码</title>
      <link href="/blog/d80a89a8/"/>
      <url>/blog/d80a89a8/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>格式化代码：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> regex.tools;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HTMLFormat2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//如果收到1个以上的明令行参数,而且是以.html结尾,或者.htm结尾</span></span><br><span class="line"><span class="keyword">if</span> (args.length &gt;= <span class="number">1</span>&amp;&amp;args[<span class="number">0</span>].matches(<span class="string">".*\\.html?"</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//定义一个缩进是4个空格</span></span><br><span class="line"><span class="keyword">final</span> String TAB = <span class="string">"    "</span>;</span><br><span class="line"><span class="comment">//存放缩进</span></span><br><span class="line">StringBuilder tabBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="comment">//匹配html开始标签</span></span><br><span class="line">String addTab = <span class="string">"(?:&lt;html&gt;|&lt;head&gt;|&lt;body&gt;|&lt;script[^&gt;]*&gt;)"</span>;</span><br><span class="line">Pattern addTabPattern = Pattern.compile(addTab);</span><br><span class="line">Matcher matcherAdd;</span><br><span class="line"><span class="comment">//匹配结束标签</span></span><br><span class="line">String MinusTab = <span class="string">"(?:&lt;/html&gt;|&lt;/head&gt;|&lt;/body&gt;|&lt;/script&gt;)"</span>;</span><br><span class="line">Pattern MinusTabPattern = Pattern.compile(MinusTab);</span><br><span class="line">Matcher matcherMinusTab;</span><br><span class="line"><span class="comment">//读取该文件,html文件默认以utf-8处理</span></span><br><span class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(</span><br><span class="line"><span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]), <span class="string">"utf-8"</span>));</span><br><span class="line">String line = <span class="keyword">null</span>;</span><br><span class="line">StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="comment">// 读取一行字符</span></span><br><span class="line"><span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//测试正则表达式</span></span><br><span class="line">matcherAdd = addTabPattern.matcher(line);</span><br><span class="line">matcherMinusTab = MinusTabPattern.matcher(line);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配到标签开始</span></span><br><span class="line"><span class="keyword">if</span> (matcherAdd.matches())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 原样输出</span></span><br><span class="line"><span class="comment">// System.out.print(tabBuilder.toString());</span></span><br><span class="line"><span class="comment">// System.out.println(line);</span></span><br><span class="line"><span class="comment">//result.append(tabBuilder.toString() + line + "\n");</span></span><br><span class="line">result.append(tabBuilder.toString());</span><br><span class="line">result.append(line);</span><br><span class="line">result.append(<span class="string">"\n"</span>);</span><br><span class="line"><span class="comment">// 让后面的代码加一个缩进</span></span><br><span class="line">tabBuilder.append(TAB);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (matcherMinusTab.matches())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 匹配到结束标签</span></span><br><span class="line"><span class="comment">// 删除缩进，对其前面的开头标签</span></span><br><span class="line">tabBuilder.delete(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// System.out.print(tabBuilder.toString());</span></span><br><span class="line"><span class="comment">// System.out.println(line);</span></span><br><span class="line"><span class="comment">//result.append(tabBuilder.toString() + line + "\n");</span></span><br><span class="line">result.append(tabBuilder.toString());</span><br><span class="line">result.append(line);</span><br><span class="line">result.append(<span class="string">"\n"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 其他代码</span></span><br><span class="line"><span class="comment">// System.out.print(tabBuilder.toString());</span></span><br><span class="line"><span class="comment">// System.out.println(line);</span></span><br><span class="line"><span class="comment">//result.append(tabBuilder.toString() + line + "\n");</span></span><br><span class="line">result.append(tabBuilder.toString());</span><br><span class="line">result.append(line);</span><br><span class="line">result.append(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// while结束</span></span><br><span class="line"><span class="comment">//关闭文件</span></span><br><span class="line">reader.close();</span><br><span class="line"><span class="comment">//System.out</span></span><br><span class="line"><span class="comment">//.println("###############################################");</span></span><br><span class="line"><span class="comment">//System.out.println(result.toString());</span></span><br><span class="line"><span class="comment">//System.out</span></span><br><span class="line"><span class="comment">//.println("###############################################");</span></span><br><span class="line">BufferedWriter writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(</span><br><span class="line"><span class="keyword">new</span> FileOutputStream(args[<span class="number">0</span>]), <span class="string">"utf-8"</span>));</span><br><span class="line">writer.write(result.toString(),<span class="number">0</span>,result.length());</span><br><span class="line">writer.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>导出成克可执行jar包：HTMLFormat.jar，然后创建bat文件：HTMLFormat.bat<br>HTMLFormat.bat中的内容写下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">java -jar D:\dev\java\my\runable\codeformat\HTMLFormat.jar %1</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p></p><p>HTMLFormat.jar的路径(D:\dev\java\my\runable\codeformat\HTMLFormat.jar)是你导出的jar包存放的路径，以你导出的为准。<br>然后在editplus中配置如下：<br><img src="https://i.imgur.com/dBhM8nC.png" alt=""></p><p><img src="https://i.imgur.com/jzzzGcC.png" alt=""></p><p><img src="https://i.imgur.com/WVhMIZ1.png" alt=""></p><p>然后打开一个没有格式化的html代码，按下ctrl+1调用该工具即可格式化html代码。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/d80a89a8/">Editplus格式化html代码</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java IO流 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JavaIO BufferedReader和BufferedWriter</title>
      <link href="/blog/3f2a064c/"/>
      <url>/blog/3f2a064c/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>为了提高字符流读写的效率，引入了缓冲机制，进行字符批量的读写，提高了单个字符读写的效率。<code>BufferedReader</code>用于加快读取字符的速度，<code>BufferedWriter</code>用于加快写入的速度</p><p>怎样读写：(出处：<code>Java</code>中，<code>BufferedReader</code>类的介绍及作用)</p><p><code>BufferedReader</code>和<code>BufferedWriter</code>类各拥有<code>8192</code>个字符的缓冲区。当<code>BufferedReader</code>在读取文本文件时，会先尽量从文件中读入字符数据并放满缓冲区，而之后若使用<code>read()</code>方法，会先从缓冲区中进行读取。如果缓冲区数据不足，才会再从文件中读取，使用<code>BufferedWriter</code>时，写入的数据并不会先输出到目的地，而是先存储至缓冲区中。如果缓冲区中的数据满了，才会一次对目的地进行写出。</p><h1 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h1><p><code>BufferedReader</code>是为了提供读的效率而设计的一个包装类，它可以包装字符流。可以从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。</p><h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object</span><br><span class="line">  |----&gt; java.io.Reader</span><br><span class="line">      |----&gt; java.io.BufferedReader</span><br></pre></td></tr></table></figure><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>BufferedReader(Reader in)</code></td><td style="text-align:left">创建一个使用默认大小输入缓冲区的缓冲字符输入流。</td></tr><tr><td style="text-align:left"><code>BufferedReader(Reader in, int sz)</code></td><td style="text-align:left">创建一个使用指定大小输入缓冲区的缓冲字符输入流。</td></tr></tbody></table><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>int read()</code></td><td style="text-align:left">读取单个字符。</td></tr><tr><td style="text-align:left"><code>int read(char[] cbuf, int off, int len)</code></td><td style="text-align:left">将字符读入数组的某一部分。</td></tr><tr><td style="text-align:left"><code>String readLine()</code></td><td style="text-align:left"><strong>读取一个文本行。</strong></td></tr><tr><td style="text-align:left"><code>long skip(long n)</code></td><td style="text-align:left">跳过字符。</td></tr><tr><td style="text-align:left"><code>boolean ready()</code></td><td style="text-align:left">判断此流是否已准备好被读取。</td></tr><tr><td style="text-align:left"><code>void close()</code></td><td style="text-align:left">关闭该流并释放与之关联的所有资源。</td></tr><tr><td style="text-align:left"><code>void mark(int readAheadLimit)</code></td><td style="text-align:left">标记流中的当前位置。</td></tr><tr><td style="text-align:left"><code>boolean markSupported()</code></td><td style="text-align:left">判断此流是否支持 mark() 操作（它一定支持）。</td></tr><tr><td style="text-align:left"><code>void reset()</code></td><td style="text-align:left">将流重置到最新的标记。</td></tr></tbody></table><h2 id="读取文件实例"><a href="#读取文件实例" class="headerlink" title="读取文件实例"></a>读取文件实例</h2><h3 id="读取文件-一个字符一个字符的读取"><a href="#读取文件-一个字符一个字符的读取" class="headerlink" title="读取文件: 一个字符一个字符的读取"></a>读取文件: 一个字符一个字符的读取</h3><p><code>int read()</code>方法,每次可以读取到一个字符(以<code>int</code> 类型表示)，不过因为返回的是<code>int</code>类型的，所以要强制类型转换成<code>char</code>类型才能打印该字符。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printByFileReader</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BufferedReader reader=<span class="keyword">new</span> BufferedReader(</span><br><span class="line">            <span class="keyword">new</span> FileReader(filePath)</span><br><span class="line">            );</span><br><span class="line">    <span class="keyword">if</span>(!reader.ready())</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"文件流暂时无法读取"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((result=reader.read())!=-<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//因为读取到的是int类型的，所以要强制类型转换</span></span><br><span class="line">        System.out.print((<span class="keyword">char</span>)result);</span><br><span class="line">    &#125;</span><br><span class="line">    reader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="读取文件-一个数组一个数组的读取"><a href="#读取文件-一个数组一个数组的读取" class="headerlink" title="读取文件:一个数组一个数组的读取"></a>读取文件:一个数组一个数组的读取</h3><p><code>int read(char[] cbuf, int off, int len)</code>方法，每次读取<code>len</code>个字符放到字符数组<code>cbuf</code>中,从数组<code>cbuf</code>的下表<code>off</code>开始放,返回的是每次读取的字符个数。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void printByFileReaderChars(String filePath) throws IOException</span><br><span class="line">&#123;</span><br><span class="line">BufferedReader reader=new BufferedReader(</span><br><span class="line">new FileReader(filePath)</span><br><span class="line">);</span><br><span class="line">if(!reader.ready())</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;文件流暂时无法读取&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">int size=0;</span><br><span class="line">char[] cbuf=new char[20];</span><br><span class="line">while((size=reader.read(cbuf, 0, cbuf.length))!=-1)</span><br><span class="line">&#123;</span><br><span class="line">System.out.print(new String(cbuf,0,size));</span><br><span class="line">&#125;</span><br><span class="line">reader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="读取文件-一行一行的读取"><a href="#读取文件-一行一行的读取" class="headerlink" title="读取文件:一行一行的读取"></a>读取文件:一行一行的读取</h3><p><code>String readLine()</code>这个方法一次可以读取一个文本行,返回的直接就是这一行的字符串,如果读到行尾了就返回<code>null</code>。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void printByFileReaderLine(String filePath) throws IOException</span><br><span class="line">&#123;</span><br><span class="line">BufferedReader reader=new BufferedReader(</span><br><span class="line">new FileReader(filePath)</span><br><span class="line">);</span><br><span class="line">if(!reader.ready())</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;文件流暂时无法读取&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">int size=0;</span><br><span class="line">String line;</span><br><span class="line">while((line=reader.readLine())!=null)</span><br><span class="line">&#123;</span><br><span class="line">System.out.print(line+&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">reader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>需要注意的是：<code>reader.readLine()</code>方法返回的一行字符中<code>不包含换行符</code>,所以输出的时候要自己加上换行符。</p><p><code>BufferedReader</code>比<code>FileReader</code>高级的地方在于这个，<code>FileReader</code>能一次读取一个字符，或者一个字符数组。而<code>BufferedReader</code>也可以，同时<code>BufferedReader</code>还能一次读取一行字符串。同时,<code>BufferedReader</code>带缓冲，会比<code>FileReader</code>快很多。</p><p>但是<code>FileReader</code>使用项目的编码来读取解析字符，不能指定编码，可能会出现编码问题，如果要指定编码可以使用包装<code>InputStreamReader</code>的<code>BufferedReader</code>。这样兼顾效率和编码。</p><p>测试上述方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException</span><br><span class="line">&#123;</span><br><span class="line">    String fileutf8=&quot;utf8.txt&quot;;</span><br><span class="line">    String filegbk=&quot;gbk.txt&quot;;</span><br><span class="line">    //一个字符一个字符的读取</span><br><span class="line">    printByFileReader(filegbk);</span><br><span class="line">    System.out.println(&quot;\n---------------------------------------&quot;);</span><br><span class="line">    //一个字符数组一个字符数组的读取</span><br><span class="line">    printByFileReaderChars(filegbk);</span><br><span class="line">    System.out.println(&quot;\n---------------------------------------&quot;);</span><br><span class="line">    //一行一行的读取</span><br><span class="line">    printByFileReaderLine(filegbk);</span><br><span class="line">    System.out.println(&quot;#########################################&quot;);</span><br><span class="line">    //一个字符一个字符的读取</span><br><span class="line">    printByFileReader(fileutf8);</span><br><span class="line">    System.out.println(&quot;\n---------------------------------------&quot;);</span><br><span class="line">    //一个数组一个数组的读取</span><br><span class="line">    printByFileReaderChars(fileutf8);</span><br><span class="line">    System.out.println(&quot;\n---------------------------------------&quot;);</span><br><span class="line">    //一行一行的读取</span><br><span class="line">    printByFileReaderLine(fileutf8);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">gbk file</span><br><span class="line">这里是一句中文</span><br><span class="line">---------------------------------------</span><br><span class="line">gbk file</span><br><span class="line">这里是一句中文</span><br><span class="line">---------------------------------------</span><br><span class="line">gbk file</span><br><span class="line">这里是一句中文</span><br><span class="line">#########################################</span><br><span class="line">utf-8 file</span><br><span class="line">杩欓噷鏄竴鍙ヤ腑鏂?</span><br><span class="line">---------------------------------------</span><br><span class="line">utf-8 file</span><br><span class="line">杩欓噷鏄竴鍙ヤ腑鏂?</span><br><span class="line">---------------------------------------</span><br><span class="line">utf-8 file</span><br><span class="line">杩欓噷鏄竴鍙ヤ腑鏂?</span><br></pre></td></tr></table></figure><p></p><p>可以看到包装<code>FileReader</code>的<code>BufferedReader</code>在读取文件时候如果文件的编码和项目的编码不一样的时候，会出现乱。</p><h2 id="乱码问题"><a href="#乱码问题" class="headerlink" title="乱码问题"></a>乱码问题</h2><p>使用包装<code>InputStreamReader</code>的<code>BufferedReader</code>读取文件<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String file = &quot;utf8.txt&quot;;</span><br><span class="line">BufferedReader reader = new BufferedReader(</span><br><span class="line">new InputStreamReader(new FileInputStream(file), &quot;utf-8&quot;));</span><br><span class="line">char[] cbuf=new char[20];</span><br><span class="line">int size;</span><br><span class="line">while((size=reader.read(cbuf, 0, cbuf.length))!=-1)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(new String(cbuf,0,size));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">utf-8 file</span><br><span class="line">这里是一句中文</span><br></pre></td></tr></table></figure><p></p><p>这里要弄清楚的是BufferedReader只负责读到它的内部缓冲区中，而解码的工作是InputStreamReader完成的。</p><h1 id="BufferedWriter"><a href="#BufferedWriter" class="headerlink" title="BufferedWriter"></a>BufferedWriter</h1><p>BufferedWriter的API：</p><h2 id="继承关系-1"><a href="#继承关系-1" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object</span><br><span class="line">  |----&gt; java.io.Writer</span><br><span class="line">      |----&gt; java.io.BufferedWriter</span><br></pre></td></tr></table></figure><h2 id="构造函数："><a href="#构造函数：" class="headerlink" title="构造函数："></a>构造函数：</h2><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>BufferedWriter(Writer out)</code></td><td style="text-align:left">创建一个缓冲字符输出流,使用默认大小的输出缓冲区</td></tr><tr><td style="text-align:left"><code>BufferedWriter(Writer out, int sz)</code></td><td style="text-align:left">创建一个缓冲字符输出流,使用给定大小的输出缓冲区</td></tr></tbody></table><h2 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h2><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>void write(int c)</code></td><td style="text-align:left">写入单个字符。</td></tr><tr><td style="text-align:left"><code>void write(char[] cbuf, int off, int len)</code></td><td style="text-align:left">写入字符数组的某一部分。</td></tr><tr><td style="text-align:left"><code>void write(String s, int off, int len)</code></td><td style="text-align:left">写入字符串的某一部分。</td></tr><tr><td style="text-align:left"><code>void newLine()</code></td><td style="text-align:left">写入一个行分隔符。</td></tr><tr><td style="text-align:left"><code>void close()</code></td><td style="text-align:left">关闭此流，但要先刷新它。</td></tr><tr><td style="text-align:left"><code>void flush()</code></td><td style="text-align:left">刷新该流的缓冲。</td></tr></tbody></table><h2 id="写文件实例"><a href="#写文件实例" class="headerlink" title="写文件实例"></a>写文件实例</h2><p>使用上述三个写方法写文件：一个字符一个字符的复制文件<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BufferedWriter writer=<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"静夜思.txt"</span>));</span><br><span class="line"><span class="keyword">char</span> ch=<span class="string">'床'</span>;</span><br><span class="line"><span class="comment">//写入一个字符</span></span><br><span class="line">writer.write(ch);</span><br><span class="line">String next=<span class="string">"前明月光,"</span>;</span><br><span class="line"><span class="keyword">char</span>[] nexts=next.toCharArray();</span><br><span class="line"><span class="comment">//写入一个字符数组</span></span><br><span class="line">writer.write(nexts,<span class="number">0</span>,nexts.length);</span><br><span class="line"><span class="comment">//写入换行符</span></span><br><span class="line">writer.newLine();<span class="comment">//写入换行符</span></span><br><span class="line">String nextLine=<span class="string">"疑是地上霜。"</span>;</span><br><span class="line"><span class="comment">//写入一个字符串。</span></span><br><span class="line">writer.write(nextLine);</span><br><span class="line"><span class="comment">//关闭流</span></span><br><span class="line">writer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果,静夜思.txt：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">床前明月光,</span><br><span class="line">疑是地上霜。</span><br></pre></td></tr></table></figure><p></p><h1 id="应用：复制文本文件"><a href="#应用：复制文本文件" class="headerlink" title="应用：复制文本文件"></a>应用：复制文本文件</h1><h2 id="逐个字符复制文件"><a href="#逐个字符复制文件" class="headerlink" title="逐个字符复制文件"></a>逐个字符复制文件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyByChar</span><span class="params">(String srcFile, String destFile)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(srcFile));</span><br><span class="line">BufferedWriter writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(destFile));</span><br><span class="line"><span class="keyword">int</span> ch=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//读取一个字符</span></span><br><span class="line"><span class="keyword">while</span> ((ch = reader.read()) != -<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//写入一个字符</span></span><br><span class="line">writer.write(ch);</span><br><span class="line">&#125;</span><br><span class="line">reader.close();</span><br><span class="line">writer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逐个字符数组复制文件"><a href="#逐个字符数组复制文件" class="headerlink" title="逐个字符数组复制文件"></a>逐个字符数组复制文件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyByCharArray</span><span class="params">(String srcFile, String destFile)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(srcFile));</span><br><span class="line">BufferedWriter writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(destFile));</span><br><span class="line"><span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span>[] cbuf=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line"><span class="comment">//读取一个字符数组</span></span><br><span class="line"><span class="keyword">while</span> ((size = reader.read(cbuf)) != -<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//读入多少写入多少</span></span><br><span class="line">writer.write(cbuf,<span class="number">0</span>,size);</span><br><span class="line">&#125;</span><br><span class="line">reader.close();</span><br><span class="line">writer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="按行复制文件"><a href="#按行复制文件" class="headerlink" title="按行复制文件"></a>按行复制文件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyByLine</span><span class="params">(String srcFile,String destFile)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BufferedReader reader=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(srcFile));</span><br><span class="line">    BufferedWriter writer=<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(destFile));</span><br><span class="line">    String line;</span><br><span class="line">    <span class="comment">//BufferedReader读取一行的时候返回的字符串中不包括换行符</span></span><br><span class="line">    <span class="comment">//如果有一行字符就返回该行字符串，没有就返回null</span></span><br><span class="line">    <span class="keyword">while</span>((line=reader.readLine())!=<span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        writer.write(line);</span><br><span class="line">        writer.newLine();<span class="comment">//写换行符</span></span><br><span class="line">    &#125;</span><br><span class="line">    reader.close();</span><br><span class="line">    writer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是,<code>BufferedReader</code>的<code>readLine()</code>读取一行的时候返回的字符串没有换行符，所以，复制的时候写文件是我们好多写入一个换行符，使用<code>writer.newLine()</code>方法即可。</p><h2 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException</span><br><span class="line">&#123;</span><br><span class="line">String from = &quot;gbk.txt&quot;;</span><br><span class="line">String to = &quot;gbk_copy.txt&quot;;</span><br><span class="line">String to1 = &quot;gbk_copy1.txt&quot;;</span><br><span class="line">String to2 = &quot;gbk_copy2.txt&quot;;</span><br><span class="line">copyByChar(from, to);</span><br><span class="line">copyByCharArray(from, to1);</span><br><span class="line">copyByLine(from, to2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源文件gbk.txt:<br>运行结果：<br>gbk_copy.txt<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gbk file</span><br><span class="line">这里是一句中文</span><br></pre></td></tr></table></figure><p></p><p>gbk_copy1.txt<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gbk file</span><br><span class="line">这里是一句中文</span><br></pre></td></tr></table></figure><p></p><p>gbk_copy2.txt</p><pre><code>gbk file这里是一句中文</code></pre><h2 id="bug-按行复制的时候多写换行符"><a href="#bug-按行复制的时候多写换行符" class="headerlink" title="bug:按行复制的时候多写换行符"></a>bug:按行复制的时候多写换行符</h2><p>细心的朋友可能发现，按行复制的时候，复制的文件会莫名其妙的在文件后面多了一个换行符。这是因为我们每次都在读到的字符串后面写一个换行符。<br>解决办法：在读到的字符串前面写换行符，这样出现新的问题,就是在文件开头多出了一个空行，所以加入控制语句，在第一行不写入换行符，第二行后再写。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyByLine</span><span class="params">(String srcFile,String destFile)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BufferedReader reader=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(srcFile));</span><br><span class="line">    BufferedWriter writer=<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(destFile));</span><br><span class="line">    String line;</span><br><span class="line">    <span class="comment">//BufferedReader读取一行的时候返回的字符串中不包括换行符</span></span><br><span class="line">    <span class="comment">//如果有一行字符就返回该行字符串，没有就返回null</span></span><br><span class="line">    <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span>((line=reader.readLine())!=<span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag)</span><br><span class="line">        &#123;</span><br><span class="line">        flag=<span class="keyword">true</span>;</span><br><span class="line">        writer.write(line);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">        writer.newLine();<span class="comment">//写换行符</span></span><br><span class="line">        writer.write(line);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    reader.close();</span><br><span class="line">    writer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这样复制的文件就不会多谢换行符了，保证复制的文件和源文件是一模一样的。</p><h2 id="bug-乱码问题"><a href="#bug-乱码问题" class="headerlink" title="bug:乱码问题"></a>bug:乱码问题</h2><p>因为我们使用的是包装<code>FileReader</code>的<code>BufferedReader</code>，包装<code>FileWriter</code>的<code>BufferedWriter</code>。所以读字符，写字符的时候使用的是默认的字符编码读写的。所以读写文件的时候会出现乱码，可以使用包装<code>InputStreamReader</code>的<code>BufferedReader</code>,包装<code>OutputStreamWriter</code>的<code>BufferedWriter</code>来复制文件，这样就可以支持各种字符编码。</p><h3 id="实例：gbk编码的文件复制到utf8编码的文件中："><a href="#实例：gbk编码的文件复制到utf8编码的文件中：" class="headerlink" title="实例：gbk编码的文件复制到utf8编码的文件中："></a>实例：gbk编码的文件复制到utf8编码的文件中：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyByLineEncoding</span><span class="params">(String srcFile, String srcEncoding, String destFile,</span></span></span><br><span class="line"><span class="function"><span class="params">String destEncoding)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">BufferedWriter writer = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(</span><br><span class="line"><span class="keyword">new</span> FileInputStream(srcFile), srcEncoding));</span><br><span class="line">writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(</span><br><span class="line"><span class="keyword">new</span> FileOutputStream(destFile), destEncoding));</span><br><span class="line"><span class="keyword">char</span>[] charArray = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">512</span>];</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">while</span> ((size = reader.read(charArray, <span class="number">0</span>, charArray.length)) != -<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">writer.write(charArray, <span class="number">0</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (UnsupportedEncodingException | FileNotFoundException e)</span><br><span class="line">&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (writer != <span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">writer.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (reader != <span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">reader.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main方法：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">String from = <span class="string">"gbk.txt"</span>;</span><br><span class="line">String to = <span class="string">"copyto_utf8.txt"</span>;</span><br><span class="line">copyByLineEncoding(from,<span class="string">"gbk"</span>,to,<span class="string">"utf-8"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>源文件gbk.txt(gbk编码)：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gbk file</span><br><span class="line">这里是一句中文</span><br></pre></td></tr></table></figure><p></p><p>目标文件copyto_utf8.txt：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">utf-8 file</span><br><span class="line">杩欓噷鏄竴鍙ヤ腑鏂�</span><br></pre></td></tr></table></figure><p></p><p>乱码是正常的，因为我们的工程目录用的gbk编码，把copyto_utf8.txt编码显示就好了：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">utf-8 file</span><br><span class="line">这里是一句中文</span><br></pre></td></tr></table></figure><p></p><p>所以使用包装<code>InputStreamReader</code>的<code>BufferedReader</code>,包装<code>OutputStreamWriter</code>的<code>BufferedWriter</code>来复制文件的好处就是可以指定复制文件的时候使用的字符编码，例如上面的复制操作，从gbk编码的文件中读取，然后写入到utf8编码的文件中去。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/3f2a064c/">JavaIO BufferedReader和BufferedWriter</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java IO流 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java IO流 FileReader和FileWriter</title>
      <link href="/blog/f1ceb471/"/>
      <url>/blog/f1ceb471/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><h1 id="FileReader类"><a href="#FileReader类" class="headerlink" title="FileReader类"></a>FileReader类</h1><p>FileReader类能按字符读取流中数据</p><h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object---&gt;Reader---&gt;InputSteamReader---&gt;FileReader</span><br></pre></td></tr></table></figure><h2 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h2><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>FileReader(File file)</code></td><td style="text-align:left">使用<code>File</code>对象创建一个新 <code>FileReader</code>。</td></tr><tr><td style="text-align:left"><code>FileReader(FileDescriptor fd)</code></td><td style="text-align:left">使用<code>FileDescriptor</code>对象创建一个新 <code>FileReader</code>。</td></tr><tr><td style="text-align:left"><code>FileReader(String fileName)</code></td><td style="text-align:left">使用文件名创建一个新 <code>FileReader</code>。</td></tr></tbody></table><h2 id="读操作方法"><a href="#读操作方法" class="headerlink" title="读操作方法"></a>读操作方法</h2><p><code>FileReader</code>操作文件的方法全部都是从它的父类<code>InputStreamReader</code>继承的来的。</p><p>从<code>InputStreamReader</code>类继承的方法：</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>boolean ready()</code></td><td style="text-align:left">判断此流是否已经准备好用于读取。</td></tr><tr><td style="text-align:left"><code>int read()</code></td><td style="text-align:left">读取单个字符。</td></tr><tr><td style="text-align:left"><code>int read(char[] cbuf, int offset, int length)</code></td><td style="text-align:left">将字符读入数组中的某一部分。</td></tr><tr><td style="text-align:left"><code>String getEncoding()</code></td><td style="text-align:left">返回此流使用的字符编码的名称。</td></tr><tr><td style="text-align:left"><code>void close()</code></td><td style="text-align:left">关闭该流并释放与之关联的所有资源。</td></tr></tbody></table><h2 id="FileReader和InputStreamReader的区别"><a href="#FileReader和InputStreamReader的区别" class="headerlink" title="FileReader和InputStreamReader的区别"></a>FileReader和InputStreamReader的区别</h2><p>参考：<a href="https://www.jb51.net/article/76773.htm" target="_blank" rel="noopener">https://www.jb51.net/article/76773.htm</a><br><code>FileReader</code>与它的父类<code>InputStreamReader</code>的主要区别在于<code>构造函数</code>。</p><p><code>InputStreamReader</code>的构造函数：</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>InputStreamReader(InputStream in)</code></td><td style="text-align:left">创建一个使用默认字符集的 InputStreamReader。</td></tr><tr><td style="text-align:left"><code>InputStreamReader(InputStream in, Charset cs)</code></td><td style="text-align:left">创建使用给定字符集的 InputStreamReader。</td></tr><tr><td style="text-align:left"><code>InputStreamReader(InputStream in, CharsetDecoder dec)</code></td><td style="text-align:left">创建使用给定字符集解码器的 InputStreamReader。</td></tr><tr><td style="text-align:left"><code>InputStreamReader(InputStream in, String charsetName)</code></td><td style="text-align:left">创建使用指定字符集的 InputStreamReader。</td></tr></tbody></table><p>从<code>InputStreamReader</code>的构造函数中看到，第一个参数统一为<code>InputStream</code>，第二个参数可以是<code>编码方式</code>或<code>解码器</code>，所以，<strong>当要指定编码方式时，必须使用<code>InputStreamReader</code>类；</strong></p><p>而<code>FileReader</code>构造函数的参数是<code>File</code>,<code>String</code>,<code>FileDescriptor</code>类型的,不是<code>InputStream</code>，在读操作的使用FileReader会使用默认的编码进行读取。所以，<strong>在使用默认编码的情况下，当要根据<code>File</code>对象或者<code>String 文件名</code>来读取一个文件时，用<code>FileReader</code>；</strong></p><h2 id="读文件实例"><a href="#读文件实例" class="headerlink" title="读文件实例"></a>读文件实例</h2><h3 id="逐个字符读取"><a href="#逐个字符读取" class="headerlink" title="逐个字符读取"></a>逐个字符读取</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**   </span><br><span class="line"> * 打印文件中的内容.</span><br><span class="line"> * @param fileName  文件路径</span><br><span class="line"> */  </span><br><span class="line">public static void readByChar(String fileName)</span><br><span class="line">&#123;</span><br><span class="line">FileReader reader=null;</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">reader = new FileReader(fileName);</span><br><span class="line">int ch;</span><br><span class="line">while((ch=reader.read())!=-1)</span><br><span class="line">&#123;</span><br><span class="line">System.out.print((char)ch);</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (FileNotFoundException e)</span><br><span class="line">&#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (IOException e)</span><br><span class="line">&#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line">if(reader!=null)</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">reader.close();</span><br><span class="line">&#125; catch (IOException e)</span><br><span class="line">&#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="按数组读取"><a href="#按数组读取" class="headerlink" title="按数组读取"></a>按数组读取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileName  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readByCharArray</span><span class="params">(String fileName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FileReader reader=<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">reader=<span class="keyword">new</span> FileReader(fileName);</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">char</span>[] cbuf=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">128</span>];</span><br><span class="line"><span class="keyword">while</span>((size=reader.read(cbuf, <span class="number">0</span>, cbuf.length))!=-<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">System.out.print(<span class="keyword">new</span> String(cbuf,<span class="number">0</span>,size));</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(reader!=<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">reader.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="main方法中调用"><a href="#main方法中调用" class="headerlink" title="main方法中调用"></a>main方法中调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">String fileName=<span class="string">"gbk.txt"</span>;</span><br><span class="line">readByChar(fileName);</span><br><span class="line">System.out.println(<span class="string">"\n------------------------------"</span>);</span><br><span class="line">readByCharArray(fileName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试文件：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gbk file</span><br><span class="line">这里是一句中文</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gbk file</span><br><span class="line">这里是一句中文</span><br><span class="line">------------------------------</span><br><span class="line">gbk file</span><br><span class="line">这里是一句中文</span><br></pre></td></tr></table></figure><p></p><h1 id="FileWriter类"><a href="#FileWriter类" class="headerlink" title="FileWriter类"></a>FileWriter类</h1><p><code>FileWriter</code>类可以把字符直接写入流中,<code>FileWriter</code>继承与<code>OutputStreamWriter</code>,它的所有方法也都继承于<code>OutputStreamWriter</code>。</p><h2 id="继承关系-1"><a href="#继承关系-1" class="headerlink" title="继承关系"></a>继承关系</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object</span><br><span class="line">  |----&gt; java.io.Writer</span><br><span class="line">      |----&gt; java.io.OutputStreamWriter</span><br><span class="line">          |----&gt; java.io.FileWriter</span><br></pre></td></tr></table></figure><h2 id="构造方法：-1"><a href="#构造方法：-1" class="headerlink" title="构造方法："></a>构造方法：</h2><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>FileWriter(File file)</code></td><td style="text-align:left">根据给定的 File 对象构造一个 FileWriter 对象。</td></tr><tr><td style="text-align:left"><code>FileWriter(File file, boolean append)</code></td><td style="text-align:left">根据给定的 File 对象构造一个 FileWriter 对象。是否追加写入</td></tr><tr><td style="text-align:left"><code>FileWriter(FileDescriptor fd)</code></td><td style="text-align:left">构造与某个文件描述符相关联的 FileWriter 对象。</td></tr><tr><td style="text-align:left"><code>FileWriter(String fileName)</code></td><td style="text-align:left">根据给定的文件名构造一个 FileWriter 对象。</td></tr><tr><td style="text-align:left"><code>FileWriter(String fileName, boolean append)</code></td><td style="text-align:left">根据给定的文件名以及指示是否追加加写入数据的 boolean 值来构造 FileWriter 对象。</td></tr></tbody></table><h2 id="读操作方法-1"><a href="#读操作方法-1" class="headerlink" title="读操作方法"></a>读操作方法</h2><p>从<code>OutputStreamWriter</code>继承的方法：</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>void write(int c)</code></td><td style="text-align:left">写入单个字符。</td></tr><tr><td style="text-align:left"><code>void write(char[] cbuf, int off, int len)</code></td><td style="text-align:left">写入字符数组的某一部分。</td></tr><tr><td style="text-align:left"><code>void write(String str, int off, int len)</code></td><td style="text-align:left">写入字符串的某一部分。</td></tr><tr><td style="text-align:left"><code>String getEncoding()</code></td><td style="text-align:left">返回此流使用的字符编码的名称。</td></tr><tr><td style="text-align:left"><code>void flush()</code></td><td style="text-align:left">刷新该流的缓冲。</td></tr><tr><td style="text-align:left"><code>void close()</code></td><td style="text-align:left">关闭此流，但要先刷新它。</td></tr></tbody></table><h2 id="FileWriter类和OutputStreamWriter类的区别"><a href="#FileWriter类和OutputStreamWriter类的区别" class="headerlink" title="FileWriter类和OutputStreamWriter类的区别"></a>FileWriter类和OutputStreamWriter类的区别</h2><p>还是和上面的一样，区别主要在构造方法上。<br>OutputStream类的构造方法：</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>OutputStreamWriter(OutputStream out)</code></td><td style="text-align:left">创建使用默认字符编码的 OutputStreamWriter。</td></tr><tr><td style="text-align:left"><code>OutputStreamWriter(OutputStream out, Charset cs)</code></td><td style="text-align:left">创建使用给定字符集的 OutputStreamWriter。</td></tr><tr><td style="text-align:left"><code>OutputStreamWriter(OutputStream out, CharsetEncoder enc)</code></td><td style="text-align:left">创建使用给定字符集编码器的 OutputStreamWriter。</td></tr><tr><td style="text-align:left"><code>OutputStreamWriter(OutputStream out, String charsetName)</code></td><td style="text-align:left">创建使用指定字符集的 OutputStreamWriter。</td></tr></tbody></table><p>从OutputStreamWriter的构造方法中可看出，第一个参数为OutputStream，第二个参数可以是字符编码或者编码器。所以<strong>写操作时<code>需要指定字符编码</code>的时候必须使用<code>OutputStreamWriter</code></strong></p><p>而 <code>FileWriter</code>的构造方法中第一个参数为<code>File</code>,<code>String</code>,<code>FileDescriptor</code>对象，第二个参数表示可以是否追加写入。FileWriter会使用默认的编码来进行写操作。所以<strong>使用<code>File</code>类或<code>String</code>文件名来进行写操作是使用<code>FileWriter</code>,<code>要求追加写入文件时</code>也要使用<code>FileWriter</code>。</strong></p><h1 id="读写实例-复制文件"><a href="#读写实例-复制文件" class="headerlink" title="读写实例:复制文件"></a>读写实例:复制文件</h1><h2 id="使用FileReader和FileWriter复制文件"><a href="#使用FileReader和FileWriter复制文件" class="headerlink" title="使用FileReader和FileWriter复制文件"></a>使用FileReader和FileWriter复制文件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**   </span></span><br><span class="line"><span class="comment"> * 从名字为from的源文件复制到名字为to的目的文件中。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> from 源文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> to  目的文件</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyByFileReader_Writer</span><span class="params">(String from, String to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FileReader reader = <span class="keyword">null</span>;</span><br><span class="line">FileWriter writer = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">reader = <span class="keyword">new</span> FileReader(from);</span><br><span class="line">writer = <span class="keyword">new</span> FileWriter(to);</span><br><span class="line"><span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">128</span>];</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((size = reader.read(cbuf, <span class="number">0</span>, cbuf.length)) != -<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">writer.write(cbuf, <span class="number">0</span>, size);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (reader != <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">reader.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (writer != <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">writer.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main方法中调用：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">String from = <span class="string">"gbk.txt"</span>;</span><br><span class="line">String to = <span class="string">"gbk_copy.txt"</span>;</span><br><span class="line">copyByFileReader_Writer(from, to);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>源文件<code>gbk.txt</code>:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gbk file</span><br><span class="line">这里是一句中文</span><br></pre></td></tr></table></figure><p></p><p>复制要的目的文件<code>gbk_copy.txt</code>：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gbk file</span><br><span class="line">这里是一句中文</span><br></pre></td></tr></table></figure><p></p><h2 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h2><p>使用FileReader和FileWriter使用默认的编码来读文件，写文件。这样容易出现问题。现在项目的编码是gbk的，但是此时用来复制utf-8编码的文件就会出现问题。<br>源文件utf8.txt(utf-8编码)：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">utf-8 file</span><br><span class="line">这里是一句中文</span><br></pre></td></tr></table></figure><p></p><p>main方法：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">String from = <span class="string">"utf8.txt"</span>;</span><br><span class="line">String to = <span class="string">"utf8_copy.txt"</span>;</span><br><span class="line">copyByFileReader_Writer(from, to);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果，复制好的<code>utf8_copy.txt</code>中的内容:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">utf-8 file</span><br><span class="line">杩欓噷鏄竴鍙ヤ腑鏂�</span><br></pre></td></tr></table></figure><p></p><p>出现这样的乱码是因为，我们现在是以默认的编码(gbk)打开的，现在改成以utf-8编码打开看看：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">utf-8 file</span><br><span class="line">这里是一句中�?</span><br></pre></td></tr></table></figure><p></p><p>可以看到虽然已经以<code>utf-8</code>编码打开了，但是还是显示乱码。</p><p><strong>所以遇到需要处理字符编码的时候要使用<code>InputStreamReader</code>和<code>OutputStreamWriter</code>来操作。</strong></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/f1ceb471/">Java IO流 FileReader和FileWriter</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java IO流 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>PrintWriter类--向文本输出流打印格式化表示形式</title>
      <link href="/blog/c2200ab8/"/>
      <url>/blog/c2200ab8/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>PrintWriter类–向文本输出流打印格式化表示形式</p><p>PintWriter是一种过滤流，也叫处理流。使用PrintWriter能方便的打印各种数据的表示形式。</p><p>PrintWriter有一系列的print方法和println方法，可以写入基本类型（转换为字符串）、字符串和对象（使用toString方法）。这些打印方法可以保证数值的表现形式不变。写的是什么样子，目的地就是什么样子。同时PrintWriter有缓冲区功能，需要及时关闭或者flush().<br>PrintWriter和BufferedWriter的区别</p><p>PrintWriter相对于BufferedWriter的好处在于，如果PrintWriter开启了自动刷新，那么当PrintWriter调用println，prinlf或format方法时，输出流中的数据就会自动刷新出去。PrintWriter不但能接收字符流，也能接收字节流。</p><p>PrintWriter的print、println方法可以接受任意类型的参数，而BufferedWriter的write方法只能接受字符、字符数组和字符串；</p><p>PrintWriter的println方法自动添加换行，BufferedWriter需要显示调用newLine方法；</p><p>PrintWriter的方法不会抛异常，若关心异常，需要调用checkError方法看是否有异常发生；</p><p>PrintWriter构造方法可指定参数，实现自动刷新缓存（autoflush）；</p><p>PrintWriter的构造方法更广。</p><p>PrintWriter和BufferedWriter都是继承java.io.Writer，所以很多功能都一样。不过PrintWriter提供println()方法可以写不同平台的换行符，而BufferedWriter可以任意设定缓冲大小。不过PrintWriter的底层还是由BufferedWriter、BufferedStreamWriter实现的。</p><p>注意：</p><p>(1)PrintWriter只有输出写入功能，而没有读取功能</p><p>顺带比较一下<br>PrintStream和PrintWriter的区别<br>首先PrintWriter 是字符输出，PrintStream 是字符输出</p><p>PrintStream和PrintWriter的API几乎相同，都能输出各种形式的数据，构造方法也几乎相同</p><p>区别：</p><p>1.PrintStream能做的PrintWriter也都能实现，并且PrintWriter的功能更为强大。但是由于PrintWriter出现的比较晚，较早的System.out使用的是PrintStream来实现的，所以为了兼容就没有废弃PrintStream。</p><p>2.两个个类最大的差别是，PrintStream在输出字符，将字符转换为字节时采用的是系统默认的编码格式，这样当数据传输另一个平台，而另一个平台使用另外一个编码格式解码时就会出现问题，存在不可控因素。而PrintWriter可以在传入Writer时可由程序员指定字符转换为字节时的编码格式，这样兼容性和可控性会更好。</p><p>1.构造函数：</p><pre><code>PrintWriter(File file)           创建PrintWriter，不自动行刷新 PrintWriter(File file, String csn)           创建PrintWriter，使用指定文件file和字符集csn，不自动刷行PrintWriter(OutputStream out)          以OutputStream创建PrintWriter，不自动行刷新 。 PrintWriter(OutputStream out, boolean autoFlush)           以OutputStream 创建新的 PrintWriter。autoFlush为true的话自动刷新PrintWriter(String fileName)           以指定文件名称创建 PrintWriter。不自动行刷新PrintWriter(String fileName, String csn)           以指定文件名称和字符集创建且不带PrintWriter，不自动刷新PrintWriter(Writer out)           创建PrintWriter,不自动行刷新PrintWriter(Writer out, boolean autoFlush)           创建新 PrintWriter 如果autoFlush为true则自动刷新</code></pre><p>2.格式化打印方法：</p><p>1.print()方法：打印基本数据类型(byte类型没有)，打印对象，打印字符串</p><pre><code>void print(int i) 打印整数。void print(long l) 打印 long 整数void print(float f) 打印一个浮点数。void print(double d) 打印 double 精度浮点数。  void print(char c) 打印字符。 void print(char[] s) 打印字符数组。 void print(boolean b) 打印 boolean 值。  void print(Object obj) 打印对象。 void print(String s) 打印字符串</code></pre><p>2.printf()方法</p><pre><code>PrintWriter printf(Locale l, String format, Object... args)          使用指定格式字符串和参数将格式化的字符串写入此 writer 的便捷方法。 PrintWriter printf(String format, Object... args)          使用指定格式字符串和参数将格式化的字符串写入此 writer 的便捷</code></pre><p>3.println()方法</p><pre><code>void println() 通过写入行分隔符字符串终止当前行。void println(int x) 打印整数，然后终止该行。 void println(long x) 打印 long 整数，然后终止该行。void println(char x) 打印字符，然后终止该行。 void println(char[] x) 打印字符数组，然后终止该行。 void println(float x) 打印浮点数，然后终止该行。void println(double x)  打印双精度浮点数，然后终止该行。 void println(boolean x) 打印 boolean 值，然后终止该行。 void println(Object x) 打印 Object，然后终止该行。 void println(String x) 打印 String，然后终止该行。 </code></pre><p>4.write方法</p><pre><code>void write(char[] buf) 写入字符数组。 void write(char[] buf, int off, int len) 写入字符数组的某一部分。 void write(int c) 写入单个字符。 void write(String s) 写入字符串。 void write(String s, int off, int len) 写入字符串的某一部分。 </code></pre><p>5.format()方法</p><pre><code>PrintWriter format(Locale l, String format, Object... args)           使用指定格式字符串和参数将一个格式化字符串写入此 writer 中。  PrintWriter format(String format, Object... args)           使用指定格式字符串和参数将一个格式化字符串写入此 writer 中。 </code></pre><p>6.append()方法</p><pre><code>PrintWriter append(char c)           将指定字符添加到此 writer。  PrintWriter append(CharSequence csq)           将指定的字符序列添加到此 writer。  PrintWriter append(CharSequence csq, int start, int end)           将指定字符序列的子序列添加到此 writer </code></pre><ol start="7"><li><p>错误方法</p><p>boolean checkError()</p><pre><code>如果流没有关闭，则刷新流且检查其错误状态。 </code></pre><p>protected void clearError()</p><pre><code>清除此流的错误状态。 </code></pre><p>protected void setError()</p><pre><code>指示已发生错误。</code></pre></li></ol><p>8.关闭刷新方法</p><pre><code>void close()          关闭该流并释放与之关联的所有系统资源。 void flush()          刷新该流的缓冲。 </code></pre><p>这里有好多个写方法，来比较一下区别：</p><p>PrintWriter中write与println方法的区别</p><p>共同点：两者都不刷新页面，只在原来的页面写数据.最终都是重写了抽象类Writer里面的write方法.</p><p>print方法可以将各种类型的数据转换成字符串的形式输出。重载的write方法只能输出字符、字符数组、字符串等与字符相关的数据。</p><p>write()方法不会写入换行符，如果用write()在一端写入了信息，在另一端如果用readLine()方法。由于读不到换行符，意味中读不到结束标记，然后由于IO流是阻塞式的，所以程序就是一直卡在那里不动了。原因即为缺少回车标识。如果在写入的时候加上“\r\n”,就可以解决这个问题了。而println()就自动加上了换行符了。</p><p>OutputStreamWriter、PrintWriter和BufferedWriter区别</p><p>PrintWriter无追加模式，若写入已有文件，将清空原文件，重新写入；其println自动换行；<br>OutputStreamWriter与BufferedWriter有追加模式，append设置为true时，在已有文件末尾追加；append=false时，从已有文件第一行开始覆盖写入，若写入内容比原有文件短，则只覆盖部分内容；<br>BufferedWriter需手动换行，bw.newLine();<br>OutputStreamWriter和BufferedWriter的缺省buffersize,OutputStreamWriter是8k bytes，BufferedWriter是8k chars。</p><p>OutputStreamWriter，PrintWriter能控制编码，BufferedWriter不能。</p><p>BufferedWriter封装的是writer，也就是当buffer满了让别的writer去处理输出。而OutputStreamWriter封装的事数据流(OutputStream)，它是让数据流去处理输出。stream和writer的不同不用说，一个是二进制数据，一个是字符数据，这两个根本就不一样了。</p><p>实例：使用BufferReader和PrintWriter复制文本文件</p><pre><code>public static void copy(String srcPath,String destPath) throws IOException{    BufferedReader reader=new BufferedReader(            new FileReader(srcPath)            );    //不带自动刷新的字符打印流    PrintWriter writer=new PrintWriter(destPath);    String line;    while((line=reader.readLine())!=null)    {        writer.println(line);        writer.flush();//手动刷新    }    reader.close();    writer.close();}</code></pre><p>测试：</p><pre><code>public static void main(String[] args) throws IOException{    String packagePath=FilePath.getSrcPackagePath(TestPrintWriter.class);    String srcFile=packagePath+&quot;fileGbk.txt&quot;;    String destFile=packagePath+&quot;副本.txt&quot;;    copy(srcFile,destFile);}</code></pre><p>fileGbk.txt:</p><pre><code>静夜思作者：李白床前明月光，疑是地上霜。举头望明月，低头思故乡。</code></pre><p>运行后：副本.txt</p><pre><code>静夜思作者：李白床前明月光，疑是地上霜。举头望明月，低头思故乡。</code></pre><p>使用PrintWriter来写文本文件十分的简介方便。平时使用时可考虑BufferReader和PrintWriter搭配使用。</p><p>参考：</p><p>PrintWriter中write与println方法的区别</p><p>PrintWriter和BufferedWriter的使用区别</p><p>OutputStreamWriter、PrintWriter和BufferedWriter区别</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/c2200ab8/">PrintWriter类–向文本输出流打印格式化表示形式</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java IO流 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>格式化html代码</title>
      <link href="/blog/fc82c7ea/"/>
      <url>/blog/fc82c7ea/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>最近在看看html相关的代码，也会从网上复制一些。但是复制过来的代码没有格式化阅读起来不方便，所以我写了点代码来格式化html代码。当然这个其实就是个自娱自乐的工具，粘贴到IDE中，使用IDE来格式化可能更方便，但，可能我想自己找麻烦吧，自己来写写看。</p><h2 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h2><h3 id="处理的文本"><a href="#处理的文本" class="headerlink" title="处理的文本"></a>处理的文本</h3><p>把下面的代码格式化<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;/jquery/jquery.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">$(document).ready(function()&#123;</span><br><span class="line">  $(&quot;button&quot;).click(function()&#123;</span><br><span class="line">  $(this).hide();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button type=&quot;button&quot;&gt;Click me&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p></p><h3 id="处理后的效果"><a href="#处理后的效果" class="headerlink" title="处理后的效果"></a>处理后的效果</h3><p>格式化后的效果为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;script type=&quot;text/javascript&quot; src=&quot;/jquery/jquery.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">        &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">            $(document).ready(function()&#123;</span><br><span class="line">              $(&quot;button&quot;).click(function()&#123;</span><br><span class="line">              $(this).hide();</span><br><span class="line">            &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;button type=&quot;button&quot;&gt;Click me&lt;/button&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p></p><a id="more"></a><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>先来实现一个最简单的情况，把处理文本处理成下面的形式。在<code>&lt;html&gt;</code>和<code>&lt;/html&gt;</code>标签之间加上缩进。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;/jquery/jquery.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    $(document).ready(function()&#123;</span><br><span class="line">    $(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $(this).hide();</span><br><span class="line">    &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;body&gt;</span><br><span class="line">    &lt;button type=&quot;button&quot;&gt;Click me&lt;/button&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p></p><p>思路：</p><ul><li>使用一个StringBuider存储缩进，缩进设置为四个空格。</li><li>一行一行的读取代码，然后使用正则表达式匹配该行代码</li><li>当匹配到<code>&lt;html&gt;</code>这一行的时候，原样输出该行<code>&lt;html&gt;</code>，然后在StringBuider中加入一个缩进。</li><li>当匹配不到<code>&lt;html&gt;</code>这行的时候，先在前面输出StringBuilder中的内容，也就是输出缩进，然后在输出该行代码本省。</li><li>当匹配到<code>&lt;/html&gt;</code>这行是，删除存放在StringBuilder中的缩进，然后输出StringBuider中的内容，然后输出该行代码。</li></ul><p>中间的代码比开始标签前面多了一个缩进，而结束标签要与开始标签对齐，也就是说结束标签要比中间的代码少一个缩颈。</p><p>关键代码如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//匹配到标签开始</span><br><span class="line">if (匹配到开始标签)</span><br><span class="line">&#123;</span><br><span class="line">//原样输出</span><br><span class="line">System.out.print(builder.toString());</span><br><span class="line">System.out.println(line);</span><br><span class="line">//让后面的代码加一个缩进</span><br><span class="line">builder.append(TAB);</span><br><span class="line">&#125; else if (匹配到结束标签)</span><br><span class="line">&#123;</span><br><span class="line">// 删除缩进，这样就和开始标签对齐，而中间的其他代码多了一个缩进</span><br><span class="line">builder.delete(0, 4);</span><br><span class="line">//输出缩进和该行代码</span><br><span class="line">System.out.print(builder.toString());</span><br><span class="line">System.out.println(line);</span><br><span class="line">&#125; else</span><br><span class="line">&#123;</span><br><span class="line">//中间代码</span><br><span class="line">System.out.print(builder.toString());</span><br><span class="line">System.out.println(line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>同理，<code>&lt;head&gt;</code>和<code>&lt;/head&gt;</code>之间，<code>&lt;body&gt;</code>和<code>&lt;/body&gt;</code>之间，<code>&lt;script type=&quot;text/javascript&quot;&gt;</code>和<code>&lt;script&gt;</code>之间也要有缩进。</p><h2 id="完整的代码："><a href="#完整的代码：" class="headerlink" title="完整的代码："></a>完整的代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> regex.tools;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="keyword">import</span> clipboard.util.SysClipboardUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReplaceJquerySrc</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">String code = SysClipboardUtil.getSysClipboardText();</span><br><span class="line">            </span><br><span class="line"><span class="keyword">final</span> String TAB = <span class="string">"    "</span>;</span><br><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">String addTab = <span class="string">"(?:&lt;html&gt;|&lt;head&gt;|&lt;body&gt;|&lt;script[^&gt;]*&gt;)"</span>;</span><br><span class="line">Pattern addTabPattern = Pattern.compile(addTab);</span><br><span class="line">Matcher matcherAdd;</span><br><span class="line"></span><br><span class="line">String MinusTab = <span class="string">"(?:&lt;/html&gt;|&lt;/head&gt;|&lt;/body&gt;|&lt;/script&gt;)"</span>;</span><br><span class="line">Pattern MinusTabPattern = Pattern.compile(MinusTab);</span><br><span class="line">Matcher matcherMinusTab;</span><br><span class="line"></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(code);</span><br><span class="line">String line = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> (scanner.hasNextLine())</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">line = scanner.nextLine();</span><br><span class="line">matcherAdd = addTabPattern.matcher(line);</span><br><span class="line">matcherMinusTab = MinusTabPattern.matcher(line);</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配到标签开始</span></span><br><span class="line"><span class="keyword">if</span> (matcherAdd.matches())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//原样输出</span></span><br><span class="line">System.out.print(builder.toString());</span><br><span class="line">System.out.println(line);</span><br><span class="line"><span class="comment">//让后面的代码加一个缩进</span></span><br><span class="line">builder.append(TAB);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (matcherMinusTab.matches())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//匹配到结束标签</span></span><br><span class="line"><span class="comment">// 删除缩进，对其前面的开头标签</span></span><br><span class="line">builder.delete(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">System.out.print(builder.toString());</span><br><span class="line">System.out.println(line);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//其他代码</span></span><br><span class="line">System.out.print(builder.toString());</span><br><span class="line">System.out.println(line);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制处理的文本，然后运行上面的程序，控制台输出如下。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;script type=&quot;text/javascript&quot; src=&quot;/jquery/jquery.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">        &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">            $(document).ready(function()&#123;</span><br><span class="line">              $(&quot;button&quot;).click(function()&#123;</span><br><span class="line">              $(this).hide();</span><br><span class="line">            &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;button type=&quot;button&quot;&gt;Click me&lt;/button&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p></p><p>好的这就格式化挺不错的，后续如果还想对其他的代码块之间进行格式化，只要两个在正则表达式中多加上一个分支就行了。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String addTab = &quot;(?:&lt;html&gt;|&lt;head&gt;|&lt;body&gt;|&lt;script[^&gt;]*&gt;)&quot;;</span><br><span class="line">String MinusTab = &quot;(?:&lt;/html&gt;|&lt;/head&gt;|&lt;/body&gt;|&lt;/script&gt;)&quot;;</span><br></pre></td></tr></table></figure><p></p><p><code>&lt;script[^&gt;]*&gt;</code>这个正则表达式是为了匹配<code>&lt;script type=&quot;text/javascript&quot;&gt;</code>而不匹配<code>&lt;script type=&quot;text/javascript&quot; src=&quot;/jquery/jquery.js&quot;&gt;&lt;/script&gt;</code>，因为这句话中间就没有其他代码，不需要设置缩进。如果使用<code>&lt;script.*&gt;</code>这个正则表达式就会匹配到这种特殊的<code>&lt;script....&gt;</code>和<code>&lt;/script&gt;</code>在同一行的情况。</p><h2 id="需求2-替换jquery库的路径"><a href="#需求2-替换jquery库的路径" class="headerlink" title="需求2:替换jquery库的路径"></a>需求2:替换jquery库的路径</h2><p>因为从其他网站上复制的代码，<code>jquery</code>路径(或者其他库的路径)和我们本机的路径肯定不一样，而且版本也可能不一样。<code>jquery</code>我已经下载好了，放在当前目录下。<br>所以要求在格式化的时候把 <code>src=&quot;/jquery/jquery.js&quot;</code>，替换成我们自己的路径： <code>src=&quot;jquery-3.3.1.js</code>。</p><h3 id="处理文本："><a href="#处理文本：" class="headerlink" title="处理文本："></a>处理文本：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;/jquery/jquery.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="要求处理后为："><a href="#要求处理后为：" class="headerlink" title="要求处理后为："></a>要求处理后为：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-3.3.1.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>使用替换就行了：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code = code.replaceAll(&quot;src=\&quot;/.*jquery.js*\&quot;&quot;,&quot;src=\&quot;jquery-3.3.1.js\&quot;&quot;);</span><br></pre></td></tr></table></figure><p></p><h2 id="完整代码："><a href="#完整代码：" class="headerlink" title="完整代码："></a>完整代码：</h2><p>完整的代码如下<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">package regex.tools;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line">import java.util.regex.Matcher;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line">import clipboard.util.SysClipboardUtil;</span><br><span class="line"></span><br><span class="line">public class ReplaceJquerySrc</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">String code = SysClipboardUtil.getSysClipboardText();</span><br><span class="line">// src=&quot;/jquery/jquery.js&quot;</span><br><span class="line">code = code.replaceAll(&quot;src=\&quot;/.*jquery.js*\&quot;&quot;,</span><br><span class="line">&quot;src=\&quot;jquery-3.3.1.js\&quot;&quot;);</span><br><span class="line"></span><br><span class="line">final String TAB = &quot;    &quot;;</span><br><span class="line">StringBuilder builder = new StringBuilder();</span><br><span class="line"></span><br><span class="line">String addTab = &quot;(?:&lt;html&gt;|&lt;head&gt;|&lt;body&gt;|&lt;script[^&gt;]*&gt;)&quot;;</span><br><span class="line">Pattern addTabPattern = Pattern.compile(addTab);</span><br><span class="line">Matcher matcherAdd;</span><br><span class="line"></span><br><span class="line">String MinusTab = &quot;(?:&lt;/html&gt;|&lt;/head&gt;|&lt;/body&gt;|&lt;/script&gt;)&quot;;</span><br><span class="line">Pattern MinusTabPattern = Pattern.compile(MinusTab);</span><br><span class="line">Matcher matcherMinusTab;</span><br><span class="line"></span><br><span class="line">Scanner scanner = new Scanner(code);</span><br><span class="line">String line = null;</span><br><span class="line">while (scanner.hasNextLine())</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">line = scanner.nextLine();</span><br><span class="line">matcherAdd = addTabPattern.matcher(line);</span><br><span class="line">matcherMinusTab = MinusTabPattern.matcher(line);</span><br><span class="line"></span><br><span class="line">// 匹配到标签开始</span><br><span class="line">if (matcherAdd.matches())</span><br><span class="line">&#123;</span><br><span class="line">// 原样输出</span><br><span class="line">System.out.print(builder.toString());</span><br><span class="line">System.out.println(line);</span><br><span class="line">// 让后面的代码加一个缩进</span><br><span class="line">builder.append(TAB);</span><br><span class="line">&#125; else if (matcherMinusTab.matches())</span><br><span class="line">&#123;</span><br><span class="line">// 匹配到结束标签</span><br><span class="line">// 删除缩进，对其前面的开头标签</span><br><span class="line">builder.delete(0, 4);</span><br><span class="line">System.out.print(builder.toString());</span><br><span class="line">System.out.println(line);</span><br><span class="line">&#125; else</span><br><span class="line">&#123;</span><br><span class="line">// 其他代码</span><br><span class="line">System.out.print(builder.toString());</span><br><span class="line">System.out.println(line);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// System.out.println(code);</span><br><span class="line">// SysClipboardUtil.setSysClipboardText(code);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;script type=&quot;text/javascript&quot; src=&quot;jquery-3.3.1.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">        &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">            $(document).ready(function()&#123;</span><br><span class="line">              $(&quot;button&quot;).click(function()&#123;</span><br><span class="line">              $(this).hide();</span><br><span class="line">            &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;button type=&quot;button&quot;&gt;Click me&lt;/button&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p></p><p>把运行结果保存在当前路径(放jquery的路径)下，然用浏览器打开就可看到运行效果了。<br><img src="https://i.imgur.com/EjnpTfH.png" alt=""><br>然后点击按钮：<br><img src="https://i.imgur.com/Fje1KTj.png" alt=""><br>可看到，按钮消失了，这说明我们替换后的jquery路径时没有问题的。而代码格式化是给人看的。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/fc82c7ea/">格式化html代码</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 我的软件 </category>
          
          <category> 使用正则表达式的工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Jquery简介</title>
      <link href="/blog/f58374be/"/>
      <url>/blog/f58374be/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p><code>jQuery</code> 语法是为 <code>HTML</code> 元素的选取编制的，可以对元素执行某些操作。</p><p>基础语法是：<code>$(selector).action()</code></p><ul><li>美元符号定义 <code>jQuery</code></li><li>选择符（<code>selector</code>）“查询”和“查找” <code>HTML</code> 元素</li><li><code>jQuery</code> 的 <code>action()</code> 执行对元素的操作</li><li><h2 id="jQuery-语法实例"><a href="#jQuery-语法实例" class="headerlink" title="jQuery 语法实例"></a>jQuery 语法实例</h2></li></ul><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>$(this).hide()</code></td><td style="text-align:left">隐藏当前的 <code>HTML</code> 元素。</td></tr><tr><td style="text-align:left"><code>$(&quot;#test&quot;).hide()</code></td><td style="text-align:left">隐藏 <code>id=&quot;test&quot;</code>的元素。</td></tr><tr><td style="text-align:left"><code>$(&quot;p&quot;).hide()</code></td><td style="text-align:left">隐藏所有 <code>&lt;p&gt;</code> 元素。</td></tr><tr><td style="text-align:left"><code>$(&quot;.test&quot;).hide()</code></td><td style="text-align:left">隐藏所有 <code>class=&quot;test&quot;</code> 的元素。</td></tr></tbody></table><p>本文链接: <a href="https://www.lansheng.net.cn/blog/f58374be/">Jquery简介</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> Java Web从入门到精通 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JavaIO InputStreamReader和OutputStreamWriter</title>
      <link href="/blog/a5e554af/"/>
      <url>/blog/a5e554af/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p><code>InputStreamReader</code>将一个<code>InputStream</code>转换成<code>Reader</code>；<code>OutputStreamWriter</code>将一个<code>OutputStream</code>转换成<code>Writer</code>。</p><p><code>InputStreamReader</code>(<code>Reader</code> 的子类）和 <code>OutputStreamWriter</code>(<code>Writer</code> 的子类）是用于处理字符流的最基本的类，用来在字节流和字符流之间的中介。</p><p><code>InputStream</code> 此抽象类是表示字节输入流的所有类的超类</p><p><code>InputStreamReader</code>能将字节流转换为字符流,是字节流通向字符流的桥梁：它读取字节并将其解码为使用指定的字符集的字符。</p><p><code>InputStreamReader</code>封裝了<code>InputStream</code>在里头, 它能以较高级的方式,一次读取一个字符</p><h2 id="InputSteamReader-的方法："><a href="#InputSteamReader-的方法：" class="headerlink" title="InputSteamReader 的方法："></a>InputSteamReader 的方法：</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>InputStreamReader(InputStream in)</code></td><td style="text-align:left">创建一个使用默认字符集的 InputStreamReader。</td></tr><tr><td style="text-align:left"><code>InputStreamReader(InputStream in, Charset cs)</code></td><td style="text-align:left">创建使用给定字符集的 InputStreamReader。</td></tr><tr><td style="text-align:left"><code>InputStreamReader(InputStream in, CharsetDecoder dec)</code></td><td style="text-align:left">创建使用给定字符集解码器的 InputStreamReader。</td></tr><tr><td style="text-align:left"><code>InputStreamReader(InputStream in, String charsetName)</code></td><td style="text-align:left">创建使用指定字符集的 InputStreamReader。</td></tr></tbody></table><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>int read()</code></td><td style="text-align:left">读取单个字符。</td></tr><tr><td style="text-align:left"><code>int read(char[] cbuf, int offset, int length)</code></td><td style="text-align:left">将字符读入字符数组中的某一部分。</td></tr><tr><td style="text-align:left"><code>boolean ready()</code></td><td style="text-align:left">判断此流是否已经准备好用于读取。</td></tr><tr><td style="text-align:left"><code>String getEncoding()</code></td><td style="text-align:left">返回此流使用的字符编码的名称。</td></tr><tr><td style="text-align:left"><code>void close()</code></td><td style="text-align:left">关闭该流并释放与之关联的所有资源。</td></tr></tbody></table><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="使用read-方法读取文件"><a href="#使用read-方法读取文件" class="headerlink" title="使用read()方法读取文件"></a>使用read()方法读取文件</h3><p>这个方法每次读取一个字符,并返回读取到的字符(int表示)，如果读取完毕就返回-1.因为返回的是int类型，我们打印字符的时候，要强制类型转换为char类型。</p><h4 id="实例：按字符读取文件"><a href="#实例：按字符读取文件" class="headerlink" title="实例：按字符读取文件"></a>实例：按字符读取文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InputStreamReader inReader = <span class="keyword">new</span> InputStreamReader(</span><br><span class="line">    <span class="keyword">new</span> FileInputStream(<span class="string">"utf8.txt"</span>), <span class="string">"utf-8"</span>);</span><br><span class="line">    <span class="comment">//先判断能不能读取</span></span><br><span class="line">    <span class="keyword">if</span> (!inReader.ready())</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"无法读取此文件！"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> read = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((read = inReader.read()) != -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print((<span class="keyword">char</span>) read);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试文件<code>utf8.txt</code>:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">utf-8 file</span><br><span class="line">这里是一句中文</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">utf-8 file</span><br><span class="line">这里是一句中文</span><br></pre></td></tr></table></figure><p></p><p>这里以字节的方式从源文件<code>utf8.txt</code>中读取一个个字节。<code>InputStreamReader</code>的<code>read()</code>方法根据给定的编码将这些读取到的字节解码成一个个的字符返回,不过因为是<code>int</code>类型表示的字符，在打印的时候我们需要强制类型转换外<code>char</code>类型</p><h3 id="读字符数组方法"><a href="#读字符数组方法" class="headerlink" title="读字符数组方法"></a>读字符数组方法</h3><p><code>int read(char[] cbuf, int offset, int length)</code>这个方法可以把一批字符读取到字符数组中，每次读<code>length</code>个字符放到数组<code>cbuf</code>中，放的时候从字符数组的<code>offset</code>下标开始放。返回读取到的字节数，如果读取完毕后就返回<code>-1</code>表示读取结束。</p><h4 id="实例：按字符数组读取文件"><a href="#实例：按字符数组读取文件" class="headerlink" title="实例：按字符数组读取文件"></a>实例：按字符数组读取文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader inReader = <span class="keyword">new</span> InputStreamReader(</span><br><span class="line"><span class="keyword">new</span> FileInputStream(<span class="string">"utf8.txt"</span>), <span class="string">"utf-8"</span>);</span><br><span class="line"><span class="comment">//先判断能不能读取</span></span><br><span class="line"><span class="keyword">if</span> (!inReader.ready())</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"无法读取此文件！"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// 每次读取一个数组</span></span><br><span class="line"><span class="keyword">while</span> ((size = inReader.read(cbuf, <span class="number">0</span>, cbuf.length)) != -<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line">System.out.print(<span class="keyword">new</span> String(cbuf));</span><br><span class="line"><span class="comment">// 注意读到多少个字符就转换多少个字符,不要转换整个字符</span></span><br><span class="line"><span class="comment">// System.out.print(new String(cbuf, 0, size));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要注意写法，因为有的时候并不能读慢整个字符数组cbuf，所以我们输出的时候，读取到多少个字符就输出多少个，<code>System.out.print(new String(cbuf, 0, size));</code>，而不是输出整个数组 <code>System.out.print(new String(cbuf));</code><br><strong>测试文件utf8.txt：</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">utf-8 file</span><br><span class="line">这里是一句中文</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">utf-8 file</span><br><span class="line">这里是一句中文</span><br></pre></td></tr></table></figure><p></p><p>如果使用的是<code>System.out.print(new String(cbuf));</code>进行输出，结果如下。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">utf-8 file</span><br><span class="line">这里是一句中文e</span><br></pre></td></tr></table></figure><p></p><p>可以看到平白无故多输出了一个字符<code>e</code>，还是一句话，<strong>读到多少输出多少。</strong></p><h1 id="OutputStreamWriter-类"><a href="#OutputStreamWriter-类" class="headerlink" title="OutputStreamWriter 类"></a>OutputStreamWriter 类</h1><p><code>OutputStreamWriter</code>能将字符流转换为字节流,是字符流通向字节流的桥梁。</p><p>它使用的字符集可以指定，否则将使用平台默认的字符，<code>wirte()</code>也就是把代有编码的一个字符，转换成字节序列写流中。</p><p>OutputStreamWriter的API：</p><h2 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h2><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>OutputStreamWriter(OutputStream out)</code></td><td style="text-align:left">创建使用默认字符编码的 OutputStreamWriter对象。</td></tr><tr><td style="text-align:left"><code>OutputStreamWriter(OutputStream out, Charset cs)</code></td><td style="text-align:left">创建使用给定字符集的 OutputStreamWriter对象。</td></tr><tr><td style="text-align:left"><code>OutputStreamWriter(OutputStream out, CharsetEncoder enc)</code></td><td style="text-align:left">创建使用给定字符集编码器的 OutputStreamWriter对象。</td></tr><tr><td style="text-align:left"><code>OutputStreamWriter(OutputStream out, String charsetName)</code></td><td style="text-align:left">创建使用指定字符集的 OutputStreamWriter对象。</td></tr></tbody></table><h2 id="其他方法："><a href="#其他方法：" class="headerlink" title="其他方法："></a>其他方法：</h2><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>void write(int c)</code></td><td style="text-align:left">写入单个字符。</td></tr><tr><td style="text-align:left"><code>void write(char[] cbuf, int off, int len)</code></td><td style="text-align:left">写入字符数组的某一部分。</td></tr><tr><td style="text-align:left"><code>void write(String str, int off, int len)</code></td><td style="text-align:left">写入字符串的某一部分。</td></tr><tr><td style="text-align:left"><code>void close()</code></td><td style="text-align:left">关闭此流，但要先刷新它。</td></tr><tr><td style="text-align:left"><code>void flush()</code></td><td style="text-align:left">刷新该流的缓冲。</td></tr><tr><td style="text-align:left"><code>String getEncoding()</code></td><td style="text-align:left">返回此流使用的字符编码的名称。</td></tr></tbody></table><h2 id="对比这两个类"><a href="#对比这两个类" class="headerlink" title="对比这两个类"></a>对比这两个类</h2><p>可看到<code>OutputStreamWriter</code>和<code>InputStreamReader</code>这两个类中的方法并不是对称的。</p><p>两个类都有的方法：</p><ul><li><code>close()</code> 关闭流</li><li><code>getEncoding()</code>返回使用的字符编码</li></ul><p>对称的读写方法：</p><ul><li><code>int read()/void write(int c)</code> 读/写一个字节</li><li><code>int read(char[] cbuf,int off,int len)/void write(char[] cbuf,int off,int len)</code> 读/写一个数组</li></ul><p><code>InputStreamReader</code>独有的方法：</p><ul><li><code>boolean ready()</code> ,判断此流是否已经准备好用于读取。</li></ul><p><code>OutputStreamWriter</code>独有的方法：</p><ul><li><code>void write(String str</code>,<code>int off</code>,<code>int len)</code>, 从字符串<code>str</code>中的<code>off</code>位置开始写<code>len</code>个字符。</li><li><code>void flush()</code>,刷新该流的缓冲</li></ul><h2 id="实例：使用上面三种方法写文件"><a href="#实例：使用上面三种方法写文件" class="headerlink" title="实例：使用上面三种方法写文件"></a>实例：使用上面三种方法写文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void writeByOutputStreamWriter(String fileName)</span><br><span class="line">throws FileNotFoundException, IOException</span><br><span class="line">&#123;</span><br><span class="line">OutputStreamWriter out = new OutputStreamWriter(</span><br><span class="line">new FileOutputStream(fileName));</span><br><span class="line">char c = &apos;I&apos;;</span><br><span class="line">// 写入单个字符</span><br><span class="line">out.write(c);</span><br><span class="line">String str = &quot;am groot\n&quot;;</span><br><span class="line">// 字符串转换为字符数组</span><br><span class="line">char[] cbuf = str.toCharArray();</span><br><span class="line">// 写入字符数组</span><br><span class="line">out.write(cbuf, 0, cbuf.length);</span><br><span class="line">String str2 = &quot;I am groot!&quot;;</span><br><span class="line">// 写入整个字符串</span><br><span class="line">out.write(str2, 0, str2.length());// 写入字符串</span><br><span class="line">out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运用上面的InputStreamReader的知识,写两个方法来读取写入的内容<br>按字符读取：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void readByInputStreamReader(String fileName)</span><br><span class="line">throws FileNotFoundException, IOException</span><br><span class="line">&#123;</span><br><span class="line">InputStreamReader in = new InputStreamReader(</span><br><span class="line">new FileInputStream(fileName));</span><br><span class="line">int ch;</span><br><span class="line">while ((ch = in.read()) != -1)</span><br><span class="line">&#123;</span><br><span class="line">System.out.print((char) ch);</span><br><span class="line">&#125;</span><br><span class="line">in.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>按字符数组读取：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void readByInputStreamReaderCharArr(String fileName)</span><br><span class="line">throws FileNotFoundException, IOException</span><br><span class="line">&#123;</span><br><span class="line">InputStreamReader in = new InputStreamReader(</span><br><span class="line">new FileInputStream(fileName));</span><br><span class="line">int size;</span><br><span class="line">char[] array = new char[10];</span><br><span class="line">while ((size = in.read(array, 0, array.length)) != -1)</span><br><span class="line">&#123;</span><br><span class="line">System.out.print(new String(array, 0, size));</span><br><span class="line">&#125;</span><br><span class="line">in.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>main方法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException</span><br><span class="line">&#123;</span><br><span class="line">String fileName = &quot;test.txt&quot;;</span><br><span class="line">System.out.println(&quot;写文件结束...&quot;);</span><br><span class="line">writeByOutputStreamWriter(fileName);</span><br><span class="line">System.out.println(&quot;写文件结束...&quot;);</span><br><span class="line">// System.out.println(c+new String(cbuf)+str2);</span><br><span class="line">System.out.println(&quot;--------------读字符：-------------------&quot;);</span><br><span class="line">// readByInputStreamReader(fileName);</span><br><span class="line">readByInputStreamReaderCharArr(fileName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">写文件结束...</span><br><span class="line">写文件结束...</span><br><span class="line">--------------读字符：-------------------</span><br><span class="line">I am groot</span><br><span class="line">I am groot!</span><br></pre></td></tr></table></figure><p></p><p><code>test.txt</code>文件中的内容：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I am groot</span><br><span class="line">I am groot!</span><br></pre></td></tr></table></figure><p></p><p>需要注意的是，写文件的时候<code>test.txt</code>文件可以不存在，OutputStreamWriter会自动创建这文件，然后写入该文件中。但前提是可以找到<code>test.txt</code>这个文件的父路径。如果父路径不存在，会抛出异常：<code>FileNotFoundException</code>。</p><p>例如把上面main中的代码改为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String fileName = &quot;\\new1\\test222.txt&quot;;</span><br><span class="line">System.out.println(&quot;写文件结束...&quot;);</span><br><span class="line">writeByOutputStreamWriter(fileName);</span><br><span class="line">System.out.println(&quot;写文件结束...&quot;);</span><br></pre></td></tr></table></figure><p></p><p>因为当前工作目录下没有<code>new1</code>这个文件夹,所以无法在<code>new1</code>目录下创建<code>test222.txt</code>这个文件。<br>运行部分结果入下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.io.FileNotFoundException: \new1\test222.txt (系统找不到指定的路径。)</span><br></pre></td></tr></table></figure><p></p><h1 id="应用：复制字符文件"><a href="#应用：复制字符文件" class="headerlink" title="应用：复制字符文件"></a>应用：复制字符文件</h1><p>我们可以从一个文件中读取字符，然后再把这些字符写入到另一个文件中，然后再读，再写，一直循环知道读取结束。从而实现文件的复制操作。</p><p>但是只能复制存放字符的文件(.txt,.c,.java等)，不能复制二进制文件(如音频，视屏，音乐)</p><p>关键代码：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while((size=in.read(cbuf, 0, cbuf.length))!=-1)</span><br><span class="line">&#123;</span><br><span class="line">//然后把数字中读取到的字符写入到输出流中，注意读多少写多好，不要整个数组都写进去</span><br><span class="line">out.write(cbuf, 0, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>完整的代码：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public static void copy(String from, String to)</span><br><span class="line">&#123;</span><br><span class="line">InputStreamReader in=null;</span><br><span class="line">OutputStreamWriter out=null;</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">in = new InputStreamReader(new FileInputStream(from),&quot;gbk&quot;);</span><br><span class="line">//如果可以读了</span><br><span class="line">if(in.ready())</span><br><span class="line">&#123;</span><br><span class="line">out=new OutputStreamWriter(new FileOutputStream(to), &quot;gbk&quot;);</span><br><span class="line">//缓存字符数组</span><br><span class="line">char[] cbuf=new char[20];</span><br><span class="line">int size;</span><br><span class="line">//从输入流中读取一个数组的字符到数组中</span><br><span class="line">while((size=in.read(cbuf, 0, cbuf.length))!=-1)</span><br><span class="line">&#123;</span><br><span class="line">//然后把数字中读取到的字符写入到输出流中，注意读多少写多好，不要整个数组都写进去</span><br><span class="line">out.write(cbuf, 0, size);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (UnsupportedEncodingException | FileNotFoundException e)</span><br><span class="line">&#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (IOException e)</span><br><span class="line">&#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">finally </span><br><span class="line">&#123;</span><br><span class="line">if(in!=null)</span><br><span class="line">&#123;</span><br><span class="line">try&#123;in.close();&#125; </span><br><span class="line">catch (IOException e)</span><br><span class="line">&#123;e.printStackTrace();&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(out!=null)</span><br><span class="line">&#123;</span><br><span class="line">try&#123;out.close();&#125; </span><br><span class="line">catch (IOException e)</span><br><span class="line">&#123;e.printStackTrace();&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>源文件：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I am groot</span><br><span class="line">I am groot!</span><br></pre></td></tr></table></figure><p></p><p>测试：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String from = &quot;test.txt&quot;;</span><br><span class="line">String to = &quot;copy.txt&quot;;</span><br><span class="line">copy(from, to);</span><br></pre></td></tr></table></figure><p></p><p>运行后，当前工程目录下创建了一个<code>copy.txt</code>文件，文件中的内容如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I am groot</span><br><span class="line">I am groot!</span><br></pre></td></tr></table></figure><p></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/a5e554af/">JavaIO InputStreamReader和OutputStreamWriter</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java IO流 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>TL-WR802N如何设置Mini路由器</title>
      <link href="/blog/cbad161/"/>
      <url>/blog/cbad161/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><pre><code>TL-WR802N提供多种工作模式，可以满足多种网络应用需求，本文指导针对您的不同需求如何选择需要的模式，并指导对应设置方法。</code></pre><p>在家里，您使用宽带账号密码，在公司，您使用静态IP地址（绑定MAC地址），在酒店，您使用<strong>动态IP地址（认证上网）</strong>。需要连接Mini路由器实现共享上网，选择路由模式，通过简单设置即可满足您的需求。<br><img src="http://service.tp-link.com.cn/pages/imageuploadfolder/20140424/20140424201628_5312.png" alt=""></p><center>Router模式应用拓扑</center><p>注意：以上拓扑中省去Modem，具体连接拓扑，需参考Router模式设置文档。</p><p>点击参考如何设置：</p><p>在办公区域或酒店，仅提供有线接口，要实现无线终端接入网络，需要有无线热点。Mini路由器的AP模式相当于“无线交换机”，<strong>可以实现有线转换为无线，提供无线热点。</strong></p><p><img src="http://service.tp-link.com.cn/pages/imageuploadfolder/20140424/20140424201644_9737.png" alt=""></p><center>AP模式应用拓扑</center><p>注意：如果酒店、公司网络限制接入终端数量或者仅提供一个ID认证或IP地址，则推荐使用Router模式。</p><p>点击参考如何设置：</p><pre><code>家里已经有无线路由器，但是书房信号较弱，卧室搜不到信号，需要增强无线信号并且扩大覆盖范围。使用Mini路由器的Repeater模式，进行中继放大。</code></pre><p>Repeater模式应用拓扑</p><pre><code>点击参考如何设置：台式机需要接入无线网络，但是没有无线网卡。Mini路由器工作在Client模式下相当于无线网卡，可以帮助台式机接入网络。</code></pre><p>Client模式应用拓扑</p><pre><code>点击参考如何设置：如果部分办公室不方便拉网线接入公司网络，但是无线网络已经覆盖。那么使用Mini路由器的Bridge模式连接到无线网络，并设置属于办公室的无线网络。</code></pre><p>Bridge模式应用拓扑</p><p>注意：该模式并不局限于办公室应用。</p><p>点击参考设置方法：</p><p>如果上述需求均不符合您的需求，请了解不同模式的功能和作用，选择对应的模式，参考设置方法：</p><p>工作模式介绍</p><p>Router（路由模式）：接入宽带线路，为局域网无线终端提供无线接入，共享宽带上网。</p><p>AP（接入点模式）：将有线转换为无线，提供无线热点，当作“无线交换机”使用。</p><p>Repeater（中继模式）：中继放大已有的无线信号，从而扩大无线覆盖范围。</p><p>Client（客户端模式）：相当于无线网卡，连接已有的无线网络，有线连接在Mini路由器下的电脑可以接入网络。</p><p>Bridge（桥接模式）：通过无线方式将两个无线网络连接，合并为同一个局域网。</p><p>您也可以将需求详细描述，发送至<a href="mailto:fae@tp-link.com.cn" target="_blank" rel="noopener">fae@tp-link.com.cn</a>，我们会针对您的需求，指导应用设置方法。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/cbad161/">TL-WR802N如何设置Mini路由器</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 我的软件 </category>
          
          <category> 自己写的工具说明 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>正则应用 自动复制Java API方法摘要中的表格</title>
      <link href="/blog/8b1861fc/"/>
      <url>/blog/8b1861fc/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>写博客的时候经常需要复制API，我之前是一条一条的复制，现在看来太low了,所以写个工具来一下子复制整个方法摘要中的表格。<a href="#goto">完整代码直达</a></p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>复制javaAPI中文档方法摘要中的方法，然后根据复制的文本生成表格。<br><img src="https://i.imgur.com/yLOvilF.png" alt=""><br>复制好的文本如下</p><h3 id="需要处理的文本："><a href="#需要处理的文本：" class="headerlink" title="需要处理的文本："></a>需要处理的文本：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void close() </span><br><span class="line">         关闭该流并释放与之关联的所有资源。 </span><br><span class="line">void mark(int readAheadLimit) </span><br><span class="line">         标记流中的当前位置。 </span><br><span class="line">boolean markSupported() </span><br><span class="line">         判断此流是否支持 mark() 操作（它一定支持）。 </span><br><span class="line">int read() </span><br><span class="line">         读取单个字符。 </span><br><span class="line">int read(char[] cbuf, int off, int len) </span><br><span class="line">         将字符读入数组的某一部分。 </span><br><span class="line">String readLine() </span><br><span class="line">         读取一个文本行。 </span><br><span class="line">boolean ready() </span><br><span class="line">         判断此流是否已准备好被读取。 </span><br><span class="line">void reset() </span><br><span class="line">         将流重置到最新的标记。 </span><br><span class="line">long skip(long n) </span><br><span class="line">         跳过字符。</span><br></pre></td></tr></table></figure><h3 id="希望处理后的文本为"><a href="#希望处理后的文本为" class="headerlink" title="希望处理后的文本为"></a>希望处理后的文本为</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|方法|描述|</span><br><span class="line">|:-|:-|</span><br><span class="line">|void close() |关闭该流并释放与之关联的所有资源。 |</span><br><span class="line">|void mark(int readAheadLimit) |标记流中的当前位置。 |</span><br><span class="line">|boolean markSupported() |判断此流是否支持 mark() 操作（它一定支持）。 |</span><br><span class="line">|int read() |读取单个字符。 |</span><br><span class="line">|int read(char[] cbuf, int off, int len) |将字符读入数组的某一部分。 |</span><br><span class="line">|String readLine() |读取一个文本行。 |</span><br><span class="line">|boolean ready() |判断此流是否已准备好被读取。 |</span><br><span class="line">|void reset() |将流重置到最新的标记。 |</span><br><span class="line">|long skip(long n) |跳过字符。 |</span><br></pre></td></tr></table></figure><h3 id="在markdown文档中显示效果："><a href="#在markdown文档中显示效果：" class="headerlink" title="在markdown文档中显示效果："></a>在markdown文档中显示效果：</h3><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">void close()</td><td style="text-align:left">关闭该流并释放与之关联的所有资源。</td></tr><tr><td style="text-align:left">void mark(int readAheadLimit)</td><td style="text-align:left">标记流中的当前位置。</td></tr><tr><td style="text-align:left">boolean markSupported()</td><td style="text-align:left">判断此流是否支持 mark() 操作（它一定支持）。</td></tr><tr><td style="text-align:left">int read()</td><td style="text-align:left">读取单个字符。</td></tr><tr><td style="text-align:left">int read(char[] cbuf, int off, int len)</td><td style="text-align:left">将字符读入数组的某一部分。</td></tr><tr><td style="text-align:left">String readLine()</td><td style="text-align:left">读取一个文本行。</td></tr><tr><td style="text-align:left">boolean ready()</td><td style="text-align:left">判断此流是否已准备好被读取。</td></tr><tr><td style="text-align:left">void reset()</td><td style="text-align:left">将流重置到最新的标记。</td></tr><tr><td style="text-align:left">long skip(long n)</td><td style="text-align:left">跳过字符。</td></tr></tbody></table><h2 id="实现过程步骤："><a href="#实现过程步骤：" class="headerlink" title="实现过程步骤："></a>实现过程步骤：</h2><h3 id="在方法和解释之间加入分界符，使两者合并到同一行中"><a href="#在方法和解释之间加入分界符，使两者合并到同一行中" class="headerlink" title="在方法和解释之间加入分界符，使两者合并到同一行中"></a>在方法和解释之间加入分界符，使两者合并到同一行中</h3><p>可以看到，的顺序是：一行方法，然后下一行是解释。我希望处理后方法和解释在同一行中。<br>例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void close() </span><br><span class="line">          关闭该流并释放与之关联的所有资源。</span><br></pre></td></tr></table></figure><p></p><p>对于这个方法，在方法和解释之间加上一个<code>|</code>将方法和解释分开。形成：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void close()|关闭该流并释放与之关联的所有资源。</span><br></pre></td></tr></table></figure><p></p><p>这样的形式，那怎么做呢，观察这个文本。<br><img src="https://i.imgur.com/8hQOIDh.png" alt=""><br>我们发现，方法和注释之间，有一个换行符，和多个空格。<br>所以，使用<code>body=body.replaceAll(&quot;\\n\\s{2,}&quot;, &quot;|&quot;);</code>这句话来吧换行符合多个空格换成”<code>|</code>“。<br>代码：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//从剪贴板中获取文本</span><br><span class="line">String body=SysClipboardUtil.getSysClipboardText();</span><br><span class="line">//方法和解释之间加入分界符&quot;|&quot;</span><br><span class="line">body=body.replaceAll(&quot;\\n\\s&#123;2,&#125;&quot;, &quot;|&quot;);</span><br><span class="line">System.out.println(body);</span><br></pre></td></tr></table></figure><p></p><p>此时运行效果如下。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void close() |关闭该流并释放与之关联的所有资源。 </span><br><span class="line"> void mark(int readAheadLimit) |标记流中的当前位置。 </span><br><span class="line"> boolean markSupported() |判断此流是否支持 mark() 操作（它一定支持）。 </span><br><span class="line"> int read() |读取单个字符。 </span><br><span class="line"> int read(char[] cbuf, int off, int len) |将字符读入数组的某一部分。 </span><br><span class="line"> String readLine() |读取一个文本行。 </span><br><span class="line"> boolean ready() |判断此流是否已准备好被读取。 </span><br><span class="line"> void reset() |将流重置到最新的标记。 </span><br><span class="line"> long skip(long n) |跳过字符。</span><br></pre></td></tr></table></figure><p></p><h3 id="在行首行尾之间加入分界符"><a href="#在行首行尾之间加入分界符" class="headerlink" title="在行首行尾之间加入分界符"></a>在行首行尾之间加入分界符</h3><p>可以看到我们已经在方法和解释之间成功加入了分界符了，现在还有行首,以及行尾的分界符没有加上，在输出语句前面加上这句<code>body=body.replaceAll(&quot;(?m)(^\\s{0,1}|$)&quot;, &quot;|&quot;);</code>。<br>此时的代码为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//从剪贴板中获取文本</span><br><span class="line">String body=SysClipboardUtil.getSysClipboardText();</span><br><span class="line">//方法和解释之间加入分界符&quot;|&quot;</span><br><span class="line">body=body.replaceAll(&quot;\\n\\s&#123;2,&#125;&quot;, &quot;|&quot;);</span><br><span class="line">body=body.replaceAll(&quot;(?m)(^\\s?|$)&quot;, &quot;|&quot;);</span><br><span class="line">System.out.println(body);</span><br></pre></td></tr></table></figure><p></p><p>运行结果:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|void close() |关闭该流并释放与之关联的所有资源。 |</span><br><span class="line">|void mark(int readAheadLimit) |标记流中的当前位置。 |</span><br><span class="line">|boolean markSupported() |判断此流是否支持 mark() 操作（它一定支持）。 |</span><br><span class="line">|int read() |读取单个字符。 |</span><br><span class="line">|int read(char[] cbuf, int off, int len) |将字符读入数组的某一部分。 |</span><br><span class="line">|String readLine() |读取一个文本行。 |</span><br><span class="line">|boolean ready() |判断此流是否已准备好被读取。 |</span><br><span class="line">|void reset() |将流重置到最新的标记。 |</span><br><span class="line">|long skip(long n) |跳过字符。 |</span><br><span class="line">|</span><br></pre></td></tr></table></figure><p></p><h3 id="删除多加入的无用分界符"><a href="#删除多加入的无用分界符" class="headerlink" title="删除多加入的无用分界符"></a>删除多加入的无用分界符</h3><p>可以看到，行首和行尾都加上了分界符，并且删除掉了行首多余的空白符了。但是又在最后面的一行了一个<code>|</code>这个是我们不需要的，应该删掉，<code>body=body.replaceAll(&quot;(?m)^\\|$&quot;,&quot;&quot;);</code><br>修改后的程序：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//从剪贴板中获取文本</span><br><span class="line">String body=SysClipboardUtil.getSysClipboardText();</span><br><span class="line">//方法和解释之间加入分界符&quot;|&quot;</span><br><span class="line">body=body.replaceAll(&quot;\\n\\s&#123;2,&#125;&quot;, &quot;|&quot;);</span><br><span class="line">body=body.replaceAll(&quot;(?m)(^\\s?|$)&quot;, &quot;|&quot;);</span><br><span class="line">body=body.replaceAll(&quot;(?m)^\\|$&quot;,&quot;&quot;);</span><br><span class="line">System.out.println(body);</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">|void close() |关闭该流并释放与之关联的所有资源。 |</span><br><span class="line">|void mark(int readAheadLimit) |标记流中的当前位置。 |</span><br><span class="line">|boolean markSupported() |判断此流是否支持 mark() 操作（它一定支持）。 |</span><br><span class="line">|int read() |读取单个字符。 |</span><br><span class="line">|int read(char[] cbuf, int off, int len) |将字符读入数组的某一部分。 |</span><br><span class="line">|String readLine() |读取一个文本行。 |</span><br><span class="line">|boolean ready() |判断此流是否已准备好被读取。 |</span><br><span class="line">|void reset() |将流重置到最新的标记。 |</span><br><span class="line">|long skip(long n) |跳过字符。 |</span><br></pre></td></tr></table></figure><p></p><p>现在表格体已经构建好了，还缺表格头，这个就简单了，不再需要使用正则表达式，定义表格头<code>String head=&quot;|方法|描述|\n|:-|:-|\n&quot;;</code>,然后<code>head+body</code>加上表格头就行了，</p><h3 id="完整版关键代码"><a href="#完整版关键代码" class="headerlink" title="完整版关键代码"></a>完整版关键代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//从剪贴板中获取文本</span><br><span class="line">String body=SysClipboardUtil.getSysClipboardText();</span><br><span class="line">//方法和解释之间加入分界符&quot;|&quot;</span><br><span class="line">body=body.replaceAll(&quot;\\n\\s&#123;2,&#125;&quot;, &quot;|&quot;);</span><br><span class="line">//在行首和行尾加上分界符插入一个|</span><br><span class="line">body=body.replaceAll(&quot;(?m)(^\\s?|$)&quot;, &quot;|&quot;);</span><br><span class="line">body=body.replaceAll(&quot;(?m)^\\|$&quot;,&quot;&quot;);</span><br><span class="line">String head=&quot;|方法|描述|\n|:-|:-|\n&quot;;</span><br><span class="line">body=head+body;</span><br><span class="line">System.out.println(body);</span><br></pre></td></tr></table></figure><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|方法|描述|</span><br><span class="line">|:-|:-|</span><br><span class="line">|void close() |关闭该流并释放与之关联的所有资源。 |</span><br><span class="line">|void mark(int readAheadLimit) |标记流中的当前位置。 |</span><br><span class="line">|boolean markSupported() |判断此流是否支持 mark() 操作（它一定支持）。 |</span><br><span class="line">|int read() |读取单个字符。 |</span><br><span class="line">|int read(char[] cbuf, int off, int len) |将字符读入数组的某一部分。 |</span><br><span class="line">|String readLine() |读取一个文本行。 |</span><br><span class="line">|boolean ready() |判断此流是否已准备好被读取。 |</span><br><span class="line">|void reset() |将流重置到最新的标记。 |</span><br><span class="line">|long skip(long n) |跳过字符。 |</span><br></pre></td></tr></table></figure><p></p><p>复制上面的运行结果，粘贴到markdown文档中，显示效果如下。</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">void close()</td><td style="text-align:left">关闭该流并释放与之关联的所有资源。</td></tr><tr><td style="text-align:left">void mark(int readAheadLimit)</td><td style="text-align:left">标记流中的当前位置。</td></tr><tr><td style="text-align:left">boolean markSupported()</td><td style="text-align:left">判断此流是否支持 mark() 操作（它一定支持）。</td></tr><tr><td style="text-align:left">int read()</td><td style="text-align:left">读取单个字符。</td></tr><tr><td style="text-align:left">int read(char[] cbuf, int off, int len)</td><td style="text-align:left">将字符读入数组的某一部分。</td></tr><tr><td style="text-align:left">String readLine()</td><td style="text-align:left">读取一个文本行。</td></tr><tr><td style="text-align:left">boolean ready()</td><td style="text-align:left">判断此流是否已准备好被读取。</td></tr><tr><td style="text-align:left">void reset()</td><td style="text-align:left">将流重置到最新的标记。</td></tr><tr><td style="text-align:left">long skip(long n)</td><td style="text-align:left">跳过字符。</td></tr></tbody></table><p>吃惊！正则表达式是果然很强大。</p><p></p><div id="goto"></div><p></p><h2 id="完成的代码："><a href="#完成的代码：" class="headerlink" title="完成的代码："></a>完成的代码：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> markdowntools.table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> clipboard.util.SysClipboardUtil;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableCopyFromAPI</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//从剪贴板中获取文本</span></span><br><span class="line">String body=SysClipboardUtil.getSysClipboardText();</span><br><span class="line"><span class="comment">//方法和解释之间加入分界符"|"</span></span><br><span class="line">body=body.replaceAll(<span class="string">"\\n\\s&#123;2,&#125;"</span>, <span class="string">"|"</span>);</span><br><span class="line"><span class="comment">//在行首和行尾加上分界符插入一个|</span></span><br><span class="line">body=body.replaceAll(<span class="string">"(?m)(^\\s?|$)"</span>, <span class="string">"|"</span>);</span><br><span class="line"><span class="comment">//去掉多加入无用的分界符</span></span><br><span class="line">body=body.replaceAll(<span class="string">"(?m)^\\|$"</span>,<span class="string">""</span>);</span><br><span class="line"><span class="comment">//定义表格头部和对齐方式</span></span><br><span class="line">String head=<span class="string">"|方法|描述|\n|:-|:-|\n"</span>;</span><br><span class="line"><span class="comment">//拼接成完整的markdown表格代码</span></span><br><span class="line">body=head+body;</span><br><span class="line"><span class="comment">//输出到控制台中</span></span><br><span class="line"><span class="comment">//System.out.println(body);</span></span><br><span class="line"><span class="comment">//          处理好的文本写入剪贴板中</span></span><br><span class="line">SysClipboardUtil.setSysClipboardText(body);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依赖：<a href="https://blog.csdn.net/qq_21808961/article/details/80671259" target="_blank" rel="noopener">clipboard.util.SysClipboardUtil</a></p><p>不足的地方，因为是使用String操作，但是总共产生了6个String对象。应该还能再优化优化，以后哪天再说啦。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="优化1：合并正则表达式"><a href="#优化1：合并正则表达式" class="headerlink" title="优化1：合并正则表达式"></a>优化1：合并正则表达式</h3><p>来看下面这两句替换语句：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法和解释之间加入分界符"|"</span></span><br><span class="line">body=body.replaceAll(<span class="string">"\\n\\s&#123;2,&#125;"</span>, <span class="string">"|"</span>);</span><br><span class="line"><span class="comment">//在行首和行尾加上分界符插入一个|</span></span><br><span class="line">body=body.replaceAll(<span class="string">"(?m)(^\\s?|$)"</span>, <span class="string">"|"</span>);</span><br></pre></td></tr></table></figure><p></p><p>我发现这两个都是加入分割符到原来的文本中，利用多选节后可以把上面的两条正则表达式语句合并成一条语句：<code>(\\n\\s{2,}|(?m)(^\\s*|$))</code>，同时我们也不需要捕获文本，所以使用非捕获括号进行限定：<code>(?:\\n\\s{2,}|(?m)(?:^\\s*|$))</code>，这样减少捕获的操作以提高效率。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">body = body.replaceAll(<span class="string">"(?:\\n\\s&#123;2,&#125;|(?m)(?:^\\s*|$))"</span>, <span class="string">"|"</span>);</span><br></pre></td></tr></table></figure><p></p><p>这样的好处就是少生成一个String对象减少内存占用吧。<br>关键代码如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从剪贴板中获取文本</span></span><br><span class="line">String body = SysClipboardUtil.getSysClipboardText();</span><br><span class="line"><span class="comment">// 方法和解释之间加入分界符"|"</span></span><br><span class="line"><span class="comment">// 在行首和行尾加上分界符插入一个|</span></span><br><span class="line">body = body.replaceAll(<span class="string">"(?:\\n\\s&#123;2,&#125;|(?m)(?:^\\s*|$))"</span>, <span class="string">"|"</span>);</span><br><span class="line"><span class="comment">// 去掉多加入无用的分界符</span></span><br><span class="line">body = body.replaceAll(<span class="string">"(?m)^\\|$"</span>, <span class="string">""</span>);</span><br><span class="line"><span class="comment">// 定义表格头部和对齐方式</span></span><br><span class="line">String head = <span class="string">"|方法|描述|\n|:-|:-|\n"</span>;</span><br><span class="line"><span class="comment">// 拼接成完整的markdown表格代码</span></span><br><span class="line">body = head + body;</span><br><span class="line"><span class="comment">// 输出到控制台中_调试的时候用</span></span><br><span class="line"><span class="comment">//System.out.println(body);</span></span><br><span class="line"><span class="comment">// 处理好的文本写入剪贴板中</span></span><br><span class="line">SysClipboardUtil.setSysClipboardText(body);</span><br></pre></td></tr></table></figure><p></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/8b1861fc/">正则应用 自动复制Java API方法摘要中的表格</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 正则表达式 </category>
          
          <category> 实例 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JAVA 正则表达式 (超详细)</title>
      <link href="/blog/cf4d6a6e/"/>
      <url>/blog/cf4d6a6e/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>原文：<a href="https://www.cnblogs.com/xyou/p/7427779.html" target="_blank" rel="noopener">https://www.cnblogs.com/xyou/p/7427779.html</a></p><h2 id="java-util-regex包说明"><a href="#java-util-regex包说明" class="headerlink" title="java.util.regex包说明"></a>java.util.regex包说明</h2><blockquote><p>在<code>regex</code>包中，包括了两个类，<code>Pattern(</code>模式类)和<code>Matcher(</code>匹配器类)。<code>Pattern</code>类是用来表达和陈述所要搜索模式的对象，<code>Matcher</code>类是真正影响搜索的对象。另加一个新的例外类，<code>PatternSyntaxException</code>，当遇到不合法的搜索模式时，会抛出例外。</p><p>即使对正则表达式很熟悉，你会发现，通过<code>java</code>使用正则表达式也相当简单。要说明的一点是，对那些被<code>Perl</code>的单行匹配所宠坏的<code>Perl</code>狂热爱好者来说，在使用<code>java</code>的<code>regex</code>包进行替换操作时，会比他们所以前常用的方法费事些。</p><p>本文的局限之处，它不是一篇正则表达式用法的完全教程。如果读者要对正则表达进一步了解的话，推荐阅读<code>Jeffrey Frieldl</code>的<code>Mastering Regular Expressions</code>，该书由<code>O’Reilly</code>出版社出版。我下面就举一些例子来教读者如何使用正则表达式，以及如何更简单地去使用它。</p></blockquote><h2 id="匹配任何格式的电话号码"><a href="#匹配任何格式的电话号码" class="headerlink" title="匹配任何格式的电话号码"></a>匹配任何格式的电话号码</h2><blockquote><p>设计一个简单的表达式来匹配任何电话号码数字可能是比较复杂的事情，原因在于电话号码格式有很多种情况。所有必须选择一个比较有效的模式。比如:<code>(212) 555-1212， 212-555-1212和212 555 1212</code>，某些人会认为它们都是等价的。</p><p>首先让我们构成一个正则表达式。为简单起见，先构成一个正则表达式来识别下面格式的电话号码数字:<code>(nnn)nnn-nnnn</code>。</p><p>第一步，创建一个<code>pattern</code>对象来匹配上面的子字符串。一旦程序运行后，如果需要的话，可以让这个对象一般化。匹配上面格式的正则表达可以这样构成:</p><p><code>(\d{3})\s\d{3}-\d{4}</code>，其中<code>\d</code>单字符类型用来匹配从0到9的任何数字，另外<code>{3}</code>用来表示正好有3个连续的数字位，也等效于(<code>\d\d\d)</code>。<code>\s</code>也另外一个比较有用的单字符类型，用来匹配空白符，比如<code>Space键</code>，<code>tab键</code>和<code>换行符</code>。</p></blockquote><h3 id="空白符有哪些-s-匹配什么"><a href="#空白符有哪些-s-匹配什么" class="headerlink" title="空白符有哪些,\s 匹配什么"></a>空白符有哪些,<code>\s</code> 匹配什么</h3><table><thead><tr><th style="text-align:left">正则表达式</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>\s</code></td><td>匹配任何空白字符，包括空格、制表符、换页符等。与<code>[ \f\n\r\t\v]</code> 等效。</td></tr></tbody></table><p>由<code>\s</code>的定义可以看出，<code>\s</code>能匹配</p><ul><li>空格、</li><li>换页符(\f)，</li><li>换行符(\n)、</li><li>回车(\r)、</li><li>水平制表符(\t)、</li><li>垂直制表符(\v)</li></ul><p>这六种中的任意一个，所以学习正则表达式应该多看看这些字符的定义。</p><h3 id="转义字符有哪些："><a href="#转义字符有哪些：" class="headerlink" title="转义字符有哪些："></a>转义字符有哪些：</h3><table><thead><tr><th style="text-align:left">转义字符</th><th style="text-align:left">意义</th><th style="text-align:left">ASCII码值（十进制）</th></tr></thead><tbody><tr><td style="text-align:left">\a</td><td style="text-align:left">响铃(BEL)</td><td style="text-align:left">007</td></tr><tr><td style="text-align:left">\b</td><td style="text-align:left">退格(BS) ，将当前位置移到前一列</td><td style="text-align:left">008</td></tr><tr><td style="text-align:left"><code>\f</code></td><td style="text-align:left"><code>换页(FF)，将当前位置移到下页开头</code></td><td style="text-align:left">012</td></tr><tr><td style="text-align:left"><code>\n</code></td><td style="text-align:left"><code>换行(LF) ，将当前位置移到下一行开头</code></td><td style="text-align:left">010</td></tr><tr><td style="text-align:left"><code>\r</code></td><td style="text-align:left"><code>回车(CR) ，将当前位置移到本行开头</code></td><td style="text-align:left">013</td></tr><tr><td style="text-align:left"><code>\t</code></td><td style="text-align:left"><code>水平制表(HT) （跳到下一个TAB位置）</code></td><td style="text-align:left">009</td></tr><tr><td style="text-align:left"><code>\v</code></td><td style="text-align:left"><code>垂直制表(VT)</code></td><td style="text-align:left">011</td></tr><tr><td style="text-align:left">\\</td><td style="text-align:left">代表一个反斜线字符’’\’</td><td style="text-align:left">092</td></tr><tr><td style="text-align:left">\’</td><td style="text-align:left">代表一个单引号（撇号）字符</td><td style="text-align:left">039</td></tr><tr><td style="text-align:left">\”</td><td style="text-align:left">代表一个双引号字符</td><td style="text-align:left">034</td></tr><tr><td style="text-align:left">\?</td><td style="text-align:left">代表一个问号</td><td style="text-align:left">063</td></tr><tr><td style="text-align:left">\0</td><td style="text-align:left">空字符(NULL)</td><td style="text-align:left">000</td></tr><tr><td style="text-align:left">\ddd</td><td style="text-align:left">1到3位八进制数所代表的任意字符</td><td style="text-align:left">三位八进制</td></tr><tr><td style="text-align:left">\xhh</td><td style="text-align:left">1到2位十六进制所代表的任意字符</td><td style="text-align:left">二位十六进制</td></tr></tbody></table><blockquote><p>是不是很简单?但是，如果把这个正则表达式的模式用在<code>java</code>程序中，还要做两件事。对<code>java</code>的解释器来说，在反斜线字符(<code>\</code>)前的字符有特殊的含义。在<code>java</code>中，与<code>regex</code>有关的包，并不都能理解和识别反斜线字符(<code>\</code>)，尽管可以试试看。但为避免这一点，即为了让反斜线字符(<code>\</code>)在模式对象中被完全地传递，应该用双反斜线字符(<code>\</code>)。此外圆括号在正则表达中两层含义，如果想让它解释为字面上意思(即圆括号)，也需要在它前面用双反斜线字符(<code>\</code>)。也就是像下面的一样:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 　　\\(\\d&#123;3&#125;\\)\\s\\d&#123;3&#125;-\\d&#123;4&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>现在介绍怎样在<code>java</code>代码中实现刚才所讲的正则表达式。要记住的事，在用正则表达式的包时，在你所定义的类前需要包含该包，也就是这样的一行:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 　　import java.util.regex.*;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>下面的一段代码实现的功能是，从一个文本文件逐行读入，并逐行搜索电话号码数字，一旦找到所匹配的，然后输出在控制台。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt; import java.io.BufferedReader;</span><br><span class="line">&gt; import java.io.FileReader;</span><br><span class="line">&gt; import java.io.IOException;</span><br><span class="line">&gt; import java.util.regex.Matcher;</span><br><span class="line">&gt; import java.util.regex.Pattern;</span><br><span class="line">&gt; </span><br><span class="line">&gt; public class Example2</span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt; public static void main(String[] args) throws IOException</span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt; BufferedReader in;</span><br><span class="line">&gt; Pattern pattern = Pattern.compile(&quot;\\(\\d&#123;3&#125;\\)\\s\\d&#123;3&#125;-\\d&#123;4&#125;&quot;);</span><br><span class="line">&gt; in = new BufferedReader(new FileReader(&quot;phoneNum.txt&quot;));</span><br><span class="line">&gt; String s;</span><br><span class="line">&gt; while ((s = in.readLine()) != null)</span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt;     Matcher matcher = pattern.matcher(s);</span><br><span class="line">&gt;     if (matcher.find())</span><br><span class="line">&gt;     &#123;</span><br><span class="line">&gt;         System.out.println(matcher.group());</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; in.close();</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>phoneNum.txt:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; (212) 555-1212</span><br><span class="line">&gt; 212-555-1212</span><br><span class="line">&gt; 212 555 1212</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>运行结果:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; (212) 555-1212</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p></p></blockquote><p>好久没有碰IO流了，既然这里看到了，那就来复习一下IO流。<br>BufferedReader</p><p>void close()<br>关闭该流并释放与之关联的所有资源。<br>void mark(int readAheadLimit)<br>标记流中的当前位置。<br>boolean markSupported()<br>判断此流是否支持 mark() 操作（它一定支持）。<br>int read()<br>读取单个字符。<br>int read(char[] cbuf, int off, int len)<br>将字符读入数组的某一部分。<br>String readLine()<br>读取一个文本行。<br>boolean ready()<br>判断此流是否已准备好被读取。<br>void reset()<br>将流重置到最新的标记。<br>long skip(long n)<br>跳过字符。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/cf4d6a6e/">JAVA 正则表达式 (超详细)</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java 正则表达式 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>String tirm()方法去不掉的空格</title>
      <link href="/blog/9712edd/"/>
      <url>/blog/9712edd/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ul><li>移除掉下面代码中的空白行。</li><li>移除每行前面的多余空白符</li></ul><h3 id="要处理的文本"><a href="#要处理的文本" class="headerlink" title="要处理的文本:"></a>要处理的文本:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">　　BufferedReader in;</span><br><span class="line"></span><br><span class="line">　　Pattern pattern = Pattern.compile(&quot;//(//d&#123;3&#125;//)//s//d&#123;3&#125;-//d&#123;4&#125;&quot;);</span><br><span class="line"></span><br><span class="line">　　in = new BufferedReader(new FileReader(&quot;phone&quot;));</span><br><span class="line"></span><br><span class="line">　　String s;</span><br><span class="line"></span><br><span class="line">　　while ((s = in.readLine()) != null)</span><br><span class="line"></span><br><span class="line">　　&#123;</span><br><span class="line"></span><br><span class="line">　　Matcher matcher = pattern.matcher(s);</span><br><span class="line"></span><br><span class="line">　　if (matcher.find())</span><br><span class="line"></span><br><span class="line">　　&#123;</span><br><span class="line"></span><br><span class="line">　　System.out.println(matcher.group());</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　in.close();</span><br></pre></td></tr></table></figure><h2 id="移除空白行-使用正则表达式"><a href="#移除空白行-使用正则表达式" class="headerlink" title="移除空白行:使用正则表达式"></a>移除空白行:使用正则表达式</h2><p>使用String类的replaceAll()方法可以移除空白行，只要我用正则表达式匹配到这些空白行，然后把这些空白行替换为空字符串就行了。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text = text.replaceAll(&quot;(?m)^\\s*$(\\n|\\r\\n)&quot;, &quot;&quot;);</span><br></pre></td></tr></table></figure><p></p><p><code>(?m)</code>表示开启多行匹配模式，<code>^</code>匹配行开头,<code>\\s*</code>0个或多个空白符,<code>$</code>匹配行结尾，<code>(\\n|\\r\\n)</code>匹配字符串中的换行符。</p><p>测试代码如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String text = SysClipboardUtil.getSysClipboardText();</span><br><span class="line">System.out.println(&quot;去除无意义空白行后：&quot;);</span><br><span class="line">text = text.replaceAll(&quot;(?m)^\\s*$(\\n|\\r\\n)&quot;, &quot;&quot;);</span><br><span class="line">System.out.println(text);</span><br></pre></td></tr></table></figure><p></p><p>依赖：<a href="https://blog.csdn.net/qq_21808961/article/details/80671259" target="_blank" rel="noopener">SysClipboardUtil.getSysClipboardText();</a><br>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">去除无意义空白行后：</span><br><span class="line">　　BufferedReader in;</span><br><span class="line">　　Pattern pattern = Pattern.compile(&quot;//(//d&#123;3&#125;//)//s//d&#123;3&#125;-//d&#123;4&#125;&quot;);</span><br><span class="line">　　in = new BufferedReader(new FileReader(&quot;phone&quot;));</span><br><span class="line">　　String s;</span><br><span class="line">　　while ((s = in.readLine()) != null)</span><br><span class="line">　　&#123;</span><br><span class="line">　　Matcher matcher = pattern.matcher(s);</span><br><span class="line">　　if (matcher.find())</span><br><span class="line">　　&#123;</span><br><span class="line">　　System.out.println(matcher.group());</span><br><span class="line">　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　in.close();</span><br><span class="line">____________________________________</span><br></pre></td></tr></table></figure><p></p><p>好的，第一个需求做到了。</p><h2 id="移除每行前面的多余空白符"><a href="#移除每行前面的多余空白符" class="headerlink" title="移除每行前面的多余空白符"></a>移除每行前面的多余空白符</h2><h3 id="String-trim-方法删除不掉该空格符"><a href="#String-trim-方法删除不掉该空格符" class="headerlink" title="String.trim()方法删除不掉该空格符"></a>String.trim()方法删除不掉该空格符</h3><p>现在text字符串中，每一行的前面有两个空白符:<code></code>，因为这些空白符在行尾，很自然想到使用text.trim()方法取出掉该空白符，但是奇怪的是根本就去不掉。<br>之所以去不掉是因为这个空格不简单啊，不是普通那种空格，这里称为<code>bug空格</code>。<br><strong>bug空格：</strong><br><img src="https://i.imgur.com/o1iRowf.png" alt=""><br><strong>普通空格：</strong><br><img src="https://i.imgur.com/TZH9IE9.png" alt="">、<br>可以看到这个<code>bug空格</code>比普通的空格的宽度要宽。不过也不是没有办法。</p><h3 id="思路1：用该空格自己匹配来自己，进行替换删除"><a href="#思路1：用该空格自己匹配来自己，进行替换删除" class="headerlink" title="思路1：用该空格自己匹配来自己，进行替换删除"></a>思路1：用该空格自己匹配来自己，进行替换删除</h3><p>不过既然这个bug空格可以复制粘贴，那我就直接粘贴到程序中，用它自己来匹配自己，这样使用<code>text.replaceAll(&quot;[　]+&quot;,&quot;&quot;)</code>就可以把这个bug空格<code>&quot;　&quot;</code>全部替换成空白字符串<code>&quot;&quot;</code>，就相当于删除掉该字符串了。<br>代码如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String text = SysClipboardUtil.getSysClipboardText();</span><br><span class="line"><span class="comment">//删除文本中的空白行</span></span><br><span class="line">text=text.replaceAll(<span class="string">"(?m)^\\s*$(\\n|\\r\\n)"</span>, <span class="string">""</span>);</span><br><span class="line">System.out.println(<span class="string">"删除空白行之后的文本:"</span>);</span><br><span class="line">System.out.println(text);</span><br><span class="line"><span class="comment">//直接粘贴这个空格到字符组中,</span></span><br><span class="line">text=text.replaceAll(<span class="string">"[　]+"</span>, <span class="string">""</span>);</span><br><span class="line">System.out.println(<span class="string">"_______________________________"</span>);</span><br><span class="line">System.out.println(<span class="string">"去除中文全角空格后:"</span>);</span><br><span class="line">System.out.println(text);</span><br></pre></td></tr></table></figure><p></p><p>复制需要处理的文本,然后运行上面的代码。运行结果如下。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">删除空白行之后的文本:</span><br><span class="line">　　BufferedReader in;</span><br><span class="line">　　Pattern pattern = Pattern.compile(&quot;//(//d&#123;3&#125;//)//s//d&#123;3&#125;-//d&#123;4&#125;&quot;);</span><br><span class="line">　　in = new BufferedReader(new FileReader(&quot;phone&quot;));</span><br><span class="line">　　String s;</span><br><span class="line">　　while ((s = in.readLine()) != null)</span><br><span class="line">　　&#123;</span><br><span class="line">　　Matcher matcher = pattern.matcher(s);</span><br><span class="line">　　if (matcher.find())</span><br><span class="line">　　&#123;</span><br><span class="line">　　System.out.println(matcher.group());</span><br><span class="line">　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　in.close();</span><br><span class="line">_______________________________</span><br><span class="line">去除中文全角空格后:</span><br><span class="line">BufferedReader in;</span><br><span class="line">Pattern pattern = Pattern.compile(&quot;//(//d&#123;3&#125;//)//s//d&#123;3&#125;-//d&#123;4&#125;&quot;);</span><br><span class="line">in = new BufferedReader(new FileReader(&quot;phone&quot;));</span><br><span class="line">String s;</span><br><span class="line">while ((s = in.readLine()) != null)</span><br><span class="line">&#123;</span><br><span class="line">Matcher matcher = pattern.matcher(s);</span><br><span class="line">if (matcher.find())</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(matcher.group());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure><p></p><p>可以看到用了这种傻瓜式的操作就可以完成任务了。不过还是有点心有不甘，因为不知道这个bug空格是什么东西，下面来看看这个bug空格到底是什么东西。</p><h3 id="思路2：转成Unicode码然后查码表看看是什么东西"><a href="#思路2：转成Unicode码然后查码表看看是什么东西" class="headerlink" title="思路2：转成Unicode码然后查码表看看是什么东西"></a>思路2：转成Unicode码然后查码表看看是什么东西</h3><p>查了一下，其实这个空格叫做<code>中文(全角)空格</code>，我怎么知道的呢。先把这个空格转换成<code>Unicode</code>字符就知道了。<br>代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String chinese_full_width_space=&quot;　&quot;;//中文全角空格</span><br><span class="line">String urlEncoderUnicode = URLEncoder.encode(chinese_full_width_space,&quot;utf-16be&quot;);//java中的字符都用utf-16be进行编码，所以转码为utf-16be我们就知道了这个奇怪的字符在java里的编码。这样方便后面查找。</span><br><span class="line">System.out.println(urlEncoderUnicode);</span><br></pre></td></tr></table></figure><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%30%00</span><br></pre></td></tr></table></figure><p></p><p><code>%30%00</code>转换成平常表示的java中的Unicode编码就是<code>\u3000</code>,然后再到网上查一下看看这个<code>\u3000</code>是什么：</p><p><img src="https://i.imgur.com/Sayko4X.png" alt=""></p><p>嗯，原来这个bug空格叫做<code>中文全角空格</code></p><p>好的，既然我们知道了这个奇怪的空格是中文全角空格，也知道对应的Unicode码为<code>\u3000</code>,java中正则表达式支持Unicode码，所以可以使用<code>text=text.replaceAll(&quot;\u3000+&quot;, &quot;&quot;);</code>把所以的中文全角空格替换成空字符，也就是移除掉所有的中文全角空格了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String text = SysClipboardUtil.getSysClipboardText();</span><br><span class="line">//删除文本中的空白行</span><br><span class="line">text=text.replaceAll(&quot;(?m)^\\s*$(\\n|\\r\\n)&quot;, &quot;&quot;);</span><br><span class="line">System.out.println(&quot;删除空白行之后的文本:&quot;);</span><br><span class="line">System.out.println(text);</span><br><span class="line">//直接粘贴这个空格到字符组中,</span><br><span class="line">//text=text.replaceAll(&quot;[　]+&quot;, &quot;&quot;);</span><br><span class="line">//    使用Unicode码匹配中文全角空格</span><br><span class="line">text=text.replaceAll(&quot;\u3000+&quot;, &quot;&quot;);</span><br><span class="line">System.out.println(&quot;_______________________________&quot;);</span><br><span class="line">System.out.println(&quot;去除中文全角空格后:&quot;);</span><br><span class="line">System.out.println(text);</span><br></pre></td></tr></table></figure><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">删除空白行之后的文本:</span><br><span class="line">　　BufferedReader in;</span><br><span class="line">　　Pattern pattern = Pattern.compile(&quot;//(//d&#123;3&#125;//)//s//d&#123;3&#125;-//d&#123;4&#125;&quot;);</span><br><span class="line">　　in = new BufferedReader(new FileReader(&quot;phone&quot;));</span><br><span class="line">　　String s;</span><br><span class="line">　　while ((s = in.readLine()) != null)</span><br><span class="line">　　&#123;</span><br><span class="line">　　Matcher matcher = pattern.matcher(s);</span><br><span class="line">　　if (matcher.find())</span><br><span class="line">　　&#123;</span><br><span class="line">　　System.out.println(matcher.group());</span><br><span class="line">　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　in.close();</span><br><span class="line">_______________________________</span><br><span class="line">去除中文全角空格后:</span><br><span class="line">BufferedReader in;</span><br><span class="line">Pattern pattern = Pattern.compile(&quot;//(//d&#123;3&#125;//)//s//d&#123;3&#125;-//d&#123;4&#125;&quot;);</span><br><span class="line">in = new BufferedReader(new FileReader(&quot;phone&quot;));</span><br><span class="line">String s;</span><br><span class="line">while ((s = in.readLine()) != null)</span><br><span class="line">&#123;</span><br><span class="line">Matcher matcher = pattern.matcher(s);</span><br><span class="line">if (matcher.find())</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(matcher.group());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure><p></p><h2 id="启发"><a href="#启发" class="headerlink" title="启发"></a>启发</h2><p>遇到一个不懂的字符的时候可以先把它转为<code>Unicode</code>码，然再查码表,或者网上查。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/9712edd/">String tirm()方法去不掉的空格</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java 正则表达式 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java使用正则表达式是删除空行，空行可能有多个空格</title>
      <link href="/blog/51e02fda/"/>
      <url>/blog/51e02fda/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string.replaceAll(&quot;(?m)^\\s*$(\\n|\\r\\n)&quot;, &quot;&quot;);</span><br></pre></td></tr></table></figure><p><code>(?m)</code>表示开启多行匹配模式，<code>^</code>是行开始，<code>\\s*</code>代表任意个空格，<code>$</code>代表行结束。<br>所以这句话的意思是:<br>&emsp;&emsp;&emsp;&emsp;所有空行(包括有任意空格的行)都会被替换为空字符串，即空行被从字符串中移除。</p><h1 id="移除多余的连续空格，只留下一个空格。"><a href="#移除多余的连续空格，只留下一个空格。" class="headerlink" title="移除多余的连续空格，只留下一个空格。"></a>移除多余的连续空格，只留下一个空格。</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string.replaceAll(&quot;[ ]+&quot;, &quot; &quot;);</span><br></pre></td></tr></table></figure><p><code>[ ]+</code>表示一个或多个空格，<code>&quot; &quot;</code>表示一个空格。这句话的意思就是把多个空格替换为一个空格。<br>原文:<a href="https://blog.csdn.net/kaukiyou/article/details/46829375" target="_blank" rel="noopener">https://blog.csdn.net/kaukiyou/article/details/46829375</a></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/51e02fda/">Java使用正则表达式是删除空行，空行可能有多个空格</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java 正则表达式 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>String类中的正则表达式</title>
      <link href="/blog/12fb64fe/"/>
      <url>/blog/12fb64fe/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><h2 id="String支持正则表达式是的方法"><a href="#String支持正则表达式是的方法" class="headerlink" title="String支持正则表达式是的方法"></a>String支持正则表达式是的方法</h2><p><code>String</code> 有 4 个方法用到了正则表达式 : <code>matches()</code>，<code>split()</code>, <code>replaceFirst()</code>, <code>replaceAll(</code> ),如下表所示。</p><table><thead><tr><th>序号</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td><code>boolean matches(String regex)</code></td><td>告知此字符串是否匹配给定的正则表达式。</td></tr><tr><td>2</td><td><code>String[] split(String regex)</code></td><td>根据给定正则表达式的匹配拆分此字符串。</td></tr><tr><td>3</td><td><code>String[] split(String regex, int limit)</code></td><td>根据匹配给定的正则表达式来拆分此字符串。</td></tr><tr><td>4</td><td><code>String replaceFirst(String regex, String replacement)</code></td><td>使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</td></tr><tr><td>5</td><td><code>String replaceAll(String regex, String replacement)</code></td><td>使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。</td></tr></tbody></table><h2 id="matches-方法"><a href="#matches-方法" class="headerlink" title="matches()方法"></a>matches()方法</h2><p><code>public boolean matches(String regex)</code></p><blockquote><p>告知此字符串是否匹配给定的正则表达式。<br>调用此方法的 <code>str.matches(regex)</code> 形式与以下表达式产生的结果完全相同：<br>&emsp;&emsp;&emsp;&emsp;<code>Pattern.matches(regex, str)</code><br>参数：<br>&emsp;&emsp;&emsp;&emsp;<code>regex</code> - 用来匹配此字符串的正则表达式<br>返回：<br>&emsp;&emsp;&emsp;&emsp;当且仅当此字符串匹配给定的正则表达式时，返回 <code>true</code><br>抛出：<br>&emsp;&emsp;&emsp;&emsp;<code>PatternSyntaxException</code> - 如果正则表达式的语法无效</p></blockquote><h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">String text=<span class="string">"I keep saying no\n"</span>+</span><br><span class="line"><span class="string">"This can't be the way we're supposed to be"</span>;</span><br><span class="line">System.out.println(text.matches(<span class="string">".*saying.*"</span>));</span><br><span class="line">System.out.println(text.matches(<span class="string">".*saying.*\n.*"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p></p><h3 id="拓展：点号-能匹配-r-n之外的任意字符"><a href="#拓展：点号-能匹配-r-n之外的任意字符" class="headerlink" title="拓展：点号.能匹配\r\n之外的任意字符"></a>拓展：点号<code>.</code>能匹配<code>\r\n</code>之外的任意字符</h3><p>你如果奇怪为什么<code>text.matches(&quot;.*saying.*&quot;)</code>不返回<code>true</code>，而是返回<code>flase</code>。那你就误解了点号<code>.</code>的意思了，点号<code>.</code>匹配任意字符是没错，但是这个任意字符不包括换行符<code>\n</code>，回车符<code>\r</code>。所以点号<code>.</code>匹配的是一个除了换行符<code>\n</code>,回车符<code>\r</code>之外的其他字符。<br>实例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public static void testMatchersSpecialCharacter()</span><br><span class="line">&#123;</span><br><span class="line">//字符串中的转义字符有：\b  \t  \n  \f  \r  \&quot;  \&apos;  \\</span><br><span class="line">String text;</span><br><span class="line">//回车符</span><br><span class="line">text=&quot;I keep saying no\r&quot;;</span><br><span class="line">System.out.println(text.matches(&quot;.*saying.*&quot;));</span><br><span class="line">//换行符</span><br><span class="line">text=&quot;I keep saying no\n&quot;;</span><br><span class="line">System.out.println(text.matches(&quot;.*saying.*&quot;));</span><br><span class="line">//\b退格符</span><br><span class="line">text=&quot;I keep saying no\b&quot;;</span><br><span class="line">System.out.println(text.matches(&quot;.*saying.*&quot;));</span><br><span class="line">//\t水平制表符</span><br><span class="line">text=&quot;I keep saying no\t&quot;;</span><br><span class="line">System.out.println(text.matches(&quot;.*saying.*&quot;));</span><br><span class="line">//\f走页符</span><br><span class="line">text=&quot;I keep saying no\f&quot;;</span><br><span class="line">System.out.println(text.matches(&quot;.*saying.*&quot;));</span><br><span class="line">//\&quot;双引号</span><br><span class="line">text=&quot;I keep saying no\&quot;&quot;;</span><br><span class="line">System.out.println(text.matches(&quot;.*saying.*&quot;));</span><br><span class="line">//\&apos;单引号</span><br><span class="line">text=&quot;I keep saying no\&apos;&quot;;</span><br><span class="line">System.out.println(text.matches(&quot;.*saying.*&quot;));</span><br><span class="line">//\\反斜线</span><br><span class="line">text=&quot;I keep saying no\\&quot;;</span><br><span class="line">System.out.println(text.matches(&quot;.*saying.*&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p></p><p>从运行结果中看，点号<code>.</code>可以匹配除了<code>\r</code>,<code>\n</code>之外的其他任意转义字符。</p><p>扯远了，回来继续说<code>String.matchers(regex)</code>方法，源码如下。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String regex)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Pattern.matches(regex, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>所以前面说，调用此方法的 <code>str.matches(regex)</code> 形式与调用<code>Pattern.matches(regex, str)</code>方法产生的结果完全相同,是因为低层还是调用了<code>Pattern.matches(regex, str)</code>方法实现的，也就少传个参数吧。</p><h2 id="split-方法"><a href="#split-方法" class="headerlink" title="split()方法"></a><code>split()</code>方法</h2><p>看源码：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(String regex) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> split(regex, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>可以看到<code>split(regex)</code>方法还是直接调用<code>split(regex, 0);</code>来实现的。</p><p>##split(String regex, int limit)方法##<br>源码：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(String regex, <span class="keyword">int</span> limit) </span><br><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line">    <span class="keyword">return</span> Pattern.compile(regex).split(<span class="keyword">this</span>, limit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>可以看到<code>String.split(regex)</code>方法最终调用了<code>Pattern.compile(regex).split(this, limit);</code>方法(这样说有点不准确)，源码太长了，先不看，去看API吧。</p><blockquote><p><code>public String[] split(String regex,int limit)</code><br>&emsp;&emsp;&emsp;&emsp;&emsp;根据匹配给定的正则表达式来拆分此字符串。</p></blockquote><p>从API中看出：</p><h3 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h3><ul><li>此方法返回一个<strong>String<code>数组</code></strong></li><li>数组中的内容是，该字符串的<code>子字符串</code>.</li><li>数组中的子串按什么分割呢？<strong>按另一个匹配正则表达式的子串(A)分割。</strong></li><li>返回的子串的顺序：按子串在要分割子串中的顺序排列</li><li>如果正则表达式匹配不到任何子串,也就是说找不到作为分割的子串。那就不分割，返回要分割的字符串本身，也就是数组中只有一个元素。</li></ul><h3 id="limit参数："><a href="#limit参数：" class="headerlink" title="limit参数："></a>limit参数：</h3><p>limit 参数控制正则表达式进行匹配的次数，因此影响所得数组的长度。</p><ul><li><p>如果该限制 n 大于 0，则模式将被最多应用 n - 1 次，数组的长度将不会大于 n，而且数组的最后一项将包含所有超出最后匹配的<strong>定界符(匹配正则作为分割的子串)</strong>的输入。</p></li><li><p>如果 n 为小于0，那么模式将被应用尽可能多的次数，而且返回的数组可以是任何长度。</p></li><li><p>如果 n 为 0，那么模式将被应用尽可能多的次数，返回的数组可以是任何长度，并且结尾空字符串将被丢弃。</p></li></ul><blockquote><p>调用此方法的 str.split(regex, n) 形式与以下表达式产生的结果完全相同：<br>Pattern.compile(regex).split(str, n)</p></blockquote><p>例如，字符串 “boo:and:foo” 使用这些参数可生成以下结果：</p><table><thead><tr><th>Regex</th><th>Limit</th><th>结果</th></tr></thead><tbody><tr><td><code>:</code></td><td><code>2</code></td><td><code>{ &quot;boo&quot;, &quot;and:foo&quot; }</code></td></tr><tr><td><code>:</code></td><td><code>-2</code></td><td><code>{ &quot;boo&quot;, &quot;and&quot;, &quot;foo&quot; }</code></td></tr><tr><td><code>:</code></td><td><code>0</code></td><td><code>{ &quot;boo&quot;, &quot;and&quot;, &quot;foo&quot; }</code></td></tr><tr><td><code>o</code></td><td><code>2</code></td><td><code>{ &quot;b&quot;, &quot;o:and:foo&quot; }</code></td></tr><tr><td><code>o</code></td><td><code>-2</code></td><td><code>{ &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot;, &quot;&quot;, &quot;&quot; }</code></td></tr><tr><td><code>o</code></td><td><code>0</code></td><td><code>{ &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot; }</code></td></tr></tbody></table><p>下面写代码验证上面的结果，分为下面两种情况。</p><h3 id="分割符不相邻的情况："><a href="#分割符不相邻的情况：" class="headerlink" title="分割符不相邻的情况："></a>分割符不相邻的情况<code>：</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public static void testSplitLimitGreaterThan0()</span><br><span class="line">&#123;</span><br><span class="line">String text=&quot;boo:and:foo&quot;;</span><br><span class="line">//n=2,最多分割n-1=1次</span><br><span class="line">String[] arr=text.split(&quot;:&quot;,2); </span><br><span class="line">for (String string : arr)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(string);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;-------------------&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void testSplitLimitLessThan0()</span><br><span class="line">&#123;</span><br><span class="line">String text=&quot;boo:and:foo&quot;;</span><br><span class="line">//n=2,分割尽可能多次</span><br><span class="line">String[] arr=text.split(&quot;:&quot;,-2); </span><br><span class="line">for (String string : arr)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(string);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;------------------------------&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void testSplitLimitEqualTo0()</span><br><span class="line">&#123;</span><br><span class="line">String text=&quot;boo:and:foo&quot;;</span><br><span class="line">//n=2,分割尽可能多次</span><br><span class="line">String[] arr=text.split(&quot;:&quot;,0); </span><br><span class="line">for (String string : arr)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(string);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;------------------------------&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">boo</span><br><span class="line">and:foo</span><br><span class="line">-------------------</span><br><span class="line">boo</span><br><span class="line">and</span><br><span class="line">foo</span><br><span class="line">------------------------------</span><br><span class="line">boo</span><br><span class="line">and</span><br><span class="line">foo</span><br><span class="line">------------------------------</span><br></pre></td></tr></table></figure><p></p><h3 id="实例1分隔符相邻的情况-o"><a href="#实例1分隔符相邻的情况-o" class="headerlink" title="实例1分隔符相邻的情况:o:"></a>实例1分隔符相邻的情况:<code>o</code>:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public static void testSplitLimitGreaterThan0Adjacent()</span><br><span class="line">&#123;</span><br><span class="line">String text=&quot;boo:and:foo&quot;;</span><br><span class="line">//n=2,最多分割n-1=1次</span><br><span class="line">String[] arr=text.split(&quot;o&quot;,2); </span><br><span class="line">for (int i=0;i&lt;arr.length;i++)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(i+&quot;--&gt;&quot;+arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;-------------------&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void testSplitLimitLessThan0Adjacent()</span><br><span class="line">&#123;</span><br><span class="line">String text=&quot;boo:and:foo&quot;;</span><br><span class="line">//n=2,分割尽可能多次</span><br><span class="line">String[] arr=text.split(&quot;o&quot;,-2); </span><br><span class="line">for (int i=0;i&lt;arr.length;i++)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(i+&quot;--&gt;&quot;+arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;------------------------------&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void testSplitLimitEqualTo0Adjacent()</span><br><span class="line">&#123;</span><br><span class="line">String text=&quot;boo:and:foo&quot;;</span><br><span class="line">//n=2,分割尽可能多次</span><br><span class="line">String[] arr=text.split(&quot;o&quot;,0); </span><br><span class="line">for (int i=0;i&lt;arr.length;i++)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(i+&quot;--&gt;&quot;+arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;------------------------------&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0--&gt;b</span><br><span class="line">1--&gt;o:and:foo</span><br><span class="line">-------------------</span><br><span class="line">0--&gt;b</span><br><span class="line">1--&gt;</span><br><span class="line">2--&gt;:and:f</span><br><span class="line">3--&gt;</span><br><span class="line">4--&gt;</span><br><span class="line">------------------------------</span><br><span class="line">0--&gt;b</span><br><span class="line">1--&gt;</span><br><span class="line">2--&gt;:and:f</span><br><span class="line">------------------------------</span><br></pre></td></tr></table></figure><p></p><p>分析，</p><p>因为第一个limit参数n=2,最多分割n-1=2-1=1次，所以遇到第一个o分割成：<code>b</code>,<code>o:and:foo</code>就停止分割了。返回数组为{“b”,”o:and:foo”}<br>第二个方法limit参数是n=-2,小于0，将尽可能多的分割下去。</p><ol><li><p>“boo:and:foo”中遇到第一个<code>o</code>的时候，分割为<code>b</code>和<code>o:and:foo</code>。此时结果为<code>{&quot;b&quot;}</code>。</p></li><li><p>然后接着在后面的子串<code>o:and:foo</code>继续匹配分割，匹配到第二个o的时候<code>o</code>:and:foo,由于前面没有子串，所以用空字符串<code>&quot;&quot;</code>代替,也就是分割为<code>&quot;&quot;</code>和<code>:and:foo</code>这两个字符串。此时结果为<code>{&quot;b&quot;,&quot;&quot;}</code>。</p></li><li><p>然后在后面的子串<code>:and:foo</code>中继续匹配分割，匹配到o,”&#58;and&#58;f<code>o</code>o”,然后分割为”<code>:and:f</code>“,和<code>o</code>。此时结果为<code>{&quot;b&quot;,&quot;&quot;,&quot;:and:f&quot;}</code>.</p></li><li><p>然后继续在剩下的子串”<code>o</code>“中匹配,正则表达式<code>o</code>,匹配到<code>o</code>,把它分割为<code>“”</code>和<code>“”</code>。此时没有待匹配的子串了，结束匹配，所以结果为<code>{&quot;b&quot;,&quot;&quot;,&quot;:and:f&quot;,&quot;&quot;,&quot;&quot;}</code>。</p></li></ol><p>第三个方法，limit参数n=0,尽可能多的分割下去，</p><ul><li>前面三步和上面的三步一样，但是到最后一步的时候不一样。</li><li>在剩下的子串”<code>o</code>“中匹配,正则表达式<code>o</code>,匹配到<code>o</code>,把它分割为<code>“”</code>和<code>“”</code>，此时没有待匹配的子串了，结束匹配。因为这是最后一次分割，最后分割的到的这两个字符串是空字符串，就把这两个空字符串<strong>丢弃</strong>,而不是放入数组中。，所以结果为<code>{&quot;b&quot;,&quot;&quot;,&quot;:and:f&quot;}</code>。</li></ul><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>如果作为分割的子串相邻，就会生成空字符串。例如上面的<code>boo:and</code>,如果用<code>o</code>分割，就会在第二个<code>o</code>匹配的时候，因为<code>o:and</code>中分割点<code>o</code>前面没有子串，所以分割出空字符串<code>&quot;&quot;</code>,和<code>&quot;:and:&quot;</code></p><p><code>split(String regex</code>, <code>int limit)</code>方法用法区别在<code>limit</code>的设置上</p><ul><li>如果limit&gt;0，则最多分割limit-1次</li><li>如果limit&lt;0，则尽可能的分割下去，如果结尾的子串正好匹配正则表达式，作为分割符，这样就会被分割成多个空字符串，这些无意义的空字符串同样会放入到数组中返回。</li><li>如果limit=0，则尽可能的分割下去，如果结尾的子串正好匹配正则表达式，作为分割符，这样会分割为空字符串，对于这些结尾生成的空字符串，就会丢弃掉，不放入数组中返回。</li></ul><p>我们可以夸张一点，把”<code>boo:and:foo</code>“改成<code>boo:and:fooooo</code>看看你运行结果就可以很清楚的看到<code>limit&lt;0</code>和<code>limit=0</code>的区别,代码就不贴了，运行结果如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0--&gt;b</span><br><span class="line">1--&gt;</span><br><span class="line">2--&gt;:and:f</span><br><span class="line">3--&gt;</span><br><span class="line">4--&gt;</span><br><span class="line">5--&gt;</span><br><span class="line">6--&gt;</span><br><span class="line">7--&gt;</span><br><span class="line">------------------------------</span><br><span class="line">0--&gt;b</span><br><span class="line">1--&gt;</span><br><span class="line">2--&gt;:and:f</span><br><span class="line">------------------------------</span><br></pre></td></tr></table></figure><p></p><p>所以平常使用的时候为了不分割到空字符串，还是设置<code>limit=0</code>比较好，可以就是直接调用<code>String.split(regex)</code>就行了。</p><h2 id="replaceFirst-方法"><a href="#replaceFirst-方法" class="headerlink" title="replaceFirst()方法"></a>replaceFirst()方法</h2><blockquote><p>String replaceFirst(String regex, String replacement)<br>&emsp;&emsp;&emsp;&emsp;使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。 调用此方法的 str.replaceFirst(regex, repl) 形式与以下表达式产生的结果完全相同：<br>&emsp;&emsp;&emsp;&emsp;<code>Pattern.compile(regex).matcher(str).replaceFirst(repl)</code></p></blockquote><p>源码如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceFirst</span><span class="params">(String regex, String replacement)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Pattern.compile(regex).matcher(<span class="keyword">this</span>).replaceFirst(replacement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这个方法简直人如其名，我不知道该怎么详细些了。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String text=<span class="string">"aaa:hahaha..."</span>;</span><br><span class="line">System.out.println(text.replaceFirst(<span class="string">"aaa"</span>, <span class="string">"I am groot"</span>));</span><br></pre></td></tr></table></figure><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I am groot:hahaha...</span><br></pre></td></tr></table></figure><p></p><h2 id="replaceAll-方法"><a href="#replaceAll-方法" class="headerlink" title="replaceAll()方法"></a>replaceAll()方法</h2><blockquote><p><code>public String replaceAll(String regex,String replacement)</code><br>使用给定的 <code>replacement</code> 替换此字符串所有匹配给定的正则表达式的子字符串。<br>调用此方法的 <code>str.replaceAll(regex, repl)</code> 形式与以下表达式产生的结果完全相同： &emsp;&emsp;&emsp;&emsp;<code>Pattern.compile(regex).matcher(str).replaceAll(repl)</code></p></blockquote><p>源码：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceAll</span><span class="params">(String regex, String replacement)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Pattern.compile(regex).matcher(<span class="keyword">this</span>).replaceAll(replacement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String text=<span class="string">"A:你好\nGtoot:_\nA:额，听不懂\nGroot:_\nA:。。。"</span>;</span><br><span class="line">text=text.replaceAll(<span class="string">"A"</span>, <span class="string">"Tony Stark"</span>);</span><br><span class="line">System.out.println(text.replaceAll(<span class="string">"_"</span>, <span class="string">"I am groot"</span>));</span><br></pre></td></tr></table></figure><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Tony Stark:你好</span><br><span class="line">Gtoot:I am groot</span><br><span class="line">Tony Stark:额，听不懂</span><br><span class="line">Groot:I am groot</span><br><span class="line">Tony Stark:。。。</span><br></pre></td></tr></table></figure><p></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/12fb64fe/">String类中的正则表达式</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java 正则表达式 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java正则表达式</title>
      <link href="/blog/4ea1809c/"/>
      <url>/blog/4ea1809c/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>正则表达式<strong>定义了字符串的模式。</strong><br>正则表达式<strong>可以用来搜索、编辑或处理文本。</strong><br>正则表达式<strong>并不仅限于某一种语言，但是在每种语言中有细微的差别。</strong></p><h2 id="一些正则表达式的实例及描述"><a href="#一些正则表达式的实例及描述" class="headerlink" title="一些正则表达式的实例及描述"></a>一些正则表达式的实例及描述</h2><p><code>Java</code> 正则表达式和 <code>Perl</code> 的是最为相似的。<br><strong>一个字符串其实就是一个简单的正则表达式</strong>，例如 <code>Hello World</code> 正则表达式匹配 “<code>Hello World</code>“ 字符串。</p><p><code>.</code>（点号）也是一个正则表达式，它匹配任何一个字符如：”<code>a</code>“ 或 “<code>1</code>“。<br>下表列出了一些正则表达式的实例及描述：</p><table><thead><tr><th>序号</th><th>正则表达式</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td><code>this is text</code></td><td>匹配字符串 “<code>this is text</code>“，字符串只能匹配它自己，如果有任何一个字符不匹配都会失败，例如不能匹配这个中间有多个空白符的情况字符串”this&emsp;&emsp;&emsp;&emsp;is&emsp;&emsp;&emsp;&emsp; text”</td></tr><tr><td>2</td><td><code>this\s+is\s+text</code></td><td>注意字符串中的 <code>\s+</code>。<br>匹配单词 “<code>this</code>“ 之后，然后后面的 \s+ 可以匹配多个空格，之后匹配 <code>is</code>字符串，再之后 <code>\s+</code> 匹配多个空格然后再跟上 <code>text</code> 字符串。<br>可以匹配这个实例：<code>this is text</code>，也可以匹配字符串”this&emsp;&emsp;&emsp;&emsp;is&emsp;&emsp;&emsp;&emsp; text”</td></tr><tr><td>3</td><td><code>^\d+(\.\d+)?</code></td><td><code>^</code> 定义了该字符串以什么开始<br><code>\d+</code>匹配一个或多个数字<br><code>?</code> 设置括号内的选项是可选的(可以匹配一次或者多次)<br><code>\.</code>匹配 “<code>.</code>“<br>可以匹配的实例：”<code>5</code>“, “<code>1.5</code>“ 和 “<code>2.21</code>“。<br></td></tr></tbody></table><h1 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h1><p><strong>在其他语言中</strong>，<code>\\</code> 表示：我想要在正则表达式中<strong>插入一个普通的</strong>（字面上的）<strong>反斜杠</strong>，请不要给它任何特殊的意义。</p><p>在 Java 中，<code>\\</code>表示：我要<strong>插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。</strong></p><p>所以，<strong>在其他的语言中（如Perl），一个反斜杠 <code>\</code>就足以具有转义的作用，<code>而在 Java 中正则表达式中则需要有两个反斜杠才能被解析为其他语言中的转义作用。</code></strong>也可以简单的理解在 Java 的正则表达式中，两个<code>\\</code>代表其他语言中的一个 <code>\</code>，这也就是为什么表示一位数字的正则表达式是<code>\\d</code>，而表示一个普通的反斜杠是<code>\\\\</code>。<br><strong>正则表达式的特殊字符字符序列如下</strong></p><h2 id="匹配位置"><a href="#匹配位置" class="headerlink" title="匹配位置"></a>匹配位置</h2><table><thead><tr><th>序号</th><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td><code>^</code></td><td>匹配输入字符串开始的位置。如果设置了 <code>RegExp</code> 对象的 <code>Multiline</code> 属性，<code>^</code> 还会与”<code>\n</code>“或”<code>\r</code>“之后的位置匹配。</td></tr><tr><td>2</td><td><code>$</code></td><td>匹配输入字符串结尾的位置。如果设置了 <code>RegExp</code> 对象的 <code>Multiline</code> 属性，$ 还会与”<code>\n</code>“或”<code>\r</code>“之前的位置匹配。</td></tr><tr><td>3</td><td><code>\b</code></td><td>匹配一个字边界，即字与空格间的位置。例如，”<code>er\b</code>“匹配”<code>never</code>“中的”<code>er</code>“，但不匹配”<code>verb</code>“中的”<code>er</code>“。</td></tr></tbody></table><h2 id="匹配单个字符"><a href="#匹配单个字符" class="headerlink" title="匹配单个字符"></a>匹配单个字符</h2><table><thead><tr><th>序号</th><th>匹配单个字符</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td><code>.</code></td><td><strong>匹配除”<code>\r\n</code>“之外的任何单个字符</strong>。若要匹配包括”<code>\r\n</code>“在内的任意字符，请使用诸如”[<code>\s\S</code>]”之类的模式。</td></tr><tr><td>2</td><td><code>[xyz]</code></td><td><strong>字符集</strong>。<strong>匹配括号里包含的任意<code>一个</code>字符</strong>。例如，”[<code>abc</code>]”匹配”<code>plain</code>“中的”<code>a</code>“。</td></tr><tr><td>3</td><td><code>[^xyz]</code></td><td><strong>反向字符集</strong>。<strong>匹配括号里未包含的任何<code>一个</code>字符</strong>。例如，”<code>[^abc]</code>“匹配”<code>plain</code>“中”<code>p</code>“，”<code>l</code>“，”<code>i</code>“，”<code>n</code>“，但不会匹配<code>a</code></td></tr><tr><td>4</td><td><code>[a-z]</code></td><td><strong>范围字符集</strong>。<strong>匹配指定范围内的任何<code>一个</code>字符</strong>。例如，”<code>[a-z]</code>“匹配”<code>a</code>“到”<code>z</code>“范围内的任何<code>一个</code>小写字母。</td></tr><tr><td>5</td><td><code>[^a-z]</code></td><td><strong>反向范围字符集</strong>。<strong>匹配不在指定的范围内的任何一个字符</strong>。例如，”<code>[^a-z]</code>“匹配任何不在”<code>a</code>“到”<code>z</code>“范围内的任何字符。</td></tr></tbody></table><h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><table><thead><tr><th>序号</th><th>量词</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td><code>?</code></td><td>匹配前面的子符或子表达<strong><code>1次</code>或者<code>0次</code></strong>，例如 <code>zo?</code>匹配<code>z</code>或者<code>zo</code>。<code>?</code> 等效于 <code>{0,1}</code>。</td></tr><tr><td>2</td><td><code>*</code></td><td>匹配前面的字符或子表达式<strong><code>0次</code>或者<code>多次</code></strong>。例如，<code>zo*</code> 匹配”<code>z</code>“,”<code>zoo</code>“,”<code>zooo</code>“,<code>...</code>。<code>*</code> 等效于 <code>{0,}</code>。</td></tr><tr><td>3</td><td><code>+</code></td><td>匹配前面的字符或子表达式<strong><code>1次</code>或<code>多次</code></strong>。例如，”<code>zo+</code>“与”<code>zo</code>“和”<code>zoo</code>“匹配，但与”<code>z</code>“不匹配。<code>+</code>等效于 <code>{1,}</code>。</td></tr><tr><td>4</td><td><code>{n}</code></td><td><code>n</code> 是非负整数。<strong>正好匹配 <code>n</code> 次</strong>。例如，”<code>o{2}</code>“与”<code>Bob</code>“中的”<code>o</code>“不匹配，但与”<code>food</code>“中的两个”<code>o</code>“匹配。</td></tr><tr><td>5</td><td><code>{n,}</code></td><td><code>n</code> 是非负整数。<strong>至少匹配 <code>n</code> 次</strong>。例如，”<code>o{2,}</code>“不匹配”<code>Bob</code>“中的”<code>o</code>“，而匹配”<code>foooood</code>“中的所有 <code>o</code>。”<code>o</code>{1,}”等效于”<code>o+</code>“。”<code>o{0,}</code>“等效于”<code>o*</code>“。</td></tr><tr><td>6</td><td><code>{n,m}</code></td><td><code>m</code> 和 <code>n</code> 是非负整数，其中 <code>n &lt;= m</code>。<strong>匹配至少 <code>n</code> 次，至多 <code>m</code> 次</strong>。例如，”<code>o{1,3}</code>“匹配”<code>fooooood</code>“中的头三个 <code>o</code>。’<code>o{0,1}</code>‘ 等效于 ‘<code>o?</code>‘。注意：您不能将空格插入逗号和数字之间。</td></tr><tr><td>7</td><td><code>?</code></td><td>当此字符紧随任何其他限定符（<code>*</code>、<code>+</code>、<code>?</code>、<code>{n}</code>、<code>{n,}</code>、<code>{n,m}</code>）之后时，匹配模式是”非贪心的”。<strong>“非贪心的”模式匹配搜索到的、尽可能短的字符串</strong>，<strong>而默认的”贪心的”模式匹配搜索到的、尽可能长的字符串。</strong>例如，在字符串”<code>oooo</code>“中，”<code>o+?</code>“只匹配单个”<code>o</code>“，而”<code>o</code>+”匹配所有”<code>o</code>“。</td></tr></tbody></table><h2 id="懒惰匹配"><a href="#懒惰匹配" class="headerlink" title="懒惰匹配"></a>懒惰匹配</h2><p>参考：<a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="noopener">http://deerchao.net/tutorials/regex/regex.htm</a><br>解释一下上表的最后一个<code>?</code>的作用，这个<code>?</code>在上面其他量词后面，让原来的量词从尽可能匹配更多的字符，编程尽可能匹配更少的字符。也就是从贪婪的编程懒惰的。</p><p>当正则表达式中包含能接受重复的限定符时，<strong>通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符</strong>。以这个表达式为例：<code>a.*b</code>，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索<code>aabab</code>的话，它会匹配整个字符串<code>aabab</code>。这被称为贪婪匹配。</p><p>有时，我们更需要<strong>懒惰匹配，也就是匹配尽可能少的字符</strong>。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号<code>?</code>。这样<code>.*?</code>就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：</p><p><code>a.*?b</code>匹配最短的，以<code>a</code>开始，以<code>b</code>结束的字符串。如果把它应用于<code>aabab</code>的话，它会匹配<code>aab</code>（第一到第三个字符）和<code>ab</code>（第四到第五个字符）。</p><p>所以，在上面的量词后面都加上问号<code>?</code>，就可以懒惰匹配量词表，如下所示。</p><table><thead><tr><th>懒惰匹配量词</th><th>说明</th></tr></thead><tbody><tr><td><code>*?</code></td><td>重复任意次，但尽可能少重复</td></tr><tr><td><code>+?</code></td><td>重复1次或更多次，但尽可能少重复</td></tr><tr><td><code>??</code></td><td>重复0次或1次，但尽可能少重复</td></tr><tr><td><code>{n,m}?</code></td><td>重复n到m次，但尽可能少重复</td></tr><tr><td><code>{n,}?</code></td><td>重复n次以上，但尽可能少重复</td></tr></tbody></table><h2 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h2><table><thead><tr><th>序号</th><th>反向引用</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td><code>\num</code></td><td>匹配 num，此处的 <code>num 是一个正整数</code>。<strong>到捕获匹配的反向引用</strong>。例如，”<code>(.)\1</code>“匹配两个连续的相同字符。”<code>(a).+\1</code>“匹配<code>axa</code>,<code>abbba</code>等等</td></tr><tr><td>2</td><td><code>\n</code></td><td>标识一个八进制转义码或反向引用。如果 <code>\n</code> 前面至少有 <code>n</code> 个捕获子表达式，那么 <code>n</code> 是反向引用。否则，如果 <code>n</code> 是八进制数 (<code>0-7</code>)，那么 <code>n</code>是八进制转义码。</td></tr></tbody></table><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><h3 id="字符组简写形式"><a href="#字符组简写形式" class="headerlink" title="字符组简写形式"></a>字符组简写形式</h3><table><thead><tr><th>序号</th><th>字符组简写形式</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td><code>\d</code></td><td>数字字符匹配。等效于 <code>[0-9]</code>。</td></tr><tr><td>2</td><td><code>\D</code></td><td>非数字字符匹配。等效于 <code>[^0-9]</code>。</td></tr><tr><td>3</td><td><code>\s</code></td><td>匹配任何空白字符，包括空格、制表符、换页符等。与<code>[ \f\n\r\t\v]</code> 等效。</td></tr><tr><td>4</td><td><code>\S</code></td><td>匹配任何非空白字符。与 <code>[^ \f\n\r\t\v]</code> 等效。</td></tr><tr><td>5</td><td><code>\w</code></td><td>匹配任何字类字符，包括下划线。与”<code>[A-Za-z0-9_]</code>“等效。</td></tr><tr><td>6</td><td><code>\W</code></td><td>与任何非单词字符匹配。与”<code>[^A-Za-z0-9_]</code>“等效。</td></tr></tbody></table><h3 id="不可见字符"><a href="#不可见字符" class="headerlink" title="不可见字符"></a>不可见字符</h3><table><thead><tr><th>序号</th><th>转义字符</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td><code>\</code></td><td>将下一字符标记为特殊字符、文本、向引用或反八进制转义符。例如，”<code>n</code>“匹配字符”<code>n</code>“,而”<code>\n</code>“匹配换行符。序列”<code>\\\\</code>“匹配”<code>\\</code>“，”<code>\\(</code>“匹配”<code>(</code>“。</td></tr><tr><td>2</td><td><code>\b</code></td><td>匹配一个字边界，即字与空格间的位置。例如，”<code>er\b</code>“匹配”<code>never</code>“中的”<code>er</code>“，但不匹配”<code>verb</code>“中的”<code>er</code>“。</td></tr><tr><td>3</td><td><code>\B</code></td><td>非字边界匹配。”<code>er\B</code>“匹配”<code>verb</code>“中的”<code>er</code>“，但不匹配”<code>never</code>“中的”<code>er</code>“。</td></tr><tr><td>10</td><td><code>\t</code></td><td>制表符匹配。与 \x09 和 \cI 等效。</td></tr><tr><td>11</td><td><code>\v</code></td><td>垂直制表符匹配。与 \x0b 和 \cK 等效。</td></tr><tr><td>12</td><td><code>\r</code></td><td>匹配一个回车符。等效于 \x0d 和 \cM。</td></tr><tr><td>13</td><td><code>\n</code></td><td>换行符匹配。等效于 \x0a 和 \cJ。</td></tr><tr><td>14</td><td><code>\f</code></td><td>换页符匹配。等效于 \x0c 和 \cL。</td></tr><tr><td>15</td><td><code>\cx</code></td><td>匹配 x 指示的控制字符。例如，<code>\cM</code> 匹配<code>Control-M</code> 或回车符。<code>x</code> 的值必须在 <code>A-Z</code> 或 <code>a-z</code> 之间。如果不是这样，则假定 <code>c</code> 就是”<code>c</code>“字符本身。</td></tr></tbody></table><h3 id="进制相关"><a href="#进制相关" class="headerlink" title="进制相关"></a>进制相关</h3><table><thead><tr><th>序号</th><th>带进制的转义符</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td><code>\xn</code></td><td>匹配 <code>n</code>，此处的 <code>n</code> 是一<strong>个十六进制转义码</strong>。十六进制转义码必须正好是两位数长。例如，”<code>\x41</code>“匹配”<code>A</code>“。”<code>\x041</code>“与”<code>\x04</code>“<code>&amp;</code>“<code>1</code>“等效。允许在正则表达式中使用 <code>ASCII</code> 代码。</td></tr><tr><td>2</td><td><code>\n</code></td><td>标识一个<strong>八进制转义码或反向引用</strong>。如果 <code>\n</code> 前面至少有 <code>n</code> 个捕获子表达式，那么 <code>n</code> 是反向引用。否则，如果 <code>n</code> 是八进制数 (<code>0-7</code>)，那么 <code>n</code> 是八进制转义码。</td></tr><tr><td>3</td><td><code>\un</code></td><td>匹配 <code>n</code>，其中 <code>n</code> 是以四位十六进制数表示的 <code>Unicode</code> 字符。例如，<code>\u00A9</code> 匹配版权符号 (<code>©</code>)。</td></tr></tbody></table><h1 id="java-使用正则表达式步骤"><a href="#java-使用正则表达式步骤" class="headerlink" title="java 使用正则表达式步骤"></a>java 使用正则表达式步骤</h1><p>参考:<a href="https://www.cnblogs.com/haodawang/p/5967219.html" target="_blank" rel="noopener">https://www.cnblogs.com/haodawang/p/5967219.html</a></p><h2 id="java的regex库常用类"><a href="#java的regex库常用类" class="headerlink" title="java的regex库常用类"></a>java的regex库常用类</h2><p><code>java</code>里提供了一个<code>java.util.regex</code>库，方便于我们在<code>java</code>里操作正则表达式，或者用它来匹配字符串。</p><h3 id="常用类：Pattern和Matcher"><a href="#常用类：Pattern和Matcher" class="headerlink" title="常用类：Pattern和Matcher"></a>常用类：Pattern和Matcher</h3><p>其中比较常用的类有 <code>Pattern</code> 和 <code>Matcher</code> ,<code>Pattern</code>是一个编译好的正则表达式，而<code>Mather</code>是一个正则表达式适配器，<code>Mather</code>的功能很强大，所以我们一般用<code>pattern</code> 来获取一个<code>Matcher</code>对象，然后用<code>Matcher</code>来操作正则表达式。</p><h3 id="Pattern-类和Matcher-类的关系"><a href="#Pattern-类和Matcher-类的关系" class="headerlink" title="Pattern 类和Matcher 类的关系"></a><code>Pattern</code> 类和<code>Matcher</code> 类的关系</h3><p>首先一个<code>Pattern</code>实例订制了一个所用语法与<code>PERL</code>的类似的正则表达式经编译后的模式，然后一个<code>Matcher</code>实例在这个给定的<code>Pattern</code>实例的模式控制下进行字符串的匹配工作。</p><h3 id="PatternSyntaxException-类"><a href="#PatternSyntaxException-类" class="headerlink" title="PatternSyntaxException 类"></a><code>PatternSyntaxException</code> 类</h3><p><code>PatternSyntaxException</code> 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</p><h2 id="通常使用步骤"><a href="#通常使用步骤" class="headerlink" title="通常使用步骤"></a>通常使用步骤</h2><h3 id="创建Pattern对象"><a href="#创建Pattern对象" class="headerlink" title="创建Pattern对象"></a>创建Pattern对象</h3><p>创建<code>pattern</code>的对象是很简单的，但是由于<code>pattern</code>的构造方法是用<code>private</code>声明的，所以我们仅能通过工厂模式的<code>compile()</code>方法来返回一个<code>Pattern</code>的对象,<code>compile</code>可以接收一个正则表达式作为参数。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pattern pattern = Pattern.compile(&quot;[abc]&quot;);</span><br></pre></td></tr></table></figure><p></p><h3 id="创建Matcher对象"><a href="#创建Matcher对象" class="headerlink" title="创建Matcher对象"></a>创建<code>Matcher</code>对象</h3><p>接下来我们创建一个<code>Matcher</code>对象。<code>Matcher</code>的构造方法也是一个<code>private</code>方法，但是我们可以通过<code>Pattern</code>的<code>Matcher</code>方法来返回一个<code>Matcher</code>对象。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Matcher matcher = pattern.matcher(&quot;hello abc&quot;);</span><br></pre></td></tr></table></figure><p></p><p>这里<code>matcher</code>可以接收一个字符串作为参数，<strong>准确的说这里所接收的参数类型是<code>CharSequences</code>接口类型的参数</strong>，<code>String</code>、<code>StringBuffer</code>、<code>StringBuilder</code>还有<code>CharBuffer</code>都实现了<code>CharSequence</code>接口，因此这四种类型的对象都可以传入。</p><h3 id="简便用法"><a href="#简便用法" class="headerlink" title="简便用法"></a>简便用法</h3><p>与此同时<code>Pattern</code>还提供了一个<code>matches</code> 静态方法(<code>Pattern.matches(regex, input)</code>)，它允许我们传入一个<code>String</code>类型的正则表达式和一个<code>String</code>类型的需要匹配的字符串，并返回一个<code>boolean</code>类型的值，这个方法的好处在于我们可以不用创建<code>pattern</code>对象和<code>matcher</code>对象就可以知道所传入的正则表达式能不能匹配所传入的字符串。</p><p>####实例####<br>使用了正则表达式 <code>.*groot.*</code>判断字符串中是否包了 groot 这个子串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegexExample1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String content = <span class="string">"I am groot"</span>;</span><br><span class="line">        String pattern = <span class="string">".*groot.*"</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isMatch = Pattern.matches(pattern, content);</span><br><span class="line">        System.out.println(<span class="string">"字符串中是否包含了 'groot' 子字符串? "</span> + isMatch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例输出结果为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串中是否包含了 &apos;groot&apos; 子字符串? true</span><br></pre></td></tr></table></figure><p></p><p>创建Matcher类对象后就可使用Matcher类许多强大的方法了。</p><h1 id="Matcher-类的主要方法介绍"><a href="#Matcher-类的主要方法介绍" class="headerlink" title="Matcher 类的主要方法介绍"></a>Matcher 类的主要方法介绍</h1><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>说到<code>Matcher</code>,这个东西就很强大了，我们比较常用的方法有:</p><ul><li><code>find();</code></li><li><code>group();</code></li></ul><p>(1)先来说一下<code>find()</code>和<code>group</code>这两个方法。<br><code>find</code>有点像一个迭代器，它能通过正则表达式向前迭代。而<code>group()</code>方法返回0号分组，也就是整个正则表达式匹配的文本。<br>下来看一个例子<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testFindGroup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Pattern pattern = Pattern.compile(<span class="string">"\\d+"</span>);</span><br><span class="line">    Matcher matcher = pattern.matcher(<span class="string">"aaa 111 bbbb 222 333 ccc"</span>);</span><br><span class="line">    <span class="comment">//find向前迭代,查找匹配的字符串</span></span><br><span class="line">    <span class="keyword">while</span>(matcher.find())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取匹配正则表达式的子串</span></span><br><span class="line">        System.out.println(matcher.group());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">111</span><br><span class="line">222</span><br><span class="line">333</span><br></pre></td></tr></table></figure><p></p><p>可以看到这和<code>Matcher.find()</code>和<code>Scanner.hasnext()</code>方法类似，而<code>Matcher.group()</code>和<code>Scanner.next()</code>方法类似。</p><h2 id="捕获组"><a href="#捕获组" class="headerlink" title="捕获组"></a>捕获组</h2><p>捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。</p><p>例如，正则表达式 (dog) 创建了单一分组，组里包含”d”，”o”，和”g”。</p><p><strong>捕获组是通过从左至右计算其开括号来编号</strong>。例如，在表达式<code>((A)(B(C))）</code>，有四个这样的组：</p><ul><li><code>((A)(B(C)))</code></li><li><code>(A)</code></li><li><code>(B(C))</code></li><li><code>(C)</code></li></ul><p>可以通过调用 <code>matcher</code> 对象的 <code>groupCount()</code>方法来查看表达式有多少个分组。<code>groupCount()</code> 方法返回一个 <code>int</code> 值，表示<code>matcher</code>对象当前有多个捕获组。</p><p>还有一个特殊的组（<code>group(0)</code>），它总是代表整个表达式。该组不包括在 <code>groupCount</code> 的返回值中。</p><table><thead><tr><th>序号</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td><code>public int groupCount()</code></td><td>返回此匹配器模式中的捕获组数。根据惯例，零组表示整个模式。它不包括在此计数中。</td></tr><tr><td>2</td><td><code>String group()</code></td><td>返回0号捕获组，也就是整个表达式匹配的字符串</td></tr><tr><td>3</td><td><code>String group(int group)</code></td><td>返回指定捕获组捕获到的子串</td></tr></tbody></table><h3 id="捕获组实例"><a href="#捕获组实例" class="headerlink" title="捕获组实例"></a>捕获组实例</h3><h4 id="查看正则表达式中有多到个捕获组"><a href="#查看正则表达式中有多到个捕获组" class="headerlink" title="查看正则表达式中有多到个捕获组"></a>查看正则表达式中有多到个捕获组</h4><p><code>int groupCount()</code>方法：返回此匹配器模式中的捕获组数.不包括0捕获组<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGroupCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Pattern pattern = Pattern.compile(<span class="string">"(\\w+)(\\s+)([0-9]+)"</span>);</span><br><span class="line">       Matcher matcher = pattern.matcher(<span class="string">"aaa 111 bbbb 222 333 ccc"</span>);</span><br><span class="line">       System.out.println(pattern.toString()+<span class="string">"这个正则表达式捕获组数目:"</span>+matcher.groupCount());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(\w+)(\s+)([0-9]+)这个正则表达式捕获组数目:3</span><br></pre></td></tr></table></figure><p></p><h4 id="捕获方法group-和group-int-group-实例"><a href="#捕获方法group-和group-int-group-实例" class="headerlink" title="捕获方法group()和group(int group)实例"></a>捕获方法group()和group(int group)实例</h4><p><strong>下面的例子说明如何从一个给定的字符串中捕获数字串：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package java1.regex.test;</span><br><span class="line"></span><br><span class="line">import java.util.regex.Matcher;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line">public class RegexMatches</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String args[])</span><br><span class="line">&#123;</span><br><span class="line">// 按指定模式在字符串查找</span><br><span class="line">String line = &quot;I hope that 2018 is also a year full of hope.&quot;;</span><br><span class="line">String pattern = &quot;(\\D*)(\\d+)(.*)&quot;;</span><br><span class="line">// 创建 Pattern 对象</span><br><span class="line">Pattern r = Pattern.compile(pattern);</span><br><span class="line">// 现在创建 matcher 对象</span><br><span class="line">Matcher m = r.matcher(line);</span><br><span class="line">if (m.find())</span><br><span class="line">&#123;</span><br><span class="line">//默认匹配捕获整个表达式-调用m.group(0);</span><br><span class="line">System.out.println(m.group());</span><br><span class="line">System.out.println(&quot;第0个分组: &quot; + m.group(0));</span><br><span class="line">System.out.println(&quot;第1个分组: &quot; + m.group(1));</span><br><span class="line">System.out.println(&quot;第2个分组: &quot; + m.group(2));</span><br><span class="line">System.out.println(&quot;第3个分组: &quot; + m.group(3));</span><br><span class="line">&#125; else</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;NO MATCH&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实例编译运行结果如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第0个分组: I hope that 2018 is also a year full of hope.</span><br><span class="line">第1个分组: I hope that </span><br><span class="line">第2个分组: 2018</span><br><span class="line">第3个分组:  is also a year full of hope.</span><br></pre></td></tr></table></figure><p></p><p>这里要注意的是<strong>第0个分组捕获的是整个正则表达式匹配到的字符串</strong>，而子字符串的捕获是从第1个分组开始的。<strong>使用无参的捕获函数group()默认捕获0号分组</strong>，看源码就知道了：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public String group() &#123;</span><br><span class="line">    return group(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="索引方法"><a href="#索引方法" class="headerlink" title="索引方法"></a>索引方法</h2><p>索引方法提供了有用的索引值，精确表明输入字符串中在哪能找到匹配：</p><table><thead><tr><th>序号</th><th>索引方法</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td><code>public int start()</code></td><td>返回匹配子序列在原序列的起始下标</td></tr><tr><td>2</td><td><code>public int start(int group)</code></td><td>返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引</td></tr><tr><td>3</td><td><code>public int end()</code></td><td>返回匹配子序列在原序列的结束下标</td></tr><tr><td>4</td><td><code>public int end(int group)</code></td><td>返回在以前的匹配操作期间，由给定组所捕获子序列的最后字符之后的偏移量。</td></tr></tbody></table><h3 id="start-和-end-方法"><a href="#start-和-end-方法" class="headerlink" title="start 和 end 方法"></a>start 和 end 方法</h3><ul><li><code>start()</code>是返回匹配成功的子串的第一个字母的索引</li><li>而<code>end()</code>是返回子串最后一个索引的位置+1。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStartEnd1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    String input = <span class="string">"hello_World"</span>;</span><br><span class="line">    Matcher matcher = Pattern.compile(<span class="string">"\\w+_"</span>).matcher(input);</span><br><span class="line">    matcher.find();</span><br><span class="line">    System.out.println(input.charAt(matcher.start()));</span><br><span class="line">    System.out.println(input.charAt(matcher.end()));</span><br><span class="line">    System.out.println(input.charAt(matcher.end()-<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h</span><br><span class="line">W</span><br><span class="line">_</span><br></pre></td></tr></table></figure><p></p><p>从运行中可以看到，end方法返回的是最后匹配的字符<code>_</code>后面的字符<code>W</code>，而不是该字符<code>_</code>本身。</p><h3 id="实例：统计一个单词出现的次数"><a href="#实例：统计一个单词出现的次数" class="headerlink" title="实例：统计一个单词出现的次数"></a>实例：统计一个单词出现的次数</h3><p>下面统计单词 “<code>groot</code>“ 在输入字符串中出现的次数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStartEnd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String regex = <span class="string">"\\bgroot\\b"</span>;</span><br><span class="line">    <span class="keyword">final</span> String text = <span class="string">"I am groot!I am groot!I am groot!I am groot!!!"</span>;</span><br><span class="line"><span class="comment">//  编译表示的正则表达式</span></span><br><span class="line">    Pattern p = Pattern.compile(regex);</span><br><span class="line"><span class="comment">//  获取  matcher  对象</span></span><br><span class="line">    Matcher m = p.matcher(text);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//  boolean  find()</span></span><br><span class="line"><span class="comment">//  尝试查找与该模式匹配的输入序列的下一个子序列。</span></span><br><span class="line"><span class="comment">//  尝试查找与正则表达式匹配的下一个字序列</span></span><br><span class="line">    <span class="keyword">while</span> (m.find())</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(<span class="string">"子序列起始下标:--&gt;"</span> + m.start());</span><br><span class="line">        System.out.println(<span class="string">"成功匹配子序列:"</span> + m.group());</span><br><span class="line">        System.out.println(<span class="string">"子序列结束下标:&lt;--"</span> + m.end());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"总共匹配次数:"</span> + count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实例编译运行结果如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">子序列起始下标:--&gt;5</span><br><span class="line">成功匹配子序列:groot</span><br><span class="line">子序列结束下标:&lt;--10</span><br><span class="line">子序列起始下标:--&gt;16</span><br><span class="line">成功匹配子序列:groot</span><br><span class="line">子序列结束下标:&lt;--21</span><br><span class="line">子序列起始下标:--&gt;27</span><br><span class="line">成功匹配子序列:groot</span><br><span class="line">子序列结束下标:&lt;--32</span><br><span class="line">子序列起始下标:--&gt;38</span><br><span class="line">成功匹配子序列:groot</span><br><span class="line">子序列结束下标:&lt;--43</span><br><span class="line">总共匹配次数:4</span><br></pre></td></tr></table></figure><p></p><p>这个例子中使用单词边界，以确保匹配的字符序列是 “<code>g</code>“ ,”<code>r</code>“,”<code>o</code>“,”<code>o</code>“,”<code>t</code>“ 而不会匹配到一个较长的字符串的子串(如 gg<code>groot</code>tttt)。而统计功能是我们通过计数器<code>count</code>实现的。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>出处：<a href="https://zhidao.baidu.com/question/443782938.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/443782938.html</a><br><code>Mathcer.start()/ Matcher.end()/ Matcher.group()</code> <strong>这三个方法必须是在有字符匹配到的条件下才能够调用，否则会报错。</strong></p><ul><li><code>start()</code>返回匹配到的子串在字符串中的索引位置</li><li><code>end()</code>返回匹配到的子串的最后一个字符在字符串中的索引位置+1</li><li><code>group()</code>返回匹配到的子字符串。</li></ul><p><code>start()</code>,<code>end()</code>,<code>group()</code>均有一个重载方法它们是<code>start(int i)</code>,<code>end(int i)</code>,<code>group(int i)</code>专用于分组操作,<code>Mathcer</code>类还有一个<code>groupCount()</code>用于返回有多少组。</p><h2 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h2><p>判断方法用来检查字符串并返回一个布尔值，表示是否匹配该正则表达式：</p><table><thead><tr><th>序号</th><th>判断方法</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td><code>public boolean matches()</code></td><td>只有整个字符序列完全匹配成功才返回<code>true</code></td></tr><tr><td>2</td><td><code>public boolean lookingAt()</code></td><td>总是从第一个字符进行匹配,匹配成功了不再继续匹配，匹配失败了,也不继续匹配。</td></tr><tr><td>3</td><td><code>public boolean find()</code></td><td>尝试查找与该模式匹配的输入序列的下一个子序列。</td></tr><tr><td>4</td><td><code>public boolean find(int start）</code></td><td>重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。</td></tr></tbody></table><h3 id="java-matcher-中find-matches-lookingAt三个方法的区别"><a href="#java-matcher-中find-matches-lookingAt三个方法的区别" class="headerlink" title="java matcher 中find,matches,lookingAt三个方法的区别"></a>java matcher 中find,matches,lookingAt三个方法的区别</h3><p>出处：<a href="https://www.cnblogs.com/wangjunxiao/p/7115559.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangjunxiao/p/7115559.html</a></p><p>在Matcher类中有find都是匹配目标的方法，但容易混淆，整理它们的区别如下：</p><ul><li><strong><code>matches()</code>:整个匹配</strong>，matches 要求整个序列，只有整个字符序列完全匹配成功，才返回<code>True</code>，否则返回<code>False</code>。但如果前部分匹配成功，将移动下次匹配的位置。</li><li><strong><code>lookingAt()</code>:部分匹配</strong>，总是从第一个字符进行匹配,匹配成功了不再继续匹配，匹配失败了,也不继续匹配。</li><li><strong><code>find()</code>:部分匹配</strong>，从当前位置开始匹配，找到一个匹配的子串，将移动下次匹配的位置。</li><li><strong><code>reset()</code>:给当前的<code>Matcher</code>对象设置新的位置</strong>，位置是就该方法的参数；如果不给参数，<code>reset</code>会把<code>Matcher</code>设到当前字符串的开始处。</li></ul><p>验证代码如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testFindLookingAtMatcher</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Pattern pattern = Pattern.compile(<span class="string">"\\d&#123;3,5&#125;"</span>);</span><br><span class="line">    String charSequence = <span class="string">"123-34345-234-00"</span>;</span><br><span class="line">    Matcher matcher = pattern.matcher(charSequence);</span><br><span class="line">    System.out.println(<span class="string">"待匹配字符序列:"</span>+charSequence);</span><br><span class="line">    System.out.println(<span class="string">"正则表达式:"</span>+pattern.toString());</span><br><span class="line">    <span class="comment">//虽然匹配失败，但由于charSequence里面的"123"和pattern是匹配的,所以下次的匹配从位置4开始</span></span><br><span class="line">    System.out.println(<span class="string">"matcher.matches()返回:"</span>+matcher.matches());</span><br><span class="line">    <span class="comment">//查找匹配位置</span></span><br><span class="line">    matcher.find();</span><br><span class="line">    System.out.println(<span class="string">"当前位置:"</span>+matcher.start());</span><br><span class="line">    <span class="comment">//使用reset方法重置匹配位置</span></span><br><span class="line">    matcher.reset();</span><br><span class="line">    <span class="comment">//第一次find匹配以及匹配的目标和匹配的起始位置</span></span><br><span class="line">    System.out.println(<span class="string">"matcher.find()返回:"</span>+matcher.find());</span><br><span class="line">    System.out.println(<span class="string">"捕获所有匹配的到子串:"</span>+matcher.group()+<span class="string">",位置:"</span>+matcher.start());</span><br><span class="line">    <span class="comment">//第二次find匹配以及匹配的目标和匹配的起始位置</span></span><br><span class="line">    System.out.println(<span class="string">"matcher.find()返回:"</span>+matcher.find());</span><br><span class="line">    System.out.println(<span class="string">"捕获到子串:"</span>+matcher.group()+<span class="string">",位置:"</span>+matcher.start());</span><br><span class="line">    System.out.println(<span class="string">"#####################################################"</span>);</span><br><span class="line">    <span class="comment">//第一次lookingAt匹配以及匹配的目标和匹配的起始位置</span></span><br><span class="line">    System.out.println(<span class="string">"matcher.lookingAt()返回:"</span>+matcher.lookingAt());</span><br><span class="line">    System.out.println(<span class="string">"捕获所有匹配的子串:"</span>+matcher.group()+<span class="string">",位置:"</span>+matcher.start());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第二次lookingAt匹配以及匹配的目标和匹配的起始位置</span></span><br><span class="line">    System.out.println(<span class="string">"matcher.lookingAt()返回:"</span>+matcher.lookingAt());</span><br><span class="line">    System.out.println(<span class="string">"捕获所有匹配的子串:"</span>+matcher.group()+<span class="string">",位置:"</span>+matcher.start());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">待匹配字符序列:123-34345-234-00</span><br><span class="line">正则表达式:\d&#123;3,5&#125;</span><br><span class="line">matcher.matches()返回:false</span><br><span class="line">当前位置:4</span><br><span class="line">matcher.find()返回:true</span><br><span class="line">捕获所有匹配的到子串:123,位置:0</span><br><span class="line">matcher.find()返回:true</span><br><span class="line">捕获到子串:34345,位置:4</span><br><span class="line">#####################################################</span><br><span class="line">matcher.lookingAt()返回:true</span><br><span class="line">捕获所有匹配的子串:123,位置:0</span><br><span class="line">matcher.lookingAt()返回:true</span><br><span class="line">捕获所有匹配的子串:123,位置:0</span><br></pre></td></tr></table></figure><h2 id="替换方法"><a href="#替换方法" class="headerlink" title="替换方法"></a>替换方法</h2><p>api看的我有点晕头转向，个人总结如下。<br>|序号|方法|描述|<br>|-|-|-|<br>|1|<code>public String replaceAll(String replacement)</code>|用<code>replacement</code>替换正则表达式匹配到的所有子串|<br>|2|<code>public String replaceFirst(String replacement)</code>|用<code>replacement</code>替换正则表达式匹配到的第一个子串|<br>|3|<code>public Matcher appendReplacement(StringBuffer sb, String replacement)</code>|实现非终端添加和替换步骤。|<br>|4|<code>public StringBuffer appendTail(StringBuffer sb)</code>|实现终端添加和替换步骤。|<br>|5|<code>public static String quoteReplacement(String s)</code>|返回指定字符串的字面替换字符串。这个方法返回一个字符串，就像传递给Matcher类的appendReplacement 方法一个字面字符串一样工作。|</p><h3 id="replaceFirst-和-replaceAll-方法"><a href="#replaceFirst-和-replaceAll-方法" class="headerlink" title="replaceFirst 和 replaceAll 方法"></a>replaceFirst 和 replaceAll 方法</h3><p><code>replaceFirst</code> 和 <code>replaceAll</code> 方法用来替换匹配正则表达式的文本。不同的是，<code>replaceFirst</code> 替换首次匹配的子串，<code>replaceAll</code> 替换所有匹配的子串。<br>看下面的例子：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testReplaceAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    String regex = <span class="string">"dog"</span>;</span><br><span class="line">    String input = <span class="string">"The dog says meow. "</span> + <span class="string">"All dogs say meow."</span>;</span><br><span class="line">    String replace = <span class="string">"cat"</span>;</span><br><span class="line">    Pattern p = Pattern.compile(regex);</span><br><span class="line"><span class="comment">//  get  a  matcher  object</span></span><br><span class="line">    Matcher m = p.matcher(input);</span><br><span class="line">    input = m.replaceAll(replace);</span><br><span class="line">    System.out.println(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The cat says meow. All cats say meow.</span><br></pre></td></tr></table></figure><p></p><h3 id="appendReplacement-和-appendTail-方法"><a href="#appendReplacement-和-appendTail-方法" class="headerlink" title="appendReplacement 和 appendTail 方法"></a>appendReplacement 和 appendTail 方法</h3><p>参考：<a href="https://blog.csdn.net/key_xyes/article/details/78705181" target="_blank" rel="noopener">https://blog.csdn.net/key_xyes/article/details/78705181</a></p><ul><li><code>appendReplacement(sb,replacement)</code>方法中：<code>sb</code>是一个<code>StringBuffer</code>，<code>replacement</code>用于替换的字符串，这个方法会把匹配到的子串替换为<code>replacement</code>，并且把从上次替换的位置到这次替换位置之间的字符串也拿到，然后，加上这次替换后的结果一起追加到<code>StringBuffer</code>里（假如这次替换是第一次替换，那就是只追加替换后的字符串啦）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Matcher <span class="title">appendReplacement</span><span class="params">(StringBuffer sb,String replacement)</span></span></span><br></pre></td></tr></table></figure><p><code>appendTail(StringBuffer sb)</code>方法:这个方法是把原来文本中最后一次匹配到的内容之后的字符串追加到<code>StringBuffer</code>中。</p><p>两个方法一起使用就可以达到所有替换或者替换第一个：</p><p>全部替换：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//find()方法向前查找匹配的子串</span></span><br><span class="line"><span class="keyword">while</span>(m.find())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取位置在匹配子串之前的文本strbefore，获取匹配的子串strmacther，然后把匹配的子串strmacther替换为replacement，</span></span><br><span class="line">    <span class="comment">//然后(strbefore+replacement)追加到StringBuffer中</span></span><br><span class="line">    m.appendReplacement(sb,replacement);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把文本中没有匹配的剩下的文本也加入到StringBuffer中</span></span><br><span class="line">m.appendTail(sb);</span><br></pre></td></tr></table></figure><p></p><p>替换第一个：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (matcher.find())</span><br><span class="line">&#123;</span><br><span class="line">    matcher.appendReplacement(sb, replacement);</span><br><span class="line">&#125;</span><br><span class="line">matcher.appendTail(sb);</span><br></pre></td></tr></table></figure><p></p><p><strong>实例1：全部替换</strong><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAppendReplace_Tail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Pattern p = Pattern.compile(<span class="string">"a"</span>);</span><br><span class="line">    String text=<span class="string">"before_ONEa_TWOa_THREEa_End"</span>;</span><br><span class="line">    Matcher m = p.matcher(text);</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">while</span> (m.find())</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//      获取位置在匹配子串之前的文本strbefore，获取匹配的子串strmacther，然后把匹配的子串strmacther替换为replacement，</span></span><br><span class="line"><span class="comment">//      然后之前的文本和替换文本一起(strbefore+replacement)追加到StringBuffer中</span></span><br><span class="line">        System.out.println(<span class="string">"替换之前StringBuffer中的内容--&gt;"</span> + sb);</span><br><span class="line">        m.appendReplacement(sb, <span class="string">"A"</span>);</span><br><span class="line">        System.out.println(<span class="string">"替换之后StringBuffer中的内容--&gt;"</span> + sb);</span><br><span class="line">        System.out.println(<span class="string">"---------------------------------------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//原来文本中把上次匹配结束位置之后剩下的字符串也写到StringBuffer中</span></span><br><span class="line">    System.out.println(<span class="string">"#######################################"</span>);</span><br><span class="line">    System.out.println(<span class="string">"替换之前StringBuffer中的内容--&gt;"</span> + sb);</span><br><span class="line">    m.appendTail(sb);</span><br><span class="line">    System.out.println(<span class="string">"替换之后StringBuffer中的内容--&gt;"</span> + sb);</span><br><span class="line">    System.out.println(<span class="string">"替换之前的文本:"</span>+text);</span><br><span class="line">    System.out.println(<span class="string">"全部替换之后的:"</span> + sb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">替换之前StringBuffer中的内容--&gt;</span><br><span class="line">替换之后StringBuffer中的内容--&gt;before_ONEA</span><br><span class="line">---------------------------------------------</span><br><span class="line">替换之前StringBuffer中的内容--&gt;before_ONEA</span><br><span class="line">替换之后StringBuffer中的内容--&gt;before_ONEA_TWOA</span><br><span class="line">---------------------------------------------</span><br><span class="line">替换之前StringBuffer中的内容--&gt;before_ONEA_TWOA</span><br><span class="line">替换之后StringBuffer中的内容--&gt;before_ONEA_TWOA_THREEA</span><br><span class="line">---------------------------------------------</span><br><span class="line">#######################################</span><br><span class="line">替换之前StringBuffer中的内容--&gt;before_ONEA_TWOA_THREEA</span><br><span class="line">替换之后StringBuffer中的内容--&gt;before_ONEA_TWOA_THREEA_End</span><br><span class="line">替换之前的文本:before_ONEa_TWOa_THREEa_End</span><br><span class="line">全部替换之后的:before_ONEA_TWOA_THREEA_End</span><br></pre></td></tr></table></figure><p></p><p><strong>分析：</strong><br><strong>while语句：</strong></p><ul><li><p>第一次替换:sb中是没有内容的，find()方法匹配到before_ONE<code>a</code>_TWOa_THREEa_End,这个时候，获取匹配文本前面的字符串<code>before_NO</code>，然后把匹配文本<code>a</code>替换成<code>A</code>,前面的字符串<code>before_NO</code>和替换文本<code>A</code>组成<code>before_NOA</code>追加到StringBuffer中。</p></li><li><p>第二次替换:sb中的内容为<code>before_NOA</code>,find()方法匹配到before_ONEa_TWO<code>a</code>_THREEa_End，同样获取前面没有匹配的文本<code>_TWO</code>(做法是获取从find()方法上次结束的位置,到这次find()方法开始位置之间的字符串：before_ONEa<code>_TWO</code>a_THREEa_End),然后把<code>a</code>替换成<code>A</code>,这样组成新的文本呢<code>_TWOA</code>,追加到StringBuffer中，这样就形成<code>before_NOA_TWOA</code></p></li><li><p>find()方法会一直向前匹配子串，然后替换,如此类推，直到所有的替换完成</p></li></ul><p>因为原来文本中还有剩下的没有匹配的内容，before_ONEa_TWOa_THREEa<code>_End</code>，<br>使用m.appendTail(sb);把这剩下的内容<code>_End</code>也追加到StringBuffer中，这样就实现全部替换了。</p><p><strong>实例2：替换第一次</strong><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAppendReplace_TailFrist</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Pattern p = Pattern.compile(<span class="string">"a"</span>);</span><br><span class="line">    String text=<span class="string">"before_ONEa_TWOa_THREEa_End"</span>;</span><br><span class="line">    Matcher m = p.matcher(text);</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">if</span>(m.find())</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//      获取匹配子串之前的文本strbefore，获取匹配的子串strmacther，然后把匹配的子串strmacther替换为replacement，</span></span><br><span class="line"><span class="comment">//      然后(strbefore+replacement)追加到StringBuffer中</span></span><br><span class="line">        System.out.println(<span class="string">"替换之前StringBuffer中的内容--&gt;"</span> + sb);</span><br><span class="line">        m.appendReplacement(sb, <span class="string">"A"</span>);</span><br><span class="line">        System.out.println(<span class="string">"替换之后StringBuffer中的内容--&gt;"</span> + sb);</span><br><span class="line">        System.out.println(<span class="string">"---------------------------------------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//原来文本中把上次匹配结束位置之后剩下的字符串也写到StringBuffer中</span></span><br><span class="line">    System.out.println(<span class="string">"#######################################"</span>);</span><br><span class="line">    System.out.println(<span class="string">"上述替换完成后StringBuffer中的内容------&gt;"</span> + sb);</span><br><span class="line">    m.appendTail(sb);</span><br><span class="line">    System.out.println(<span class="string">"加上文本中剩余子串后StringBuffer中的内容--&gt;"</span> + sb);</span><br><span class="line">    System.out.println(<span class="string">"替换之前的文本:"</span>+text);</span><br><span class="line">    System.out.println(<span class="string">"全部替换之后的:"</span> + sb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">替换之前StringBuffer中的内容--&gt;</span><br><span class="line">替换之后StringBuffer中的内容--&gt;before_ONEA</span><br><span class="line">---------------------------------------------</span><br><span class="line">#######################################</span><br><span class="line">上述替换完成后StringBuffer中的内容------&gt;before_ONEA</span><br><span class="line">加上文本中剩余子串后StringBuffer中的内容--&gt;before_ONEA_TWOa_THREEa_End</span><br><span class="line">替换之前的文本:before_ONEa_TWOa_THREEa_End</span><br><span class="line">全部替换之后的:before_ONEA_TWOa_THREEa_End</span><br></pre></td></tr></table></figure><p></p><p>这里我们只替换了第一次，before_ONE<code>a</code>_TWOa_THREEa_End,然后StringBuffer中处理完毕的文本为<code>before_ONEA</code>，未处理的文本为<code>_TWOa_THREEa_End</code>，最后调用m.appendTail(sb);把未处理的文本也追加入到StringBuffer中，处理完毕的文本为:<code>before_ONEA_TWOa_THREEa_End</code></p><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><ul><li><code>find()</code>方法匹配子串的时候都会<strong>记下</strong>本次成功<strong>匹配子串的<code>开始位置</code>和<code>结束位置</code></strong></li><li><code>appendReplacement(sb</code>,<code>replacement)</code>方法先获取所有<code>从上次结束位置，到本次结束位置的所有字符串</code>，然后<code>替换其中匹配的部分</code>，最后追加到<code>sb</code>中。</li><li><code>appendReplacement(sb)</code>方法把结束位置到文本结尾的所有字符追加到<code>sb</code>中。</li><li>使用appendReplace()和appendTail()方法可以更加灵活的进行替换操作，注意要结合find()方法使用。</li></ul><p>本文链接: <a href="https://www.lansheng.net.cn/blog/4ea1809c/">Java正则表达式</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java 正则表达式 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java正则表达式应用</title>
      <link href="/blog/aa025735/"/>
      <url>/blog/aa025735/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>参考：<a href="https://www.cnblogs.com/lzq198754/p/5780340.html" target="_blank" rel="noopener">https://www.cnblogs.com/lzq198754/p/5780340.html</a></p><h2 id="匹配验证-验证Email是否正确"><a href="#匹配验证-验证Email是否正确" class="headerlink" title="匹配验证-验证Email是否正确"></a>匹配验证-验证Email是否正确</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testEmail</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 要验证的字符串</span></span><br><span class="line">    String str = <span class="string">"service@xsoftlab.net"</span>;</span><br><span class="line">    <span class="comment">// 邮箱验证规则</span></span><br><span class="line"><span class="comment">//    String regEx = "[a-zA-Z_]&#123;1,&#125;[0-9]&#123;0,&#125;@(([a-zA-z0-9]-*)&#123;1,&#125;\\.)&#123;1,3&#125;[a-zA-z\\-]&#123;1,&#125;";</span></span><br><span class="line">    String regEx = <span class="string">"[a-zA-Z_]+[0-9]*@(\\w*\\.)&#123;1,3&#125;[a-zA-z\\-]&#123;1,&#125;"</span>;</span><br><span class="line">    <span class="comment">// 编译正则表达式</span></span><br><span class="line">    Pattern pattern = Pattern.compile(regEx);</span><br><span class="line">    <span class="comment">// 忽略大小写的写法</span></span><br><span class="line">    <span class="comment">// Pattern pat = Pattern.compile(regEx, Pattern.CASE_INSENSITIVE);</span></span><br><span class="line">    Matcher matcher = pattern.matcher(str);</span><br><span class="line">    <span class="comment">// 字符串是否与正则表达式相匹配</span></span><br><span class="line">    <span class="keyword">boolean</span> rs = matcher.matches();</span><br><span class="line">    System.out.println(rs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure><p></p><h2 id="在字符串中查询字符或者字符串"><a href="#在字符串中查询字符或者字符串" class="headerlink" title="在字符串中查询字符或者字符串"></a>在字符串中查询字符或者字符串</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void testFind()</span><br><span class="line">&#123;</span><br><span class="line">// 要验证的字符串</span><br><span class="line">    String str = &quot;baike.xsoftlab.net&quot;;</span><br><span class="line">    // 正则表达式规则</span><br><span class="line">    String regEx = &quot;Baike.*&quot;;</span><br><span class="line">    // 编译正则表达式</span><br><span class="line">//    Pattern pattern = Pattern.compile(regEx);</span><br><span class="line">    // 编译正则表达式忽略大小写的</span><br><span class="line">     Pattern pattern = Pattern.compile(regEx, Pattern.CASE_INSENSITIVE);</span><br><span class="line">    Matcher matcher = pattern.matcher(str);</span><br><span class="line">    // 查找字符串中是否有匹配正则表达式的字符/字符串</span><br><span class="line">    boolean rs = matcher.find();</span><br><span class="line">    System.out.println(rs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure><p></p><h2 id="3常用正则表达式"><a href="#3常用正则表达式" class="headerlink" title="3常用正则表达式"></a>3常用正则表达式</h2><table><thead><tr><th>规则</th><th>正则表达式语法</th></tr></thead><tbody><tr><td>一个或多个汉字</td><td>^[\u0391-\uFFE5]+$</td></tr><tr><td>邮政编码</td><td>^[1-9]\d{5}$</td></tr><tr><td>QQ号码</td><td>^[1-9]\d{4,10}$</td></tr><tr><td>邮箱</td><td>^[a-zA-Z_]{1,}[0-9]{0,}@(([a-zA-z0-9]-*){1,}.){1,3}[a-zA-z-]{1,}$</td></tr><tr><td>用户名（字母开头 + 数字/字母/下划线）</td><td>^[A-Za-z][A-Za-z1-9_-]+$</td></tr><tr><td>手机号码</td><td>^1[3&#124;4&#124;5&#124;8][0-9]\d{8}$</td></tr><tr><td>URL</td><td>^((http&#124;https)://)?([\w-]+.)+[\w-]+(/[\w-./?%&amp;=]*)?$</td></tr><tr><td>18位身份证号</td><td>^(\d{6})(18&#124;19&#124;20)?(\d{2})([01]\d)([0123]\d)(\d{3})(\d&#124;X&#124;x)?$</td></tr></tbody></table><p><a href="https://blog.csdn.net/u013553529/article/details/51024733" target="_blank" rel="noopener">表格中如何加入竖线</a></p><h1 id="JAVA正则表达式练习题（IP地址排序、检验email地址）"><a href="#JAVA正则表达式练习题（IP地址排序、检验email地址）" class="headerlink" title="JAVA正则表达式练习题（IP地址排序、检验email地址）"></a>JAVA正则表达式练习题（IP地址排序、检验email地址）</h1><p>原文：<a href="https://blog.csdn.net/sinat_36713319/article/details/53463120" target="_blank" rel="noopener">https://blog.csdn.net/sinat_36713319/article/details/53463120</a></p><h2 id="删除重复字符"><a href="#删除重复字符" class="headerlink" title="删除重复字符"></a>删除重复字符</h2><p>1、需求： 将“我我我、、、我我、、我要、我要要、、、要要要、、要要、、学学学、、、、学学编、、、学编编编、、编编编程、、程程”还原成：我要学编程<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testRaplaceDuplicateWord</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    String temp = <span class="string">"我我我、、、我我、、我要、要要、、、要要要、、要要、、学学学、、、、学学编、、、编编编、、编编编程、、程程"</span>;</span><br><span class="line">    temp = temp.replaceAll(<span class="string">"(、+)"</span>, <span class="string">""</span>);</span><br><span class="line">    System.out.println(temp);</span><br><span class="line">    temp = temp.replaceAll(<span class="string">"(.)\\1+"</span>, <span class="string">"$1"</span>);</span><br><span class="line">    System.out.print(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>来解释一下这个<code>(.)\\1+</code>正则表达还是的意思，</p><ul><li><code>(.)</code>:捕获一个任意字符</li><li><code>\1</code>反向引用,表示前面捕获的字符</li><li><code>+</code>表示前面的字符出现1此或多次<br>这句话的意思就是,匹配两个或者两个以上的重复的字符</li></ul><p>然后<code>$1</code>表示第一个捕获组中的内容，也就是捕获到的这个字符。<br>所以<code>temp.replaceAll(&quot;(.)\\1+&quot;, &quot;$1&quot;);</code>这句话的意思就是，把temp字符串中两个或者两个以上的重复字符替换成该字符本身，换句话说就是删除所有重复到的字符。</p><h2 id="对IP地址进行排序"><a href="#对IP地址进行排序" class="headerlink" title="对IP地址进行排序"></a>对IP地址进行排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static void sortIPAddress()</span><br><span class="line">&#123;</span><br><span class="line">String temp = &quot;192.168.1.200 10.10.10.10 10.10.10.11 11.10.10.10 3.3.50.3 127.0.0.1&quot;;</span><br><span class="line">// 对所有的数字全部都在前面补上两个0</span><br><span class="line">temp = temp.replaceAll(&quot;(\\d+)&quot;, &quot;00$1&quot;);</span><br><span class="line">System.out.println(&quot;ip地址:--&gt;&quot;+temp);</span><br><span class="line">// 因为ip地址占3位(\d&#123;3&#125;)捕获后三位,</span><br><span class="line">// 把多余的0删除掉</span><br><span class="line">temp = temp.replaceAll(&quot;0+(\\d&#123;3&#125;)&quot;, &quot;$1&quot;);// 将ip地址补成同样位数</span><br><span class="line">System.out.println(&quot;ip地址:--&gt;&quot;+temp);</span><br><span class="line">// 用空格割</span><br><span class="line">String[] str = temp.split(&quot; +&quot;);</span><br><span class="line">// 排序从大到小排序</span><br><span class="line">Arrays.sort(str);</span><br><span class="line">System.out.println(&quot;从小到大排序:&quot;);</span><br><span class="line">for (String string : str)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(string);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;去掉加上的辅助0&quot;);</span><br><span class="line">for (String ips : str)</span><br><span class="line">//删除多余的0</span><br><span class="line">System.out.println(ips.replaceAll(&quot;0+(\\d+)&quot;, &quot;$1&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ip地址:--&gt;00192.00168.001.00200 0010.0010.0010.0010 0010.0010.0010.0011 0011.0010.0010.0010 003.003.0050.003 00127.000.000.001</span><br><span class="line">ip地址:--&gt;192.168.001.200 010.010.010.010 010.010.010.011 011.010.010.010 003.003.050.003 127.000.000.001</span><br><span class="line">从小到大排序:</span><br><span class="line">003.003.050.003</span><br><span class="line">010.010.010.010</span><br><span class="line">010.010.010.011</span><br><span class="line">011.010.010.010</span><br><span class="line">127.000.000.001</span><br><span class="line">192.168.001.200</span><br><span class="line">去掉加上的辅助0</span><br><span class="line">3.3.50.3</span><br><span class="line">10.10.10.10</span><br><span class="line">10.10.10.11</span><br><span class="line">11.10.10.10</span><br><span class="line">127.0.0.1</span><br><span class="line">192.168.1.20</span><br></pre></td></tr></table></figure><p></p><ul><li>首先来看<code>temp.replaceAll(&quot;(\\d+)&quot;, &quot;00$1&quot;);</code>这句，<code>(\\d+)</code>将捕获到<code>ip</code>地址中除了点号之外的所有数字串，因为ip地址每一位可以是1位数，2位数，3位数，这里先不管使用<code>00$1</code>进行替换，这样每一位就是3位数到5位数。</li><li><code>temp.replaceAll(&quot;0+(\\d{3})&quot;, &quot;$1&quot;);</code>这句，首先<code>\d{3}</code>表示正好匹配<code>3</code>位数，<code>0+</code>一个或者多个<code>0</code>，<code>0+(\\d{3})</code>这个表达式的意思就是，匹配多个0开头，然后后面正好有<code>3</code>位数，把这<code>3</code>位数捕获出来，<code>temp.replaceAll(&quot;0+(\\d{3})&quot;, &quot;$1&quot;);</code>这句话的意思就是捕获最后的3位数，然后用这<code>3</code>位数，<code>替换掉原来的3到5位的数</code></li><li>经过上面两步之后，所有的<code>ip</code>地址都会变成<code>3</code>位数表示的，不足的前面会补<code>0</code>，这样转换的好处就是可以方便的使用<code>Array.sort()</code>方法对这些字符串进行排序。</li><li>注意排序后的字符，都是我们<code>高位补0</code>后的<code>ip</code>地址这与平时的<code>ip</code>地址表示方式不同所以，要把高位的0去掉。</li><li><code>ips.replaceAll(&quot;0+(\\d+)&quot;, &quot;$1&quot;)</code>这句话实现去掉高位的<code>0</code>,高位的0不会被捕获到，高位的<code>0</code>不包含在捕获组<code>$1</code>,这样在进行替换的时候就等于删除了高位的<code>0</code></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>使用替换进行删除或添加元素，就是<code>拿出来又放回去</code></strong>，如果少放了就相当于删除一部分了，如果多方了就是新增了一部分。</p><ul><li>替换删除，<code>以少换多</code>：我们匹配较多的字符，然后只捕获其中较少的一部分，再用捕获到的少量字符替换匹配的较多的字符，这样就等同于删除掉那些没有捕获的部分。这就好比从果篮里拿出几个水果，例如拿出苹果和香蕉，然后我再把苹果放回去，香蕉丢掉。这样果篮里的香蕉就没有了，相当于被删除掉了。</li><li>替换添加，<code>以多换少</code>：我么匹配较少的字符,并且捕获这些字符，然后捕获到的字符加上一些新的字符替换回去。这样等效于添加了字符。例如我现在只拿出雪梨，然后我变出一个芒果，然后雪梨和芒果一起放回果篮里，这样果篮里就多出了一个芒果，而雪梨还是原来的雪梨。</li></ul><p>本文链接: <a href="https://www.lansheng.net.cn/blog/aa025735/">Java正则表达式应用</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java 正则表达式 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>从网页上复制表格生产markdown表格</title>
      <link href="/blog/a84bbd3e/"/>
      <url>/blog/a84bbd3e/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>例如我这里有一个表格：<br><img src="https://i.imgur.com/WqedYrX.png" alt=""><br>表格里的文本是可复制的，复制下来的文本如下。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">序号 方法 描述</span><br><span class="line">1 public URL(String spec) throws MalformedURLException 根据 String 表示形式的地址创建 URL 对象。</span><br><span class="line">2 public URL(String protocol,String host,int port,String file) throws MalformedURLException 创建URL对象，并指定协议protocol，主机host，端口名称port，资源文件名file</span><br><span class="line">3 public URLConnection openConnection() throws IOException 返回一个 URLConnection 对象，它表示到 URL 所引用的远程对象的连接。</span><br><span class="line">4 public final InputStream openStream() throws IOException 打开到此 URL 的连接并返回一个用于从该连接读入的 InputStream</span><br></pre></td></tr></table></figure><p></p><p>现在需要，把这个复制下来的文本生成markdown表格。</p><h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><p>观察这个文本，我发现，每个单元格之间不多不少刚好有两个空白符，所以，只要发现有两个空白符的地方我就认为表格中单元格之间的边界。<br>代码如下所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package regex.tools;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line">import clipboard.util.SysClipboardUtil;</span><br><span class="line"></span><br><span class="line">public class MDtable</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">String text=SysClipboardUtil.getSysClipboardText();</span><br><span class="line">System.out.println(text);</span><br><span class="line">Scanner scanner=new Scanner(text);</span><br><span class="line">String line;</span><br><span class="line">String[] fragments;</span><br><span class="line">System.out.println(&quot;-------------------------------------------&quot;);</span><br><span class="line">boolean flag=true;</span><br><span class="line">while(scanner.hasNextLine())</span><br><span class="line">&#123;</span><br><span class="line">line=scanner.nextLine();</span><br><span class="line">//刚好两个的地方分割</span><br><span class="line">fragments=line.split(&quot;\\s&#123;2&#125;&quot;);</span><br><span class="line">//System.out.println(&quot;line:---&gt;&quot;);</span><br><span class="line">//System.out.println(&quot;fragments:&quot;);</span><br><span class="line">System.out.print(&quot;|&quot;);</span><br><span class="line">for (String string : fragments)</span><br><span class="line">&#123;</span><br><span class="line">System.out.print(string+&quot;|&quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">//打印表格对其方式,使用默认对齐方式</span><br><span class="line">if(flag)</span><br><span class="line">&#123;</span><br><span class="line">System.out.print(&quot;|&quot;);</span><br><span class="line">for(int i=0;i&lt;fragments.length;i++)</span><br><span class="line">&#123;</span><br><span class="line">System.out.print(&quot;-|&quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">flag=false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>复制表格中的文字<br><img src="https://i.imgur.com/TNm26e9.png" alt=""><br>然后运行上面的代码，运行结果如下。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">序号 方法 描述</span><br><span class="line">1 public URL(String spec) throws MalformedURLException 根据 String 表示形式的地址创建 URL 对象。</span><br><span class="line">2 public URL(String protocol,String host,int port,String file) throws MalformedURLException 创建URL对象，并指定协议protocol，主机host，端口名称port，资源文件名file</span><br><span class="line">3 public URLConnection openConnection() throws IOException 返回一个 URLConnection 对象，它表示到 URL 所引用的远程对象的连接。</span><br><span class="line">4 public final InputStream openStream() throws IOException 打开到此 URL 的连接并返回一个用于从该连接读入的 InputStream</span><br><span class="line">-------------------------------------------</span><br><span class="line">|序号|方法|描述|</span><br><span class="line">|-|-|-|</span><br><span class="line">|1|public URL(String spec) throws MalformedURLException|根据 String 表示形式的地址创建 URL 对象。|</span><br><span class="line">|2|public URL(String protocol,String host,int port,String file) throws MalformedURLException|创建URL对象，并指定协议protocol，主机host，端口名称port，资源文件名file|</span><br><span class="line">|3|public URLConnection openConnection() throws IOException|返回一个 URLConnection 对象，它表示到 URL 所引用的远程对象的连接。|</span><br><span class="line">|4|public final InputStream openStream() throws IOException|打开到此 URL 的连接并返回一个用于从该连接读入的 InputStream|</span><br></pre></td></tr></table></figure><p></p><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>把markdown表格代码粘贴到markdown文档中，效果如下。</p><table><thead><tr><th>序号</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>public URL(String spec) throws MalformedURLException</td><td>根据 String 表示形式的地址创建 URL 对象。</td></tr><tr><td>2</td><td>public URL(String protocol,String host,int port,String file) throws MalformedURLException</td><td>创建URL对象，并指定协议protocol，主机host，端口名称port，资源文件名file</td></tr><tr><td>3</td><td>public URLConnection openConnection() throws IOException</td><td>返回一个 URLConnection 对象，它表示到 URL 所引用的远程对象的连接。</td></tr><tr><td>4</td><td>public final InputStream openStream() throws IOException</td><td>打开到此 URL 的连接并返回一个用于从该连接读入的 InputStream</td></tr></tbody></table><p>可以看到这样就很容易的复制一个表格了。</p><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><h3 id="Java复制网上表格的方法"><a href="#Java复制网上表格的方法" class="headerlink" title="Java复制网上表格的方法"></a>Java复制网上表格的方法</h3><p>把上面的代码封装成方法：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 生成markdown表格。</span><br><span class="line"> * @param text 复制的表格文字</span><br><span class="line"> * @return markdown表格代码</span><br><span class="line"> */</span><br><span class="line">public static String toMarkdownTable(String text)</span><br><span class="line">&#123;</span><br><span class="line">StringBuilder sBuider=new StringBuilder();</span><br><span class="line">Scanner scanner=new Scanner(text);</span><br><span class="line">String line;</span><br><span class="line">String[] fragments;</span><br><span class="line">boolean flag=true;</span><br><span class="line">while(scanner.hasNextLine())</span><br><span class="line">&#123;</span><br><span class="line">line=scanner.nextLine();</span><br><span class="line">//刚好两个的地方分割</span><br><span class="line">fragments=line.split(&quot;\\s&#123;2&#125;&quot;);</span><br><span class="line">//System.out.print(&quot;|&quot;);</span><br><span class="line">sBuider.append(&quot;|&quot;);</span><br><span class="line">for (String string : fragments)</span><br><span class="line">&#123;</span><br><span class="line">//System.out.print(string+&quot;|&quot;);</span><br><span class="line">sBuider.append(string+&quot;|&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//System.out.println();</span><br><span class="line">sBuider.append(&quot;\n&quot;);</span><br><span class="line">//打印表格对其方式,使用默认对齐方式</span><br><span class="line">if(flag)</span><br><span class="line">&#123;</span><br><span class="line">//System.out.print(&quot;|&quot;);</span><br><span class="line">sBuider.append(&quot;|&quot;);</span><br><span class="line">for(int i=0;i&lt;fragments.length;i++)</span><br><span class="line">&#123;</span><br><span class="line">//System.out.print(&quot;-|&quot;);</span><br><span class="line">sBuider.append(&quot;-|&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//System.out.println();</span><br><span class="line">sBuider.append(&quot;\n&quot;);</span><br><span class="line">flag=false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return sBuider.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h3><p>调用：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">//从剪贴板获取文本</span><br><span class="line">String text=SysClipboardUtil.getSysClipboardText();</span><br><span class="line">//写回剪贴板</span><br><span class="line">SysClipboardUtil.setSysClipboardText(toMarkdownTable(text));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>控制台没有输出，markdown表格代码已经写到剪贴板中去了，不再粘贴，效果和上面的一致。</p><h3 id="依赖类："><a href="#依赖类：" class="headerlink" title="依赖类："></a>依赖类：</h3><p>依赖类：<a href="https://blog.csdn.net/qq_21808961/article/details/80671259" target="_blank" rel="noopener">clipboard.util.SysClipboardUtil</a></p><h3 id="完整的代码："><a href="#完整的代码：" class="headerlink" title="完整的代码："></a>完整的代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">package regex.tools;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;</span><br><span class="line">import clipboard.util.SysClipboardUtil;</span><br><span class="line"></span><br><span class="line">public class MDtable</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">// 从剪贴板获取文本</span><br><span class="line">String text = SysClipboardUtil.getSysClipboardText();</span><br><span class="line">// 写回剪贴板</span><br><span class="line">SysClipboardUtil.setSysClipboardText(toMarkdownTable(text));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 生成markdown表格。</span><br><span class="line"> * </span><br><span class="line"> * @param text</span><br><span class="line"> *            复制的表格文字</span><br><span class="line"> * @return markdown表格代码</span><br><span class="line"> */</span><br><span class="line">public static String toMarkdownTable(String text)</span><br><span class="line">&#123;</span><br><span class="line">StringBuilder sBuider = new StringBuilder();</span><br><span class="line">Scanner scanner = new Scanner(text);</span><br><span class="line">String line;</span><br><span class="line">String[] fragments;</span><br><span class="line">// System.out.println(&quot;-------------------------------------------&quot;);</span><br><span class="line">boolean flag = true;</span><br><span class="line">while (scanner.hasNextLine())</span><br><span class="line">&#123;</span><br><span class="line">line = scanner.nextLine();</span><br><span class="line">// 刚好两个的地方分割</span><br><span class="line">fragments = line.split(&quot;\\s&#123;2&#125;&quot;);</span><br><span class="line">// System.out.println(&quot;line:---&gt;&quot;);</span><br><span class="line">// System.out.println(&quot;fragments:&quot;);</span><br><span class="line">// System.out.print(&quot;|&quot;);</span><br><span class="line">sBuider.append(&quot;|&quot;);</span><br><span class="line">for (String string : fragments)</span><br><span class="line">&#123;</span><br><span class="line">// System.out.print(string+&quot;|&quot;);</span><br><span class="line">sBuider.append(string + &quot;|&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// System.out.println();</span><br><span class="line">sBuider.append(&quot;\n&quot;);</span><br><span class="line">// 打印表格对其方式,使用默认对齐方式</span><br><span class="line">if (flag)</span><br><span class="line">&#123;</span><br><span class="line">// System.out.print(&quot;|&quot;);</span><br><span class="line">sBuider.append(&quot;|&quot;);</span><br><span class="line">for (int i = 0; i &lt; fragments.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">// System.out.print(&quot;-|&quot;);</span><br><span class="line">sBuider.append(&quot;-|&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// System.out.println();</span><br><span class="line">sBuider.append(&quot;\n&quot;);</span><br><span class="line">flag = false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return sBuider.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文链接: <a href="https://www.lansheng.net.cn/blog/a84bbd3e/">从网页上复制表格生产markdown表格</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java 正则表达式 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>MarkdownPad 导出html带侧边栏目录</title>
      <link href="/blog/728ca7fc/"/>
      <url>/blog/728ca7fc/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>参考：<a href="https://blog.csdn.net/zwx_lucky/article/details/53998930" target="_blank" rel="noopener">https://blog.csdn.net/zwx_lucky/article/details/53998930</a><br>原文给的代码如下：个人觉得不足的地方是没有自动编号，虽然使用了缩进但是父子标题看起来不是很明显，我在此基础加上了点代码<a href="#Mark">实现在标题前面自动编号</a>。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--bookmark --&gt;</span><br><span class="line">&lt;script src=&quot;http://code.jquery.com/jquery-1.7.2.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;http://yandex.st/highlightjs/6.2/highlight.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"> $(document).ready(function()&#123;</span><br><span class="line"></span><br><span class="line">      $(&quot;h1,h2,h3,h4,h5,h6&quot;).each(function(i,item)&#123;</span><br><span class="line">        var tag = $(item).get(0).localName;</span><br><span class="line">        $(item).attr(&quot;id&quot;,&quot;wow&quot;+i);</span><br><span class="line">        $(&quot;#category&quot;).append(&apos;&lt;a class=&quot;new&apos;+tag+&apos;&quot; href=&quot;#wow&apos;+i+&apos;&quot;&gt;&apos;+$(this).text()+&apos;&lt;/a&gt;&lt;/br&gt;&apos;);</span><br><span class="line">        $(&quot;.newh1&quot;).css(&quot;margin-left&quot;,0);</span><br><span class="line">        $(&quot;.newh2&quot;).css(&quot;margin-left&quot;,20);</span><br><span class="line">        $(&quot;.newh3&quot;).css(&quot;margin-left&quot;,40);</span><br><span class="line">        $(&quot;.newh4&quot;).css(&quot;margin-left&quot;,60);</span><br><span class="line">        $(&quot;.newh5&quot;).css(&quot;margin-left&quot;,80);</span><br><span class="line">      $(&quot;.newh6&quot;).css(&quot;margin-left&quot;,100);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">       $(&quot;.book-body&quot;).html($(&quot;.book-body&quot;).nextAll())</span><br><span class="line"> &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line"></span><br><span class="line">@media (max-width: 1600px) &#123;</span><br><span class="line">    .book-body &#123;</span><br><span class="line">       padding-left:200px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media (max-width: 1400px) &#123;</span><br><span class="line">    .book-body &#123;</span><br><span class="line">       padding-left:200px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media (max-width: 1200px) &#123;</span><br><span class="line">    .book-body &#123;</span><br><span class="line">       padding-left:300px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media (max-width: 700px) &#123;</span><br><span class="line">    .book-body &#123;</span><br><span class="line">       padding-left:0px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media (min-width: 600px) &#123;</span><br><span class="line">    #category&#123;</span><br><span class="line">        position: fixed;</span><br><span class="line">        left: 20px;</span><br><span class="line">        top:0;</span><br><span class="line">        height: 100%;</span><br><span class="line">        overflow-y: scroll;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media (-webkit-max-device-pixel-ratio: 1) &#123;</span><br><span class="line">    ::-webkit-scrollbar-track-piece &#123;</span><br><span class="line">        background-color:#FFF</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ::-webkit-scrollbar &#123;</span><br><span class="line">        width: 6px;</span><br><span class="line">        height: 6px</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ::-webkit-scrollbar-thumb &#123;</span><br><span class="line">        background-color: #c2c2c2;</span><br><span class="line">        background-clip: padding-box;</span><br><span class="line">        min-height: 28px</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ::-webkit-scrollbar-thumb:hover &#123;</span><br><span class="line">        background-color: #A0A0A0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;a href=&quot;javascript:scroll(0,0)&quot; style=&quot;position:fixed;float:right;right:32px;top:70%&quot;&gt;返回顶部&lt;/a&gt; </span><br><span class="line">&lt;div style=&quot;width:20%;&quot; id=&quot;category&quot; class=&quot;book-summary&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;book-body&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p></p><p>实现方式2：缺点是书签在顶部，不好快速跳转<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  document.addEventListener(&quot;DOMContentLoaded&quot;, function() &#123;</span><br><span class="line">        var div1 = document.createElement(&quot;div&quot;);</span><br><span class="line">        div1.style.cssText = &quot;clear:both&quot;;</span><br><span class="line">        // 生成目录列表</span><br><span class="line">        var outline = document.createElement(&quot;div&quot;);</span><br><span class="line">        outline.setAttribute(&quot;id&quot;, &quot;outline-list&quot;);</span><br><span class="line">        outline.style.cssText = &quot;border:solid 1px #ccc; background:#eee; min-width:200px;padding:4px 10px;&quot;;</span><br><span class="line">        </span><br><span class="line">        var ele_p = document.createElement(&quot;p&quot;);</span><br><span class="line">        ele_p.style.cssText = &quot;text-align: left; margin: 0;&quot;;</span><br><span class="line">        outline.appendChild(ele_p);</span><br><span class="line">        </span><br><span class="line">        var ele_span = document.createElement(&quot;span&quot;);</span><br><span class="line">        // ele_span.style.cssText = &quot;float: left;&quot;;</span><br><span class="line">        var ele_text=document.createTextNode(&quot;目录&quot;);</span><br><span class="line">        ele_span.appendChild(ele_text);</span><br><span class="line">        </span><br><span class="line">        var ele_a = document.createElement(&quot;a&quot;);</span><br><span class="line">        ele_a.appendChild(document.createTextNode(&quot;[+]&quot;));</span><br><span class="line">        ele_a.setAttribute(&quot;href&quot;, &quot;#&quot;);</span><br><span class="line">        ele_a.setAttribute(&quot;onclick&quot;, &quot;javascript:return openct(this);&quot;);</span><br><span class="line">        ele_a.setAttribute(&quot;title&quot;, &quot;点击打开目录&quot;);</span><br><span class="line"> </span><br><span class="line">        ele_span.appendChild(ele_a);</span><br><span class="line">        ele_p.appendChild(ele_span);</span><br><span class="line"> </span><br><span class="line">        var ele_ol = document.createElement(&quot;ol&quot;);</span><br><span class="line">        ele_ol.style.cssText = &quot;display:none;margin-left:14px;padding-left:14px;line-height:160%;&quot;;</span><br><span class="line">        ele_ol.setAttribute(&quot;id&quot;, &quot;outline_ol&quot;);</span><br><span class="line">        outline.appendChild(ele_ol);</span><br><span class="line">        var div1 = document.createElement(&quot;div&quot;);</span><br><span class="line">        div1.style.cssText = &quot;clear:both&quot;;</span><br><span class="line"> </span><br><span class="line">        document.body.insertBefore(outline, document.body.childNodes[0]);</span><br><span class="line">        // 获取所有标题</span><br><span class="line">        var headers = document.querySelectorAll(&apos;h1,h2,h3,h4,h5,h6&apos;);</span><br><span class="line">        if (headers.length &lt; 2)</span><br><span class="line">          return;</span><br><span class="line"> </span><br><span class="line">        // -----</span><br><span class="line">        var old_h = 0, ol_cnt = 0;</span><br><span class="line">        // -----</span><br><span class="line">        </span><br><span class="line">        for (var i = 0; i &lt; headers.length; i++) &#123;</span><br><span class="line">          </span><br><span class="line">          var ele_ols = null;</span><br><span class="line">            // 找出它是H几，为后面的有序列表做准备</span><br><span class="line">            var header = headers[i];</span><br><span class="line">            header.setAttribute(&quot;id&quot;, &quot;t&quot; + i + header.tagName);</span><br><span class="line">            var h = parseInt(header.tagName.substr(1), 10);</span><br><span class="line">            // -----</span><br><span class="line">            if (!old_h)&#123;</span><br><span class="line">              old_h = h;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (h &gt; old_h) &#123;</span><br><span class="line">              ele_ols = document.createElement(&quot;ol&quot;);</span><br><span class="line">              var ele_Current = ele_ol;</span><br><span class="line">              if(ele_Current &amp;&amp; ol_cnt &gt; 0)&#123;</span><br><span class="line">                var temp = ol_cnt;</span><br><span class="line">                while(temp &gt; 0)&#123;</span><br><span class="line">                  ele_Current = ele_Current.lastChild;</span><br><span class="line">                  temp--;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              ele_Current.lastChild.appendChild(ele_ols);</span><br><span class="line">              ol_cnt++;</span><br><span class="line">            &#125; else if (h &lt; old_h &amp;&amp; ol_cnt &gt; 0) &#123;</span><br><span class="line">              if (h == 1) &#123;</span><br><span class="line">                while (ol_cnt &gt; 0) &#123;</span><br><span class="line">                  ol_cnt--;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                ele_ols = document.createElement(&quot;ol&quot;);</span><br><span class="line">                var ele_Current = ele_ol;</span><br><span class="line">                if(ele_Current &amp;&amp; ol_cnt &gt; 0)&#123;</span><br><span class="line">                  var temp = ol_cnt;</span><br><span class="line">                  while(temp &gt; 1)&#123;</span><br><span class="line">                    ele_Current = ele_Current.lastChild;</span><br><span class="line">                    temp--;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              ele_Current.appendChild(ele_ols);</span><br><span class="line"> </span><br><span class="line">              ol_cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (h == 1) &#123;</span><br><span class="line">              while (ol_cnt &gt; 0) &#123;</span><br><span class="line">                ol_cnt--;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            old_h = h;</span><br><span class="line">            // -----</span><br><span class="line">            if (ele_ols)&#123;</span><br><span class="line">              ele_li = document.createElement(&quot;li&quot;)</span><br><span class="line">              ele_ols.appendChild(ele_li);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              ele_li = document.createElement(&quot;li&quot;)</span><br><span class="line">              ele_ol.appendChild(ele_li);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            var a = document.createElement(&quot;a&quot;);</span><br><span class="line">            // 为目录项设置链接</span><br><span class="line">            a.setAttribute(&quot;href&quot;, &quot;#t&quot; + i + header.tagName);</span><br><span class="line">            // 目录项文本</span><br><span class="line">            a.innerHTML = header.textContent;</span><br><span class="line"> </span><br><span class="line">            </span><br><span class="line">            ele_li.appendChild(a);</span><br><span class="line">          &#125;</span><br><span class="line">          // -----</span><br><span class="line">          while (ol_cnt &gt; 0) &#123;</span><br><span class="line">            ol_cnt--;</span><br><span class="line">          &#125;</span><br><span class="line">          // -----</span><br><span class="line"> </span><br><span class="line">        &#125;);</span><br><span class="line">// 代开和关闭目录的函数</span><br><span class="line">function openct(e) &#123;</span><br><span class="line">  if (e.innerHTML == &apos;[+]&apos;) &#123;</span><br><span class="line">    // createTextNode</span><br><span class="line">    e.setAttribute(&apos;title&apos;, &apos;收起&apos;);</span><br><span class="line">    e.innerHTML = &apos;[-]&apos;;</span><br><span class="line">    var element = document.getElementById(&quot;outline_ol&quot;);</span><br><span class="line">    element.style.cssText = &quot;margin-left:14px;padding-left:14px;line-height:160%;&quot;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    e.setAttribute(&apos;title&apos;, &apos;展开&apos;);</span><br><span class="line">    e.innerHTML = &apos;[+]&apos;;</span><br><span class="line">    var element = document.getElementById(&quot;outline_ol&quot;);</span><br><span class="line">    element.style.cssText = &quot;display:none;margin-left:14px;padding-left:14px;line-height:160%;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  e.blur();</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p></p><h2 id="具体实现的步骤，和改进"><a href="#具体实现的步骤，和改进" class="headerlink" title="具体实现的步骤，和改进"></a>具体实现的步骤，和改进</h2><p>js忘光了，先用最弱智的方法来实现吧。<br>关键代码：这个代码有点脑残的。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">var h1Count=1,h1Addflag=0;</span><br><span class="line">var h2Count=1,h2Addflag=0;</span><br><span class="line">var h3Count=1,h3Addflag=0;</span><br><span class="line">var h4Count=1,h4Addflag=0;</span><br><span class="line">var h5Count=1,h5Addflag=0;</span><br><span class="line">var h6Count=1,h6Addflag=0;</span><br><span class="line">$(document).ready(function()</span><br><span class="line">&#123;</span><br><span class="line">$(&quot;h1,h2,h3,h4,h5,h6&quot;).each(function(i,item)</span><br><span class="line">&#123;</span><br><span class="line">//获取标签的名字,h1,还是h2</span><br><span class="line">var tag = $(item).get(0).localName;</span><br><span class="line">if(tag===&quot;h1&quot;)</span><br><span class="line">&#123;</span><br><span class="line">if(h1Addflag===1)</span><br><span class="line">&#123;</span><br><span class="line">h1Count++;</span><br><span class="line">&#125;</span><br><span class="line">h1Addflag=1;</span><br><span class="line">//初始化子节点</span><br><span class="line">h2Count=1;h3Count=1;h4Count=1;h5Count=1;h6Count=1;</span><br><span class="line">//初始化子节点标志刚开始不要加1</span><br><span class="line">h2Addflag=0;h3Addflag=0;h4Addflag=0;h5Addflag=0;h6Addflag=0;</span><br><span class="line">console.log(&quot;捕获到标签:%s&quot;,tag);</span><br><span class="line">var text=$(item).get(0).innerHTML;</span><br><span class="line">$(item).get(0).innerHTML=(h1Count)+&quot; &quot;+text;</span><br><span class="line">&#125;</span><br><span class="line">if(tag===&quot;h2&quot;)</span><br><span class="line">&#123;</span><br><span class="line">if(h2Addflag===1)</span><br><span class="line">&#123;</span><br><span class="line">h2Count++;</span><br><span class="line">&#125;</span><br><span class="line">h2Addflag=1;</span><br><span class="line">//初始化子节点</span><br><span class="line">h3Count=1;h4Count=1;h5Count=1;h6Count=1;</span><br><span class="line">//初始化子节点标志刚开始不要加1</span><br><span class="line">h3Addflag=0;h4Addflag=0;h5Addflag=0;h6Addflag=0;</span><br><span class="line">console.log(&quot;捕获到标签:%s&quot;,tag);</span><br><span class="line">var text=$(item).get(0).innerHTML;</span><br><span class="line">$(item).get(0).innerHTML=(h1Count)+&quot;.&quot;+(h2Count)+&quot; &quot;+text;</span><br><span class="line">&#125;</span><br><span class="line">if(tag===&quot;h3&quot;)</span><br><span class="line">&#123;</span><br><span class="line">if(h3Addflag===1)</span><br><span class="line">&#123;</span><br><span class="line">h3Count++;</span><br><span class="line">&#125;</span><br><span class="line">h3Addflag=1;</span><br><span class="line">//初始化子节点</span><br><span class="line">h4Count=1;h5Count=1;h6Count=1;</span><br><span class="line">//初始化子节点标志刚开始不要加1</span><br><span class="line">h4Addflag=0;h5Addflag=0;h6Addflag=0;</span><br><span class="line">console.log(&quot;捕获到标签:%s&quot;,tag);</span><br><span class="line">var text=$(item).get(0).innerHTML;</span><br><span class="line">$(item).get(0).innerHTML=(h1Count)+&quot;.&quot;+(h2Count)+&quot;.&quot;+(h3Count)+&quot; &quot;+text;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">if(tag===&quot;h4&quot;)</span><br><span class="line">&#123;</span><br><span class="line">if(h4Addflag===1)</span><br><span class="line">&#123;</span><br><span class="line">h4Count++;</span><br><span class="line">&#125;</span><br><span class="line">h4Addflag=1;</span><br><span class="line">//初始化子节点</span><br><span class="line">h5Count=1;h6Count=1;</span><br><span class="line">//初始化子节点标志刚开始不要加1</span><br><span class="line">h5Addflag=0;h6Addflag=0;</span><br><span class="line">console.log(&quot;捕获到标签:%s&quot;,tag);</span><br><span class="line">var text=$(item).get(0).innerHTML;</span><br><span class="line">$(item).get(0).innerHTML=(h1Count)+&quot;.&quot;+(h2Count)+&quot;.&quot;+(h3Count)+&quot;.&quot;+(h4Count)+&quot; &quot;+text;</span><br><span class="line">&#125;</span><br><span class="line">if(tag===&quot;h5&quot;)</span><br><span class="line">&#123;</span><br><span class="line">if(h5Addflag===1)</span><br><span class="line">&#123;</span><br><span class="line">h5Count++;</span><br><span class="line">&#125;</span><br><span class="line">h5Addflag=1;</span><br><span class="line">//初始化子节点</span><br><span class="line">h6Count=1;</span><br><span class="line">console.log(&quot;捕获到标签:%s&quot;,tag);</span><br><span class="line">//初始化子节点标志刚开始不要加1</span><br><span class="line">h6Addflag=0;</span><br><span class="line">var text=$(item).get(0).innerHTML;</span><br><span class="line">$(item).get(0).innerHTML=(h1Count)+&quot;.&quot;+(h2Count)+&quot;.&quot;+(h3Count)+&quot;.&quot;+(h4Count)+&quot;.&quot;+(h5Count)+&quot; &quot;+text;</span><br><span class="line">&#125;</span><br><span class="line">if(tag===&quot;h6&quot;)</span><br><span class="line">&#123;</span><br><span class="line">if(h6Addflag===1)</span><br><span class="line">&#123;</span><br><span class="line">h6Count++;</span><br><span class="line">&#125;</span><br><span class="line">h6Addflag=1;</span><br><span class="line">console.log(&quot;捕获到标签:%s&quot;,tag);</span><br><span class="line">var text=$(item).get(0).innerHTML;</span><br><span class="line">$(item).get(0).innerHTML=(h1Count)+&quot;.&quot;+(h2Count)+&quot;.&quot;+(h3Count)+&quot;.&quot;+(h4Count)+&quot;.&quot;+(h5Count)+&quot;.&quot;+(h6Count)+&quot; &quot;+text;</span><br><span class="line">&#125;</span><br><span class="line">//为该标签设置id属性</span><br><span class="line">$(item).attr(&quot;id&quot;,&quot;wow&quot;+i);</span><br><span class="line">//添加一个超链接</span><br><span class="line">$(&quot;#category&quot;).append(&apos;&lt;a class=&quot;new&apos;+tag+&apos;&quot; href=&quot;#wow&apos;+i+&apos;&quot;&gt;&apos;+$(this).text()+&apos;&lt;/a&gt;&lt;/br&gt;&apos;);</span><br><span class="line">//为每一个标题超链接的class属性设置左边距</span><br><span class="line">$(&quot;.newh1&quot;).css(&quot;margin-left&quot;,0);</span><br><span class="line">$(&quot;.newh2&quot;).css(&quot;margin-left&quot;,20);</span><br><span class="line">$(&quot;.newh3&quot;).css(&quot;margin-left&quot;,40);</span><br><span class="line">$(&quot;.newh4&quot;).css(&quot;margin-left&quot;,60);</span><br><span class="line">$(&quot;.newh5&quot;).css(&quot;margin-left&quot;,80);</span><br><span class="line">$(&quot;.newh6&quot;).css(&quot;margin-left&quot;,100);</span><br><span class="line">&#125;);</span><br><span class="line">//设置class选择器为.book-body的html内容</span><br><span class="line">$(&quot;.book-body&quot;).html($(&quot;.book-body&quot;).nextAll())</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>上面通过6个计数器来完成的，和六个标志来完成的，js没学好，代码都很烂。不过幸运的是可以跑起来，下面来改进</p><h3 id="改进："><a href="#改进：" class="headerlink" title="改进："></a>改进：</h3><p>把上面的计数器用数组实现，然后从0开始计数，减少标志位的使用。<br>关键代码：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--重要代码--&gt;</span><br><span class="line">//标题序号计数器</span><br><span class="line">var hCount=[0,0,0,0,0,0];</span><br><span class="line">//设置计数器</span><br><span class="line">function setHCount(number)</span><br><span class="line">&#123;</span><br><span class="line">//当前计数器加一</span><br><span class="line">hCount[number-1]++;</span><br><span class="line">for(var i=number,length=hCount.length;i&lt;length;i++)</span><br><span class="line">&#123;</span><br><span class="line">//子目录计数器全部置零</span><br><span class="line">hCount[i]=0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//重命名目录名称</span><br><span class="line">function setHTagValue(item,number)</span><br><span class="line">&#123;</span><br><span class="line">//获取标题名</span><br><span class="line">var text=$(item).get(0).innerHTML;</span><br><span class="line">//初始化空字符串</span><br><span class="line">var before=&quot;&quot;;</span><br><span class="line">//生成序号</span><br><span class="line">for(var i=0,length=hCount.length;i&lt;number;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(i&lt;number-1)</span><br><span class="line">before+=hCount[i]+&quot;.&quot;;</span><br><span class="line">else</span><br><span class="line">before+=hCount[i]+&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">//$(item).get(0).innerHTML=(h1Count)+&quot;.&quot;+(h2Count)+&quot;.&quot;+(h3Count)+&quot;.&quot;+(h4Count)+&quot;.&quot;+(h5Count)+&quot;.&quot;+(h6Count)+&quot; &quot;+text;</span><br><span class="line">//在标题前面加上序号</span><br><span class="line">$(item).get(0).innerHTML=before+text;</span><br><span class="line">&#125;</span><br><span class="line">function renameHTag(item)</span><br><span class="line">&#123;</span><br><span class="line">var tag = $(item).get(0).localName;</span><br><span class="line">if(tag===&quot;h1&quot;)</span><br><span class="line">&#123;</span><br><span class="line">setHCount(1);</span><br><span class="line">setHTagValue(item,1);</span><br><span class="line">&#125;</span><br><span class="line">if(tag===&quot;h2&quot;)</span><br><span class="line">&#123;</span><br><span class="line">setHCount(2);</span><br><span class="line">setHTagValue(item,2);</span><br><span class="line">&#125;</span><br><span class="line">if(tag===&quot;h3&quot;)</span><br><span class="line">&#123;</span><br><span class="line">setHCount(3);</span><br><span class="line">setHTagValue(item,3);</span><br><span class="line">&#125;</span><br><span class="line">if(tag===&quot;h4&quot;)</span><br><span class="line">&#123;</span><br><span class="line">setHCount(4);</span><br><span class="line">setHTagValue(item,4);</span><br><span class="line">&#125;</span><br><span class="line">if(tag===&quot;h5&quot;)</span><br><span class="line">&#123;</span><br><span class="line">setHCount(5);</span><br><span class="line">setHTagValue(item,5);</span><br><span class="line">&#125;</span><br><span class="line">if(tag===&quot;h6&quot;)</span><br><span class="line">&#123;</span><br><span class="line">setHCount(6);</span><br><span class="line">setHTagValue(item,6)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">$(document).ready(function()</span><br><span class="line">&#123;</span><br><span class="line">$(&quot;h1,h2,h3,h4,h5,h6&quot;).each(function(i,item)</span><br><span class="line">&#123;</span><br><span class="line">//给&lt;H&gt;类标签编号</span><br><span class="line">renameHTag(item);</span><br><span class="line">//获取标签的名字,h1,还是h2</span><br><span class="line">var tag = $(item).get(0).localName;</span><br><span class="line"></span><br><span class="line">//为该标签设置id属性</span><br><span class="line">$(item).attr(&quot;id&quot;,&quot;wow&quot;+i);</span><br><span class="line">//添加一个页内超链接,并设置class选择器</span><br><span class="line">//$(&quot;#category&quot;).append(&apos;&lt;a class=&quot;new&apos;+tag+&apos;&quot; href=&quot;#wow&apos;+i+&apos;&quot;&gt;&apos;+$(this).text()+&apos;&lt;/a&gt;&lt;/br&gt;&apos;);</span><br><span class="line">$(&quot;#category&quot;).append(&apos;&lt;a class=&quot;new&apos;+tag+&apos;&quot; href=&quot;#wow&apos;+i+&apos;&quot;&gt;&apos;+$(item).text()+&apos;&lt;/a&gt;&lt;/br&gt;&apos;);</span><br><span class="line">//为每一个标题超链接的class属性设置左边距</span><br><span class="line">$(&quot;.newh1&quot;).css(&quot;margin-left&quot;,0);</span><br><span class="line">$(&quot;.newh2&quot;).css(&quot;margin-left&quot;,20);</span><br><span class="line">$(&quot;.newh3&quot;).css(&quot;margin-left&quot;,40);</span><br><span class="line">$(&quot;.newh4&quot;).css(&quot;margin-left&quot;,60);</span><br><span class="line">$(&quot;.newh5&quot;).css(&quot;margin-left&quot;,80);</span><br><span class="line">$(&quot;.newh6&quot;).css(&quot;margin-left&quot;,100);</span><br><span class="line">&#125;);</span><br><span class="line">//设置class选择器为.book-body的html内容</span><br><span class="line">$(&quot;.book-body&quot;).html($(&quot;.book-body&quot;).nextAll())</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><div id="Mark"></div><h2 id="实现在标题前面自动编号："><a href="#实现在标题前面自动编号：" class="headerlink" title="实现在标题前面自动编号："></a>实现在标题前面自动编号：</h2><p>改进：把上面的代码用函数封装好，这样阅读起来方便点，不至于一个函数很长。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://code.jquery.com/jquery-1.7.2.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;http://yandex.st/highlightjs/6.2/highlight.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;</span><br><span class="line">&lt;!--重要代码--&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">&lt;!--重要代码--&gt;</span><br><span class="line">&lt;!--重要代码--&gt;</span><br><span class="line">//标题序号计数器</span><br><span class="line">var hCount=[0,0,0,0,0,0];</span><br><span class="line">//设置计数器</span><br><span class="line">function setHCount(number)</span><br><span class="line">&#123;</span><br><span class="line">//当前计数器加一</span><br><span class="line">hCount[number-1]++;</span><br><span class="line">for(var i=number,length=hCount.length;i&lt;length;i++)</span><br><span class="line">&#123;</span><br><span class="line">//子目录计数器全部置零</span><br><span class="line">hCount[i]=0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//重命名目录名称</span><br><span class="line">function setHTagValue(item,number)</span><br><span class="line">&#123;</span><br><span class="line">//获取标题名</span><br><span class="line">var text=$(item).get(0).innerHTML;</span><br><span class="line">//初始化空字符串</span><br><span class="line">var before=&quot;&quot;;</span><br><span class="line">//生成序号</span><br><span class="line">for(var i=0,length=hCount.length;i&lt;number;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(i&lt;number-1)</span><br><span class="line">before+=hCount[i]+&quot;.&quot;;</span><br><span class="line">else</span><br><span class="line">before+=hCount[i]+&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">//$(item).get(0).innerHTML=(h1Count)+&quot;.&quot;+(h2Count)+&quot;.&quot;+(h3Count)+&quot;.&quot;+(h4Count)+&quot;.&quot;+(h5Count)+&quot;.&quot;+(h6Count)+&quot; &quot;+text;</span><br><span class="line">//在标题前面加上序号</span><br><span class="line">$(item).get(0).innerHTML=before+text;</span><br><span class="line">&#125;</span><br><span class="line">function renameHTag(item)</span><br><span class="line">&#123;</span><br><span class="line">var tag = $(item).get(0).localName;</span><br><span class="line">if(tag===&quot;h1&quot;)</span><br><span class="line">&#123;</span><br><span class="line">setHCount(1);</span><br><span class="line">console.log(&quot;捕获到标签:%s&quot;,tag);</span><br><span class="line">setHTagValue(item,1);</span><br><span class="line">&#125;</span><br><span class="line">if(tag===&quot;h2&quot;)</span><br><span class="line">&#123;</span><br><span class="line">setHCount(2);</span><br><span class="line">console.log(&quot;捕获到标签:%s&quot;,tag);</span><br><span class="line">setHTagValue(item,2);</span><br><span class="line">&#125;</span><br><span class="line">if(tag===&quot;h3&quot;)</span><br><span class="line">&#123;</span><br><span class="line">setHCount(3);</span><br><span class="line">console.log(&quot;捕获到标签:%s&quot;,tag);</span><br><span class="line">setHTagValue(item,3);</span><br><span class="line">&#125;</span><br><span class="line">if(tag===&quot;h4&quot;)</span><br><span class="line">&#123;</span><br><span class="line">setHCount(4);</span><br><span class="line">console.log(&quot;捕获到标签:%s&quot;,tag);</span><br><span class="line">setHTagValue(item,4);</span><br><span class="line">&#125;</span><br><span class="line">if(tag===&quot;h5&quot;)</span><br><span class="line">&#123;</span><br><span class="line">setHCount(5);</span><br><span class="line">console.log(&quot;捕获到标签:%s&quot;,tag);</span><br><span class="line">setHTagValue(item,5);</span><br><span class="line">&#125;</span><br><span class="line">if(tag===&quot;h6&quot;)</span><br><span class="line">&#123;</span><br><span class="line">setHCount(6);</span><br><span class="line">console.log(&quot;捕获到标签:%s&quot;,tag);</span><br><span class="line">setHTagValue(item,6)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">$(document).ready(function()</span><br><span class="line">&#123;</span><br><span class="line">$(&quot;h1,h2,h3,h4,h5,h6&quot;).each(function(i,item)</span><br><span class="line">&#123;</span><br><span class="line">//给&lt;H&gt;类标签编号</span><br><span class="line">renameHTag(item);</span><br><span class="line">//获取标签的名字,h1,还是h2</span><br><span class="line">var tag = $(item).get(0).localName;</span><br><span class="line"></span><br><span class="line">//为该标签设置id属性</span><br><span class="line">$(item).attr(&quot;id&quot;,&quot;wow&quot;+i);</span><br><span class="line">//添加一个页内超链接,并设置class选择器</span><br><span class="line">//$(&quot;#category&quot;).append(&apos;&lt;a class=&quot;new&apos;+tag+&apos;&quot; href=&quot;#wow&apos;+i+&apos;&quot;&gt;&apos;+$(this).text()+&apos;&lt;/a&gt;&lt;/br&gt;&apos;);</span><br><span class="line">$(&quot;#category&quot;).append(&apos;&lt;a class=&quot;new&apos;+tag+&apos;&quot; href=&quot;#wow&apos;+i+&apos;&quot;&gt;&apos;+$(item).text()+&apos;&lt;/a&gt;&lt;/br&gt;&apos;);</span><br><span class="line">//为每一个标题超链接的class属性设置左边距</span><br><span class="line">$(&quot;.newh1&quot;).css(&quot;margin-left&quot;,0);</span><br><span class="line">$(&quot;.newh2&quot;).css(&quot;margin-left&quot;,20);</span><br><span class="line">$(&quot;.newh3&quot;).css(&quot;margin-left&quot;,40);</span><br><span class="line">$(&quot;.newh4&quot;).css(&quot;margin-left&quot;,60);</span><br><span class="line">$(&quot;.newh5&quot;).css(&quot;margin-left&quot;,80);</span><br><span class="line">$(&quot;.newh6&quot;).css(&quot;margin-left&quot;,100);</span><br><span class="line">&#125;);</span><br><span class="line">//设置class选择器为.book-body的html内容</span><br><span class="line">$(&quot;.book-body&quot;).html($(&quot;.book-body&quot;).nextAll())</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line"></span><br><span class="line">@media (max-width: 1600px) &#123;</span><br><span class="line">    .book-body &#123;</span><br><span class="line">       padding-left:200px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media (max-width: 1400px) &#123;</span><br><span class="line">    .book-body &#123;</span><br><span class="line">       padding-left:200px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media (max-width: 1200px) &#123;</span><br><span class="line">    .book-body &#123;</span><br><span class="line">       padding-left:300px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media (max-width: 700px) &#123;</span><br><span class="line">    .book-body &#123;</span><br><span class="line">       padding-left:0px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media (min-width: 600px) &#123;</span><br><span class="line">    #category&#123;</span><br><span class="line">        position: fixed;</span><br><span class="line">        left: 20px;</span><br><span class="line">        top:0;</span><br><span class="line">        height: 100%;</span><br><span class="line">        overflow-y: scroll;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media (-webkit-max-device-pixel-ratio: 1) &#123;</span><br><span class="line">    ::-webkit-scrollbar-track-piece &#123;</span><br><span class="line">        background-color:#FFF</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ::-webkit-scrollbar &#123;</span><br><span class="line">        width: 6px;</span><br><span class="line">        height: 6px</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ::-webkit-scrollbar-thumb &#123;</span><br><span class="line">        background-color: #c2c2c2;</span><br><span class="line">        background-clip: padding-box;</span><br><span class="line">        min-height: 28px</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ::-webkit-scrollbar-thumb:hover &#123;</span><br><span class="line">        background-color: #A0A0A0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;!--返回顶部--&gt;</span><br><span class="line">&lt;a href=&quot;javascript:scroll(0,0)&quot; style=&quot;position:fixed;float:right;right:32px;top:70%&quot;&gt;返回顶部&lt;/a&gt; </span><br><span class="line">&lt;!--目录栏，设置占用宽度为20%可以根据实际情况设置--&gt;</span><br><span class="line">&lt;div style=&quot;width:20%;&quot; id=&quot;category&quot; class=&quot;book-summary&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;!--文章主体部分--&gt;</span><br><span class="line">&lt;div class=&quot;book-body&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p></p><h2 id="MarkdownPad2中的设置"><a href="#MarkdownPad2中的设置" class="headerlink" title="MarkdownPad2中的设置"></a>MarkdownPad2中的设置</h2><p>复制上面的代码，然后打开MarkDownPad2，<br>在MarkdownPad2中点击<code>工具--&gt;选项--&gt;高级--&gt;HTML Head编辑器</code>，然后粘贴上面代码，然后<code>保存并关闭</code>即可。<br><img src="https://i.imgur.com/pxuD8Y8.png" alt=""></p><p><img src="https://i.imgur.com/KIlcMJS.png" alt=""></p><p><img src="https://i.imgur.com/K6IXNSF.png" alt=""></p><h3 id="导出HTML"><a href="#导出HTML" class="headerlink" title="导出HTML"></a>导出HTML</h3><p>然后来导出HTML，这样才能看见侧目录。<br>选择<code>文件--&gt;导出--&gt;导出 HTML</code>,然后保存到本地即可。<br><img src="https://i.imgur.com/m1Q2OuZ.png" alt=""></p><p>然后就可看到效果了</p><p><img src="https://i.imgur.com/IjHSC6W.png" alt=""></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/728ca7fc/">MarkdownPad 导出html带侧边栏目录</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> markdown使用 </category>
          
          <category> markdown编辑器 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>带书签JS设置1</title>
      <link href="/blog/59af15ef/"/>
      <url>/blog/59af15ef/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:17 GMT+0800 (中国标准时间) --><p>参考：<a href="https://blog.csdn.net/zwx_lucky/article/details/53998930" target="_blank" rel="noopener">https://blog.csdn.net/zwx_lucky/article/details/53998930</a><br>原文给的代码如下：个人觉得不足的地方是没有自动编号，虽然使用了缩进但是父子标题看起来不是很明显，我在此基础加上了点代码<a href="#Mark">实现在标题前面自动编号</a>。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--bookmark --&gt;</span><br><span class="line">&lt;script src=&quot;http://code.jquery.com/jquery-1.7.2.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;http://yandex.st/highlightjs/6.2/highlight.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"> $(document).ready(function()&#123;</span><br><span class="line"></span><br><span class="line">      $(&quot;h1,h2,h3,h4,h5,h6&quot;).each(function(i,item)&#123;</span><br><span class="line">        var tag = $(item).get(0).localName;</span><br><span class="line">        $(item).attr(&quot;id&quot;,&quot;wow&quot;+i);</span><br><span class="line">        $(&quot;#category&quot;).append(&apos;&lt;a class=&quot;new&apos;+tag+&apos;&quot; href=&quot;#wow&apos;+i+&apos;&quot;&gt;&apos;+$(this).text()+&apos;&lt;/a&gt;&lt;/br&gt;&apos;);</span><br><span class="line">        $(&quot;.newh1&quot;).css(&quot;margin-left&quot;,0);</span><br><span class="line">        $(&quot;.newh2&quot;).css(&quot;margin-left&quot;,20);</span><br><span class="line">        $(&quot;.newh3&quot;).css(&quot;margin-left&quot;,40);</span><br><span class="line">        $(&quot;.newh4&quot;).css(&quot;margin-left&quot;,60);</span><br><span class="line">        $(&quot;.newh5&quot;).css(&quot;margin-left&quot;,80);</span><br><span class="line">      $(&quot;.newh6&quot;).css(&quot;margin-left&quot;,100);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">       $(&quot;.book-body&quot;).html($(&quot;.book-body&quot;).nextAll())</span><br><span class="line"> &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line"></span><br><span class="line">@media (max-width: 1600px) &#123;</span><br><span class="line">    .book-body &#123;</span><br><span class="line">       padding-left:200px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media (max-width: 1400px) &#123;</span><br><span class="line">    .book-body &#123;</span><br><span class="line">       padding-left:200px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media (max-width: 1200px) &#123;</span><br><span class="line">    .book-body &#123;</span><br><span class="line">       padding-left:300px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media (max-width: 700px) &#123;</span><br><span class="line">    .book-body &#123;</span><br><span class="line">       padding-left:0px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media (min-width: 600px) &#123;</span><br><span class="line">    #category&#123;</span><br><span class="line">        position: fixed;</span><br><span class="line">        left: 20px;</span><br><span class="line">        top:0;</span><br><span class="line">        height: 100%;</span><br><span class="line">        overflow-y: scroll;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media (-webkit-max-device-pixel-ratio: 1) &#123;</span><br><span class="line">    ::-webkit-scrollbar-track-piece &#123;</span><br><span class="line">        background-color:#FFF</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ::-webkit-scrollbar &#123;</span><br><span class="line">        width: 6px;</span><br><span class="line">        height: 6px</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ::-webkit-scrollbar-thumb &#123;</span><br><span class="line">        background-color: #c2c2c2;</span><br><span class="line">        background-clip: padding-box;</span><br><span class="line">        min-height: 28px</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ::-webkit-scrollbar-thumb:hover &#123;</span><br><span class="line">        background-color: #A0A0A0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;a href=&quot;javascript:scroll(0,0)&quot; style=&quot;position:fixed;float:right;right:32px;top:70%&quot;&gt;返回顶部&lt;/a&gt; </span><br><span class="line">&lt;div style=&quot;width:20%;&quot; id=&quot;category&quot; class=&quot;book-summary&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;book-body&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p></p><p>实现方式2：缺点是书签在顶部，不好快速跳转<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  document.addEventListener(&quot;DOMContentLoaded&quot;, function() &#123;</span><br><span class="line">        var div1 = document.createElement(&quot;div&quot;);</span><br><span class="line">        div1.style.cssText = &quot;clear:both&quot;;</span><br><span class="line">        // 生成目录列表</span><br><span class="line">        var outline = document.createElement(&quot;div&quot;);</span><br><span class="line">        outline.setAttribute(&quot;id&quot;, &quot;outline-list&quot;);</span><br><span class="line">        outline.style.cssText = &quot;border:solid 1px #ccc; background:#eee; min-width:200px;padding:4px 10px;&quot;;</span><br><span class="line">        </span><br><span class="line">        var ele_p = document.createElement(&quot;p&quot;);</span><br><span class="line">        ele_p.style.cssText = &quot;text-align: left; margin: 0;&quot;;</span><br><span class="line">        outline.appendChild(ele_p);</span><br><span class="line">        </span><br><span class="line">        var ele_span = document.createElement(&quot;span&quot;);</span><br><span class="line">        // ele_span.style.cssText = &quot;float: left;&quot;;</span><br><span class="line">        var ele_text=document.createTextNode(&quot;目录&quot;);</span><br><span class="line">        ele_span.appendChild(ele_text);</span><br><span class="line">        </span><br><span class="line">        var ele_a = document.createElement(&quot;a&quot;);</span><br><span class="line">        ele_a.appendChild(document.createTextNode(&quot;[+]&quot;));</span><br><span class="line">        ele_a.setAttribute(&quot;href&quot;, &quot;#&quot;);</span><br><span class="line">        ele_a.setAttribute(&quot;onclick&quot;, &quot;javascript:return openct(this);&quot;);</span><br><span class="line">        ele_a.setAttribute(&quot;title&quot;, &quot;点击打开目录&quot;);</span><br><span class="line"> </span><br><span class="line">        ele_span.appendChild(ele_a);</span><br><span class="line">        ele_p.appendChild(ele_span);</span><br><span class="line"> </span><br><span class="line">        var ele_ol = document.createElement(&quot;ol&quot;);</span><br><span class="line">        ele_ol.style.cssText = &quot;display:none;margin-left:14px;padding-left:14px;line-height:160%;&quot;;</span><br><span class="line">        ele_ol.setAttribute(&quot;id&quot;, &quot;outline_ol&quot;);</span><br><span class="line">        outline.appendChild(ele_ol);</span><br><span class="line">        var div1 = document.createElement(&quot;div&quot;);</span><br><span class="line">        div1.style.cssText = &quot;clear:both&quot;;</span><br><span class="line"> </span><br><span class="line">        document.body.insertBefore(outline, document.body.childNodes[0]);</span><br><span class="line">        // 获取所有标题</span><br><span class="line">        var headers = document.querySelectorAll(&apos;h1,h2,h3,h4,h5,h6&apos;);</span><br><span class="line">        if (headers.length &lt; 2)</span><br><span class="line">          return;</span><br><span class="line"> </span><br><span class="line">        // -----</span><br><span class="line">        var old_h = 0, ol_cnt = 0;</span><br><span class="line">        // -----</span><br><span class="line">        </span><br><span class="line">        for (var i = 0; i &lt; headers.length; i++) &#123;</span><br><span class="line">          </span><br><span class="line">          var ele_ols = null;</span><br><span class="line">            // 找出它是H几，为后面的有序列表做准备</span><br><span class="line">            var header = headers[i];</span><br><span class="line">            header.setAttribute(&quot;id&quot;, &quot;t&quot; + i + header.tagName);</span><br><span class="line">            var h = parseInt(header.tagName.substr(1), 10);</span><br><span class="line">            // -----</span><br><span class="line">            if (!old_h)&#123;</span><br><span class="line">              old_h = h;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (h &gt; old_h) &#123;</span><br><span class="line">              ele_ols = document.createElement(&quot;ol&quot;);</span><br><span class="line">              var ele_Current = ele_ol;</span><br><span class="line">              if(ele_Current &amp;&amp; ol_cnt &gt; 0)&#123;</span><br><span class="line">                var temp = ol_cnt;</span><br><span class="line">                while(temp &gt; 0)&#123;</span><br><span class="line">                  ele_Current = ele_Current.lastChild;</span><br><span class="line">                  temp--;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              ele_Current.lastChild.appendChild(ele_ols);</span><br><span class="line">              ol_cnt++;</span><br><span class="line">            &#125; else if (h &lt; old_h &amp;&amp; ol_cnt &gt; 0) &#123;</span><br><span class="line">              if (h == 1) &#123;</span><br><span class="line">                while (ol_cnt &gt; 0) &#123;</span><br><span class="line">                  ol_cnt--;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                ele_ols = document.createElement(&quot;ol&quot;);</span><br><span class="line">                var ele_Current = ele_ol;</span><br><span class="line">                if(ele_Current &amp;&amp; ol_cnt &gt; 0)&#123;</span><br><span class="line">                  var temp = ol_cnt;</span><br><span class="line">                  while(temp &gt; 1)&#123;</span><br><span class="line">                    ele_Current = ele_Current.lastChild;</span><br><span class="line">                    temp--;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              ele_Current.appendChild(ele_ols);</span><br><span class="line"> </span><br><span class="line">              ol_cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (h == 1) &#123;</span><br><span class="line">              while (ol_cnt &gt; 0) &#123;</span><br><span class="line">                ol_cnt--;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            old_h = h;</span><br><span class="line">            // -----</span><br><span class="line">            if (ele_ols)&#123;</span><br><span class="line">              ele_li = document.createElement(&quot;li&quot;)</span><br><span class="line">              ele_ols.appendChild(ele_li);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              ele_li = document.createElement(&quot;li&quot;)</span><br><span class="line">              ele_ol.appendChild(ele_li);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            var a = document.createElement(&quot;a&quot;);</span><br><span class="line">            // 为目录项设置链接</span><br><span class="line">            a.setAttribute(&quot;href&quot;, &quot;#t&quot; + i + header.tagName);</span><br><span class="line">            // 目录项文本</span><br><span class="line">            a.innerHTML = header.textContent;</span><br><span class="line"> </span><br><span class="line">            </span><br><span class="line">            ele_li.appendChild(a);</span><br><span class="line">          &#125;</span><br><span class="line">          // -----</span><br><span class="line">          while (ol_cnt &gt; 0) &#123;</span><br><span class="line">            ol_cnt--;</span><br><span class="line">          &#125;</span><br><span class="line">          // -----</span><br><span class="line"> </span><br><span class="line">        &#125;);</span><br><span class="line">// 代开和关闭目录的函数</span><br><span class="line">function openct(e) &#123;</span><br><span class="line">  if (e.innerHTML == &apos;[+]&apos;) &#123;</span><br><span class="line">    // createTextNode</span><br><span class="line">    e.setAttribute(&apos;title&apos;, &apos;收起&apos;);</span><br><span class="line">    e.innerHTML = &apos;[-]&apos;;</span><br><span class="line">    var element = document.getElementById(&quot;outline_ol&quot;);</span><br><span class="line">    element.style.cssText = &quot;margin-left:14px;padding-left:14px;line-height:160%;&quot;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    e.setAttribute(&apos;title&apos;, &apos;展开&apos;);</span><br><span class="line">    e.innerHTML = &apos;[+]&apos;;</span><br><span class="line">    var element = document.getElementById(&quot;outline_ol&quot;);</span><br><span class="line">    element.style.cssText = &quot;display:none;margin-left:14px;padding-left:14px;line-height:160%;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  e.blur();</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p></p><h2 id="具体实现的步骤，和改进"><a href="#具体实现的步骤，和改进" class="headerlink" title="具体实现的步骤，和改进"></a>具体实现的步骤，和改进</h2><p>js忘光了，先用最弱智的方法来实现吧。<br>关键代码：这个代码有点脑残的。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">var h1Count=1,h1Addflag=0;</span><br><span class="line">var h2Count=1,h2Addflag=0;</span><br><span class="line">var h3Count=1,h3Addflag=0;</span><br><span class="line">var h4Count=1,h4Addflag=0;</span><br><span class="line">var h5Count=1,h5Addflag=0;</span><br><span class="line">var h6Count=1,h6Addflag=0;</span><br><span class="line">$(document).ready(function()</span><br><span class="line">&#123;</span><br><span class="line">$(&quot;h1,h2,h3,h4,h5,h6&quot;).each(function(i,item)</span><br><span class="line">&#123;</span><br><span class="line">//获取标签的名字,h1,还是h2</span><br><span class="line">var tag = $(item).get(0).localName;</span><br><span class="line">if(tag===&quot;h1&quot;)</span><br><span class="line">&#123;</span><br><span class="line">if(h1Addflag===1)</span><br><span class="line">&#123;</span><br><span class="line">h1Count++;</span><br><span class="line">&#125;</span><br><span class="line">h1Addflag=1;</span><br><span class="line">//初始化子节点</span><br><span class="line">h2Count=1;h3Count=1;h4Count=1;h5Count=1;h6Count=1;</span><br><span class="line">//初始化子节点标志刚开始不要加1</span><br><span class="line">h2Addflag=0;h3Addflag=0;h4Addflag=0;h5Addflag=0;h6Addflag=0;</span><br><span class="line">console.log(&quot;捕获到标签:%s&quot;,tag);</span><br><span class="line">var text=$(item).get(0).innerHTML;</span><br><span class="line">$(item).get(0).innerHTML=(h1Count)+&quot; &quot;+text;</span><br><span class="line">&#125;</span><br><span class="line">if(tag===&quot;h2&quot;)</span><br><span class="line">&#123;</span><br><span class="line">if(h2Addflag===1)</span><br><span class="line">&#123;</span><br><span class="line">h2Count++;</span><br><span class="line">&#125;</span><br><span class="line">h2Addflag=1;</span><br><span class="line">//初始化子节点</span><br><span class="line">h3Count=1;h4Count=1;h5Count=1;h6Count=1;</span><br><span class="line">//初始化子节点标志刚开始不要加1</span><br><span class="line">h3Addflag=0;h4Addflag=0;h5Addflag=0;h6Addflag=0;</span><br><span class="line">console.log(&quot;捕获到标签:%s&quot;,tag);</span><br><span class="line">var text=$(item).get(0).innerHTML;</span><br><span class="line">$(item).get(0).innerHTML=(h1Count)+&quot;.&quot;+(h2Count)+&quot; &quot;+text;</span><br><span class="line">&#125;</span><br><span class="line">if(tag===&quot;h3&quot;)</span><br><span class="line">&#123;</span><br><span class="line">if(h3Addflag===1)</span><br><span class="line">&#123;</span><br><span class="line">h3Count++;</span><br><span class="line">&#125;</span><br><span class="line">h3Addflag=1;</span><br><span class="line">//初始化子节点</span><br><span class="line">h4Count=1;h5Count=1;h6Count=1;</span><br><span class="line">//初始化子节点标志刚开始不要加1</span><br><span class="line">h4Addflag=0;h5Addflag=0;h6Addflag=0;</span><br><span class="line">console.log(&quot;捕获到标签:%s&quot;,tag);</span><br><span class="line">var text=$(item).get(0).innerHTML;</span><br><span class="line">$(item).get(0).innerHTML=(h1Count)+&quot;.&quot;+(h2Count)+&quot;.&quot;+(h3Count)+&quot; &quot;+text;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">if(tag===&quot;h4&quot;)</span><br><span class="line">&#123;</span><br><span class="line">if(h4Addflag===1)</span><br><span class="line">&#123;</span><br><span class="line">h4Count++;</span><br><span class="line">&#125;</span><br><span class="line">h4Addflag=1;</span><br><span class="line">//初始化子节点</span><br><span class="line">h5Count=1;h6Count=1;</span><br><span class="line">//初始化子节点标志刚开始不要加1</span><br><span class="line">h5Addflag=0;h6Addflag=0;</span><br><span class="line">console.log(&quot;捕获到标签:%s&quot;,tag);</span><br><span class="line">var text=$(item).get(0).innerHTML;</span><br><span class="line">$(item).get(0).innerHTML=(h1Count)+&quot;.&quot;+(h2Count)+&quot;.&quot;+(h3Count)+&quot;.&quot;+(h4Count)+&quot; &quot;+text;</span><br><span class="line">&#125;</span><br><span class="line">if(tag===&quot;h5&quot;)</span><br><span class="line">&#123;</span><br><span class="line">if(h5Addflag===1)</span><br><span class="line">&#123;</span><br><span class="line">h5Count++;</span><br><span class="line">&#125;</span><br><span class="line">h5Addflag=1;</span><br><span class="line">//初始化子节点</span><br><span class="line">h6Count=1;</span><br><span class="line">console.log(&quot;捕获到标签:%s&quot;,tag);</span><br><span class="line">//初始化子节点标志刚开始不要加1</span><br><span class="line">h6Addflag=0;</span><br><span class="line">var text=$(item).get(0).innerHTML;</span><br><span class="line">$(item).get(0).innerHTML=(h1Count)+&quot;.&quot;+(h2Count)+&quot;.&quot;+(h3Count)+&quot;.&quot;+(h4Count)+&quot;.&quot;+(h5Count)+&quot; &quot;+text;</span><br><span class="line">&#125;</span><br><span class="line">if(tag===&quot;h6&quot;)</span><br><span class="line">&#123;</span><br><span class="line">if(h6Addflag===1)</span><br><span class="line">&#123;</span><br><span class="line">h6Count++;</span><br><span class="line">&#125;</span><br><span class="line">h6Addflag=1;</span><br><span class="line">console.log(&quot;捕获到标签:%s&quot;,tag);</span><br><span class="line">var text=$(item).get(0).innerHTML;</span><br><span class="line">$(item).get(0).innerHTML=(h1Count)+&quot;.&quot;+(h2Count)+&quot;.&quot;+(h3Count)+&quot;.&quot;+(h4Count)+&quot;.&quot;+(h5Count)+&quot;.&quot;+(h6Count)+&quot; &quot;+text;</span><br><span class="line">&#125;</span><br><span class="line">//为该标签设置id属性</span><br><span class="line">$(item).attr(&quot;id&quot;,&quot;wow&quot;+i);</span><br><span class="line">//添加一个超链接</span><br><span class="line">$(&quot;#category&quot;).append(&apos;&lt;a class=&quot;new&apos;+tag+&apos;&quot; href=&quot;#wow&apos;+i+&apos;&quot;&gt;&apos;+$(this).text()+&apos;&lt;/a&gt;&lt;/br&gt;&apos;);</span><br><span class="line">//为每一个标题超链接的class属性设置左边距</span><br><span class="line">$(&quot;.newh1&quot;).css(&quot;margin-left&quot;,0);</span><br><span class="line">$(&quot;.newh2&quot;).css(&quot;margin-left&quot;,20);</span><br><span class="line">$(&quot;.newh3&quot;).css(&quot;margin-left&quot;,40);</span><br><span class="line">$(&quot;.newh4&quot;).css(&quot;margin-left&quot;,60);</span><br><span class="line">$(&quot;.newh5&quot;).css(&quot;margin-left&quot;,80);</span><br><span class="line">$(&quot;.newh6&quot;).css(&quot;margin-left&quot;,100);</span><br><span class="line">&#125;);</span><br><span class="line">//设置class选择器为.book-body的html内容</span><br><span class="line">$(&quot;.book-body&quot;).html($(&quot;.book-body&quot;).nextAll())</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>上面通过6个计数器来完成的，和六个标志来完成的，js没学好，代码都很烂。不过幸运的是可以跑起来，下面来改进</p><h3 id="改进："><a href="#改进：" class="headerlink" title="改进："></a>改进：</h3><p>把上面的计数器用数组实现，然后从0开始计数，减少标志位的使用。<br>关键代码：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--重要代码--&gt;</span><br><span class="line">//标题序号计数器</span><br><span class="line">var hCount=[0,0,0,0,0,0];</span><br><span class="line">//设置计数器</span><br><span class="line">function setHCount(number)</span><br><span class="line">&#123;</span><br><span class="line">//当前计数器加一</span><br><span class="line">hCount[number-1]++;</span><br><span class="line">for(var i=number,length=hCount.length;i&lt;length;i++)</span><br><span class="line">&#123;</span><br><span class="line">//子目录计数器全部置零</span><br><span class="line">hCount[i]=0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//重命名目录名称</span><br><span class="line">function setHTagValue(item,number)</span><br><span class="line">&#123;</span><br><span class="line">//获取标题名</span><br><span class="line">var text=$(item).get(0).innerHTML;</span><br><span class="line">//初始化空字符串</span><br><span class="line">var before=&quot;&quot;;</span><br><span class="line">//生成序号</span><br><span class="line">for(var i=0,length=hCount.length;i&lt;number;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(i&lt;number-1)</span><br><span class="line">before+=hCount[i]+&quot;.&quot;;</span><br><span class="line">else</span><br><span class="line">before+=hCount[i]+&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">//$(item).get(0).innerHTML=(h1Count)+&quot;.&quot;+(h2Count)+&quot;.&quot;+(h3Count)+&quot;.&quot;+(h4Count)+&quot;.&quot;+(h5Count)+&quot;.&quot;+(h6Count)+&quot; &quot;+text;</span><br><span class="line">//在标题前面加上序号</span><br><span class="line">$(item).get(0).innerHTML=before+text;</span><br><span class="line">&#125;</span><br><span class="line">function renameHTag(item)</span><br><span class="line">&#123;</span><br><span class="line">var tag = $(item).get(0).localName;</span><br><span class="line">if(tag===&quot;h1&quot;)</span><br><span class="line">&#123;</span><br><span class="line">setHCount(1);</span><br><span class="line">setHTagValue(item,1);</span><br><span class="line">&#125;</span><br><span class="line">if(tag===&quot;h2&quot;)</span><br><span class="line">&#123;</span><br><span class="line">setHCount(2);</span><br><span class="line">setHTagValue(item,2);</span><br><span class="line">&#125;</span><br><span class="line">if(tag===&quot;h3&quot;)</span><br><span class="line">&#123;</span><br><span class="line">setHCount(3);</span><br><span class="line">setHTagValue(item,3);</span><br><span class="line">&#125;</span><br><span class="line">if(tag===&quot;h4&quot;)</span><br><span class="line">&#123;</span><br><span class="line">setHCount(4);</span><br><span class="line">setHTagValue(item,4);</span><br><span class="line">&#125;</span><br><span class="line">if(tag===&quot;h5&quot;)</span><br><span class="line">&#123;</span><br><span class="line">setHCount(5);</span><br><span class="line">setHTagValue(item,5);</span><br><span class="line">&#125;</span><br><span class="line">if(tag===&quot;h6&quot;)</span><br><span class="line">&#123;</span><br><span class="line">setHCount(6);</span><br><span class="line">setHTagValue(item,6)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">$(document).ready(function()</span><br><span class="line">&#123;</span><br><span class="line">$(&quot;h1,h2,h3,h4,h5,h6&quot;).each(function(i,item)</span><br><span class="line">&#123;</span><br><span class="line">//给&lt;H&gt;类标签编号</span><br><span class="line">renameHTag(item);</span><br><span class="line">//获取标签的名字,h1,还是h2</span><br><span class="line">var tag = $(item).get(0).localName;</span><br><span class="line"></span><br><span class="line">//为该标签设置id属性</span><br><span class="line">$(item).attr(&quot;id&quot;,&quot;wow&quot;+i);</span><br><span class="line">//添加一个页内超链接,并设置class选择器</span><br><span class="line">//$(&quot;#category&quot;).append(&apos;&lt;a class=&quot;new&apos;+tag+&apos;&quot; href=&quot;#wow&apos;+i+&apos;&quot;&gt;&apos;+$(this).text()+&apos;&lt;/a&gt;&lt;/br&gt;&apos;);</span><br><span class="line">$(&quot;#category&quot;).append(&apos;&lt;a class=&quot;new&apos;+tag+&apos;&quot; href=&quot;#wow&apos;+i+&apos;&quot;&gt;&apos;+$(item).text()+&apos;&lt;/a&gt;&lt;/br&gt;&apos;);</span><br><span class="line">//为每一个标题超链接的class属性设置左边距</span><br><span class="line">$(&quot;.newh1&quot;).css(&quot;margin-left&quot;,0);</span><br><span class="line">$(&quot;.newh2&quot;).css(&quot;margin-left&quot;,20);</span><br><span class="line">$(&quot;.newh3&quot;).css(&quot;margin-left&quot;,40);</span><br><span class="line">$(&quot;.newh4&quot;).css(&quot;margin-left&quot;,60);</span><br><span class="line">$(&quot;.newh5&quot;).css(&quot;margin-left&quot;,80);</span><br><span class="line">$(&quot;.newh6&quot;).css(&quot;margin-left&quot;,100);</span><br><span class="line">&#125;);</span><br><span class="line">//设置class选择器为.book-body的html内容</span><br><span class="line">$(&quot;.book-body&quot;).html($(&quot;.book-body&quot;).nextAll())</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><div id="Mark"></div><h2 id="实现在标题前面自动编号："><a href="#实现在标题前面自动编号：" class="headerlink" title="实现在标题前面自动编号："></a>实现在标题前面自动编号：</h2><p>改进：把上面的代码用函数封装好，这样阅读起来方便点，不至于一个函数很长。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://code.jquery.com/jquery-1.7.2.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;http://yandex.st/highlightjs/6.2/highlight.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;</span><br><span class="line">&lt;!--重要代码--&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">&lt;!--重要代码--&gt;</span><br><span class="line">&lt;!--重要代码--&gt;</span><br><span class="line">//标题序号计数器</span><br><span class="line">var hCount=[0,0,0,0,0,0];</span><br><span class="line">//设置计数器</span><br><span class="line">function setHCount(number)</span><br><span class="line">&#123;</span><br><span class="line">//当前计数器加一</span><br><span class="line">hCount[number-1]++;</span><br><span class="line">for(var i=number,length=hCount.length;i&lt;length;i++)</span><br><span class="line">&#123;</span><br><span class="line">//子目录计数器全部置零</span><br><span class="line">hCount[i]=0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//重命名目录名称</span><br><span class="line">function setHTagValue(item,number)</span><br><span class="line">&#123;</span><br><span class="line">//获取标题名</span><br><span class="line">var text=$(item).get(0).innerHTML;</span><br><span class="line">//初始化空字符串</span><br><span class="line">var before=&quot;&quot;;</span><br><span class="line">//生成序号</span><br><span class="line">for(var i=0,length=hCount.length;i&lt;number;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(i&lt;number-1)</span><br><span class="line">before+=hCount[i]+&quot;.&quot;;</span><br><span class="line">else</span><br><span class="line">before+=hCount[i]+&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">//$(item).get(0).innerHTML=(h1Count)+&quot;.&quot;+(h2Count)+&quot;.&quot;+(h3Count)+&quot;.&quot;+(h4Count)+&quot;.&quot;+(h5Count)+&quot;.&quot;+(h6Count)+&quot; &quot;+text;</span><br><span class="line">//在标题前面加上序号</span><br><span class="line">$(item).get(0).innerHTML=before+text;</span><br><span class="line">&#125;</span><br><span class="line">function renameHTag(item)</span><br><span class="line">&#123;</span><br><span class="line">var tag = $(item).get(0).localName;</span><br><span class="line">if(tag===&quot;h1&quot;)</span><br><span class="line">&#123;</span><br><span class="line">setHCount(1);</span><br><span class="line">console.log(&quot;捕获到标签:%s&quot;,tag);</span><br><span class="line">setHTagValue(item,1);</span><br><span class="line">&#125;</span><br><span class="line">if(tag===&quot;h2&quot;)</span><br><span class="line">&#123;</span><br><span class="line">setHCount(2);</span><br><span class="line">console.log(&quot;捕获到标签:%s&quot;,tag);</span><br><span class="line">setHTagValue(item,2);</span><br><span class="line">&#125;</span><br><span class="line">if(tag===&quot;h3&quot;)</span><br><span class="line">&#123;</span><br><span class="line">setHCount(3);</span><br><span class="line">console.log(&quot;捕获到标签:%s&quot;,tag);</span><br><span class="line">setHTagValue(item,3);</span><br><span class="line">&#125;</span><br><span class="line">if(tag===&quot;h4&quot;)</span><br><span class="line">&#123;</span><br><span class="line">setHCount(4);</span><br><span class="line">console.log(&quot;捕获到标签:%s&quot;,tag);</span><br><span class="line">setHTagValue(item,4);</span><br><span class="line">&#125;</span><br><span class="line">if(tag===&quot;h5&quot;)</span><br><span class="line">&#123;</span><br><span class="line">setHCount(5);</span><br><span class="line">console.log(&quot;捕获到标签:%s&quot;,tag);</span><br><span class="line">setHTagValue(item,5);</span><br><span class="line">&#125;</span><br><span class="line">if(tag===&quot;h6&quot;)</span><br><span class="line">&#123;</span><br><span class="line">setHCount(6);</span><br><span class="line">console.log(&quot;捕获到标签:%s&quot;,tag);</span><br><span class="line">setHTagValue(item,6)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">$(document).ready(function()</span><br><span class="line">&#123;</span><br><span class="line">$(&quot;h1,h2,h3,h4,h5,h6&quot;).each(function(i,item)</span><br><span class="line">&#123;</span><br><span class="line">//给&lt;H&gt;类标签编号</span><br><span class="line">renameHTag(item);</span><br><span class="line">//获取标签的名字,h1,还是h2</span><br><span class="line">var tag = $(item).get(0).localName;</span><br><span class="line"></span><br><span class="line">//为该标签设置id属性</span><br><span class="line">$(item).attr(&quot;id&quot;,&quot;wow&quot;+i);</span><br><span class="line">//添加一个页内超链接,并设置class选择器</span><br><span class="line">//$(&quot;#category&quot;).append(&apos;&lt;a class=&quot;new&apos;+tag+&apos;&quot; href=&quot;#wow&apos;+i+&apos;&quot;&gt;&apos;+$(this).text()+&apos;&lt;/a&gt;&lt;/br&gt;&apos;);</span><br><span class="line">$(&quot;#category&quot;).append(&apos;&lt;a class=&quot;new&apos;+tag+&apos;&quot; href=&quot;#wow&apos;+i+&apos;&quot;&gt;&apos;+$(item).text()+&apos;&lt;/a&gt;&lt;/br&gt;&apos;);</span><br><span class="line">//为每一个标题超链接的class属性设置左边距</span><br><span class="line">$(&quot;.newh1&quot;).css(&quot;margin-left&quot;,0);</span><br><span class="line">$(&quot;.newh2&quot;).css(&quot;margin-left&quot;,20);</span><br><span class="line">$(&quot;.newh3&quot;).css(&quot;margin-left&quot;,40);</span><br><span class="line">$(&quot;.newh4&quot;).css(&quot;margin-left&quot;,60);</span><br><span class="line">$(&quot;.newh5&quot;).css(&quot;margin-left&quot;,80);</span><br><span class="line">$(&quot;.newh6&quot;).css(&quot;margin-left&quot;,100);</span><br><span class="line">&#125;);</span><br><span class="line">//设置class选择器为.book-body的html内容</span><br><span class="line">$(&quot;.book-body&quot;).html($(&quot;.book-body&quot;).nextAll())</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line"></span><br><span class="line">@media (max-width: 1600px) &#123;</span><br><span class="line">    .book-body &#123;</span><br><span class="line">       padding-left:200px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media (max-width: 1400px) &#123;</span><br><span class="line">    .book-body &#123;</span><br><span class="line">       padding-left:200px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media (max-width: 1200px) &#123;</span><br><span class="line">    .book-body &#123;</span><br><span class="line">       padding-left:300px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media (max-width: 700px) &#123;</span><br><span class="line">    .book-body &#123;</span><br><span class="line">       padding-left:0px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media (min-width: 600px) &#123;</span><br><span class="line">    #category&#123;</span><br><span class="line">        position: fixed;</span><br><span class="line">        left: 20px;</span><br><span class="line">        top:0;</span><br><span class="line">        height: 100%;</span><br><span class="line">        overflow-y: scroll;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media (-webkit-max-device-pixel-ratio: 1) &#123;</span><br><span class="line">    ::-webkit-scrollbar-track-piece &#123;</span><br><span class="line">        background-color:#FFF</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ::-webkit-scrollbar &#123;</span><br><span class="line">        width: 6px;</span><br><span class="line">        height: 6px</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ::-webkit-scrollbar-thumb &#123;</span><br><span class="line">        background-color: #c2c2c2;</span><br><span class="line">        background-clip: padding-box;</span><br><span class="line">        min-height: 28px</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ::-webkit-scrollbar-thumb:hover &#123;</span><br><span class="line">        background-color: #A0A0A0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;!--返回顶部--&gt;</span><br><span class="line">&lt;a href=&quot;javascript:scroll(0,0)&quot; style=&quot;position:fixed;float:right;right:32px;top:70%&quot;&gt;返回顶部&lt;/a&gt; </span><br><span class="line">&lt;!--目录栏，设置占用宽度为20%可以根据实际情况设置--&gt;</span><br><span class="line">&lt;div style=&quot;width:20%;&quot; id=&quot;category&quot; class=&quot;book-summary&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;!--文章主体部分--&gt;</span><br><span class="line">&lt;div class=&quot;book-body&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p></p><h2 id="MarkdownPad2中的设置"><a href="#MarkdownPad2中的设置" class="headerlink" title="MarkdownPad2中的设置"></a>MarkdownPad2中的设置</h2><p>复制上面的代码，然后打开MarkDownPad2，<br>在MarkdownPad2中点击<code>工具--&gt;选项--&gt;高级--&gt;HTML Head编辑器</code>，然后粘贴上面代码，然后<code>保存并关闭</code>即可。<br><img src="https://i.imgur.com/pxuD8Y8.png" alt=""></p><p><img src="https://i.imgur.com/KIlcMJS.png" alt=""></p><p><img src="https://i.imgur.com/K6IXNSF.png" alt=""></p><h3 id="导出HTML"><a href="#导出HTML" class="headerlink" title="导出HTML"></a>导出HTML</h3><p>然后来导出HTML，这样才能看见侧目录。<br>选择<code>文件--&gt;导出--&gt;导出 HTML</code>,然后保存到本地即可。<br><img src="https://i.imgur.com/m1Q2OuZ.png" alt=""></p><p>然后就可看到效果了</p><p><img src="https://i.imgur.com/IjHSC6W.png" alt=""></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/59af15ef/">带书签JS设置1</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java 正则表达式 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>小技巧-cmd常用命令之创建文件</title>
      <link href="/blog/6aff1849/"/>
      <url>/blog/6aff1849/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:16 GMT+0800 (中国标准时间) --><p>一、建立空文件的几种方法<br>1、<code>cd.&gt;a.txt</code><br>cd.表示改变当前目录为当前目录，即等于没改变；而且cd命令不会有输出。<br>“&gt;”表示把命令输出写入到文件。后面跟着a.txt，就表示写入到a.txt。<br>而此例中命令不会有输出，所以就创建了没有内容的空文件。<br><img src="https://i.imgur.com/jLjCU4z.png" alt=""><br>当然不用写地址也是可以的，也就是说<code>cd &gt;1.txt</code>也是可以的。<br><img src="https://i.imgur.com/s914p7I.png" alt=""></p><p>2、<code>copy nul a.txt</code><br><strong>nul表示空设备</strong>，从概念上讲，它不可见，存在于每个目录中，可以把它看成一个特殊的“文件”，它没有内容；<strong>一般可把输出写入到nul，来达到屏蔽输出的目的</strong>，如pause&gt;nul，此命令执行效果是暂停，并且不会显示“请按任意键继续…”。<br>此例子表示将空设备复制到a.txt，同样创建了没有内容的空文件。<br><img src="https://i.imgur.com/IMKmwSW.png" alt=""><br>3、<code>type nul&gt;a.txt</code><br>此例子表示显示空设备的内容，并写入到a.txt。空目录没有内容，所以也就是创建了一个空文件。<br><img src="https://i.imgur.com/gvC4DMB.png" alt=""></p><p>4、<code>echo a 2&gt;a.txt</code><br><strong>“<code>2</code>”表示错误输出的句柄</strong>，此例中没有错误输出，所以创建了没有内容的空文件。<br>其实<strong><code>&gt;</code>默认都是重定向了<code>句柄1</code>，即标准输出句柄</strong>。比如cd.&gt;a.txt，其实就是cd. 1&gt;a.txt。<br>同样，句柄3到9也可以使用在本例中，它们是未经定义的句柄，也不会有输出，如<br>echo a 3&gt;a.txt。</p><p>5、fsutil file createnew d:\a.txt 0<br>使用fsutil创建了一个空文件。</p><p>6、其他命令<br><strong>只要没有输出，并重定向到文件就可以了</strong></p><p>二、建立非空文件的几种方法<br>1、echo a&gt;a.txt<br>最常用的是echo命令，此例子表示把字母a和回车换行覆盖输出到a.txt（如果a.txt原来已有内容则覆盖掉原来的内容），如果追加内容，可以使用&gt;&gt;，如echo b&gt;&gt;a.txt，表示把b和回车换行追加到文件末尾。</p><p>2、其他命令的重定向输出，如<br>type a.txt &gt; b.txt<br>copy a.txt b.txt<br>fsutil file createnew d:\a.txt 1<br>转载自<br><a href="https://zhidao.baidu.com/question/277563240.html" target="_blank" rel="noopener">百度知道-cmd 如何新建文件</a></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/6aff1849/">小技巧-cmd常用命令之创建文件</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用git上传本地项目到GitHub上和更新</title>
      <link href="/blog/39d991de/"/>
      <url>/blog/39d991de/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:16 GMT+0800 (中国标准时间) --><p>使用git上传本地项目到GitHub上和更新<br>最近在玩GitHub这个基友平台，在这里做个总结，方便以后查阅，也可以给网友们做个参考。<br><strong>一：注册GitHub账号和下载git。</strong><br><strong>二：在GitHub上新建个仓库</strong>，点+号再点击<code>New repository</code>，给你的仓库起个名字，我的是test。<br><img src="https://images2017.cnblogs.com/blog/1214959/201711/1214959-20171109092743356-1757164386.jpg" alt=""></p><p><img src="https://images2017.cnblogs.com/blog/1214959/201711/1214959-20171109093101247-1143276449.jpg" alt=""><br><br><strong>三：安装git</strong>，我安装的是win64版本，直接解压安装就好。在本地磁盘找一个文件夹作为本地仓库，选择Git Bash Here，切换到/e/te 目录下，输入git init初始化，发现目录下多了一个.git文件夹。<br><img src="https://images2017.cnblogs.com/blog/1214959/201711/1214959-20171109093734716-1606118198.jpg" alt=""><br><img src="https://images2017.cnblogs.com/blog/1214959/201711/1214959-20171109094827934-1230236170.jpg" alt=""><br><img src="https://images2017.cnblogs.com/blog/1214959/201711/1214959-20171109094857966-1693570795.jpg" alt=""><br><strong>四：配置ssh key值</strong><br>在git命令行中对git进行全局设置，<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;你的GitHub用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的GitHub邮箱地址&quot;</span><br></pre></td></tr></table></figure><p></p><p><img src="https://images2017.cnblogs.com/blog/1214959/201711/1214959-20171109095703513-1069227161.jpg" alt=""></p><p>在git命令行中，输入命令： cd ~/.ssh，来检测是否生成过key,没有生成过key，会有相关信息提示；然后输入命令： ssh-keygen -t rsa -C “邮箱地址”，按下回车键；然后根据返回的信息，找到.ssh目录下的两个文件；<br><img src="https://images2017.cnblogs.com/blog/1214959/201711/1214959-20171109100717231-679281242.jpg" alt=""><br><br>在github网站上点击“setting”，找到添加SSH key的菜单，然后新增SSH key；把文件id_rsa.pub 里面的内容全部复制到 key编辑框中，Title可以随便命名，保存完毕；<br><img src="https://images2017.cnblogs.com/blog/1214959/201711/1214959-20171109102959716-1646619495.jpg" alt=""></p><p>在git-bash中命令行输入：ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>；这里会要求你输入SSH key密码，如果刚才生成SSH key时未输入密码，密码就为空；然后看到信息：</p><p>ERROR: Hi 用户名! You’ve successfully authenticated，but GitHub does not provide shell access.；说明配置成功；</p><p>登陆到github上查看刚刚输入的SSH key，现在图标的颜色变为绿色，说明密钥配置有效；现在可以在git命令行上进行git操作了；<br><img src="https://images2017.cnblogs.com/blog/1214959/201711/1214959-20171109103846028-153793615.jpg" alt=""></p><p><strong>五：上传本地项目到仓库</strong></p><p><strong>（1）远程仓库</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:用户名/项目名</span><br></pre></td></tr></table></figure><p></p><p><img src="https://images2017.cnblogs.com/blog/1214959/201711/1214959-20171109105248622-376913523.jpg" alt=""></p><p><strong>（2）添加你要上传的文件</strong>，<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p></p><p><code>.</code>代表上传目录下所有文件，可以在<code>git add</code>后面加上你要添加的特定文件，比如<code>git add aa.html</code><br><img src="https://images2017.cnblogs.com/blog/1214959/201711/1214959-20171109105846528-1532870439.jpg" alt=""><br><strong>(3)提交项目</strong>，输入<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m &quot;提交说明&quot;</span><br></pre></td></tr></table></figure><p></p><p><strong>(4)推送到GitHub上的master分支</strong><br>再输入<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p></p><p><img src="https://images2017.cnblogs.com/blog/1214959/201711/1214959-20171109110138091-1582511346.jpg" alt=""><br>大功告成，可以在GitHub查看项目<br><img src="https://images2017.cnblogs.com/blog/1214959/201711/1214959-20171109110521934-2132006458.jpg" alt=""></p><h2 id="更新项目"><a href="#更新项目" class="headerlink" title="更新项目"></a>更新项目</h2><p>更新项目，先添加文件(<code>git add .</code>)，再提交<code>git commit -m &quot;说明&quot;</code>，更新前最好用<code>git pull origin master</code>更新一下你的本地项目，因为可能有别人做了更新。最后再推送到远程仓库<code>git push origin master</code>就行了。<br><img src="https://images2017.cnblogs.com/blog/1214959/201711/1214959-20171109110853559-1249314412.jpg" alt=""></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/39d991de/">使用git上传本地项目到GitHub上和更新</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> git教程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>上传本地代码及更新代码到GitHub教程</title>
      <link href="/blog/afb052f3/"/>
      <url>/blog/afb052f3/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:16 GMT+0800 (中国标准时间) --><h2 id="上传本地代码"><a href="#上传本地代码" class="headerlink" title="上传本地代码"></a>上传本地代码</h2><p><strong>第一步：去github上创建自己的Repository</strong>，创建页面如下图所示：<br><img src="https://images2017.cnblogs.com/blog/1249529/201710/1249529-20171025111734035-171097772.png" alt=""><br>红框为新建的仓库的https地址<br><img src="https://images2017.cnblogs.com/blog/1249529/201710/1249529-20171025111740348-1861677831.png" alt=""><br><strong>第二步：打开你的工程目录</strong><br>我这里没有是个空目录，所以先来创建一个文件，在工程目录(Test)下新建一个文件<code>README.md</code><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;# Test&quot; &gt;&gt; README.md</span><br></pre></td></tr></table></figure><p></p><p><strong>第三步：建立git仓库</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p></p><p><strong>第四步：将项目的所有文件添加到仓库中</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p></p><p><strong>第五步：提交到仓库</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;提交说明&quot;</span><br></pre></td></tr></table></figure><p></p><p><strong>第六步：将本地的仓库关联到GitHub</strong><br>后面的https改成刚刚自己的地址，上面的红框处<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/zlxzlxzlx/Test.git</span><br></pre></td></tr></table></figure><p></p><p><strong>第七步：上传代码到GitHub远程仓库</strong><br>因为这里是第一次上传，所以需要加上<code>-u</code>，参数，后面上传就不用加<code>-u</code>参数了直接使用<code>git push origin master</code>推送到主分支上就行了<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p></p><p>中间可能会让你输入Username和Password，你只要输入github的账号和密码就行了。执行完后，如果没有异常，等待执行完就上传成功了。</p><h2 id="更新代码"><a href="#更新代码" class="headerlink" title="更新代码"></a>更新代码</h2><p><strong>第一步：查看当前的git仓库状态</strong>，可以使用git status<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p></p><p><strong>第二步：更新全部</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add *</span><br></pre></td></tr></table></figure><p></p><p><strong>第三步：接着输入git commit -m “更新说明”</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;更新说明&quot;</span><br></pre></td></tr></table></figure><p></p><p><strong>第四步：先git pull,拉取当前分支最新代码</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p></p><p>第五步：push到远程master分支上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>不出意外，打开GitHub已经同步了</p><p>本文参考：<a href="https://www.cnblogs.com/zlxbky/p/7727895.html" target="_blank" rel="noopener">https://www.cnblogs.com/zlxbky/p/7727895.html</a></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/afb052f3/">上传本地代码及更新代码到GitHub教程</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> git教程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>git上传项目全部流程</title>
      <link href="/blog/be26f7a6/"/>
      <url>/blog/be26f7a6/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:16 GMT+0800 (中国标准时间) --><h2 id="一、下载git"><a href="#一、下载git" class="headerlink" title="一、下载git"></a>一、下载git</h2><p>进入网址：<a href="https://git-scm.com/downloads；" target="_blank" rel="noopener">https://git-scm.com/downloads；</a><br><img src="https://images2017.cnblogs.com/blog/1322155/201801/1322155-20180120160852662-37045569.png" alt=""><br>点击中的Download 2.16.0 for Windows;<br><img src="https://images2017.cnblogs.com/blog/1322155/201801/1322155-20180120161042428-614927451.png" alt=""></p><p>在中选择蓝色字段点击，根据电脑64或32位选择适合的下载，点击即可进行下载，下载完成后傻瓜式安装，一直点击下一步即可完成安装；</p><p>安装完成后，鼠标右击桌面，会发现：“Git Bash Here”,选择进入git命令行</p><h2 id="二、在github上新建个远程厂库"><a href="#二、在github上新建个远程厂库" class="headerlink" title="二、在github上新建个远程厂库"></a>二、在github上新建个远程厂库</h2><p>在此页面进行注册，注册完了在右上角有个：“Sign in”,点击进入进行登录；<br><img src="https://images2017.cnblogs.com/blog/1322155/201801/1322155-20180120162101099-542604259.png" alt=""></p><p>登录成功后，在右下方寻找，点击New repository，然后在此处</p><p><img src="https://images2017.cnblogs.com/blog/1322155/201801/1322155-20180120162525224-1063916899.png" alt=""><br>填写你新建的厂库名，这里用“fire”作为示例，填完点击下方绿色框内的“Create repository”即可完成厂库的新建</p><p><img src="https://images2017.cnblogs.com/blog/1322155/201801/1322155-20180120162657334-1430375785.png" alt=""></p><h2 id="三、利用git命令行连接github"><a href="#三、利用git命令行连接github" class="headerlink" title="三、利用git命令行连接github"></a>三、利用git命令行连接github</h2><p>在连接远程厂库前，必须确保电脑连接了自己的GitHub</p><h3 id="1、配置秘钥"><a href="#1、配置秘钥" class="headerlink" title="1、配置秘钥"></a>1、配置秘钥</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;</span><br></pre></td></tr></table></figure><p>此处的”<a href="mailto:`your_email@youremail.com" target="_blank" rel="noopener">`your_email@youremail.com</a><code>&quot;改为你自己的邮箱，回车之后一直回车就行，结束后你会在</code>C:\Users\Administrator.ssh<code>目录下看到“</code>id_rsa.pub<code>”，使用记事本打开，然后复制里面的内容，然后打开你的github账号，找到这个页面选择</code>Settings<code>，点击进入在左边出现的目录中有：“</code>SSH and GPG keys”<code>,选择它会在右上角出现一个绿色框，里面有文字：“</code>New SSH key<code>”,点击然后在&quot;</code>Key<code>&quot;中把你刚刚复制的粘贴上去，“</code>Title`”可以随便填，没什么用。<br><img src="https://images2017.cnblogs.com/blog/1322155/201801/1322155-20180120163907162-1205073827.png" alt=""></p><h3 id="2、验证连接是否成功"><a href="#2、验证连接是否成功" class="headerlink" title="2、验证连接是否成功"></a>2、验证连接是否成功</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>如果回车看到：<code>You&#39;ve successfully authenticated</code>,<code>but GitHub dose not provide shell access</code>,表示已经成功连上<code>github</code>。</p><h3 id="3、设置username和email"><a href="#3、设置username和email" class="headerlink" title="3、设置username和email"></a>3、设置username和email</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;your name&quot;</span><br><span class="line"></span><br><span class="line">$ git config --global user.name &quot;your_email@youremail.com&quot;</span><br></pre></td></tr></table></figure><p>在项目每次上传的时候每次commit都会记录你的username和email，所以要设置</p><h2 id="四、连接远程厂库"><a href="#四、连接远程厂库" class="headerlink" title="四、连接远程厂库"></a>四、连接远程厂库</h2><p>基本配置完成，接下来就是上传你要上传的项目了。</p><h3 id="1、初始化git"><a href="#1、初始化git" class="headerlink" title="1、初始化git"></a>1、初始化git</h3><p><strong>进入你要上传的项目的文件夹</strong>，在文件夹内鼠标右击，选择“<code>Git Bash Here</code>”打开<code>git</code>命令行，输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><p>目的是初始化<code>git</code>，并且会创建个“<code>.git</code>”文件夹，里面有个“<code>config</code>”就是用来保存远程厂库路径地址的，如果想更换厂库可直接在里面对路径进行修改</p><h3 id="2、添加远程厂库"><a href="#2、添加远程厂库" class="headerlink" title="2、添加远程厂库"></a>2、添加远程厂库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:tt-wedos/fire.git</span><br></pre></td></tr></table></figure><p>这里的“<code>tt-wedos</code>”是我<code>github</code>上的用户名，你们要改成自己的，“<code>fire</code>”是我刚刚创建的厂库名字，你们也要对应改成自己新建的厂库名字</p><h3 id="3-添加项目并上传"><a href="#3-添加项目并上传" class="headerlink" title="3.添加项目并上传"></a>3.添加项目并上传</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br></pre></td></tr></table></figure><p>注意这里的<code>add</code>后面还有个“<code>.</code>”，小点的意识是选择所有文件进行上传，不能忽略<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &apos;my projest push&apos;</span><br></pre></td></tr></table></figure><p></p><p>引号内的内容可以随便填写，目的是描述记录每次上的内容是什么<br>第一次推送master分支的所有内容：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure><p></p><p>第一次要加上-u参数，如果不加的话会推送失败，后面就不需要再加-u参数了。</p><p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改高GitHub中</p><p>push内容到github上面，如果你的厂库不是新建的，里面以前已经有内容，你再次上传新内容想覆盖，就要在后面加“-f”,代码如下：$ git push origin master -f</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/be26f7a6/">git上传项目全部流程</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> git教程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>文件流和缓冲流的比较_输出缓冲流源码详解</title>
      <link href="/blog/d2ebfe94/"/>
      <url>/blog/d2ebfe94/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:16 GMT+0800 (中国标准时间) --><p>我们知道使用FileInputStream和FileOutputStream可以实现文件复制，有两种复制方法，一种是读一个字节，写一个字节。方法如下:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用FileInputStream和FileOutputSteam来复制文件。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> fromPath 源文件</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> toPath 目的文件</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> FileNotFoundException</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyByFileStreamOneByOne</span><span class="params">(String fromPath, String toPath)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> FileNotFoundException, IOException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InputStream in = <span class="keyword">new</span> FileInputStream(fromPath);</span><br><span class="line">    OutputStream out = <span class="keyword">new</span> FileOutputStream(toPath);</span><br><span class="line">    <span class="keyword">int</span> readNum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 每次从输入流读取一个字节到readNum中</span></span><br><span class="line">    <span class="keyword">while</span> ((readNum = in.read()) != -<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// System.out.println(a++);</span></span><br><span class="line">        <span class="comment">// 把放在readNum中读到的字节写入到输出流中</span></span><br><span class="line">        out.write(readNum);</span><br><span class="line">    &#125;</span><br><span class="line">    in.close();</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>当然一个字节一个字节的读取时很慢的，所以可以每次读入一个字节数组，然后写入一个字节数组，这样比上面块一点，如下所示。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用FileInputStream和FileOutputSteam来复制文件。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> fromPath</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> toPath</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> FileNotFoundException</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyByFileStream</span><span class="params">(String fromPath, String toPath)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> FileNotFoundException, IOException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InputStream in = <span class="keyword">new</span> FileInputStream(fromPath);</span><br><span class="line">    OutputStream out = <span class="keyword">new</span> FileOutputStream(toPath);</span><br><span class="line">    <span class="comment">// 缓冲数组</span></span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> readLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 每次从输入流读取一个数字</span></span><br><span class="line">    <span class="keyword">while</span> ((readLength = in.read(buffer)) != -<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// System.out.println(a++);</span></span><br><span class="line">        <span class="comment">// 写入到输出流中</span></span><br><span class="line">        out.write(buffer, <span class="number">0</span>, readLength);</span><br><span class="line">    &#125;</span><br><span class="line">    in.close();</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>java.io包中还提供了带缓冲的字节流，BufferedInputStream和BufferedOutputStream,这两个字节流可以分别包装上面的FileInputSteam和FileOutpuStream。带缓冲的字节类内部提供了缓冲，</p><p>BufferedInputStream先读取比请求更多的数据到缓冲区(内部字节数字)，当调用read时如果数据已经在缓存区，则直接从缓冲区返回对应数据不做IO操作。缓冲中的数据实际上是保存在内存中，而原始数据可能是保存在硬盘或NandFlash等存储介质中；而我们知道，从内存中读取数据的速度比从硬盘读取数据的速度至少快10倍以上。<br>使用BufferedOutput的write()方法进行写入的时候，write()方法会先写到BuffredOutputStream的内部字节数组中。当内部缓冲写满后，BufferedOutputStream会自动把内部的字节数组写入到文件中。<br>使用带缓冲的字节流进行复制文件如下所示，虽然看起来是一个字节一个字节的读写，但是由于使用缓冲了，这种方式比FileInputStream和FileOutputSteam方式一个字节一个字节的读写方式要快很多很多。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用BufferedInputStream和BufferOutputStream进行文件复制.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> fromPath</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> toPath</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> FileNotFoundException</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyByBufferedStreamOneByOne</span><span class="params">(String fromPath, String toPath)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> FileNotFoundException, IOException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BufferedOutputStream buffOut = <span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">    <span class="keyword">new</span> FileOutputStream(toPath),<span class="number">1024</span>*<span class="number">10</span>);</span><br><span class="line">    BufferedInputStream buffIn = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">    <span class="keyword">new</span> FileInputStream(fromPath),<span class="number">1024</span>*<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//byte[] buf = new byte[1024*10];</span></span><br><span class="line">    <span class="keyword">while</span> ((len = buffIn.read()) != -<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//System.out.println(count++);</span></span><br><span class="line">        buffOut.write(len);</span><br><span class="line">    &#125;</span><br><span class="line">    buffOut.close();</span><br><span class="line">    buffIn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>当然BufferedInputStream和BufferedOutputStream也可以提供一次读取一个数字和一次写入一个数字的方法，方法如下所示。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用BufferedInputStream和BufferOutputStream进行文件复制.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> fromPath</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> toPath</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> FileNotFoundException</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyByBufferedStream</span><span class="params">(String fromPath, String toPath)</span> <span class="keyword">throws</span> FileNotFoundException, IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BufferedOutputStream buffOut = <span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">    <span class="keyword">new</span> FileOutputStream(toPath));</span><br><span class="line">    BufferedInputStream buffIn = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">    <span class="keyword">new</span> FileInputStream(fromPath));</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">while</span> ((len = buffIn.read(buf)) != -<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//System.out.println(count++);</span></span><br><span class="line">        buffOut.write(buf,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    buffOut.close();</span><br><span class="line">    buffIn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这四种方法复制文件比较：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    String fromPath = <span class="string">"C:\\Users\\lan\\Desktop\\副本.png"</span>;</span><br><span class="line">    String toPath = <span class="string">"C:\\Users\\lan\\Desktop\\副本的副本.png"</span>;</span><br><span class="line">    <span class="keyword">long</span> start=System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>*<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        copyByFileStream(fromPath, toPath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> end=System.currentTimeMillis();</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"使用FileInputStream和FileOutputStream复制文件用时:"</span>+(end-start));</span><br><span class="line">    start=System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>*<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        copyByBufferedStream(fromPath, toPath);</span><br><span class="line">    &#125;</span><br><span class="line">    end=System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"使用BufferdInputStream和BufferedOutputStream复制文件用时:"</span>+(end-start));</span><br><span class="line">    start=System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>*<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        copyByBufferedStreamOneByOne(fromPath, toPath);</span><br><span class="line">    &#125;</span><br><span class="line">    end=System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"使用BufferdInputStream和BufferedOutputStream逐个字节复制文件用时:"</span>+(end-start));</span><br><span class="line">    start=System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        copyByFileStreamOneByOne(fromPath, toPath);</span><br><span class="line">    &#125;</span><br><span class="line">    end=System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"使用FileInputStream和FileOutputStream逐个字节复制文件用时:"</span>+(end-start));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>运行结果：</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用FileInputStream和FileOutputStream复制文件用时:17499</span><br><span class="line">使用BufferdInputStream和BufferedOutputStream复制文件用时:16165</span><br><span class="line">使用BufferdInputStream和BufferedOutputStream逐个字节复制文件用时:32333</span><br><span class="line">使用FileInputStream和FileOutputStream逐个字节复制文件用时:40719</span><br></pre></td></tr></table></figure><p></p><p><strong>先来看按数组读取的情况：</strong><br>可以看到，使用FileInputStream和FileOutputStream每次读写<code>1024*10</code>个字节的数组，与使用BufferInputStream和BufferOutputStream每次读取<code>1024*10</code>个字节的数组。速度差不多，可能使用缓冲方式会快一点。</p><p><strong>按字节逐个字节读写的情况：</strong><br>可以发现使用缓冲流逐个字节读取的情况还是挺快的，使用缓冲流逐个字节读写方式，复制一个文件1000*10次的事件为32333，而使用文件流读写100次就用时40719。这两个简直一个天上一个地下。</p><p>所以说<strong>如果是逐个字符方式进行读写的话，使用缓冲流效率更好。</strong></p><h2 id="BufferedOutputStream源码分析"><a href="#BufferedOutputStream源码分析" class="headerlink" title="BufferedOutputStream源码分析"></a>BufferedOutputStream源码分析</h2><p>要介绍BufferedOutputStream，我们先了解一下OutputStream类<br>抽象类OutputStream类有三个write方法</p><h3 id="OutputStream源码："><a href="#OutputStream源码：" class="headerlink" title="OutputStream源码："></a>OutputStream源码：</h3><p>参考文章：<a href="https://blog.csdn.net/u010149189/article/details/51355523" target="_blank" rel="noopener">BufferedOutputStream的缓存功能解析（源码阅读）</a><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputStream</span> <span class="keyword">implements</span> <span class="title">Closeable</span>, <span class="title">Flushable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        write(b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((off &lt; <span class="number">0</span>) || (off &gt; b.length) || (len &lt; <span class="number">0</span>) ||</span><br><span class="line">                   ((off + len) &gt; b.length) || ((off + len) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i++) &#123;</span><br><span class="line">            write(b[off + i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>可以看到OutputStream一共定义了以上5个方法。有三个write()方法，一个flush()方法，一个close()方法。<br>现在主要来看着三个write()方法<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[])</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></span></span><br></pre></td></tr></table></figure><p></p><p>第一个方法<code>public abstract void write(int b)</code>使用<code>abstract</code>修饰，所以第一个方法明显是让子类去覆盖的,第二个方法源码如下。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    write(b, <span class="number">0</span>, b.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>可以看到，这个写整个数组的方法还是调用第三个方法去实现的，第三个方法的源码如下<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((off &lt; <span class="number">0</span>) || (off &gt; b.length) || (len &lt; <span class="number">0</span>) ||</span><br><span class="line">               ((off + len) &gt; b.length) || ((off + len) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i++) &#123;</span><br><span class="line">    <span class="comment">//调用前面的抽象方法write（int b）同时进行类型转换</span></span><br><span class="line">        write(b[off + i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>问题<br>我们先不看抽象方法是如何实现的，也就是说OutputStream也具有缓存器功能，不过这个缓冲器(byte数组)要我们自己提供，然后我们可以将要写入到流中的数据写到这个byte数组中，然后调用write(byte b[])或者write(byte b[], int off, int len)就可以吧缓存在数组中的数据写入输出流中。</p><p>那为什么还要BufferedInputStream类干什么呢，他们有什么区别呢。同时我们知道BufferedInputStream类中还有一个flush()方法，在OutputStream流中没有flush()方法，这又是为什么呢？flush()是不是必须的呢，接下来看一下BufferedOutputStream的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedOutputStream</span> <span class="keyword">extends</span> <span class="title">FilterOutputStream</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//内部缓存数组</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">byte</span> buf[];</span><br><span class="line">    <span class="comment">//记录内部缓存数组内已经放了多少个字节</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">//默认构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BufferedOutputStream</span><span class="params">(OutputStream out)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(out, <span class="number">8192</span>);<span class="comment">//调用带参构造函数，设置默认缓存数组大小为8192</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//带参构造函数，设置缓存区大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BufferedOutputStream</span><span class="params">(OutputStream out, <span class="keyword">int</span> size)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(out);</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Buffer size &lt;= 0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        buf = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//刷新缓存写入文件</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushBuffer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//计数器大于0，表示内部缓存中有字节</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//调用低层低级流的写数组方法，内部缓存</span></span><br><span class="line">            out.write(buf, <span class="number">0</span>, count);</span><br><span class="line">            <span class="comment">//计数器重新置零</span></span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写字节方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//如果count长度大于内部缓存的大小</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt;= buf.length) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//就刷新内部缓存</span></span><br><span class="line">            flushBuffer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把这个字节放到内部缓存中(写到内部缓存中，而不是写文件)</span></span><br><span class="line">        buf[count++] = (<span class="keyword">byte</span>)b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写数组方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//如果数组的长度大于或等于内部缓存的长度，那是没办法放入缓存中的</span></span><br><span class="line">        <span class="keyword">if</span> (len &gt;= buf.length) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//先把之前读取到缓存中的数据写入低层</span></span><br><span class="line">            flushBuffer();</span><br><span class="line">            <span class="comment">//然后直接调用out(低级流如FileOutputStream out)的写数组方法把这次读取到的数据写入低层中</span></span><br><span class="line">            out.write(b, off, len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果传入的数组，长度小于内部缓存的长度</span></span><br><span class="line">        <span class="comment">//说明内部缓存剩余位置不够放，</span></span><br><span class="line">        <span class="keyword">if</span> (len &gt; buf.length - count) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//先把内部缓存写文件，这样才能挪出位置放下这个数组</span></span><br><span class="line">            flushBuffer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把这个数字复制到内部缓存中</span></span><br><span class="line">        System.arraycopy(b, off, buf, count, len);</span><br><span class="line">        <span class="comment">//更新计数器</span></span><br><span class="line">        count += len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//强制写文件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//写入内部缓存到文件中</span></span><br><span class="line">        flushBuffer();</span><br><span class="line">        <span class="comment">//调用低层低级流的刷新方法，这个out是继承来的</span></span><br><span class="line">        out.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论：<br>OutputStream的缓存器（自定义数组）与BufferedOutputStream中类的缓存器（内部数组）本质是一样的，只是BufferedOutputStream类中将要写入到底层io流中的数据先放到内部数字中去凑个整，然后再一起写入底层io流中。<br>区别在于OutputStream写数组的时候，数组中有多好字节就写多少字节，BufferedOutputStream写数组的时候，如果这个数组能放到内部缓存中就放到内部缓存中，如果不能就写入这个数组。这样就是使用BufferedOutputStream可能会少写几次数组，从而提高效率。</p><p>这样也出现了一个问题，假设向硬盘中写入一个文件，文件最后读到的数据比BufferedOutputSteam内部缓存长度要小，则BufferOutputStream就不会将这些数据写入底层io流中，这样造成文件缺失，因此就需要在close()前调用flush（）方法，强制将还没有装满buf数组的数据写入底层io中。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"try"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (OutputStream ostream = out) </span><br><span class="line">    &#123;</span><br><span class="line">        flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>对比三个读写数组的方式</strong><br>方式1：使用FileInputStream和FileOutputStream复制文件，每次读写10240个字节<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyByFileStream</span><span class="params">(File fromPath, File toFile)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> FileNotFoundException, IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InputStream in = <span class="keyword">new</span> FileInputStream(fromPath);</span><br><span class="line">    OutputStream out = <span class="keyword">new</span> FileOutputStream(toFile);</span><br><span class="line"><span class="comment">//  缓冲数组</span></span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10240</span>];</span><br><span class="line">    <span class="keyword">int</span> readLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//  每次从输入流读取一个数字</span></span><br><span class="line">    <span class="keyword">while</span> ((readLength = in.read(buffer)) != -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//      System.out.println(a++);</span></span><br><span class="line"><span class="comment">//      写入到输出流中</span></span><br><span class="line">        out.write(buffer, <span class="number">0</span>, readLength);</span><br><span class="line">    &#125;</span><br><span class="line">    in.close();</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>方式二：使用默认长度(<code>8192</code>)的BufferedInputStream和BufferedOutputStream复制文件，同样每次读写<code>10240</code>字节<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyByBufferedStream</span><span class="params">(File fromPath, File toPath)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> FileNotFoundException, IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BufferedOutputStream buffOut = <span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">    <span class="keyword">new</span> FileOutputStream(toPath));</span><br><span class="line">    BufferedInputStream buffIn = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">    <span class="keyword">new</span> FileInputStream(fromPath));</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//这个数组长度比8192大，内部缓存放不下，会把缓存中的数据写入文件，然后写入读入的这个数组</span></span><br><span class="line">    <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10240</span>];</span><br><span class="line">    <span class="keyword">while</span> ((len = buffIn.read(buf)) != -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//      System.out.println(count++);</span></span><br><span class="line">        buffOut.write(buf, <span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">    buffOut.close();</span><br><span class="line">    buffIn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>第三种方式：使用长度为<code>102400</code>的内部缓存的BufferedInputStream和BufferedOutputStream复制文件，同样每次读写<code>10240</code>字节<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyByBufferedStream2</span><span class="params">(File fromPath, File toPath)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> FileNotFoundException, IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BufferedOutputStream buffOut = <span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">    <span class="keyword">new</span> FileOutputStream(toPath),<span class="number">102400</span>);</span><br><span class="line">    BufferedInputStream buffIn = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">    <span class="keyword">new</span> FileInputStream(fromPath),<span class="number">102400</span>);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//这个数组比内部数组长度要小，所以读取的时候会先放入到内部缓存中，缓存满了会下文件，</span></span><br><span class="line">    <span class="comment">//或者而缓存没满，但放不下新数据，则内部缓存先写入文件，再拷贝新数据到缓存中</span></span><br><span class="line">    <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10240</span>];</span><br><span class="line">    <span class="keyword">while</span> ((len = buffIn.read(buf)) != -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//      System.out.println(count++);</span></span><br><span class="line">        buffOut.write(buf, <span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">    buffOut.close();</span><br><span class="line">    buffIn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>测试，main方法：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException, IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    String fromPath = <span class="string">"C:\\Users\\lan\\Desktop\\副本.png"</span>;</span><br><span class="line">    String toPath = <span class="string">"C:\\Users\\lan\\Desktop\\副本的副本.png"</span>;</span><br><span class="line">    File fromeFile=<span class="keyword">new</span> File(fromPath);</span><br><span class="line">    File toFile=<span class="keyword">new</span> File(toPath);</span><br><span class="line">    <span class="comment">//源文件不存在就退出程序，不然后面这么多次循环，会把电脑搞崩溃的，又没有进行一场处理。</span></span><br><span class="line">    <span class="keyword">if</span>(!fromeFile.exists())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> start=System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>*<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        copyByFileStream(fromeFile, toFile);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> end=System.currentTimeMillis();</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"使用FileInputStream和FileOutputStream逐个数组复制文件用时:"</span>+(end-start));</span><br><span class="line">    start=System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>*<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        copyByBufferedStream(fromeFile, toFile);</span><br><span class="line">    &#125;</span><br><span class="line">    end=System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"使用BufferdInputStream和BufferedOutputStream逐个数组复制文件用(数组长度比内部缓存大)时:"</span>+(end-start));</span><br><span class="line">    start=System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>*<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        copyByBufferedStream2(fromeFile, toFile);</span><br><span class="line">    &#125;</span><br><span class="line">    end=System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"使用BufferdInputStream和BufferedOutputStream逐个数组复制文件用(数组长度比内部缓存小)时:"</span>+(end-start));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用FileInputStream和FileOutputStream逐个数组复制文件用时:<span class="number">15744</span></span><br><span class="line">使用BufferdInputStream和BufferedOutputStream逐个数组复制文件用(数组长度比内部缓存大)时:<span class="number">14805</span></span><br><span class="line">使用BufferdInputStream和BufferedOutputStream逐个数组复制文件用(数组长度比内部缓存小)时:<span class="number">13605</span></span><br></pre></td></tr></table></figure><p></p><p>可以看到虽然每次读取量为10240字节时，</p><ul><li>使用默认长度的缓冲流，还是比直接使用文件流要快。(如果每次读写的都是10240个字节的话，他们应该一样快才是)</li><li>而缓存大的比缓存小的读写块(这很明显)</li><li>缓存大于读写量的效率比，缓存小于读写量的好(因为有时放不到缓存中，这跟使用第一个方法效果一样)</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不管是一个字节一个字节的读写，还是一个数组一个数组的读写，使用缓冲流(BufferedInputStream/BufferedOutputSteam)都比使用文件流(FileInputStream/FileOutputStream)效率要好。<br>还有就是应该使得缓冲区的长度比每次读写的数组长度大,这样效率比较好。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/d2ebfe94/">文件流和缓冲流的比较_输出缓冲流源码详解</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>测试格式化</title>
      <link href="/blog/1ae845fa/"/>
      <url>/blog/1ae845fa/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:16 GMT+0800 (中国标准时间) --><ul><li>支持：throws.*这种单起一行的语句–&gt;缩进四个空格</li><li>支持：单行注释的缩进</li><li>修复：遇到仅仅一行<code>{</code>的时候多打换行的bug</li><li>说明：上面只对，VC样式的代码进行优化。</li></ul><p><strong>代码如下：</strong><br><strong>CodeFormat.java:</strong><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> code.format;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="comment">//import clipboard.util.SysClipboardUtil;</span></span><br><span class="line"><span class="keyword">import</span> clipboard.util.SysClipboardUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodeFormat</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">String text = SysClipboardUtil.getSysClipboardText();</span><br><span class="line">System.out.println(<span class="string">"接收到的文本:"</span>);</span><br><span class="line">System.out.println(<span class="string">"------------------------------------"</span>);</span><br><span class="line">System.out.println(text);</span><br><span class="line">System.out.println(<span class="string">"------------------------------------"</span>);</span><br><span class="line">System.out.println(<span class="string">"java方式的格式化："</span>);</span><br><span class="line">System.out.println(<span class="string">"------------------------------------"</span>);</span><br><span class="line">System.out.println(formatLikeJava(text));</span><br><span class="line">System.out.println(<span class="string">"------------------------------------"</span>);</span><br><span class="line">System.out.println(<span class="string">"VC方式的格式化："</span>);</span><br><span class="line">System.out.println(<span class="string">"------------------------------------"</span>);</span><br><span class="line">System.out.println(formatLikeVC(text));</span><br><span class="line">System.out.println(<span class="string">"------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">// main结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unformattedCode  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatLikeJava</span><span class="params">(String unformattedCode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//tab键：4个空格</span></span><br><span class="line"><span class="keyword">final</span> String Tab = <span class="string">"    "</span>;</span><br><span class="line">StringBuilder TabBuider = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">StringBuilder formatedCode=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(unformattedCode);</span><br><span class="line">String line = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> (scanner.hasNextLine())</span><br><span class="line">&#123;</span><br><span class="line">line = scanner.nextLine().trim();</span><br><span class="line"><span class="keyword">if</span> (line.matches(<span class="string">".*\\&#125;.*$"</span>))</span><br><span class="line">&#123;</span><br><span class="line">TabBuider.delete(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">//System.out.println(TabBuider.toString() + line);</span></span><br><span class="line">formatedCode.append(TabBuider.toString() + line+<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (line.matches(<span class="string">".*\\&#123;.*$"</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//vs样式的格式化：</span></span><br><span class="line"><span class="comment">//System.out.println(TabBuider.toString() + line.substring(0,line.lastIndexOf('&#123;')));</span></span><br><span class="line"><span class="comment">//System.out.println(TabBuider.toString()+line.substring(line.lastIndexOf('&#123;')));</span></span><br><span class="line"><span class="comment">//Java样式的格式化：</span></span><br><span class="line"><span class="comment">//System.out.println(TabBuider.toString()+line);</span></span><br><span class="line">formatedCode.append(TabBuider.toString()+line+<span class="string">"\n"</span>);</span><br><span class="line">TabBuider.append(Tab);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(line.matches(<span class="string">"^throws.*$"</span>))</span><br><span class="line">&#123;</span><br><span class="line">formatedCode.append(Tab + line+<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//System.out.println(TabBuider.toString() + line);</span></span><br><span class="line">formatedCode.append(TabBuider.toString() + line+<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">scanner.close();</span><br><span class="line"><span class="keyword">return</span> formatedCode.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unformattedCode  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatLikeVC</span><span class="params">(String unformattedCode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">final</span> String Tab = <span class="string">"    "</span>;</span><br><span class="line">StringBuilder TabBuider = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">StringBuilder formatedCode=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(unformattedCode);</span><br><span class="line">String line = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> (scanner.hasNextLine())</span><br><span class="line">&#123;</span><br><span class="line">line = scanner.nextLine().trim();</span><br><span class="line"><span class="comment">//System.out.println("--&gt;"+line);</span></span><br><span class="line"><span class="keyword">if</span> (line.matches(<span class="string">".*\\&#125;.*$"</span>))</span><br><span class="line">&#123;</span><br><span class="line">TabBuider.delete(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">//System.out.println(TabBuider.toString() + line);</span></span><br><span class="line">formatedCode.append(TabBuider.toString() + line+<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果这一行只有一个开括号，就不用再分割了</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(line.matches(<span class="string">"\\&#123;"</span>))</span><br><span class="line">&#123;</span><br><span class="line">formatedCode.append(TabBuider.toString() + line+<span class="string">"\n"</span>);</span><br><span class="line">TabBuider.append(Tab);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (line.matches(<span class="string">".*\\&#123;.*$"</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//vs样式的格式化：</span></span><br><span class="line"><span class="comment">//System.out.println(TabBuider.toString() + line.substring(0,line.lastIndexOf('&#123;')));</span></span><br><span class="line"><span class="comment">//System.out.println(TabBuider.toString()+line.substring(line.lastIndexOf('&#123;')));</span></span><br><span class="line">formatedCode.append(TabBuider.toString() + line.substring(<span class="number">0</span>,line.lastIndexOf(<span class="string">'&#123;'</span>))+<span class="string">"\n"</span>);</span><br><span class="line">formatedCode.append(TabBuider.toString()+line.substring(line.lastIndexOf(<span class="string">'&#123;'</span>))+<span class="string">"\n"</span>);</span><br><span class="line"><span class="comment">////Java样式的格式化：</span></span><br><span class="line"><span class="comment">//System.out.println(TabBuider.toString()+line);</span></span><br><span class="line">TabBuider.append(Tab);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(line.matches(<span class="string">"^throws.*$"</span>))<span class="comment">//匹配抛出异常语句</span></span><br><span class="line">&#123;</span><br><span class="line">formatedCode.append(Tab + line+<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//else if(line.matches("^//(\\s+).*$"))//匹配行注释,替换其中的空白符</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(line.matches(<span class="string">"^//(\\s+).*$"</span>))<span class="comment">//匹配行注释,替换其中的空白符</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//总感觉这里应该怎么优化一下，匹配两次正则</span></span><br><span class="line">Pattern pattern=Pattern.compile(<span class="string">"^//(\\s+).*$"</span>);</span><br><span class="line">Matcher matcher = pattern.matcher(line);</span><br><span class="line"><span class="comment">//System.out.println(matcher.matches());</span></span><br><span class="line"><span class="comment">//Pattern.compile("^//(\\s+).*$").matcher(line).matches();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">matcher.find();<span class="comment">//查找捕获组</span></span><br><span class="line"><span class="comment">//使用缩进替换空白符,因为注释符本省占两个字节，所以缩进空格少打两个</span></span><br><span class="line">line=line.replaceAll(<span class="string">"\\s+"</span>, TabBuider.toString().substring(<span class="number">2</span>));</span><br><span class="line"><span class="comment">//System.out.println("#---&gt;"+line);</span></span><br><span class="line">formatedCode.append(line+<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//System.out.println(TabBuider.toString() + line);</span></span><br><span class="line">formatedCode.append(TabBuider.toString() + line+<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">scanner.close();</span><br><span class="line"><span class="keyword">return</span> formatedCode.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>参考文章：<a href="https://blog.csdn.net/just4you/article/details/70767928" target="_blank" rel="noopener">正则表达式的捕获组(capture group)在Java中的使用</a></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/1ae845fa/">测试格式化</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java IO流操作二 缓冲流</title>
      <link href="/blog/b72cf8a8/"/>
      <url>/blog/b72cf8a8/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:16 GMT+0800 (中国标准时间) --><p><strong>IO的缓冲区的存在就是为了提高效率,把要操作的数据放进缓冲区,然后一次性把缓冲区的内容写到目的地,而不是写一次就往目的地写一次.</strong><br>在这里要注意的是当我们<strong>关闭了缓冲区对象实际也关闭了与缓冲区关联的流对象</strong>.<br>BufferWriter类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FileWriter fw =<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    fw =<span class="keyword">new</span> FileWriter(<span class="string">"test.txt"</span>);</span><br><span class="line">    <span class="comment">//使用缓冲区必须要与一个流对象相关联</span></span><br><span class="line">    BufferedWriter bw =<span class="keyword">new</span> BufferedWriter(fw);</span><br><span class="line">    <span class="comment">//写入缓冲</span></span><br><span class="line">    bw.write(<span class="string">"hello world!"</span>);</span><br><span class="line">    <span class="comment">//使用缓冲区的时候要注意刷新</span></span><br><span class="line">    bw.flush();</span><br><span class="line">    <span class="comment">//关闭缓冲区的对象,实际上是关闭与它关联的流对象最好放在finally执行</span></span><br><span class="line">    bw.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实BufferReader也是差不多的,这里就不多讲</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FileReader fr =<span class="keyword">new</span> FileReader(<span class="string">"test.txt"</span>);</span><br><span class="line">BufferedReader br =<span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">String line =<span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//注意readLine方法读取的内容不包括换行符</span></span><br><span class="line"><span class="keyword">while</span>((line=br.readLine())!=<span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>readLine原理:</strong><br>无论是读一行,获取多个字符,最终都是在硬盘上一个一个读取,所以最终使用的还是read方法一次读一个的方法.</p><h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式:"></a>装饰模式:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"吃饭"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonEnhance</span></span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> Person p;</span><br><span class="line">    <span class="comment">//把需要增强 的类传进去初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonEnhance</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.p=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enhanceEat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开胃酒"</span>); </span><br><span class="line">        p.eat(); </span><br><span class="line">        System.out.println(<span class="string">"甜点"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>装饰模式就是在原有类的基础上把某个方法增强功能</strong></p><p>但是这让我想到了java 的动态代理,他也是在某个方法的基础上增加额外的功能,那么她们有什么区别呢?</p><h3 id="装饰模式和动态代理的区别"><a href="#装饰模式和动态代理的区别" class="headerlink" title="装饰模式和动态代理的区别"></a>装饰模式和动态代理的区别</h3><p><strong>装饰类和被装饰的类是应该继承或实现相同的接口,而java的动态代理不是</strong>,<br>还有一个不同点就是<strong>动态代理可以</strong>横切多个面,也就是<strong>同时对多个方法进行增强</strong>.</p><p>通过装饰模式和继承的区别发现了程序设计之美,虽然继承也可以增强某个方法,但是它使得类的体系很臃肿,并且可扩展性不好</p><p>因为装饰模式中,我们可以把被装饰类的父类当作参数传进装饰类的构造方法内,那么你这一个装饰类就可以应用于这个体系的了,这也是java多态性的好处.<br>相比较之下使用装饰模式降低了类之间的关系.<br>装饰类是因为增强了已有的对象,具有的功能和已有的是相同的,是不过提供了更强的功能,所以装饰类和被装饰类通常属于一个体系中的.</p><p>在API中可以看到BufferedReader类还有一个子类LineNumberReader</p><p>通过API对得知,这是一个字符缓冲输出流,该类保持对行号的跟踪,可以通过该类的setLineNumber(int) 和 getLineNumber() 方法分别设置获取行号<br>例如程序:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lan.base;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.LineNumberReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLineNumberReader</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FileReader fr =<span class="keyword">new</span> FileReader(<span class="string">".\\src\\lan\\base\\TestLineNumberReader.java"</span>);</span><br><span class="line">    LineNumberReader lnr =<span class="keyword">new</span> LineNumberReader(fr);</span><br><span class="line">    String line =<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>((line=lnr.readLine())!=<span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(lnr.getLineNumber()+<span class="string">":"</span>+line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1:package lan.base;</span><br><span class="line">2:</span><br><span class="line">3:import java.io.FileReader;</span><br><span class="line">4:import java.io.IOException;</span><br><span class="line">5:import java.io.LineNumberReader;</span><br><span class="line">6:</span><br><span class="line">7:public class TestLineNumberReader</span><br><span class="line">8:&#123;</span><br><span class="line">9:public static void main(String[] args)throws IOException</span><br><span class="line">10:&#123;</span><br><span class="line">11:    FileReader fr =new FileReader(&quot;.\\src\\lan\\base\\TestLineNumberReader.java&quot;);</span><br><span class="line">12:    LineNumberReader lnr =new LineNumberReader(fr);</span><br><span class="line">13:    String line =null;</span><br><span class="line">14:    while((line=lnr.readLine())!=null)</span><br><span class="line">15:    &#123;</span><br><span class="line">16:        System.out.println(lnr.getLineNumber()+&quot;:&quot;+line);</span><br><span class="line">17:    &#125;</span><br><span class="line">18:&#125;</span><br><span class="line">19:&#125;</span><br></pre></td></tr></table></figure><p></p><p>但是我们也可以改变行号的开始值<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FileReader fr =<span class="keyword">new</span> FileReader(<span class="string">".\\src\\lan\\base\\TestLineNumberReader.java"</span>);</span><br><span class="line">    LineNumberReader lnr =<span class="keyword">new</span> LineNumberReader(fr);</span><br><span class="line">    String num =<span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//设置行号的开始值为100</span></span><br><span class="line">    lnr.setLineNumber(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">while</span>((num=lnr.readLine())!=<span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(lnr.getLineNumber()+<span class="string">":"</span>+num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>输出结果为:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">101:package lan.base;</span><br><span class="line">102:</span><br><span class="line">103:import java.io.FileReader;</span><br><span class="line">104:import java.io.IOException;</span><br><span class="line">105:import java.io.LineNumberReader;</span><br><span class="line">106:</span><br><span class="line">107:public class TestLineNumberReader</span><br><span class="line">108:&#123;</span><br><span class="line">109:public static void main(String[] args) throws IOException</span><br><span class="line">110:&#123;</span><br><span class="line">111:FileReader fr = new FileReader(</span><br><span class="line">112:&quot;.\\src\\lan\\base\\TestLineNumberReader.java&quot;);</span><br><span class="line">113:LineNumberReader lnr = new LineNumberReader(fr);</span><br><span class="line">114:String line = null;</span><br><span class="line">115:// 设置行号的开始值为100</span><br><span class="line">116:lnr.setLineNumber(100);</span><br><span class="line">117:while ((line = lnr.readLine()) != null)</span><br><span class="line">118:&#123;</span><br><span class="line">119:System.out.println(lnr.getLineNumber() + &quot;:&quot; + line);</span><br><span class="line">120:&#125;</span><br><span class="line">121:&#125;</span><br><span class="line">122:&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p>下面开始学习字节流<br>通过<code>API</code>文档字节流的顶级类为<code>InputStream</code>和<code>OutputStream</code><br>首先来看一下<code>FileOutputStream</code>和<code>FileInputStream</code></p><h3 id="使用FileOutStrem写文件"><a href="#使用FileOutStrem写文件" class="headerlink" title="使用FileOutStrem写文件"></a>使用FileOutStrem写文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeData</span><span class="params">()</span><span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    OutputStream out =<span class="keyword">new</span> FileOutputStream(<span class="string">"D:\\test2.txt"</span>);</span><br><span class="line">    out.write(<span class="string">"hello inputStream!"</span>.getBytes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上面代码后,发现在D盘创建了test2.txt文件并且内容是hello inputStream!<br>从上面可以看出这和字符流是有区别的,因为当我们在使用字符流的时候,如果没有刷新并且没有关闭那么文件内容是空的,而这里刚好相反.<br>但是最好我们还是调用close方法,关闭资源.提高性能.</p><h3 id="使用FileInputStream读文件"><a href="#使用FileInputStream读文件" class="headerlink" title="使用FileInputStream读文件"></a>使用FileInputStream读文件</h3><p>下面实现读取操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readData</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">"D:\\test2.txt"</span>);</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((num = is.read()) != -<span class="number">1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print((<span class="keyword">char</span>) num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello inputStream!</span><br></pre></td></tr></table></figure><p></p><p>但是这样效率比较低,因为读取一次写一次。我们可以一次读取一个字节数组。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readData2</span><span class="params">()</span><span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InputStream is =<span class="keyword">new</span> FileInputStream(<span class="string">"D:\\test2.txt"</span>);</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer =<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">//把读取到的数据放进字节数组里面</span></span><br><span class="line">    <span class="keyword">while</span> ((num = is.read(buffer)) != -<span class="number">1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(buffer, <span class="number">0</span>, num));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>##获取文件的长度<br>在InputStream类中有这样一个方法available(),该方法的作用是返回文件内容的长度。那么我们就可以把字节数组的长度定义成文件长度,则这个数组就刚好装下这个文件的所有字节。这样读取数据就不需要使用while循环了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">publicstaticvoid <span class="title">readData3</span><span class="params">()</span><span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    InputStream is =<span class="keyword">new</span> FileInputStream(<span class="string">"D:\\test2.txt"</span>);</span><br><span class="line">    <span class="comment">//返回文件的长度</span></span><br><span class="line">    <span class="keyword">int</span> num = is.available();</span><br><span class="line">    <span class="comment">//把字节数组的长度定义成文件长度,那么这个数组就刚好装下这个文件了</span></span><br><span class="line">    <span class="keyword">byte</span>[] buffer =newbyte[num];</span><br><span class="line">    is.read(buffer);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(buffer));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样有一个缺陷,如果一个文件非常大,该文件的长度(字节数)超出了int的最大表示范围(2.147483647GB)，就会出现内存溢出了.这样获取的文件长度不对，所以这个方法只能用于操作小型的文件.</p><h2 id="使用FileInputSteam和FileOutputStream复制文件"><a href="#使用FileInputSteam和FileOutputStream复制文件" class="headerlink" title="使用FileInputSteam和FileOutputStream复制文件"></a>使用FileInputSteam和FileOutputStream复制文件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">       <span class="comment">/**   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> FileNotFoundException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyByFileStream</span><span class="params">(String fromPath,String toPath)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> FileNotFoundException, IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">InputStream is = <span class="keyword">new</span> FileInputStream(fromPath);</span><br><span class="line">OutputStream os = <span class="keyword">new</span> FileOutputStream(toPath);</span><br><span class="line"><span class="comment">//缓冲数组</span></span><br><span class="line"><span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> readNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//每次从输入流读取一个数字</span></span><br><span class="line"><span class="keyword">while</span>((readNum=is.read(buffer))!=-<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    System.out.println(a++);</span></span><br><span class="line"><span class="comment">//写入到输出流中</span></span><br><span class="line">    os.write(buffer, <span class="number">0</span>, readNum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用java缓冲输出流<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BufferedOutputStream buffOs =<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"F:\\KuGou\\baby2 - baby one more time.mp3"</span>));</span><br><span class="line">BufferedInputStream buffIs =<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"F:\\KuGou\\baby - baby one more time.mp3"</span>));</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len=buffIs.read())!=-<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    buffOs.write(len);</span><br><span class="line">&#125;</span><br><span class="line">buffOs.close();</span><br><span class="line">buffIs.close();</span><br></pre></td></tr></table></figure><p></p><p>获取键盘录入:<br>System.out对应的是标准的输出设备一般指控制台<br>System.in对应的是标准输入设备:键盘<br>下面模拟一个键盘录入的功能:<br>publicstaticvoid main(String[] args)throws IOException {<br>InputStream is = System.in;<br>StringBuilder buffer =new StringBuilder();<br>int i = 0;<br>while (true) {<br>i = is.read();<br>if (‘\r’ == i)<br>continue;<br>if (‘\n’ == i) {<br>String value = buffer.toString();<br>//如果录入的是over那么则退出<br>if (“over”.equals(buffer.toString()))<br>break;<br>System.out.println(value);<br>//清空缓冲区 以免下次录入时不会和前面录入的汇合<br>buffer.delete(0, buffer.length());<br>}<br>else {<br>buffer.append((char)i);<br>}<br>}<br>}<br>注意在输入流在读取数据的时候连回车也会读取的.在windows中\r\n代表换行 例如下面简单的程序<br>InputStream is = System.in;<br>System.out.println(is.read());<br>System.out.println(is.read());<br>控制台输出:<br>13<br>10<br>对于键盘录入功能我们可以使用更加简单的方式:因为他这个功能实际上就是读取一行 的操作:<br>那么就可以考虑使用readLine方法,然后该方法是字符六BufferedReader的方法<br>然而InputStream又是字节流.那么怎么办呢?<br>我们可以使用InputStreamReader类,这个类是字节流到字符流的桥梁,<br>publicstaticvoid main(String[] args)throws IOException {<br>InputStream is = System.in;<br>InputStreamReader isr =new InputStreamReader(is);<br>BufferedReader br =new BufferedReader(isr);<br>String line =null;<br>while((line=br.readLine())!=null){<br>if(line.equals(“over”)){<br>break;<br>}<br>System.out.println(line.toUpperCase());<br>}<br>}</p><p>对应的OutputStreamWriter是字符流向字节流转换的桥梁 也就是读进来的是字符,写进去的是字节,在上面的基础上我们可以这样改写:<br>publicstaticvoid main(String[] args)throws IOException {<br>InputStream is = System.in;<br>InputStreamReader isr =new InputStreamReader(is);<br>BufferedReader br =new BufferedReader(isr);<br>OutputStreamWriter osw =new OutputStreamWriter(System.out);<br>BufferedWriter bw =new BufferedWriter(osw);<br>String line =null;<br>while((line=br.readLine())!=null){<br>if(line.equals(“over”)){<br>break;<br>}<br>bw.write(line);<br>//注意使用字符流要注意flush<br>bw.flush();<br>//System.out.println(line.toUpperCase());<br>}<br>}<br>但是控制台输出为:</p><p>发现输出的数据没有换行<br>当然我们可以在line后面加上\r\n<br>但是这是不跨品台的<br>我们可以这样解决:<br>我们可以使用<br>BufferedWriter 的newLine方法<br>在bw.write(line);后面加上bw.newLine(); 即可<br>总结: 下面总结一下IO的操作规律:<br>1,明确源和目的:<br>源 :输入流,InputStream Reader<br>目的: 输入流 OutpuStream Writer<br>3当明确体系后,在明确使用哪个具体的对象<br>通过设备来进行区分:<br>源设备: 存 硬盘 键盘<br>目的设备: 内存 硬盘 控制台</p><p>转载请注明 出处: <a href="http://blog.csdn.net/johnny901114/article/details/8710403" target="_blank" rel="noopener">http://blog.csdn.net/johnny901114/article/details/8710403</a></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/b72cf8a8/">Java IO流操作二 缓冲流</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java获取文件大小的方法</title>
      <link href="/blog/aa316c45/"/>
      <url>/blog/aa316c45/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:16 GMT+0800 (中国标准时间) --><p>本文转自：<a href="https://www.cnblogs.com/hellowhy/p/7238570.html" target="_blank" rel="noopener">https://www.cnblogs.com/hellowhy/p/7238570.html</a></p><h1 id="java获取文件大小的方法"><a href="#java获取文件大小的方法" class="headerlink" title="java获取文件大小的方法"></a>java获取文件大小的方法</h1><p><strong>目前Java获取文件大小的方法有两种：</strong></p><ul><li><p>1、通过file的length()方法获取；</p></li><li><p>2、通过流式方法获取；</p></li></ul><p>通过流式方法又有两种，分别是旧的<code>java.io.*</code>中<code>FileInputStream</code>的<code>available()</code>方法和新的<code>java.nio.*</code>中的<code>FileChannel</code></p><p>下面依次介绍这几种方法：</p><p>首先选择一个文件并查看这个文件在windows中显示的大小，为了测试准确性，我这里选取了一个大文件（超过2GB）</p><p>查看这个文件在windows中显示的大小：<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAxgAAAEHCAYAAAAtYuADAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAEQtSURBVHhe7Z1bjxzHebD3BySBL5OL3AfIjQ0BAXZhBF8uAgSGgQTIhRDlxv6AzEUAJ5fBRyCWLEq2zjuibVkUdaCONiQroURxJJGUSZriSSIpiZR40JLUgZZIUWfJEkVJdn31Vnf1VFVX93TvzGx37zwP8JLTp6rq6t6t95nqmZ379vcfUG+optit1n772+rbhbFW75HyxgPq+9LW3Wsj+w1jbXbA+Lz99tvpqybQfVNybXav/b56wN0o/WP6wF//xgPfn2ifjMu5c+fSV93lj3/8o4k//OEP6uuvv1ZfffWV+vLLL9UXX3yhPv/8c/X73/9effLJJ+qjjz5SH374oXrvvffU+fPn1dmzZ9Xp06fVK6+8ov587XGzvShOnjyZ1gYAAFAfGUdi40sYMh7t27dPvfDCC2Z8WlpaUq+//roZsyQPeuedd9S7776rPvjgA7O/jG8yzsl4J+OejH8yDsp4KOOiHSNhtplL/289u9emsiGCUZAxTzqZvnDhQvqqCaoKxhvqge8Xy1XbBKPZPp0MCAYAALQdBAOapDHB2L3Wn3koDTdDXsEZjPfffz991QSjZneCGQxLNpNREI3OWDXdp5MBwQAAgLaDYECTdGYGownkBwkmy2roUwQDAADaDoIBTYJglPDpp5+mr2BSrIY+RTAAAKDtIBjQJAhGCfyATJ7V0Kf2lyeCAQAAbQXBgCZBMABqgmAAAEDbQTCgSRAMgJogGAAA0HYQDGgSBAOgJggGAAC0HQQDmgTBAKgJggEAAG0HwYAmQTAAaoJgAABA20EwoEnmXl06pQiCqB4nX10yceLkq+r4iZMmjh0/oV5+5Zg6evRl9dKRo+qFF19Sh/Uv64OHDqvnnj+o9u7br367+1n1zDO/UYMnn2pEMB588EETDzzwgLr//vvVfffdp+699z618d571caNG9U999yj7r77bnXXXXerO++6S2248051x4YN6o47Nqj16+9Q9+vjLuhBBgAA2k8dwXj4kV+rxx7fbManbdufUTt27jJj1rN79qp9+w+oA889b8azQ4dfMOObjHNH9Hgn496xY8fNGChjoYyLdoyMjZ/E7AQzGAA16eoMhsiFtDmMr934Ooyvzbk+9NBD5h2te7WUXLhwIS0RAADaCjMY0CQIBkBNuioYMnMhbTbtNW228aW6ZONS8v8X+v8kLplzFMGQczp9+oy6Z+NGJAMAoOUgGNAkCAZATboqGPJYVEwwMrmQ1yWCYc/lhG7bXXffo95BMgAAWguCAU2CYADUpKuCIZ+5kDYbuYgJhshFJhZ5wZABRgaat956Sx09elTdddddackAANA2EAxoEgQDoCZdFQz5QHcmGKlcSLvjgnEpJxg33XSTF/1169KSAQCgbSAY0CRzcgMSBFE9Tpw4YeL48ePq2DH5Bo1j5peyvKt/5MgR9eKLL6rDhw+rQ4cOqeeff14dOHBA7dmzR+3atUtt375dbdmypRHBkG+LMoKRyUXJ41FfDAVDXp/XA8y58zbO68HmPdW/9da05NlhzZo1BEEQKx7LQcaR2PgShoxHDz/8sNq0aZMaDAZq27ZtaseOHWbM2r17t9q7d6/av3+/Gc8OHjxoxjcZ51566SUz7sn4JyFjoYyLdox0x02ietQlVkYbghkMgJp0dQZDvorWCsZQLBy5MELhhkhGIhgX3bj4hT7nr9VifzYFAwBgJVkJwWAGY3wmMW4vp4xp5AuTAMEAqElXBUP+zoV8FW1MLmRGYueuXeqJJ59UW7c/o54YPKl27tylLlx4NxCMLzLBuGWxn5Y8OyAYALDSIBjdAMHwQTAAatJVwZA/opcIhsxgJGLxySefGpF4evt2dVIPKK9fuKDO6MHktG7v0VOn1OannlK/2bFDffTxJ5lgfJ4Kxs23LKYlzw4IBgCsNAhGN0AwfBAMgJp0VTDkL3TLH8+zj0OJXMgf33vzd79TH3z6qTqv23pWDyKvnX9HnTl3Tp3WA8spHfuPvaw2PnC/loyPzeyFFYybbrklLXl2QDAAYKVBMLoBguETFYwnnnhC3Xzzzea13EBXXHGFSZLKkO2XXXZZ4X6y/i/+4i/U3Nyc+rM/+zPz4SCL1CXbRtUxDaRuadOo+N73vpce4eP2VQzpv3/8x3/0zje2ri6j+rvrSJ9K31qkr/7zP/8zXcoTuw6yrui6jUNdwfidTuD/4R/+QW3durVRwbjzrruSGQwRDN3enTt3qjfP/s6s+/zSJfW+bvO5999Xb+jB5LVz541gnDj3ltrx4Vm18/hR9Zvf7DByYQXjxpL7frWCYADASoNgdAMEw2fZgiH7xBLxMGySKMdLOe/rBEaS62uvvTa6v8Tf/d3fmXpXgjCRte2sWr/bVzFiiXFRsix1yrm7fRGKl9TlbnejiqTJ8ZJ0x+oK+132Kzu3aSFtCO85aYt7nUKkP62w2deyfxsEQ85D/or2wsKC+eXdlGBsuPNOM4MhH+C+8O57atvWZ9RHn3yqPtftNpKh/39H/3ye0BJ05q231NL5c+q3H/5OHX7nrDrx5ptq0xNb1Pl3LgwF4yYEox5Lqr+Q/Kz1BsFyv68W5hZUf8ns2C2WOtx2gA6AYHSDonH7qquuykUR0xYMub7y5qJFlvt6/Ln99tvN37gahRzrHl9GJhhyo9h31d2kOUz2bKIXJm+yPXxHXcqwSaGsdwXDJoNNY9so4SbbbtjEW87BzsKUhU30wzLtzI3UGVsvdUhdts9i2PbK/tKPcowQXqcY7jFV6pJ9VvpaxfpGvi4v1u/2urjnZe8zeS3n1oRgyNf5/emf/mmuvW40IRh3bNhg2ivfDCWfu3j7pXPq8zcvqs8++FxdvHhJDyhvmK8nPPryy2a25bcnj6qj77ylTmq5OP7a6+rg0ZfVDv2LxQrGDTfelJY8OxQO9EuSZLvXOJ9wL/UX1FxiFgZv2Rw/ZpI+6JXUP1C9krbZ7QuxBnjl9vSeAZNoOwAUgmB0g6Jx+9lnn1VPPfWUuvPOO9XVV1/dCsGQa3bbbbepH/7wh+aNUPmMpjwy/YMf/ED913/9l5GNzz77zGyXdWVh97dlytfxS3mVBePVV181SZ5dHyZvktiNEgybJLoJtU2KY8dXQcp4+umnzY29HGwbi5JRaY9NWO3yX/3VX2VJt9tX4Tm422z/SrLslifYd9xlXVXBENw2y7G2L4uQfe2xVeoS3DqqImVP4ppYpH7bjxZ3nfxv2yjHDZMhP8Iyyig7hyqC8e///u/mF7H84Mr3hNtf1k0+InXHHSIYyQzGE1u2qNff1APH2ffV789+pj576zO1VcvFu++9r87qXxRnz51XT+nzP6Xl4tU3tGCceU29fOq0emzzE6lgfKWuv+HGtOTZITrQmwQ8SLBT4XB8Qu/mJ/Dh8nhoQVjoq6w00yYrA8lMSVZXZJss92LtkX3dcgFgxUEwukHRuC39asXiuuuu8wRD+tBlWoJhk38rBe6shWwTIbAzGPL3UIpmM0bNYPzyl78cLRg2Kfubv/kbE+HnJsoSOTdsomgTdTuDIUmYLIu4SFL+3e9+1+wbJpejECuUiyWPoCwnobX1lZ2Pfafc4oqEbbP0jYiHm+DbbYLt33/913/NnV8VwShrXxgxIXCvr12O1SXb//Iv/zLbT/6X49zzH8U410TqkftCRMzeJ7Z+259um6S/RVzlnGXZPUfZP9YXVSg7h1GC4T4iJb+cv/3tb6vLL7+8ccFYv/4O016ZwRB5OHHmjFp64w31xltv6wHltDry8svqzd+9lQwwr72u9h88pF45cdLsc0y3++irS2qg+0UEQ/4a+HU33JCWPDvkB/rknX9XJDK8RF4WpykYIdKuVHqWRHbcmYdEKsI259sj+zEzAdA0CEZzyB8XlHfyQ2SdbHOJjdvyBS8iFzfo8VK2yx8utIJx6tQpIxzSv5bljP11jpHr685guLIhYuDOSMi+VkhGhewriJxIv9SawXATZyFM3tyk22KTd0HWxwRD1rtlucdUQW5oSQKXm9Da+sLzsdh2Sz/I9lhCHwvZV8p011lJs9ssoWC4x4RtssdK2EexhKLrZJH17vWJ1WWTd1cwwuOqMM41kXptf1iJsMg52/vSIssibfYY+d8i+4f9V5WycygTDPkF/Ld/+7dev8aiCcG4ff160175uxaPb35CHT35qnpl6ZQ6cfqMOqnj6a1bjWy8euY1dUzLx5NaJnY/f1DtPfyC2vfCi+b//33sMX1NLhrB+Mn1CEb5O/zDJF+S9+H1T2YL3OVBTgIScbH7DBP/ovUBrtzI68AmYnKTWydt0ufWd9oarS9ou3n0K2tj8Tn52wCgCASjGQ4cOGBygJ///OeeZMhrWSfbZB9LbNyWhFv2kzfTBVcwpJ/ltexjWUnBsLMW7mvBzmDYfQU551tuuSXrB3k6Q44TZB8rGC4rKhjuI1LuDIa88//Xf/3XWb32mKpcunQpm3aSP21fB5uYSp3Dgc+PcAbDYo/5+7//e1NGiD0fwe1fwZWMUDCKzl/Wu22RY2wSLlEmGO6+wqi6LLKf2+6qLPeaSH+F/W/bKNtCYVivk2a5l1yxsMhxyxUMoegcygRD+svOYOzZs0d95zvfMd8i5X5N7T/90z81Ihi/uP129ZVur/w9C/kMxrP6F+PBI0fVC68cU0dPnFR79LLMbOzVUiEzFYe0UBx86Yj67YHn1K79z6mt+pgdO3aqz1LB+PF116clzw71BMOfKQgTeG95yU3Sk0Q8n8wPhSUhPhORlDVcH372Q6gkGEZSnPJNuZEZDbft3nm4RM7JlSAAKATBaAZXJKxkxNZZYuO27POTn/wkXcojOYbsY1kJwZAZB5m1kAhnIiTsDIZFBCLc5/rrr8+kqYjagiHbJZmTfcJEMBY2OZTjpRx3BkP+l2/WkTJt/bFHiMqQG3q575a75yxIIijrZFnWS1tlXQxJXK0kXHPNNSZZt31mCfvRrcvt1yqCIdtFzGJ97EZR30k9sRmMUX0dHleFca6JxV4Daadg2xs+qifIcpV7Uo635Y2i7ByqCIb8cv7zP/9z82FvkRMrGPIhr6YE47Zf/CITjHcuvKt+9cgjav+hF9RzL7yoDmiZ2LZrt3paC8RTz/xG7dyzV71w9GV1+rXX1HN62w69fP9Dv1Tnzr8zFIyfXJeWPDvUF4xhQl5ZMIrKTBP+MNwyk9mDQALkuOUKRtCO2HG+VNhZikgbcudUIEgA4IFgNEcoFO5rVy6E2LgtjyGJRBQh22Qfy7QEQ66RfSTKzkpYZJs7gxFDtoko2XO2ohKbubDUFgy7Tf533x0uSkRt8mf/t/VYwQiTRVt2VcZ53t9ts7TLJtzSJtu2cHZCtsugbtso/9u+kv/dBNjd5vavi7vebUMMWW/73MqNtF2ujxxb1neyn/vh9KK6ZHv4GYzwsyWjGPdzMYLUa4VKzlXOzZ5zKAqyr9xbIW5/1WXSn8GwyeA///M/mx/IJgTj57cNBUNi+zPPqK1aJnbvO6Ce1P8Ptg9j267fqt/sflYdfvGIOnXmjNquxWPb9u1GLqxgXPvj4ndlViv5gT5JqKNJshGC4Tv0ExGMQplJygtFwpA7Lp7Y5+RB2lRbMCxJHZloFApGZEYEADwQjGZxJaNILoTYuP3YY4+ZY6RPQ+wjUrKPZVqCYZHrax+Rcj/07YZ8UNsiYiEzGrH9bIQzHpaoYEgyZxMi+XCqKxiyzSbNLrI9Jhh2fxu2HhEMSRRtPW4UJckxpLzlfmORtCdM2AXpA2mjlO0m5rJPmLDKMVKORY6R87LluecVe/fd7Td7bNExbsJsy5fjqgiGYI8RbF3h/lKXKxhunVWRspd7TaQue+5WJGSd+3mTcFnaOmnBKDuHcQRD4k/+5E+aEYyf36bbqgXj4hcmPvroY7Xx3nvVrzc9pjY/tdWLp7RkPP3MDi0Wu9QOLRv33Xe/+uDDjzzBuObHP05Lnh1iA3101sAk3X4SX1kwctIyUP0kS8/JzKCXHuMdHxIIRYGo5OUhOc5vY3qeudfDdvSzRrj1FjwiVSJMAJCAYDSPlYwiuRBi47b03dq1a80jRceOHUvXKvNa1sk22ceyUoIhWMmQdYKcl8xSlM1kyL6ugJSRCYab2LkJs+BuiyXJFnc/d3/7eYv77rvPrHOTw5BRSfIksTMr0m6pV9pkPyfi9kFRAitIW8P+srjb5AfRCpxbj8SoJFiOLZKxWNjEPETqtuJUBbfNK41tq338LGyz9JldX3R9xhGMMkYJhtzv9u9ghI9IyWcwDh061Ihg/Ez/YhTBkG+BsvGhloxt27arO+++Rz3y6Ca1afPAxBNPPq3/36Luufc+s92VCysYa69FMDJ0Yj3q72BUFwyNV17R+kAanPW57UXlOeQFQ7CPPMXKiwiGRsqx+/szKn5ZfP4CoBoIRjuQBLxILoSicfvFF1/0vqbWfrZT1sk2l5UUDIsIg8xEyN+8iJ2f7G+3WcGwMxtlspEJBswGIjxVk24rXuAzSjDcGQz7l7xdwZAf0CYE46c/+1lOMGzIX+iWP6L38CO/Vo/+z/+qR/T/8oFu+5mLMEQwrr7m2rTk2WG5Az0AwHJBMLpB2bh94cIF8yiUzBhIyGt35sIyTcEQURCRkP+tVEhYSXDXSRtlUsDub4+VkHvEIq9lXUw0EAyAmnRVMNb9tFgwPr94Ubc9LxJFIYLxo7XXpCXPDggGAKw0CEY3mMS4PU3BWGkQDICadFUwbl33U9NWKxN1hCIMIxhXr01Lnh0QDABYaRCMboBg+CAYADXpqmD0160zYhAThroh5VyFYAAATB0EoxsgGD4IBkBNOisYt95qxGBSceWPrk5Lnh0QDABYaRCMboBg+CAYADXpqmAs9m9Vtyz21c23LKqbbrlF3XjzzerGm25WN9x4k7r+hhvVdTfcoH5y/Q3mL3TLH9GTv3MhX0Ur3xYlH+iWz1zIY1EycyFy8cOrfpSWPDsgGACw0iAY3QDB8JmThhEEUT1OnDhh4vjx4+a7rCXkl/LRo0fVkSNHzNfOHT582Hwd7fPPP68OHDig9uzZY76udvv27WrLli2NCAaMD4IBACvNSgjGww8/rDZt2qQGg4Hatm2b2rFjhxmzdu/erfbu3Wu+fl3Gs4MHD5rxTcY5+Yp4Gfdk/JOQsVDGRTtGuuMmUT3qEiujDcEMBkBNujqDAeODYADASsMMBnQRBAOgJgjG7IJgAMBKg2BAF0EwAGqCYMwuCAYArDQIBnQRBAOgJgjG7IJgAMBKg2BAF0EwAGqCYMwuCAYArDQIBnQRBAOgJgjG7IJgAMBKg2BAF0EwAGqCYMwuMtATBEGsdCwHBAOaZGYE4+LFi+krgOrIL9Irr7zS/G9BMAAAoO0gGFCVt956K301ORAMgALkl+i//Mu/qPXr16t/+7d/yyQDwQAAgLaDYEBVEIwxQDCgDlYuHn/8cbMsv6itZCAYAADQdhAMqAqCMQYIBlQllAuLlYyPP/4YwQAAgFaDYEBVEIwxQDCgKvLLc8eOHemSj/zCPnHiBIIBAACtBsGAqiAYY4BgwKSwvzwRDAAAaCsIBlQFwRgDBAMmBYIBAABtB8GAqiAYY4BgwKRAMAAAoO0gGFAVBGMMpicYr6ibv3ereuRculjGuR3qP763Rn33e79S+/Xi/vVr1M2Hkk3QHRAMAABoOwgGVAXBGIPpCIbIhQhDPP5j8wWz19nNt6brErEwGNlwlqEzIBgAANB2EAyoCoIxBpMWDCsN0RkIkYf/3qHOposJF9Qj/22FQl7nhUTCSgm0FwQDAADaDoIBVUEwxmCSgmHkIhWI/euDx6MO/SrbllAkE/nZCx6Z6gYIBgAAtB0EA6qCYIzBdD+DkYiBCMJ317+Srg+R/axUvKIecR6fMrMW0VkPaCMIBgAAtB0EA6qCYIzB9ARjxONSFpnZMDMX/oxHJhjQGRAMAABoOwgGVAXBGINpCIaZscgeecrHUBwuqEfW/0rdbD6D8Yr+f4c6K8Kx/pVUMF4xj1HxeFQ3QDAAAKDtIBhQFQRjDCYpGFYs/uO/S2YftEDYbUOJGD4iZR+XGs5gyLqKX3cLjdIFwdi4cSNBEATR4RgXBAOqgmCMwTRmMEofb3IEY/96kQn7LVLJh77tbIVXRvoBcWg3XRAMAACYbRAMqAqCMQbTEozwsSg3fPmwguFTKinQShAMAABoOwgGVAXBGIMmZzASAsGQ2YpURPjsRbdAMAAAoO0gGFAVBGMMpiEYMJsgGAAA0HYQDKgKgjEGCAZMCgQDAADaTicE45vf1JmoTkWJ9oZco2Wgj5wNEAyYFAgGAAC0nU4IhiSw0DilMxjLvEYIBkBNEAwAAGg7CAZUBcEYAwQDJgWCAQAAbQfBgKogGGOAYMCkQDAAAKDtIBhQFQRjDBAMmBQIBgAAtB0EA6qCYIwBggGTAsEAAIC2g2BAVRCMMUAwYFIgGAAA0HYQDJgICEY5CAZMCgQDAADaDoIBEwHBKAfBgEmBYAAAQNtBMGAiIBjlIBgwKRAMAABoOwgGTAQEoxwEAyYFggEAAG0HwYCJgGCUg2DApEAwAACg7SAYMBEQjHLGFQz5QSUIiRMnTpg4fvy4OnbsmAn5pXz06FF15MgR9eKLL6rDhw+rQ4cOqeeff14dOHBA7dmzR+3atUtt375dbdmyBcEAAICpIuNIbHwJQ8ajhx9+WG3atEkNBgO1bds2tWPHDjNm7d69W+3du1ft37/fjGcHDx4045uMcy+99JIZ92T8k5CxUMZFO0a642ZRSPIaW09MPyqDYJSDYBCTCgQDAADajowjsfElDARjNqMyCEY50xKMBx98UN3/wAPqvvvuU/fee6+6556N6u6771Z33nWX2rBhg1p/xx1mvfxQxo4nuhfdFIwltTg/p3qDdLGIQU/NLy6lCyl63VzsQFk/N6/s7oPe8LVeUj1nW7LvXD7mF9VSVr60saeP7B5L/YXRfZshfbO88yytR/fjQj/pcNlvbqGve7QKS6q/UO3esOVnZNdumSz11cLcggqLBYDxkXEkNr6EgWDMZlRGX6PlgGBUJHZxJEQu5JlDG1+b5/KH8dBDD5kfurvvuQfJWCXRTcEQgqQ/gisJ2euSJHJpcT6RBP16eKzUM6dFZaCWvLqcxNotM3vdFcGQhNxPinOJf6TPTNJvxSoXznmbpDuyXpOrx2HQS9skdXtl6yg6KEOuTXmin5Xvvi65N0LM+Yf7TkAwBr25vPgAgBlHYuNLGAjGbEZl9DVaDghGRWIXR0JmLkQsvjQf9P1KXfryS3Xp0pfqizREMC5cuGB++O68865oGUS3oguCIbMVuSSzKFJB0Lag5u1rSTjt64pJpD+DEWO1CIbgJ+Re4m8S/Px5ZPtIUu3NLoiwBIKR9keyXuqKXDe3DFumSdjdup0+NySzFbmyisLW4bVZl2lfVxWM3DlPkrzwAQCCQZRHZfQ1Wg4IRkViF0dCHn8ygmHlwhOMS0YwbrrpJhP9deuiZdSPrWrNt5IE4PINwfKaNepbc99Sa7aGx3Qgtnaj7V0QDIvMMETzP50Yho9CmdkIu7NJkp1E0wk5Tt41jm2LhcxklAlPr9dFwdA4SXOxPAzJSUi2UEEwwnrcJF8j6xf6g5HykFWp8drjotsWzgjIvlXujaKZBLlfonVNCq8/AUCQcSQ2voSBYMxmVEZfo+WAYFQkdnEk5DMXIhh5uUgE44svLqmLOr766mu12L81WoYXJsl2B+18wr11zbfU3OUb4suTSNI3XF5S/wZ1eUnb7PZvrdkarNfhlXu52hBuRzCykHomgsxKRBKv/GxD+i652VcSfWd7afKWHOdJR9G+7gyJW2b22hEM2XfE41xtojBZF0oS8lxIIbUFI7kGSXLvyoqsH4pLro1ZPT7uo1AJSfn2GnmzBZUS++AYF2lD0MZhfwzXZ22IbtOUiB3ArCLjSGx8CaPzgvHkOvWDH/wgjavUg/sj++jY/+BVzn461j053F5QRu6YNNY9OSzXC6+cderJbNuTal22vqiNyT5XPbg/si2JJ9cFde9/UF0lZabnItuH9eu46kG13+4bRGX0NVoOCEZFYhdHQj7QLZ+7ELn45JNP1T79Q7hZ/4Bu3jJQ+/btVx99/EkmGDcvLkbLyMIk4EGCnQpHMlORxIbL/QQ+XB4vtCB8a43aapdNm6wMJDMlWV2RbbJ8eaw9sq9bboejU4KhUy5PFgTvUagEmb2Y7/USGQmlJJdESpn5RC+bLQkT6vRYEZBs1iSamHZDMOrM3rjnmL2Lb/rHTZBdKdCYpNuWIeuHMjFM/ofrJClf0An8UDCc+oPwuzyS+EcSdVO+vjeMjIRSUkkwfNHxcAXDfe2RyIU3O5Lrw5I6AGYUGUdi40sY3RYMnZS7SbRJ8N3EfhiSfMeT9+plJAl9wTY5LprQ71cPXuXUXVC+lZnqgpEIiSsc4Tka4XBFyonK6Gu0HBCMisQujoR8W5R8mFvkYvPmzerk6TPqzPnz6vjZs2rfiy+pR/7nf7RkfGwE46abb4mWkUTyzr8rEll4ify0BSMMaVcqPUZ23JmHRCrCNufbI/u1f2aianRLMDSeUEgilk/cB1p+l0KxsFRKImW3EiEIy/CWkwTSJMGB+LSe8DyK3kWX/dxtXiIfEQxTZiIAC2WPPen9Bv2+DisYUtVwu5eULy3l2+a1Q65DfqZByjef7XCvn6XKveHVESDbMjGw90HQhrDvDIlIDauOyBLAjCPjSGx8CaPzMxheSNIdnyHwk/OyWE4ZIhEFMxM5KUmEIzcToeXkwUAQwhjWn8hFuG8oGEZaEIzpMi3BkK+iFcGQ2YoTp06pi5e+VKfffFO9pLcdPXNG7dY/jHv37jOCceNNN0fLMFH6Dv8wyZfkfZhgJLMF7vKGnAQk4mL3GSb+ReuDcOVGXjuPZknE5Ca3Ttqkz22N09ZofUHbzaNfWRuLz8nfNv3onGAIkqSZviqRACsY2b4FMd9TvRofIs997W1K4edDOoR5dz/LagsEwyTR8b5xI+uLLJmPiIfez5OGlKQdyWcwkkNtnTrp7g+vZ7S/s+tdkqDbNo26N6IiIeJQMLtg2hluS+Qha0+hYLjtLakDYEaRcSQ2voSxqgSjcPYhSeqHjw8VzEJIFJVROEOhwxEEW0eW6MtxQZLvi8BQOEJBCCMRjGBGJNgeKzfcT6Iy+hotBwSjIrGLIyF/50IE4/HNT6iTr7+uTunYuXOnicMvv6IOHz+hNj2+2QjG9TfcGC3DRKlg+DMFYQLvLXtJepKI55P5obAky/GZiPDxrPCzHxKVBMNIilO+KTcyo+G2PZCNYUTOyZWgFYhuC0ZBkimMM4Mh+8zPq/mSJK/So0V2BqPFj0gNCd/xDwRDkme77PRh9qiUs78IQtbFNpk3SbTtz2FCvaSFIRQBKzpZH5ty00S91zf/F17CSveGbVNAlXsj7CcjFemyKxj6tXaklKTtSdFyfOQRqbCvEQwADxlHYuNLGKtGMNLPIxQl1G6Yd/ZjslBYRnmynkiJs92Uk8xoxGYRXBEoeh0L2W4EpkB0su02ioRIR2X0NVoOCEZFYhdH4vbb12vB+FpLxOPquSNH1UH9A2cFY/+hw+q5l46oTY89rgXjK3Xd9TdEyzAxUjCGCXllwSgqM034w3DLTGYPAgmQ45YrGEE7Ysf5UmFnKSJtyJ1TgSBNKbokGFnC6SSBdl1uZmE5gmGTU+8RLCl/dLJXOoPResGIJL2yLkx67Qk6fVhJMEwf2n5Mku1hXW7ynWAFI11KxEKS+MGwDea6OweV3Rv+eWncc3GpJBhJudlu5vwigqHJ2hS0S29J7ysbwf1VsR0As4SMI7HxJYzVIBjJ5xeKPjwdi/xjUKVlGGEYMesRJPOZLJTNYATHVREMkRgjEhF5yB1vxCfe7sroa7QcEIyKhBfGxm2/+IX6SgvG3n371ZPbn1G7Dzxn/t/57LPq1VOn1bYdO80Pp/ydjB9fd120jCSShDqaJBshGL5DPxHBKJSZpLxQJEzkjosn9jl5kDbVFgwbSR2ZaBQKRmRGZErRBcGwH8Iuy7nM19JKsubOGsQOyCVvzoe8Cz8z4SSENR+pavvnMJIkOCZQNrEfRpWvjvVChMNL5pN+jF8WvX+6wZ/B0Mm781iULwvDNsbKtEh5WXuSFWMJhjnela+JIufkzJAAgEHGkdj4EkbXBcMk2wWfMygOXzBGlZFL3MNIH5EqFAxvm50NSf73ZhxGzDxImcksSXpsycxIEsWfJ6mMvkbLAcGoSHhhbPz8ttuMYHz00cfql7/6lfr1psfV5qe2qqe2/0Y9rUXj0UcfVR98+JERjGt//JNoGTaiswYm6faT+MqCkZOWDWqN2S8vMxsuT4+JJvk2AqEoEJW8PCTH+W1MzzP3etiONVn73HoLHpEqEaZJRxcEA6BtGGmpIiM1EanKzbgAgBlHYuNLGJ0WjFEzC1ns1+cwXDZCYZP4kWUUJ+nDSBL+LLl3HpHKPV4Vme2wMUpkhoIhIe3yJSN3PDMY02dagvHTn/3cfL7i84tfqA+1ZMgHuh/59a91PKr26B9KkYvPPr9oBGPttT+OluGFSbKTdxiTyL8zX10w7LItq2h9IA3O+tz2ovKcyAuGhH3kKVZeRDB0SDl2f39GxS+LD3kDAAD4yDgSG1/C6LRgmAQ6fdffCZOEe+IQzBa4CX5ZGbK9SEBy69OEPzw+29duK5aZeoIhkdaZno9st/WPqqsy+hotBwSjIrGLI7Hupz/NBMOElgkRijBEMK6+5ppoGUS3AsEAAIC2I+NIbHwJo9OCURYiDrUfnaoR0y5/ylEZBKOcaQlGf906Iw9V4qqr10bLILoVCAYAALQdGUdi40sYq1Uw5EPb/rv9k41plz/tqAyCUc60BGOxf6v5C93yR/Tk71zIV9HKt0XJB7rlMxfyWJTMXIhcXPmjq6NlEN0KBAMAANqOjCOx8SWMVTuDQZRGZRCMcqYlGMTsBYIBAABtR8aR2PgSBoIxm1EZBKMcBIOYVCAYAADQdmQciY0vYSAYsxmVQTDKQTCISQWCAQAAbUfGkdj4EgaCMZtRGQSjHASDmFQgGAAA0HZkHImNL2EgGLMZlUEwyhlXMAAsf/zjH0384Q9/UF9//bX6Sr4l7Msv1RdfyNcUf65+//vfq08++cT84v7www/Ve++9p86fP6/Onj2rTp8+bX4RIxgAADBNZByJjS9hyHi0b98+9cILL5jxaWlpSb3++utmzHr77bfVO++8o9599131wQcfmP1lfJNxTsY7Gfdk/JNxUMZDGRftGFmJZSavsIIgGOUgGDApEAwAAGg7CAZMBASjHAQDJgWCAQAAbacTgvGNbyQJLNHekGu0DPSRswGCAZMCwQAAgLbTCcGAVQuCAVATBAMAANoOggFNgmAA1ATBAACAtoNgQJMgGAA1QTAAAKDtIBjQJAgGQE0QDAAAaDsIBjQJggFQEwQDANrAo48+SqzyGAcEA5oEwQCoCYIBAG1AEtA33niDWKWBYECXQTAAaoJgAEAbQDBWdyAY0GUQDICaIBgA0AYQjNUdCAZ0GQQDoCYIxuzy1Yn/q7566f/E48wavcMn6Z4A0wfBWN2BYECXQTAAaoJgzC4IBrQJBGN1B4IBXQbBAKhJdwRjSS3Oz6vFpXSxjEFPzc3NVYreID0mYNCbU/OVKnPQ9ZpjTP09VVB0axCRWNjydro0JJMMLSBGMpoQjaW+WphbUP2al8Ag/b/Q13fMCmPa7F73geqV3QfuOY66Z+35RO+tJdVfCO/lZJ1bRq9XVIft58gxusyl/oK3blp9i2Cs7kAwoMsgGAA16aZgSOLmJDxuBMYw6IVSoo+dX6yQIEkdFYXGYgUjfR22pW1kIhGJr1/+jvrj6/9PqXM/HR0XHkpLLEaELewPk7gGyWq2rouCITiSYc45do/qyLrCnmffv1+kH/K3T8F9v7CgywjXpecv5duCnHtyWL5IhSsYQ3mx+8j/C9mF0G1AMIhlBIIBXQbBAKhJFwQjl6iFgrC0qObz2ZihimCUJYK56PWK5SYWBe1qBTFZWG6MIpf023fLfYmQazFMZpdJk4Ih6PoX9H2SJfYaOS+zKAl/rG1p8m8EK3cfJX1k7lMpxDm/ZH+RgkQ+crdbKBi5siVcwfC3yaG5Ns2KYGy8wj/vkrhiY+R4G7qcy67cFd82Q4FgQJdBMABq0gXBSCh5RGpMwXBZWpyv/2iUpaQdrSQmCsuNUdh36rOulYRYy5pNvA3uu+lj0KBgGAnQdQ90UpOuSYQ0nWVwb49MGJKFTDB8wXL6pFAQ8pHVU2sGI8+wPXIeE7g2JXRiBqNMFkIhuWKjWb/xisvUlbsi+6ex68rLsn2T2KiuiJYz12lRQTCgyyAYADVZfYIh+zmD86gIZEMEIyuqLkWCIevrPm61EsREYbkxkuTd8ax7nIQ6S7KNhKSP6LivbXIrjxGl181PwtMk3g1PMMLtw8eA/BmTZD+vjd5MQf54F6+sTAb8fY1UyPq0kkwy3P7I6rExFAz/vONYecjqsmU4/edHUn687oKYgsC1UTBM8h87fyeiSf+uK9VlRgwCWbBhhUL2u+xKtcsel0qKNyOSSc0udeVl5bLS5kAwoMsgGAA16ZZg2AE6SNYnOIPhJ2VuDMsRCYlvLygbwTC4MiH9bF6KSNhkNU2yDTnB0H3sbbPvpgdSoDHXMEuAk+1eYm6S/6Rst02yfkFmGtJ9pRzz2mvLKNK2FkZBOY5g+BIRzjCUle/ulyJtd87PnquVkHz5lmG/mf60ZUyRtgqGJxDBDEZuu41UMMLtMgvhyoO/nMjIqMet/NmO7gSCAV0GwQCoSRcEY5j0FyTphYIRm/XQiVOhYBTNkkiyFUsMw7Lk+KqJaAuIicJyowqZTLhJ7fB1ltCb1aFguEmwc7wkzeG76e662HZzvCM4aT2DnpSp68q1UeovSOBz2ONjSJn+/SHnbNqh2ynnHp9FcOstLj9pf7pgcQXDYSgYQ4Y/ZxLBfSz96Lap8ByXz+qbwbhSXXmZ3ieboQhnIIJlkQd3NiMW4YxHhwLBgC6DYADUpAuCkVCU/GsKBUMSwzDh1+uKBMMkUeH+QqwcIV9WljB2gUAStrz8uPna2lEh+4XHViPtx0w00rWmz9yEXjN1wbDl2de6DrNfujzw25gg2ySpdNsSYstJ8Gck5Hj3Phq2I3ffBH00RPrCT3D9CNrmCEZcXpJIdrHnF6xfAbkQujCDUbosyb/bTzouu3Kjlogr1Eaz/0Z1hScHMmNht+moIhjhMR0KBAO6DIIBUJPVLBjmUabcep2gRQVDyi/42xdSfvSYSFmSjNk67XHyfwcekZq+YEj36KRVvmHJzYJNn/X8d+arCkaacA8vc5okZ2Ul23P1hRKgy3MfH3IflZK29IPyI7dbiq7PKdsXBznWFQy7r3t+8nooYf2csPrlh+RmMUw/SrLrr4/NYITty/bR/TXsv/L6x6HzMxju7EL6iJQtQ/YJ5SQ3G1FJMLr7OQwEA7oMggFQk9UqGEYuqkqBKVsnC9H9NZKQFpXlJhumDWlZ+nX2jVQdEYyYTBRFeGxlpC91X/mXK+1Hd2VlwdCkZSah18uHmb0kOLhOWbkpaRKeVW+W/YRcRCE73m98HJvY64S9l80KBPVKu+U+kZmFtL2ZIMjxZl1wrnIulQQjESGpN9bcYsGwbXWO9fpXxwwJRpj0iyS4n5HIzWBEBcF+0DsUg3A2QpZHyQMzGKMCwYBpgGAA1KQLgjH8ULWboKWJfJr0uDMPxXIh6AQt2GaSRy/b8sv2P/vhbgsSxgyb0LZQKlwCSYiJRFGEx4LGS8Rj98ZQdOR2MzMl2gasFNik3wiH7GfvSZGN7P4MZSkMX4wyrPAURSYzw3ZnEqLPa1ZnMEyIZEjiv1EegSpJ7l3B8MQkFYycfOSFIpkxCSRDl+U/hpW2wbxO9y16bctoQSAY0GUQDICadEEwYEoEklAqEKO2A4xJawVDR5L4pzJW9C1OJrFP90llwh5nZj2sqDiJf/itUibMfmk5Em59ss0uIxjRQDBgGiAYADVBMGaYQBJKBWLUdoAxaZtgSPJvk3zvsxOhAEhI0i/r7SxFKhvecSbkMxTp/na/3MxGUfB3MGLjSxgIBkwDBAOgJgjGDBNIQqlAjNoOMCZtnsGYZphZjqJZESf4S94IBjQHggFQEwRjhrnwkCcJpQJRtl3KARiTWRWMWQkEA7oMggFQEwQDLJ5ARBi1HWAcEIzVHQgGdBkEA6AmCAZYRgnEqO0A44BgrO5AMKDLIBgANUEwAKANIBirOxAM6DIIBkBNEAwAaAMIxuoOBAO6DIIBUBMEAwDaAIKxugPBgC6DYADUBMEAgDaAYKzuQDCgyyAYADVBMACgDUgCSqzuGAcEA5oEwQCoCYIBAABtB8GAJkEwAGqCYAAAQNtBMKBJEAyAmiAYAADQdhAMaBIEA6AmCAYAALQdBAOaBMEAqAmCAQAAbQfBgCZBMABqgmAAAEDbQTCgSRAMgJogGAAA0HYQDGgSBAOgJggGAAC0HQQDmgTBAKgJggEAAG0HwYAmQTAAatIFwdi4cSNBEATR4RgXBAOaBMEAqEkXBAMAAGYbBAOaBMEAqAmCAQAAbQfBgCZBMABqgmAAAEDbQTCgSRAMgJogGAAA0HYQDGgSBAOgJggGAAC0HQQDmgTBAKgJggEAAG0HwYAmQTAAaoJgAABA20EwoEkQDICaIBgAANB2EAxoEgQDoCYIBgAAtB0EA5oEwQCoCYIBAABtB8GAJkEwAGqCYAAAQNtBMKBJEAyAmiAYAADQdhAMaBIEA6AmCAYAALQdBAOaBMEAqAmCAQAAbQfBgCZBMABqgmAAAEDbQTCgSRAMgJogGAAA0HYQDGgSBAOgJggGAAC0HQQDmgTBAKgJggEAAG0HwYAmQTAAaoJgAABA20EwoEkQDICadEowBj011xukCxpZnl9US+nikCW1OD+n5uZGRPRYqMNSf0G5l0SvUAveigB9zRb6Qa+H17UyS6q/sKDC4mJE27nQL7j+A9Wb6+l/p4W0O7kHkzY5y33drrlq5wQwSyAY0CQIBkBNuiQYg968WgwSr6XF+YgoiGDYBNF97SaO+jWCoRkmt1l4ibf0WVHCK8f6ifigZ5PmOIPesKzsdU4wyuoMkGOLRMGRnTqCIfsuT3iqEZbvLUu7xhUM6ZPseoZlSd8WbROS7TkJFLxypylgAHkQDGgSBAOgJt0RjFQIvCQnEiZRYwajOolglOXTkgCHCadJir3+lGTVTV6dsIm8l9Trfe3rnGDE60yS70j5uXAS57RsKa83KGifhNuu2HYnosl3DUTC3DLC5fFw+lUwPy9D2ZZrndUV2SbLvVh7ZF+3XIAVBsGAJkEwAGrSFcEwMxVlWfAI5PgxDl/FjBYMXwyGJEl7uqCJJcruOiMl9gCT3OaTdwmzf6xOWedWqBOHsE2CO0uilzJh8M6x5JzK7rNJyMB0BSNEzj/tDyNo7sxD/Nrn2yP7xWY7AFYOBAOaBMEAqEk3BCNNEtNMSBKgXA4oCWs6I2FkJE0qR4YUtLSo5ufyj1/NBgWCYZJRm1TG9pF1Olm1ibqbsOtrkZcE9xoGCatcu3wD4u3KSLaXyYCRhTShtjIk907sPjDFmHfpFyKzJMO2Ru+9HEOpSWKY1Pv1J7MF3n45CfDLGib+ResDjMil5UX6OS8TkXXpdew7bS2sD2BKIBjQJAgGQE26IBgiDPPzzgyGCEHweJMkRfOeIegErOQRKC9RRDCyxDFLHk2iWyIBsl2WPYlI0fuGCagk+As9vd4e45YVSXwN3vp8O0sjaJMrGLGqhGTmQ9833rG+DJUdn5Ak/t75y3kEkuFu95ZNv9t9I2UZZL1zbdK+ybXLlDVcH5udCdsi5NaZ9rs/L1KuWz/A9EEwoEkQDICadEEwBjoxHQTJ5qIWjqEQSMLlvusrJMlZLvF0IpeQzSQFyWkOv4+T2YF4f0YT2b5O2kOxsBQJRvS6aqScUGo0YfIvy2EbCyMrL3bf1BAMOZdc2/w+DhN4b9kVjGhZmjThD8MtM7k+gQRE+jlsi5BbF2lH7DiAaYJgQJMgGAA16YJgGILkyMxqWMOIJE56ZfUZjJmmqmAUJJW5ZD8pL5fcClYwChLkLJzy8nVaARidPIckZfVV3zkwL0O6/FhSb5BzG/HOfSQZD48Lz8lbrioYhW1Myov2Re64+LXP9XlE6HL7AEwZBAOaBMEAqElXBcN9TCr29bV6bfUZDB6RyguGSXSDZDqSaCb7pX2qC8kS9lgSLPvmKtKE19YlVqfBisyw7iLsbIvdRZYXdMIv6/JJcl4w7PEmZFthm4TkvvPKDfqismCkZQ1PbZDKUbheykiP8Y4PCa517Bpp8vKQHOe3cYRoAUwYBAOaBMEAqElnBcMS+TxGgk7C+AxGBWoIhtk3WSf95yXdemuybpjchsumzNg1LBMMp06fpN1ZG0z4+9k2SmKcXO8kMZf2Dow0xBJxvU+hPKSUtldI68nCr0faUk0wNGY5Uo63PpAGZ31ue1F5DmH7EvxzKj19gCmAYECTIBgANemaYNiksTDme1osIuuLokRCIE/ukSJJWG3CXvBueLZe9o1lpiMS9qxOLzkukY6iduQSaidpduofeY/x7j3AioNgQJMgGAA16YxgQEuQpDz+zvf0aKJOAGgTCAY0CYIBUBMEA2A5hI9BJVEyEQMAY4BgQJMgGAA1QTAAAKDtIBjQJAgGQE0QDAAAaDsIBjQJggFQEwQDAADaDoIBTYJgANQEwQAAgLaDYECTIBgANUEwAACg7SAY0CQIBkBNEAwAAGg7CAY0CYIBUBMEAwAA2g6CAU2CYADUBMEAAIC2g2BAkyAYADVBMAAAoO0gGNAkCAZATRAMAABoOwgGNAmCAVATBAMAANoOggFNgmAA1ATBAACAtoNgQJMgGAA1QTCgk3zzm/o3vv6VT6x8SN8DrDAIBjSJ/s03GyAYMCkQDOgkkuhCM9D30AAIBjQJggFQEwQDOglJbnPQ99AACAY0CYIBUBMEAzoJSW5z0PfQAAgGNAmCAVATBAM6CUluc9D30AAIBjQJggFQEwQDOglJbnPQ99AACAY0CYIBUBMEAzoJSW5z0PfQAAgGNAmCAVATBAM6CUluc9D30AAIBjQJggFQEwQDOglJbkMsmb7v6/8AVhIEA5oEwQCoSVcFY2lxXvUG6UIVBj01N78o6RGsBhCM5tB9P7fQH/mztNRf8H5GZXkBM4FlgmBAkyAYADVBMMD0jSSNJhYqvDs9UD29bz5ZLFofY0n1F2ydEj199JBBz92mI0xo9boQSWDn7E1R8ZzMMdl+OvyMWC0427z7rWyby6h2eNv9PijdliPS914ba9Zt8fZJQv+TWyfRG4TXdEToTpPrjHRAFRAMaBIEA6AmCMasoxNTN3k3CWV5MmuT8mFiaBPLnupVSRjTxNe/fn47wsTTCId7gD7eQ8rMjq9+TsUJbpKwZ1V6ZZRtcxnRDll2t7uUbYuQvyaRNoZtqVK+3i/XP2Hfa6R+/3rm18lyvq/l3qkitTDrIBjQJAgGQE26IBi5d7NLYn5xmKmIhGTLklAZwVhSi/NhcgtDJDEtSfjSRL5fkJiPfkc6kZFR/R+WYxJo9yB9rV1k/+Iyi8+p+Dg5xpUGt4yybWW4+5Ul1jWT7tg1yQmEW2b9pN79GZS+d3/myq93BaSt/EDCCBAMaBIEA6AmXRCMGOUJpRAkgZlgaJYW1by7zSzPK8dNZhfpJy95dhnKQSgAlqL1Gd5MQzF+OcN6MyTRzRiRMBeeU1LuMFn29/HecQ+S4LJthbjtcKQgl6iXbctRcE2krpxgpH1Yq/wIen/BSF/Yr1J2WmZZeN1V8Z6A2QbBgCZBMABq0k3BSGYhypI6b/ZCkITLeURKkrHseAQjIU0Oi7rVTWCLRKJofUaY+HoJ6TBZNdcnW68jTED1uiHhjILDiHNyMQmzU0+SQA/b4J5X2bYoYTuMbDjLZnsqSWXbAgqvSVl9NcqPoo+NykWIlBsRBzk2q9tQcv0AUhAMaBIEA6AmnRQMSZB0hjLoFUiBCEP4eQs5xlsnSY2TZM04ScI4YhbASRYnJhgZfpKZK8ckxU4Sqq9dRkkiW+1D6xZpQ7p/Lul27peybRGi7Yj0Q3bOZdtcRl0T02epBOn9+r20DVXL13v4MzxJ6H9y60wEZZZdF7+vRsxAAWgQDGgSBAOgJt0TDEnmUrEQkYhkdVHxkKQqkA6Z5QjXzSKSXJY/4hNPNGNJZTxRdXGSeA9ZXyIY4XG67iH+scLoc4oxrMNIQXC8bVPZtpDCdkSS76yMsm0Z1a9JgtNHlcovQeqo0rcFgjGwopORv34AIQgGNAmCAVCTbgmGJCL+O8VGEqokOxHByJjlR6QkCSxK7sy2+DvLZQn1qEQ1PrPgJ5m5csy78U479X0wZCgGhrJz8tCy4FXhJOe5c3fuvbJtLqXtSAQhO0evzLJtxZT1vb9teeVnjCUYUndQV2k/ASQgGNAkCAZATTojGOnjHrG8xiSGoxIUBCNO2q9hxBPpIUXJbFmS62HK9ut0j0uuqRvB9dXrXGT/7N4YeU62rGAWIEyGg3K8e69om1t+WTsMiZjk1wsF20qScb/v/XPLX5Oyukcgx1Q5QNqa9ql3PcNjpZ9qNQBmEQQDmgTBAKhJFwTDJCejHmUykhAmL34S5X3oG7qNvp4eTjJbyrST2a6XX4KVBOn7Sk2odE0iMxoAERAMaBIEA6AmXRAMgByhYGhin40IyX/AeLJ0vfxKRPp+ufizLgDFIBjQJAgGQE0QDOgkE0xyoSb0PTQAggFNgmAA1ATBgE5Cktsc9D00AIIBTYJgANQEwYBOQpLbHPQ9NACCAU2CYADUBMGATkKS2xz0PTQAggFNgmAA1ATBgE5Cktsc9D00AIIBTYJgANQEwYBO8o1vJIkusfIhfQ+wwiAY0CT6N99sgGDApEAwAACg7SAY0CQIBkBNEAwAAGg7CAY0CYIBUBMEAwAA2g6CAU2CYADUBMEAAIC2g2BAkyAYADVBMAAAoO0gGNAkCAZATRAMAABoOwgGNAmCAVATBAMAANoOggFNgmAA1ATBAACAtoNgQJMgGAA1QTAAAKDtIBjQJAgGQE0QDAAAaDsIBjQJggFQEwQDAADaDoIBTYJgANQEwQAAgLaDYECTIBgANUEwAACg7SAY0CQIBkBNEAwAAGg7CAY0CYIBUBMEAwAA2g6CAU2CYADUBMEAgOosqf7CguovpYsAKwSCAU2CYADUpJuCsaQW5+fVYkmSs7Q4r+bm5kZETw3S/X2k/Dk1X1KBlG+3l9XVi1cA0F0GPTW30Nc/JeUs9Re8+1+WFzATWCYIBjQJggFQk9UsGJ4gLC2qeS/blzJSwZCEKSIHsfASprCOgEGvI4LhnX+Vd6cHqqf3zSeLRetjyDvhbt/6sid9N9ymo2JCO2c7vOI5mWPcevyMWC042/zbp2Sby6h2eNsD4S3bliPS914ba9Zt8fYpj94gvKYjQneaXGekA6qAYECTIBgANemuYEQSFh3urEIdwSgTBUsmDE5ZsdkLW1Y3BEMnpm7ybhLK8mTWJuXDxNAmlj3Vq5Iwpomv3zd+O8LE0whHWWdKmdnx1c+pOMFNEvasSq+Msm0uI9ohy+52l7JtEfLXJNLGsC1Vytf7jbyeGqk/vDzhOlnOl8UjV1ANBAOaBMEAqEl3BWNKj0iJPBQlkpZAMLztOiHrlmCEyDmXJHxpIt8vSMyLE3ZLIiOj+iUsxyTQJQeV93XxORUfJ8e494dbRtm2Mtz9yhLrmkl37JrkBMIts35SL/0U/xkadb0rIG3t3g8KrDAIBjQJggFQk9UsGJVnMAyS/OmEaX7RScoSbHKVHV5XMIy0lLe3NUiyFxMvw1AO5NyWJRjeTEMxfjnDeuOMSJgLzykpd5gs+/t477gHSXDZtkLcdjhSkEvUy7blKLgmUldOMOz9WKf8Yoz0hf0qZadlloXXXRXvCZhtEAxoEgQDoCadEQyTnMWTFRtu0pJL/EsEQxKz4qTaIvunjz8FghG2o7OCkSaHXjc5uAmsLwBDitZnhImvl5AOr0FyTZwoTUDDGQWHEefkYhJmp54kgR62wT2vsm1Rwnak93O2bLanklS2LaDwmpTVV6P8IqJyESLlRq6bHJvVbSi5fgApCAY0CYIBUJMuCYY3IxEQCkUs8c+Hk9QYCYjtY8MRhEAwvGTJaackfH4i1V6ShHHELICTLBaJRNH6jKCcIX6SmSvHJMUlElGQyFb70LrFeYQpl3QnM1zmepZtixBtR6QfsnMu2+Yy6pqYPkvvX71fv5e2oWr5eg9/hmdEBGWWXRe/r0bMQAFoEAxoEgQDoCarVTAkYfKSmJIZjBg5cXBZZYIh7Sx/xKck0ayUqLo4SbzHCMEoPE7wjxVGn1OMYR1GCoLjbZvKtoUUtiOSfGdllG3LqH5NEpw+qlR+CSIoVfq2QDAGVnQy8tcPIATBgCZBMABqsjoFIyIPUxSMMMHLCYbs39ZHpCQJLJsZKEjqixLSKolqfGbBTzJz5UhSW5iEDsXAUHZOHloWvCqc5Dx37lJHzRmM0nYkgpCdo1dm2bZiyvre37a88jPGEgypO6irtJ8AEhAMaBIEA6AmXRKMMJEPI8t5ZN/ww9orNYPhMOilUtFmwSjoV3NOJYlnUTJbluR6mLL9Ot3jTLLvbS9PQGX/7DqMPCdbVjALECbDQTnedS7a5pZf1g5DIib59ULBtpJkPCYR9vj8NSmrewRyXlUOkLamfepdz/DYquXBTINgQJMgGAA16ZJgVJ3B8JJNi5UCk+yniY6VkIJEMBam3JysOHhllSfFMEGcZLaUaSezXS+/BFcSKjWh0jWJzGgAREAwoEkQDICadEYwAEYQ+2xESP4DxpOl6+WvNP6sC0AxCAY0CYIBUBMEAwAA2g6CAU2CYADUBMEAAIC2g2BAkyAYADVBMAAAoO0gGNAkCAZATRAMAABoOwgGNAmCAVATBAMAANoOggFNgmAA1ATBAACAtoNgQJMgGAA1QTAAAKDtIBjQJAgGQE0QDAAAaDsIBjQJggFQEwQDAADaDoIBTYJgANQEwQAAgLaDYECTIBgANUEwAACg7SAY0CQIBkBNEAwAAGg7CAY0CYIBUBMEAwAA2g6CAU2CYADUBMEAAIC2g2BAkyAYADVBMAAAoO0gGNAkCAZATRAMAABoOwgGNIdS/x+kPLcexlF87gAAAABJRU5ErkJggg==" alt="图片描述"></p><p>可以看出这个文件的实际大小是<code>2588266496Byte</code>(<code>2527604KB</code>)，下面通过代码来获取文件大小，并进行比较：</p><h2 id="一、通过File类的length-方法获取文件的大小"><a href="#一、通过File类的length-方法获取文件的大小" class="headerlink" title="一、通过File类的length()方法获取文件的大小"></a>一、通过File类的length()方法获取文件的大小</h2><p>1、创建一个文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File bigFile=<span class="keyword">new</span> File(<span class="string">"F:\\软件\\安装包_office2016\\Office2016.iso"</span>);</span><br></pre></td></tr></table></figure><p>2、获取文件大小：File.length()方法可以获取文件的大小(占用的字节数)<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 获取文件长度</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getFileSize1</span><span class="params">(File file)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (file.exists() &amp;&amp; file.isFile()) </span><br><span class="line">    &#123;</span><br><span class="line">      </span><br><span class="line">        System.out.println(<span class="string">"文件"</span>+file.getName()+<span class="string">"的大小是："</span>+file.length()\<span class="number">1024</span>+<span class="string">"KB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>3.运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件Office2016.iso的大小是：2588266496(Byte)=2527604(KB)</span><br></pre></td></tr></table></figure><p></p><p><strong>可见，使用length方法获取的文件大小与windows中显示的大小一致！</strong></p><h2 id="二、通过file-io-中的流式方法获取"><a href="#二、通过file-io-中的流式方法获取" class="headerlink" title="二、通过file.io.*中的流式方法获取"></a>二、通过file.io.*中的流式方法获取</h2><p><strong>使用FileInputStream.available方法获取：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据java.io.*的流获取文件大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getFileSize2</span><span class="params">(File file)</span></span>&#123;</span><br><span class="line">    FileInputStream fis  = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(file.exists() &amp;&amp; file.isFile())&#123;</span><br><span class="line">            String fileName = file.getName();</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            System.out.println(<span class="string">"文件"</span>+fileName+<span class="string">"的大小是："</span>+fis.available()+<span class="string">"(Byte)="</span>+fis.available()/<span class="number">1024</span>+<span class="string">"(KB)"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span>!=fis)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、查看结果：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件Office2016.iso的大小是：<span class="number">2147483647</span>(Byte)=<span class="number">2097151</span>(KB)</span><br></pre></td></tr></table></figure><p></p><p>通过这种方法获取的文件大小是2147483647(Byte)，很明显，这是int类型所能表示的最大值<code>(2^31-1)=2147483647</code>，究其原因是因<strong>为文件的大小超过了int所能表示的最大值！！！</strong></p><p>而上面file.length()方法计算没有问题是因为，<strong>file.length()方法返回的是long,而available()方法返回的类型是int类型。</strong></p><h2 id="三、通过file-nio-中的FileChannel工具来获取文件大小："><a href="#三、通过file-nio-中的FileChannel工具来获取文件大小：" class="headerlink" title="三、通过file.nio.*中的FileChannel工具来获取文件大小："></a>三、通过file.nio.*中的FileChannel工具来获取文件大小：</h2><p><strong>使用FileChannel获取文件大小：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据java.nio.*的流获取文件大小</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getFileSize3</span><span class="params">(File file)</span></span>&#123;</span><br><span class="line">      FileChannel fc = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span>(file.exists() &amp;&amp; file.isFile())&#123;</span><br><span class="line">              String fileName = file.getName();</span><br><span class="line">              FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">              fc = fis.getChannel();</span><br><span class="line">              System.out.println(<span class="string">"文件"</span>+fileName+<span class="string">"的大小是："</span>+fc.size()+<span class="string">"\n"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(<span class="keyword">null</span>!=fc)&#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  fc.close();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>该方法运行结果。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件Office2016.iso的大小是：<span class="number">2588266496</span>(Byte)=<span class="number">2527604</span>KB</span><br></pre></td></tr></table></figure><p></p><p>这里的size()方法的返回值类型也是long,通过这种方法获取的文件大小和第一种一样，都能获取文件实际大小。</p><h2 id="四、使用小文件测试以上三种方法："><a href="#四、使用小文件测试以上三种方法：" class="headerlink" title="四、使用小文件测试以上三种方法："></a>四、使用小文件测试以上三种方法：</h2><p>以上情况中文件大小超过了available()返回类型int的最大值，下面使用一个没有超过int最大值的文件测试，来验证通过这三种方法获取的大小是否和windows中显示的一致：</p><p>1、获取文件，查看其在windows中的大小：</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAyUAAAEmCAYAAAB8nz8YAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAGJHSURBVHhe7b3rcxzHee+PPyBJnZdJpfI2Jy8lO7YEpPIiv6oc5zhKpc4LlkWzIkukuDzFVJT4d5zYP6ZEiiAJgiRILEgB4EUkwatctGnKNgHHEiRZhqhLSOp6RF0gly+SZYmUKNuxCIKg/fz66eme7e7pmZ0Bdhszi++n6iF3Lt3TM7uz83zQPTtdBEBgfve738n47W9/Szdv3qS5uTm6ceMGXb9+na5du0a/+c1v6Ne//jX98pe/pI8//pg+/PBDev/99+mdd96hH/3oR/Taa6/RH256XS5PizfffFNtbeEMDAzQvn37aOrpp+lXol2zoq0zoq0yZkSb0+Iax0wcn6i4NjMjys7S1asf0/cffZS2i/p5G0uBdevWqVcAABCG+X7v8HXEd31xg69Hzz77LL344ovy+jQ9PU0/+clP5DXrvffeow8++ICuXLkivvOvyvX5+sbXOb7e8XWPr398HeTrIV8X9TUSpNOKa/x86mhlbgGSBJWSnTt3UldXV9O4++67VQmbs2fPyjpaBSe7n/70p+X/Swk+jn/1V38lvxAXgzxSwl/wf/zHf0xPCxEog5Ts3buXfjglpORXQkpmhZT4JMSKpIx8IvaNw5KS7wsp2bEDUgIAAG0CUtJ5QEo6k66QySkLBSfEGk42v/jFL+befpaUcB28L6bc/NEf/ZFXOLLkKK2MCZdncSqyTYbLtFKq5gukpBgsDKPtlJLtkBIAAGgXkJLOI+0a/8ADDyQijXZLCX8WfvCDH6ipaLper8s/cv785z9Xc9Phsmb50HzyySe0a9cu+X8ogveUcELMYSbyZuhkmRNRTvB965ihJUALgik9ejvmPEa34+WXX6a///u/l2UZ/p8lKUtKzDJFtsnw+lyW61hMuG1ll5KyDd8aGR2lH/5wSkrJdSElfhHhaMhIQ0oiGeH4jfxfSMlMJCX/8f3v07bt2yElAADQJiAlnUfaNZ7/kPkf//Ef9NBDD1Fvb28ppITf35GREVq/fr3MaQ4dOkQnTpygf/qnf6KvfvWrUlA48eflPC8r9Pq6zsnJSVkfT7eaPFLS6nYUkhI+gb4vkig+ceaDKSW+IVqcfJo9Jzz9Z3/2Z3ESz+V0TwMvM4decRlXEBguy3Xo9RjdDsZsC9fRTEp4XV22yDY15vbystDj7sJtCCElae2upJSIkw5SsnCCSMlEjbp66jStJjuG6Tr1dPVQveN2DID2AinpPNKu8fweaBnp7++3pMTNedolJTpR1yJh9o7wMk7edU/JI488ktpr0qyn5OGHH7ZkQG+XP4OtIG9PiduOhdDlJtRZsH3yG3z8+PF5JchFeko0nJBq+eByXIcv6ecyPkEw52dt1w2fOHBdZk9Hnm3yun/yJ38Sl+H/zd6ZPCz0uPNxcnudzOPsLudjrPdBSyDDr81yzUhrdx4p4S/4P/3TP5USwu174okn6Pd+7/fiNoaWkmFxoj/11A9F3b9SUiKEQ0dCQtxQUvKJ2DcRppR8Txyj/m3bICU0QTX13sqoTaj58yC3lExTvcfYJkeZZQZSAsC8gJRUg/Pnz3sTYJ7Hy0x813j+4yULyfbt2+XyqampWErefvttKSn8XmjmkycUKeP2lJiCwkm82fPB62qJaRZaOlho+LgstpS47VgIhaSETxhOMOebIJtS0qynhJdbyUJG8Lo6ic4SBA2vr9th3gPC62b1lPD8PL0z5nxXStw68rCQ487b4X1091/LBS83e6PMtnPo9dL2NYu0dheVknfffZf+5V/+RX7R8zSfdIshJT9ok5Rs7V/iUsISIc5jy0PEvJ75Zt8FpWQh/tN6ytgmAKoNpKT8PP/88zJXGB4etpJgfs3zeBmvo/Fd4zk55vXeeustOW1KCb8n/JrX0YSUEt07Yr5mdE+JXpdxZYBHjOhkn9fxSQevaw7/4jyJy7jz+bWul8lazv+b7eBtp9XTKgpJCTM7Oxt3iT311FNqbj7++Z//WSa/vE1XLHToJNhFl/nrv/7rOIE2SUuaeb7Zu8HLzW3wfPMekSwpMddl+P882zTJWpbFfI+7u7+MOY9fu+8BBwukKSwcaUPSsvC1u6iU8Db5LyB8Euj2BZcS8aX4gx88Jeu+fn1WtDOHhOhQMqIjkpLr8gI18T0hJVv7l7CURD0kLU3CISUAAANISfnhBFfLhxYT3zyN7xrP62zdulVNJeFchNfRhJASTuC5d4RDJ/Rm6J4SjZn469i2bVssWlnw58jsKeHjxXmTlh2Gl2mhyLNcSwm3kY8tv24nwXpK3GSc//rN83ia53/00Udyng/+y77u3di8ebNMqM1hRQzX5RMEMwHnbf3BH/yBlXz7Iu2YcHKcp6fE3KaLW0ceFnLcfW0x52W1leHjzsdaRxHS2l1USlhmfv/3f1+eKDz9rW99a5Gk5AeybkjJ/EkkB7kEwhna1VUTc0zc5SKsOu3ljR6YLAHI2qYup9aR2+LXPVSf4CFWURlZr+oFsrcrmG6sF6/rbtM9LrKM0Q5vHYyvfQAsXSAl1YATXlNCzNduMuy7xnNCzuKRBi/jdTTtkhItBywUZsLP8DKzp8SHKwBabrRspOFKCf/P0zxfY67TbDlvX0sJB+dgrkS1mmD3lJjJOJ+IOpnXUsL/u70gvJwvtrqN/L9OjPl/Fgy9vlmnhl+b6zA8jxNtRosOt0kPG+N6zTpMeL20oU4ad5v8v3tPSdEeh4Ued3P4lm6zFhF3OcNf4Lp93F5+X9J6qLJo1T0lfBPVX/zFX8TDt/7t3/4tuJQ8+OAwPfnkk/SxqJt/zreZjPAN7aaIxPGbSFJmZmboI3GBGp/4HvWJLx9ISRpRYm0l9DLR18l5tNwUi4mamYgrWYiLmyISvY4lIN5Os23qcqaoOAKgZUQ3zBIKUb5m7LOnbnN/YgrWYbcPgKULpKQ6cPKrZSRNSBjfNf7b3/62LMPH34Xn8TJeR9MuKdHwZ4GlRCf6Zu+HDs5vNJzsc9LvW09HlhSYQsGkSYeWombLTSnR6G20S04KSQmfQPP9FShO9l0ZYDjRZSnRCbJO+nkdvb6Gy5h/recynFzzevq1mWDoxNuE63DbwdvNIyWMLsPk2Sbviykl5vbzwvUt5Ne3eJu6fSxMW7ZssdrJbTN7kMz91/tYtM1MWruLSgn3oLGU6PbdcccdwaVkz4MPtlxKPhQXqLMTE7QFUtJIrl28y43E3bfcnCeT9cb5qSMSjhQBaLZNbzlXfppNi1rqPUabikpJROE6AFiCQEqqhRaTNCFhfNd4Ps6bNm2Sw50uXbqk5pJ8zfN4Ga+jCSUljE7mtTDwfnFvSFZiz+ua0tIM3zZ8w7O0iORZbg7f0kPI3O20ksL3lMwXfT8JJ7ec+Ou/0PPF1BQNXofX9cFtNdctgk6uGxfw7HDlQsPt0xJVFC5jDmFbqhSVEv6sLPZPAu/es4eeiKUkaifLhQ6vgBjxX0JG/us3n8jgab5B/sOPhJSMT9Dmvr6lKyWeZN0iVRBUmTxSkiivSUnem23TW66AlEi5MHpiLNnIEApzvfnWAcASBFJSPTgR5kgj7Rr/0ksvWT8JrO9p5Xm8zCSklGhYMrjHQ9+34cLr62VcntdnIeCeiTyCwuW5flc8dE+Lu92s5fy/2VOi285RRJaKEPThiZ0Ci9F8eg60kC118khJn0jU//Iv/1J+oXe8lGxZylLC+TT/td9M4AVCDDKHUsXSEC1vJOBRQp6+nIs3S96bbXOBUuJIT7T/KW2SsmHKjFqvSB0ALHEgJZ1H1jX+8uXLcpgWJ+Yc/NrsIdG0U0q0HPD/vmTenMdtPHr0aLy+LsvBnycNv+Z57RKCMgApAcHJkhK+iZ17qv7wD/+QfvzjH5fm4YlDu3fT4088IdojpGTmejREyxGPZEQS4gYvi6TkI/ru+Dht2rxlSUuJhJNs8b7HYWXUkSQ0luvkW2GVFQl83U7Yo2S+Ub5RdVbynrXNBUqJKq/r7hGSZA7Liodk8T6kSUlmHZASAEwgJZ1HK67x7ZQSMD8gJSA4WVKie0r4S5u/vMsiJfUhISWPt0dKeiElIA+WlAAA8gIp6TwgJZ0JpAQEp4pSMlgfosnHH0+Xkt9w+CXEDVNKvnP2LG3ctBlSApoie1DMHiAAQC4gJZ0HpKQzgZSA4FRTSuptlJJNkBKQTjw8Db0kAMwHSEnnASnpTCAlIDiVlJLBQXpscpKuiva0Ukq+/V0hJb29kBIAAGgTkJLOA1LSmXTxAUYgQsYbb7wh4/XXX5e/H87BX+SvvvoqvfLKK/Jn+1544QW6ePEinT9/np5//nk6d+6cfLL7pBCD8fHx4FKyU0jJo2LbH7GUsDwJqbDiWtrT3ZPB63MdWko2bISUAABAuwghJadOnaJHHnmEJiYm6LHHHpPPteJr1tTUFD3zzDP03HPPyevZhQsX5PWNr3P8eAC+7vH1j4OvhXxd1NdI87qJaE8UxVcHonWBnhIQnCr2lAwIKfmPRx+lD65cIb6BvRXx/gcf0Jlvf4fWb9wIKQEAgDaBnhIAqgGkBASnklKyc5COHjsue0ue/MEPonjyB/SEjCfpcY4nOJ6gSY7HH6fHdIgyXC6Oxx6j74v47tlxGtm7D1ICAABtBFICQDWAlIDgVFVKdg3W5TCugV27xPQu2jGwU8b2HQO0bfsO6t+2XcbW/m3U199PW7ZupS19W+XDETeJ4J/+7d28Wd7Y/kDvJjlsiwNSAgAA7QNSAkA1gJSA4FRNSkDrgJQAAEIDKQGgGkBKQHAgJUsXSAkAIDSQEgCqAaQEBAdSsnSBlAAAQgMpAaAaQEpAcCAlSxdICQAgNJASAKpBW6RkZmZGvQIgSZqUsHz8+7//uxQQSElnAikBAISmalLy7rvvQkrAkgRSAoLjk5KPPvqIvvCFL9CDDz5I99xzj/wi5y9vSElnwckBAoFAhI75ACkBICyQEhAcV0r4i5qF5PTp0/JLmp90e/fdd8svZkgJAACAxQBSAkBYICUgOKaUsHTceeeddObMGeuekhdeeIG+9KUv0c9+9jNICQAAgOBASgAIC6QEBMeVksnJSfmlbEoJf2lfvHiRzp8/DykBAAAQHEgJAGGBlIDgmFLCX8L8ZeyTEv7yxvAtAAAAiwGkBICwQEpAcCAlAAAAyg6kBICwQEpAcCAlAAAAyg6kBICwVExKXqOddw/RN36hJrP4xZN0393r6I67v07Picnn9q2jnRejRWBxgZQAAAAoO5ASAMJSISlhIWHJ8Md9370s13rnu0NqXiQjEikoxjRYVCAlAAAAyg6kBICwVEJKtGh4ezpYOO5/kt5RkxGX6Rv3awnh10mJ4dAiA8ICKQEAAFB2ICUAhKX0UiKFREnHc/ucoVsXvx4vi0gTkGQvCYZzLR6QEgAAAGUHUgJAWCp4T0kkEywVd+x7Tc134fW0iLxG3zCGdsneEW/vCggFpAQAAEDZgZQAEJaKSUmToVwa7kGRPSR2z0osJWBRgZQAAAAoO5ASAMJSGSmRPSPxcKxkNGTjMn1j39dpp7yn5DXx/5P0DkvKvteUlLwmh3hh6NbiASkBAABQdiAlAISl9FKiZeS++zN6OYR06GUN8WgM39JDuRo9JTwv508Lg5YDKQEAAFB2ICUAhKUyPSWZQ68MKXluHwuI/vWt6MZ33Sti1aFukgfhgZQAAAAoO5ASAMJSKSlxh2yZYQuLlhKbTLEBwaiClIyNjSEQCASiwrFQICUAhKXjekoiHCnhXhElL7iXZPGpgpQAAABY2kBKAAhLZaQEdA6QEgAAAGUHUgJAWCAlIDiQEgAAAGUHUgJAWCAlIDiQEgAAAGUHUgJAWCAlIDiQEgAAAGUHUgJAWCAlIDiQEgAAAGUHUgJAWCAlIDiQEgAAAGUHUgJAWCAlIDiQEgAAAGUHUgJAWCAlIDiQEgAAAGUHUgJAWCAlIDiQEgAAAGVnsaREXyMBWGpASkBwICUAAADKDqQEgLBASkBwICUAAADKDqQEgLBASkBwICUAAADKDqQEgLBASkBwICUAAADKDqQEgLBASkBwICUAAADKDqQEgLBASkBwICUAAADKDqQEgLBASkBwICUAAADKDqQEgLBUSkp+/fLf0a9euoN+9eId9EuOF+6gjy/+bRQX/paunv+8jI/+8/P0y1f/UZUCZQNSAgAAoOxASgAIS6WkhIWErhwTcVTEGNHlwyIOiniI6IP9IvYRvT8qYoQ+fP5/qlKgbEBKAAAAlB1ICQBhqZaUvMhS0lxI6P0H6cPnICVlpZpSMk2D3V1Um1CTaUzUqHtwWk0oxLwuX0Ge39VNevWJWuO1mKKasSxatysZ3YM0HdfPbayJkiDJNNV78r1/PfWc719epuvU09VDbrUAgHIDKQEgLJWSEh6ylUdI6Be76UpbpIQTRSQXC6WaUsI4ouDBFIv4dUZSOz3YHYmFeN0oy9vpEnIzIS5uPK3h+Uo6zDqrKiXc7p663PcGkTwkj5eabwpZomwzmp+/E7XG8vh1ASmZrvck112AlEzUupKSBAAIAqQEgLBUS0peEFKSQ0joF0N05dm/UaUykMmCmeg0SxwgJa2gClLCvSJWApwVSiqEYVC3fs2fFf06Z1Jr95T4WAJSwudkT484L939SPZ0cMLuP64egckK3Qa5bd0ecaz167xSYpVvFbwv+M4BYDGAlAAQlkpJCd/QnkdI6BeDdPmZJlLCiYYrGEpSGvmHmwhBSlpBFaREwz0Z3nxUfH7cYVqy10OvLD9fngRYBJeTCbVnmS+4xyRLkmq1zpES7mngngE+PvZxT0qJLO99cxpwfd5VRFm3B8Lq5ch4/9J6LpJtbhE59hMA0HogJQCEpYJS0lxI6L1dTaSE5SIlgZDJiE7sICXtoEpSIns/PB+UZK9G9JlqyIGxPDOpjMpZopK2rtkTY9YZvzakhNdtMtRs0eF2W1Ji9Ap4l5nnYjTddGgT/6HBczzNYVoR9vtn9U5kvn8ap4yJ/GOHIYvqjx9actx9qk2otuj9b0sPDACgGZASAMJSLSm5IKQkh5DQewN0+dznVCkPiYTHRIuHSgx0yPXVsroor+dbyYpdppEw+ZMN+ZfZeP0K/YV7gVRKSsQ7ZQkGYw3TiuBeku5aLRIYV2QSSS3XmXzf414ZXj/+XIhQZVla4t4Zb6JccSmxpvV5KCcE0TnUOC4pApDAIwueJF/20Ij3TwqMKzLeY+3C7U05hy0pEe2pOftsLpP76NaTUTcAoG1ASgAIS6WkhJ9BkkdIfvfuVvrg6c/R7+b+S5V0cJMhCy0Q7mtGSYWeIZMNnfD4kyizHivZsBKVpUW1pERgSQi/z8lkf2JQLHdlRJMrqeXVMiTCrcOaVp9LDkeWSo1zHrJ0mT0f9rR9LspepRzHVGJJiHueRkzUxXJXRjR53j9rGw6ec93/Bwn3+0bD8/NKGACgVUBKAAhL9aSkiZDQezvo4wt30ofP/T19/Oq/qpIOTjJkYyYAbpLgEw81zXXGSUYjoqTKl2zoRHLpJRuVkxImfn8zxEFLScpnIY7uGtUK3Eif+IlhRer9LhXBuocjPh/cSEvYo/Vz73/8nmScb1pKmr1/3u8Obk/KHxlMKZGvDdmyhMX3PcFk1A0AaBuQEgDCUikp4Se1NxMS+vk22Uty86cb5f9+MhIamZBkJUIZUpIpOmkJVLRsKclJtaUkIxFeSE8Jr9PdTd0ZyWd8z0lW6J6S0g/fij73cXJunXca8zxNnkNSalLPOYdc75+SEpc875/73SBlQ02b4sF1GW2OekzSvm8UlrgAAEIBKQEgLNWSEn5KexMhoZ/30/tT/6PxfwpRMuCIgLz4m0mBmyRkSIlcZicUE7WMZENsq566nc6mSlISi4Dx5uh5iR6M+UiJTpat4WFcf/MkNLOnpMRSknpMPTvTmO87R6J5qcdWkPX+mUPFJHz+++rKJSVRvfFq8rvEIyW6zfI9Fm3g+1iaSUnO7QMAWgukBICwVEpKPmQpaSIk9G4fvf9DISP6/yyUhOgEwddbEY/9ln/dzJISnrTra+QR/mQjTpg4llDSUQUp0TeiZ70t8ieA+b0zeyd8BRJJpXGje+o9IFpOeJ1iw70qdV9JW2gk/pnvn3VuyxkLkhJZ3tdzY0lJUZzvGABAMCAlAISlWlLCT2lvIiT07hb6xQ9ZStT/oHRUQUoAmA9SdByBkfPyDjNz4D9cJHp0AABBgJQAEJZKSckVKSXZQkLvbqJfPMVSov4HpQNSApYEemge7gcBoJJASgAIS7Wk5Nm/kQ9FlHHuc/JGdg6+d4SHanHPCIvIe0/9tfz//XP/S5UEZQJSAgAAoOxASgAIS6WkBHQGkBIAAABlB1ICQFggJSA4kBIAAABlB1ICQFggJSA4kBIAAABlB1ICQFhKKSX8RYDo3HjjjTdkvP7663Tp0iUZ/EX+6quv0iuvvEIvvfQSvfDCC3Tx4kU6f/48Pf/883Tu3Dl66qmnaHJyksbHxyElAAAA2gpfR3zXFzf4enTq1Cl65JFHaGJigh577DF68skn5TVramqKnnnmGXruuefk9ezChQvy+sbXuZdfflle9/j6BykBAFKCWISAlAAAACg7fB3xXV/cgJQA0BoqJSUnTpygY8eP09GjR+nIkSN0+PAYHTp0iB46eJAOHDhA+/bvl9N80vvKI8oRkBIAAABlh68jvuuLG5ASAFpDpaSEhYRPWB03OW424uTJkzLBfeihhyAmJQ5ICQAAgLLD1xHf9cUNSAkAraFSUsI9JHzC3hAn740bczR74wbNzt6g6ypYSi5fvixPcBYTXx2IxQ9ICQAAgLLD1xHf9cUNSAkAraFSUsJDtqSUaCGxpGRWSsnAwICM+u7d3jraFge+QF23rqNHfcuqHI+uo1u7bqV1j3qWzTMgJQAAAMoOX0d81xc3ICUAtIZKSQnfQ8InbFJIIim5fn2WZkTMzd2kwfqQtw47DtAXurqoS8cXDnjWyRm5peRRWnersU2OMssMpAQAAMAShK8jvuuLG7GUHO2jf1yxgu66/6CUkmO999DKlStp1apVtHr1aqp9bT9NQkoASKVSUsI3sfN9JEkhEaGEREvJzsFBbx1xsEQIIfjCAXveresetdfLGwWlxNruokfYNkFKAAAAlB2+jviuL25EUjJIX12+nNbta/SUsJT8n+GzcU/JN/prtGbbNyElAKRQKSnhX9niG9oTQjLbEJKZ69ellAzs3OWtI4qoh6SlSTikJHdASgAAAJQdvo74ri9u8PXo/122jP5331Fr+JYrJY/t/xqkBIAMKiUl/LO/LCWukDR6Sa7TtZlISnYM7PTWISOXQDhDu7q+QAcyl4uw6rSXN3pgsgQga5u6nFpHbotf30rrDvAQq6iMrFf1AtnbFSGHYum6dRucbbrHRZYx2uGtg8PXPr3MDkgJAACAssPXEd/1xQ2+Ht278aHEPSW2lHyf9n+tRtu+ieFbAKRRKSnh55BEUiJExJIRFUJItJRs277DW4eMplISJdZWQi8TfZ2cR8tNsTjwBTMRV7IQ34dhikj0OpaAeDvNtqnLmaLiCICWEX1vjCUUovwXjH321G3uTxwF67Db5w9ICQAAgLLD1xHf9cUNvh495LnRHfeUAFCMSknJ3r375EmbkJHr12MhiaRkjvq3bffWIYOT6Swp8S43EnffcnOeTNYj4TAjEo4UAWi2TW85V36aTb9Jj6671WhTUSmJonAdTkBKAABl4PTp04gOj4XA1xHf9cUNvh4tu3cjHc3sKXmOzn+jn9as2UbfgpQA4KVSUjIyOkpz4qR1hUTLiIxrM/I5Jn39/d46okgm61akCoIqk0dKEuV1pCTvzbbpLVdAStSwq7gnxu0BySMl863DCUgJAKAMcNL605/+FNGhEVJKNt67jJZ/dThbSs5/g7at+f/o4BOQEgB8VEpKhkdGIikR8mH2jOj4RAgJB0vJlr6t3jp0RH/tNxN4EUIMModSxdIQLW8k4FFCnr6ch3c1S96bbXOBUuJIT7T/KW2SsmHKjFqvSB0ZASkBAJQBSElnR0gpOaV+fWvFun3oKQFgnlRKSvY8OCxO3JsJGbkmtqeFREvJpi193jqs4CRbiEAc1nNKIklIDlPylRUJ/Do7Yde9CnqdRrKelbxnbXOBUqLK67pvFZJkDsuKh2TxPqRJSWYdkBIAQLWAlHR2hJUSvqdkmNbxc0ru20WP+O4pqfXTN3FPCQCpVEpKdu/ZY0uJISKulPRu3uytA1EwLClpTUBKli5btg20LABYKJCSzo7wUoInugOwEColJfXdu6Vw5IkHejd560AUC9mDYvYAtSAgJUsXn1zMNwBYKJCSzg5ICQDVolJSMlgfkk9q5wcj8nNI+Gd/+Ve2+KZ2voeEh2xxDwkLyYaNvd46EDkjHp7W2l4SjupIyTQNdnfT4LSazGKiFg9raxa1CVXGYaLWRd25NmYgtivLyO3XKKXq0uCTizzxw6efSbwOynSderp6qF7w7UkyTfWe9M8ACAukpLMDUgJAtaiUlCA6I6opJRNU8wiGDCfDnKi5IiPKdg+K2prB28gpQRotJeq125aywTJx48aNBQekBLQCSElnB6QEgGoBKUEEjypICfdaWOLhSsX0IHWnZJZ5pCRRf1bUaulC5IsSZ7xpUsIX7h07dsj/fcvdCC4lLWMhUgKhaTWlk5KxL/rPaU98ccxTXoeo59MbnvIvW0IBKQGgWkBKEMGjmj0lDguUEpPpwe7iw7Y0Ge0oI5ASSEmZqERPSZZguBLzxTE5f+yLn6YNT3nWV/HUhk/H60YxRl/01tNVabmBlABQLSAliODReVLC6xkX9GbhCApLybwTzTQp4flFh4IFwCclDx08SK+/9Tb96J2f0ytvTtPQngdluOuZkU9KdBKvht711GlaDsMy7r2xpnm9HqrXG/cH9ejxWt5yjfe08RZ4tqmWRDjLE+UF3rrt9ZP1gvlQRimRwmC+157wisJTG+jTUiYcwdChJYTX+/QGekqXU2Jj9bzEIvQUbfh0tuCUOSAlAFSLUkoJ6Gz0Fy5/+fKXMH8Zc6J5nZ/Of+0a/eY3v6Ff//rX8sv+448/pg8//JDef/99euedd+hHP/qR/AIPJyX6ou4k+C3sKUkfytWoh8XFvzyl7opICV+gWUhmxeuTJ0/S9dkbdPH1aRm8zFzXjCJSYv0AQFMpEevr91UuU/eRWOuJemuGFFg/MuDZpoVnuVu+Sd0pHzswD8oqJZZ0OD0lieU6lJS4y7m3wxQOezoSmGZDwexelepESCl59tln6cUXX5TXp+npafrJT34ir1nvvfceffDBB3TlyhW6evWqXJ+vb3yd4+sdX/f4Ow1SAkDFpOTEiRN07PhxOnr0KB05coQOHx6jQ4cOyb+0HjhwgPbt309jY2Py5AflpQpS0hCFlMQ+VUp8vStZUpLWG8MJsi+xdevi8mkJcPlwpYSHbHEPCQsJw/+/+qOfyPj3jZvp6LfGafyxJ+XnwSxXrKdETTJNpcS8mZ3L+6QkYrreoz4jpmQ0Ewff8uS8+dUNitJ5PSUbaMOnxTpxT4jb0+FMs3CYvSa+cHtWKhSQEgCqRaWkhIWET1gdN2VS2whOaHgoEIsKxKS8VEFKItKEQZAqJT6ZyJAS6y/hJnmlhKuoTqLq6ynhIVvcQ8Ln7zXx/6PPvyTj6Avv08sfz9HhCz+nx59+1iq3qFIiX6cN7WomDr7lxrwF1Q2KUoWeksxpFgZDViJhGRPi8UUak+uP0RctoeCeEb1MRB4pcctUKCAlAFSLSkkJ95DwCSsfkHhjTg75mBVJDCc0Oqm5fPmy/FJgMQHlpJOlRA6zSsxPkxKuP+XZJFy/t4ynLvOngHU5/r8iw7fCS0lDPKIeiYJSwsfbuKfDrqPZNqPl5mfEKl+0brAgKt9TYvZiqOFbug5exxWaRK9HLimp7n0lkBIAqkWlpISHbEkp0ULCEUvJrExqBgYGZPDT35c0TnIT4yRli0GnSokUkrwiIesWCYZ3fQG/f2l1mQmKbIOqS7yOf8mrIlLCsf+hg/Iekld//A4999pb1D98UMbLv5yj469epZc+viGHcZll5i0lgijRj45fT61m9ETklBJVr78OzzY9UlITZXR5u6csq26uSrUdN7q3hDJKiSsKLBbmPR+JnhKvVOib3V2ZcHs9eLqZcKCnpFlASgBoDZWSEr6HhE/YpJBEUnL9+izNiJibuymf/t4cX4LXIUBK1NbmR+PGcjthNH9ly+zhSBcSJikl8p4VO3O16rbvZTGXme0x0Z/l8omIiU9KOMyfBH7i6WdlHFM9JWMX36NLb//EWj+flLQQS0pAp1BKKeFgMWFZGOPhWRlCYEqJJTNKShLCkpSQqGfGERNRlz1ETLVBvlbrpr3WdZQggkvJ5Ah9ecUKumv7WSklj+66h1auXEmrVq2i1atXU239aZoW60NKAPBTKSnhIVl8H0lSSDihjYRES8nOwUFVKgVO2sWXtpUXinnxWO6qkyYlJaAKUgLaQ5qUmMHvPcfE5JN07Fvj9ML/fUNOm+uElhLZQ4HeiY6jtFIiIpIF9ceItF+/kjKg1lECosvJ3hUtN4YsuL/GJUOup+rhMLfHy/Q0pMQbkZQco97ly6nvTKOnhKVk3cMvxz0lU8M1WjN6DlICQAqVkhL+lS2+oT0hJLMNIZkRJzhLycDOXaqUj+ivyp3UMZIAUqK2BspE5aRE/fEivYcKVJmySQkLgxYD614QVxo4WBR4vu4NUYJilZPB94So9fV6iR6UtMBzSnzXFzf4enT/smV038ikNXzLlZI3T6+HlACQQaWkhH/2l6XEFZJGL4lIamciKdkxsFOV8pArYXeGdllJCS/rofoED+mIlkvBiRMY49dzCq0rkMNEovnxuhJVj+/BbhK3vSJSh28Z+5K6PT02XtXbQsGBlCxd8khJngjdUwI6kzL3lLQzZG9KWu+LEXiie34pWTs0nrinxJaSS3R6fY1Gz2H4FgBpVEpK+DkkkZQIEbFkRIUQEi0l27bvUKU8NJWSKBG3kn4pETqZdxJ1LRg6o7cS/yLrChFIfXCaqscqp+8NiZY1hIKLGts0yb09fcOtnm4dkJKlC8tEqwKAhbJUpWSpREgpGffc6I57SgAoRqWkZO/effKkTciIOKm1kERSMkf927arUh44+c6SEu9y3XPAr1kCzJvFs6aLrBth/jqQLSXmetweNe1rb9o+WlIS4d+eub+tBVICACgDkJLOjpBSsmztEE1m9pRcoatTw7RmzSg9AykBwEulpGRkdJTmxEnrComWERnXZuRzTPr6+1UpH0kRsEiVEl2miGgUWFcKg9FDYwmEW64FUpK5PUgJAKCzgZR0doSUkqG1y2h576lsKbk6RaNrNtAjb0NKAPBRKSkZHhmJpETIh9kzouMTISQcLCVb+raqUn6i3gEzyReIRD5K0FkAPMO34iS/gGgUWdcRiaiNOaRELjMFIhKKuC4pG2pdUzwytwcpAQB0NpCSzo6QUqJ/fWtF3xn0lAAwTyolJXseHBYn7s2EjFwT29NCoqVk05Y+VSoDTsrlkCUVVgYeJfqN5TpZZzLEQmJOF1lXyYTaZu4HuzHWvoj5fEN8MynJ3B6kBADQ2UBKOjvCSgnfU3KK+vg5JV85TBd895TUhumcWB/3lADgp1JSsnvPHltKDBFxpaR382ZVClhYUrI4QEoAAGUAUtLZEV5K8ER3ABZCpaSkvnu3FI488UDvJlUKmMghWsaQrcUAUgIAKAOQks4OSAkA1aJSUjJYH5JPaucHI/JzSPhnf/lXtvimdr6HhIdscQ8JC8mGjb2qFJDEw7sWt5eEgZQAAMoAJ62Izo6FACkBICyVkhLQGUBKAAAAlB1ICQBhgZSA4EBKAAAAlB1ICQBhgZSA4EBKAAAAlB1ICQBhgZSA4EBKAAAAlB1ICQBhgZSA4EBKAAAAlB1ICQBhqZSUnDhxgo4dP05Hjx6lI0eO0OHDY3To0CF66OBBOnDgAO3bv5/GxsbkyQ/KC6QEAABA2YGUABCWSkkJCwmfsDpuyqS2ESdPnqRLly5JUYGYlBdICQAAgLIDKQEgLJWSEu4h4RNWPiDxxhzNihN5dlYksypYSi5fviy/FFhMQDmBlAAAACg7kBIAwlIpKeEhW1JKtJBYUjIrpWRgYEAGP/19ScMPS8z75PbpOvV09VBdrjxBtfgBi+br1uGVku/cS123D9CrrpRc3Eqf7fosbXoWUgIAACAckBIAwlIpKeF7SPiETQpJJCXXr8/SjIi5uZvy6e/N4aSbn3KuorbYzzpvIY6UTNS6yNo9KSJqnwtJycKPWRWkhO9NQiAQCER1Y6EUlpLJEfryihV01/azUkoe3XUPrVy5klatWkWrV6+m2vrTNC3Wh5QA4KdSUsJDsvg+kqSQiFBCoqVk5+CgKpUCJ+0iqbZyajGvJ8rMq0+mlERi4feJDClp0TErJCUYvgUAAGARKCYlx6h3+XLqO9PoKWEpWffwy3FPydRwjdaMnoOUAJBCpaSEf2WLb2hPCMlsQ0hmxAnOUjKwc5cq5SMrKe8QUqUk2vd0kUiTktYdM0gJAACAslNESu5ftozuG5m0hm+5UvLm6fWQEgAyqJSU8M/+spS4QtLoJblO12YiKdkxsFOV8uAk7H6iJDwepmQNY+JlPVSfUEOgdLKuehI4Gkl/kXUFeliVua5E1VNPKZdor4iElExTvccjJHKbaSKiXjc9Zvn3M/rCHafVan4cqcO37qITWkoev59uEetCSgAAALSTIlKydmg8cU+JLSWX6PT6Go2ew/AtANKolJTwc0giKREiYsmICiEkWkq2bd+hSnnIlWA7ybtMru1eg7gOnXhrg0gk+XnXFdJQM9rl26ZVzrwPxBQYLmpsU0+b7TBpmZQY9WfsJwsJr7t6vNFT8p17xbpNpWSK7r/zfvoeekoAAAC0mSJSMu650R33lABQjEpJyd69++RJm5ARcVJrIYmkZI76t21XpTw0S7C9y6NehijH5gRcCwGTNV1k3Yjpek+U0MswBcFcj9ujpn3tdebp4VuurEhaJiX59vN341zXIL2ZZ/iW21Pyox/R9752C6QEAABAWykiJcvWDtFkZk/JFbo6NUxr1ozSM5ASALxUSkpGRkdpTpy0rpBoGZFxbUY+x6Svv1+V8uEmzA6pUqLL5E/AC60r5cDooUnIglluflISlTN6MJg8UiJfm9t3cZenT89bSqYeoE+J43PL174HKQEAANBWikjJ0NpltLz3VLaUXJ2i0TUb6JG3ISUA+KiUlAyPjERSIuTD7BnR8YkQEg6Wki19W1UpP1FvhJNki0Q+EgJOoD3Dt+IkP38CXmhdRySiNuaQErnMHL6lxMMrJUy0fvpwM9/rPMcsZb8kjenk8K03aGe3aI+Wkle2021dt1H/i46UHF1BXZ/C8C0AAADtp4iU6F/fWtF3Bj0lAMyTSknJngeHxYl7MyEj18T2tJBoKdm0pU+VyoAlgJNzHWbvgUyijWVGcl4kAS+2rpIJtc2emkj4c0mJwNoXMZ9viE+VEobrE+vyOjmlRJJ6zNz2pU/LL1zuLYnr6aadO42ekjQp4XtKPhWVgZQAAABoJ8WkhO8pOUV9/JySrxymC757SmrDdE6sj3tKAPBTKSnZvWePLSWGiLhS0rt5syoFyob+wuUv33j4lvhS5i9n/pJOHb6FnwQGAAAQiOJSgie6A7AQKiUl9d27pXDkiQd6N6lSoGwUkZKLWz9LXZ/dQs9CSgAAAAQEUgJAWColJYP1Ifmkdn4wIj+HhH/2l39li29q53tIeMgW95CwkGzY2KtKgbKRS0pO36OGdn2Jvo6HJwIAAAgMpASAsFRKSkBnkEtK9PAtPNEdAADAIgApASAskBIQHEgJAACAsgMpASAskBIQHEgJAACAsgMpASAskBIQHEgJAACAsgMpASAskBIQHEgJAACAsgMpASAslZKSEydO0LHjx+no0aN05MgROnx4jA4dOkQPHTxIBw4coH3799PY2Jg8+UF5gZQAAAAoO5ASAMJSKSlhIeETVsdNmdQ24uTJk3Tp0iUpKhCT8gIpAQAAUHYgJQCEpVJSwj0kfMLKByTemKNZcSLPzopkVgVLyeXLl+WXAosJKCeQEgAAAGUHUgJAWColJTxkS0qJFhJLSmallAwMDMjgp78vaSZq1NVTp2k1WSZSpeTbq6jr9h30iisl57fQZ7o+Qw9MLYKU8HGsTagJAU93D3qO6zQNdvPDHpuEtyxoCe34zE/Xqaerh+p40xwmqNZVE/8C0LlASgAIS6WkhO8h4RM2KSSRlFy/PkszIubmbsqnvzeHL6xGwmgmn1XHStCmqd7D++hJruaVyC3suFVJSiZq3TToHJzpwW6PXLCU6CTNfG0mb+I1pESgP49mpCW4fPxySsGCpCRlO22TkgL7VYh21evC24GUgM6msJRMjtCXV6ygu7aflVLy6K57aOXKlbRq1SpavXo11dafpmmxPqQEAD+VkhIeksX3kSSFRIQSEi0lOwcHVakUOIERyZCVT4t5Pe2/mofBIyW1midpK5rIteC4FZaSRRu+JRIvlgi1z6khDwZ6SvKjPo/OZ4iPj89vp+s9+T5fRT/LDrm30yLatT1/vZ5jviAgJaDzKSYlx6h3+XLqO9PoKWEpWffwy3FPydRwjdaMnoOUAJBCpaSEf2WLb2hPCMlsQ0hmxAnOUjKwc5cq5YMvqK28QJcQK0HTCUn0v5WwFErkWnPcqiIlskdkATvL5Tv6MzZvUhJk2SvhSXR5fp7P6AKlJPd2WkW7tuetF1ICQFGKSMn9y5bRfSOT1vAtV0rePL0eUgJABpWSEv7ZX5YSV0gavSTX6dpMJCU7BnaqUh5yJS9RAt74K7d5AeZlPVSf4CQqWi4v9lyvmm4k/kXWFcjELJofrytR9dRTyiXaKyLeRyMhUfXH9SaORcZ+Nz1u+fa1ISXjtFrNjyN1+NY/0FEtJd/7WgApUcdBHaiJmvleKHi/VM+HFBh3X9KCK5oepO6u5NCwpUFagux+TvUwpLT1sz7zjL08Ol+iusxzh3sWonKe7ch2GOeA9/zMqlNOeMowvv3Kdw75ttk4P916neMUHyP3+LmSkbWclzWm5f6m1gNANSkiJWuHxhP3lNhScolOr6/R6DkM3wIgjUpJCT+HJJISISKWjKgQQqKlZNv2HaqUh1zJteeCH19s1cVa16ETBp0FWIlMkXVFMlEz2uXbplVOJ23RskYSwkWNbXK9RpISJRCqXutYNNlva10f+fZ1XH7hRkKy+myjp+Tbq8S6TaXkcfrasvZLCUtGd7fRU8IS4Qy94mPcbVmF2P+M4VmW2EBKrM9rhDHf+nwL+LNkFWj2meflRnmzbutz7LTF3U7e8zO1zowyjLs9tV/NzqHkNnkyYz+sNjHRdpp9x2UvV6+tYwRA51BESsY9N7rjnhIAilEpKdm7d588aRMyIk5qLSSRlMxR/7btqpQH52KewLvcvKi7CU/WdJF1I/x/dXTX4/aoaV97rXluQhJNy6TFXK/ZfnuXm+Tb18G3xBfuONc1SG/kGb7l9pQEGL41URPHnfc3Pmh8z4gpEbwvbiLG8/T75o/Ge7CUcT+PGuMzncA53r7PovtZ9hz/KMk2PpeJhNrZjifhbnp+5i7DONsz65FkTbuvs+p1jrn3XG52rpt1mPXza94vs50AVJ8iUrJs7RBNZvaUXKGrU8O0Zs0oPQMpAcBLpaRkZHSU5sRJ6wqJlhEZ12bkc0z6+vtVKR/mxdxD6gXZlwwwWdMF1pXJjPHXSSu5ccsZ7fG115rnJCSM2pZ183vh/XbJt68LkpLH76dbRLvbLSUSPh7GQZO9J9pKnGURYv/y9pQsaTyfR8b7+WvAxy8+N3zrmvNy1sWyYPUGCKztmOdg5vmZUmeTMoy1PXWOxJNNpvW2pPQ4B9Su1znm3uPT5DvFXC7bYe+H3gbkBHQKRaRkaO0yWt57KltKrk7R6JoN9MjbkBIAfFRKSoZHRiIpEfJh9ozo+EQICQdLyZa+raqUn+gvl87FU1yIo4s4X3DNC7rAukgXSRwKrOskAlEbc0iJXGYmeSo5iOuKpt0kMKrfXC+qJ32/dRmzHQLruKXsmySallKSGL71Og3cLtqipeSlbXRb12209aIjJQfvpK5bQtxTIuB9Nw+aMYTL91PB0f5xUpYecXUYvmV/HvlYm58Vmbw7nzOe53xW0z/z7nLehJFEy7pqVIvPIQNzO6ZEZJ6fAl+dzcowif1KnjOp03n3Q/xrH/Po+GR/xzVbrvZDbKfeOAje7xoAqkgRKdG/vrWi7wx6SgCYJ5WSkj0PDosT92ZCRq6J7Wkh0VKyaUufKpWBTISMpNHOkuRFubHcTCScxCBzusi6KrFS2+wRSVSunhLG2hcxn2+IT01INGp78XoMb6fRhkQCxaQet3z7GknJ7+i346uNerppYMDoKUmTEr6n5JbF6SmJ8dxfEiH2D/eU5MD+nMuwPoMCTqitzw5T5DMvkHU0tmG/laoNvvfX3I6sQ58Ddrvt85Px1dmsDGNsT50j7jmTPh19rhLHT2LWK6ZS/gih25Y817OW87LGtGyDXs97TAGoHsWkhO8pOUV9/JySrxymC757SmrDdE6sj3tKAPBTKSnZvWePLSWGiLhS0rt5syoFyob+wuUvX/4Sjodv8VA88SXNX9aLfU+JREmJlXD5orsmZMQzPy0yxAVkIxPrAElvvB1LStrHQvbLHqZlE+p4AdCJFJcSPNEdgIVQKSmp794thSNPPNC7SZUCZaOolJzf8lnq+swmmgotJaCE2H+hbx/Rduqc1Ht7IVrNPPerqTSFOl4AdB6QEgDCUikpGawPySe184MR+Tkk/LO//CtbfFM730PCQ7a4h4SFZMPGXlUKlI3cUvLNu1Xvwl10YlGe6A6WLPHQsPIm9LoHDx0hALQHSAkAYamUlIDOILeUiC9vOXxrkZ7oDgAAYOkCKQEgLJASEBxICQAAgLIDKQEgLJASEBxICQAAgLIDKQEgLJASEBxICQAAgLIDKQEgLJASEBxICQAAgLIDKQEgLJWSkhMnTtCx48fp6NGjdOTIETp8eIwOHTpEDx08SAcOHKB9+/fTsWPH5MkPygukBAAAQNmBlAAQlkpJCQsJn7A6bsqkthEnT56kS5cu0ZgQFohJeYGUAAAAKDuQEgDCUikp4R4SPmHlAxJvzNGsOJFnZ0Uyq4Kl5PLly/JL4dChw6oUKBuQEgAAAGUHUgJAWColJTxkS0qJFhJLSmallAwMDMjgp7+3FuPJyPIpyj1Ub/djnnk78dOkp6neE21/omZve5qfOi0f9KajRjX1YDUrrCdT20965jp6zEonava0D72OfNCc+ZC5tGPF+9BFtXFICQAAgHIDKQEgLJWSEr6HhE/YpJBEUnL9+izNiJibuymf/t5awkuJLQoNKUnbPq+f/nRn0X5roS0lDD8hWq7CkpHnMdGmuFhlWislX79LCNU/nICUAAAACEZhKZkcoS+vWEF3bT8rpeTRXffQypUradWqVbR69WqqrT9N02J9SAkAfiolJXxTO99HkhQSTmgjIdFSsnNwUJVqFckkvr242zOkhOFk3xIHsbxm9ITwcrNnREiDXp3lw+xBqdW4p8Oep6OnXhft8C/zRmQ1Kcdqnj0lX79L1P0PdBRSAkJzyy3iW1J8TSKi4OMBwBKhmJQco97ly6nvTKOnhKVk3cMvxz0lU8M1WjN6DlICQAriKtN62iUl/CtbfEN7QkhmG0IyI05wlpKBnbtUqVYRWEq458EabsWzeoRA2EO1zJ4Ka7iVIy3ukK+oB8OzP249WSTESNNiKfnw6/QPYl9XHIWUgMBwIg4a4HiAJUQRKbl/2TK6b2TSGr7lSsmbp9dDSgDIoFJSwj/7y1LiCkmjl0QktTORlOwY2KlKpcGJsye5l/iWGYm2ldCrRHvCLmPm6vY9H2ayntYGNV9IyYR7v4hXAqI2WPVYcsHLHUlg6QkhJb5jpaXkzUHq5jbf+10lJd+mlXo/RdzW/2J8T8mJfxDzVhyFlICwiM8hMMDxAEuIIlKydmg8cU+JLSWX6PT6Go2ew/AtANKolJTwc0giKREiYsmICiEkWkq2bd+hSvngpNnsOdBiwa8jIUgm5tmJtpXgmwm/ta5JehvkvSQ1IQdOT0niZnSN3J6qS0uFnNdI8HXo8o0hXFwu2md3XV2nLVXmMlHOaWNE9rGSUjIetXnXG7qn5Du0qut22vGq7il5ifpv66IvnVI3uj+7if68awUdlFLyPUgJCIP4rAMDHA+whCgiJeOeG91xTwkAxaiUlOzdu0+etAkZESe1FpJISuaof9t2VcpDVsLOy+aTaEcTiqTkxNKgyWjDRF1sn7fhtoPneXomJoTA8LAuWb+WEg/xjfCybiE4ch+M/WIyyst9sdrE+2mUjWlyrOQ9LDUaN4dvfefexLHg+OzWi+rXt56lB/68i+48KKTke1+DlIAwiM8gMMDxAEuIIlKybO0QTWb2lFyhq1PDtGbNKD0DKQHAS6WkZGR0lObESesKiZYRGddm5HNM+vr7VSkPqeIhaLmUaKJ5sZxktYHxSYnZBof4nhEpFZ6b00VddfXrWpGcpNRVSEp4dXc/mexj1SWFqIcG33Sk5PYBetV7T0n0k8BTD/w5dd15kL73tVsgJSAMSMJtcDzAEqKIlAytXUbLe09lS8nVKRpds4EeeRtSAoCPSknJ8MhIJCVCPsyeER2fCCHhYCnZ0rdVlfLBSbOdTHNvQzTpLpugepTtZyfaRmXRcKfGuvV4kSkrWW0QeKWE1zGGlhnr2FLilorQAiF7YuT2o+25v8ZlhdUGUcZtE8uV3om4PdnHSg7femtQzO+i1WfN4VtdtPKRhpR88+676ZQhJe9MPUCf6voU3XILpAQEQnwmgQGOB1hCFJES/etbK/rOoKcEgHlSKSnZ8+CwOHFvJmTkmtieFhItJZu29KlSKchkuZF8m3JgL9MJdZNEWw5JcstEWEm/uaFmbfBISdQOta4hBOY2/FJiChFj7I9Js54StQ0ZsrKGlDXueckhJeIL97e/HafVsq576TviS/n6awN0u1H/3d90H544Rfd/Siy7BcO3QCDE5xAY4HiAJUQxKeF7Sk5RHz+n5CuH6YLvnpLaMJ0T6+OeEgD8VEpKdu/ZY0uJISKulPRu3qxKtRs32W8RqVLCNORAbze1p4TFRa2b6PXIJSVKOmQdnvUluj2qDU3QX7j85RsP32Ip4aF4GcO38PBEEBzxuQYGOB5gCVFcSvBEdwAWQqWkpL57txSOPPFA7yZVqt20SUo6GEgJqAxIwm1wPMASAlICQFgqJSWD9SH5pHZ+MCI/h4R/9pd/ZYtvaud7SHjIFveQsJBs2NirSrUbSElRICWgMlQ+Cefvp3w9mLmAlIAlBKQEgLBUSkpAZ1BVKZke7C4mnzx0rnvQGDIHKkcnJOH8OUwdCtog/slwReMeMQNICVhCQEoACAukBAQHUgIionuR0n9YgWncP+W/pylPHfxWOL2Z+kcm1MzEL9DpJF68TkP+yp5VaSv2h0nWE/2in9G+tA+ieQ9Zk6hNmPeL5Qjepvi/2bEGoFOAlAAQFkgJCA6kZKmjk2F+6GdWksvrNRJ3KQ7xG5C3jghbSqKk33wveblZR7wtsZ4X64coWrE/DbSAuO1pto8S8ZnLs57bK8K483g6UZdoV0uHgwFQYiAlAIQFUgKCUwUpkQmjSMDyRPdgI0NjcYmnYymZpsFu3HfkI3eyzfDx9AxDylMHrxMdf39vhluHFAMuINb10ajPZsH7o2SHH3Rq1pO2vTR4fd9nlSN3+3yI8rLd+DCDJQCkBICwQEpAcKogJT6aJ4ac8BpDcmIpEUwPUre5TE53k+EzS5IiSXzaunnqiN67qEejeR3RevK95iQ8AS/39xYsbH8a2/W1pyEWacO+sol6YJyyehhbk4g/9+K1Fqd8ewlAdYGUABCWSknJiRMn6Njx43T06FE6cuQIHT48RocOHaKHDh6kAwcO0L79+2lsbEye/KC8VFNKot6OrL8QW70kjCklctIoDymRNE3ijaQ57dDnEQF57LmelGQ6Xq5DrydeJ3Hk02Ah+2OWzapHykVBKfAKiUuKbHBZS0oy9h+ATgJSAkBYKiUlLCR8wuq4KZPaRpw8eZIuXbokRQViUl4qKSVqyMpELUUkWDLc+0ccKYmSufTkeinSNIk3kOLgSZrz1MHr8HHPXQe/dyLx9kpJRk9BnrZorLbw9ow6s+vhz5Gvp8btUWkS7j7klpL0niIAOglICQBhqZSUcA8Jn7DyAYk35mhWnMizsyKZVcFScvnyZfmlwGICykn1pISTQCUjLB8eq/DKSkJKuHh3Yt5SpkgSn5aM56mD14neNpW4O+9hso5oW1ES7sLL5tlTYqH3J0MmvPLjPw6pKKFuSoqUTNSMbYk2RdtHTwnofCAlAISlUlLCQ7aklGghsaRkVkrJwMCADH76e2Hk0Ap9AQ594c2ZaFhtrCbVkhJ+X+zeDSkWeZI8j5TEYPiWJJHEm59vfm0c57RhS8WkhIneU/M9TNSR1VOSca5mtiXn/jB2PdMiyVEvBbwsrZyXBUmJ0yvCx0O+R5AS0PlASgAIS6WkhO8h4RM2KSSRlFy/PkszIubmbsqnv6fj+cskX4zNhEgmHnkuvMm68lz/k0BKSiclMjH1v58yMWz2+YCUNCWRxDuf7+heCH1u+Y93pggoeB37fVRiopLw6P00Q21LvPaRrC/Cvz+NdufZH8aux/mOKSIkzDykxDoeZlkxnbs+ACpOYSmZHKEvr1hBd20/K6Xk0V330MqVK2nVqlW0evVqqq0/TdNifUgJAH4qJSU8JIvvI0kKCSe0kZBoKdk5OKhK+Ygu8tnX1SJSYkhCbmlw25BTSjqAKkiJTMqaDbOSYuEkbfJ9bCR01o3voHpwEu7DSOAzWcQE3hSLXE3Is0+iLtxPApYKxaTkGPUuX059Zxo9JSwl6x5+Oe4pmRqu0ZrRc5ASAFKolJTwr2zxDe0JIZltCMmMOMFZSgZ27lKlfLRRSgSJv5Z6gZSUvqcEgDQpEchejybZPq+zSE7SHsTxaP7dBkBnUERK7l+2jO4bmbSGb7lS8ubp9ZASADKolJTwz/6ylLhC0uglEUntTCQlOwZ2qlI+UqTEGmrhSon9F3B7aEWGlMg63b9Y2nVFwzGUlNSjIUMyfNmM1UaBt35G76PaVtEhH20EUgIqgzh3gAGOB1hCFJGStUPjiXtKbCm5RKfX12j0HIZvAZBGpaSEn0MSSYkQEUtGVAgh0VKybfsOVcpHlLDHyb8IKRGpUqKEIc7qTalxpETWoafFspohA/IeBV2nWQej5EHPsOoxsNrYvP6sceuLBaQEVAYk4TY4HmAJUURKxj03uuOeEgCKUSkp2bt3nzxpEzIiTmotJJGUzFH/tu2qlA9XCBRpUiKTfVtiYpGJk38dSZHw39zqkxJXfJpJSUS++ssDpARUBnFOAQMcD7CEKCIly9YO0WRmT8kVujo1TGvWjNIzkBIAvFRKSkZGR2lOnLSukGgZkXFtRj7HpK+/X5XyMQ8pSR3+lCIPjKzPHcrVQikpVH95gJSAyoAk3AbHAywhikjJ0NpltLz3VLaUXJ2i0TUb6JG3ISUA+KiUlAyPjERSIuTD7BnR8YkQEg6Wki19W1UpHwWlRL6215+omcl/ipQ4MhP1aKRJQ4aUyHaZr1UdheovD5ASUBmQhNvgeIAlRBEp0b++taLvDHpKAJgnlZKSPQ8OixP3ZkJGrontaSHRUrJpS58q5aOolAjkMj1EyiybISVqO7pMjxCZRv1cpRp2Zd7oXkRKMutP2ccSACkBlUGcV8AAxwMsIYpJCd9Tcor6+DklXzlMF3z3lNSG6ZxYH/eUAOCnUlKye88eW0oMEXGlpHfzZlWqw7CkpJpASkBlQBJug+MBlhDFpQRPdAdgIVRKSuq7d0vhyBMP9G5SpToL2btSop/3nQ+QElAZkITb4HiAJQSkBICwVEpKButD8knt/GBEfg4J/+wv/8oW39TO95DwkC3uIWEh2bCxV5XqEOJfAKt2LwkDKQGVAUm4DY4HWEJASgAIS6WkBHQGkBJQGf7bf4sScUQUfDwAWCJASgAIi7jKtB5ICcgCUgIAAKDsQEoACAukBAQHUgIAAKDsQEoACAukBAQHUgIAAKDsQEoACAukBAQHUgIAAKDsQEoACEulpOTEiRN07PhxOnr0KB05coQOHx6jQ4cO0UMHD9KBAwdo3/79NDY2Jk9+UF4gJQAAAMoOpASAsFRKSlhI+ITVcVMmtY04efIkXbp0SYoKxKS8QEoAAACUHUgJAGGplJRwDwmfsPIBiTfmaFacyLOzIplVwVJy+fJl+aXAYgLKCaQEAABA2YGUABCWSkkJD9mSUqKFxJKSWSklAwMDMvjp76lM16mnq4fqVXosutXmCapV6SGKzvGGlAAAACg7kBIAwlIpKeF7SPiETQpJJCXXr8/SjIi5uZvy6e+pLGkp4bL8ZHiOrGNgrpe1rRzrQUoAAABUjMJSMjlCX16xgu7aflZKyaO77qGVK1fSqlWraPXq1VRbf5qmxfqQEgD8VEpKeEgW30eSFBJOaCMh0VKyc3BQlZoP01Tv6aLagroiFlpHVvn5SklUZ4+2g4laikjweo35EzUhHN6G5F3PBlICAACg7BSTkmPUu3w59Z1p9JSwlKx7+OW4p2RquEZrRs9BSgBIoVJSwr+yxTe0J4RktiEkM+IEZykZ2LlLlZoPCxUKZqF1ZJWfp5TIHguzXM42srz01MXaTci5HqQEAABA2SkiJfcvW0b3jUxaw7dcKXnz9HpICQAZVEpK+Gd/WUpcIWn0koikdiaSkh0DO1UpD4nk3MQcjiQiTrLt+bq3YbreY/U2RL0FtZQ6HNx2xNOeNljr2lIStUGvb9TnwtLgGAi3N+45SSHPOkzqes5+/u6tQTHd2L97v6ul5DXacXsXrfzWt+geXnZbP12ElACwAPgPDxUbqgpASSgiJWuHxhP3lNhScolOr6/R6DkM3wIgjUpJCT+HJJISISKWjKgQQqKlZNv2HaqUh0wpYdweBJYA88JuL4+TcaunIEcvRKqUyAm7fJqUNN2XBlJe8kqJrDeShub70GQ9Z78Ga4P0lu4pObtalL2XvmNISVfXSjpdup4S0e7ubhrMSO6mB7vlcciOtPeK6++i7owNcP16eda2Mt8vsPTI2YPJ3w/mZ4en8/wxAoBOpYiUjHtudMc9JQAUo1JSsnfvPnnSJmREnNRaSCIpmaP+bdtVKQ+JBF8ndFo8HCHgi7qR9OloXLB1Heni4t2OKxRO8p5LSuRrd9uMZ3sL6CnJk9SkrufsJ3/ZvjVo9u7YUrLyW2UcvpVPSiypmB6kbut4cx3qOKR8pnxhVpHYhgO/B85bXHKiz2n6Z9DzOY7JWmaTOC7yMynKqZnysxvXJSJnEp+8h2oB+6Pb5FvGWJ+ZxvlkUehzFX3H+JZ5Q+wrHyeIClgqFJGSZWuHaDKzp+QKXZ0apjVrRukZSAkAXiolJSOjozQnTlpXSLSMyLg2I59j0tffr0p5cJLkJB4pyUxSdKJhJhKulHhw22FN55USjU4wMpKzxH7kaKOEt5ed9EWkrGe2Xb4Wic3gW1FPyRu7qLsyUmIkaEaYvRdFpCRLLjRxMm3U5esl0XVVTUr00EN/oht9PuNlMuG2zw//siT2cYnOV/M4uck2TyeFw4A/x57vhPnvj9Mm91x1p9MQ6/m3beP2ijDuPJ5O1sX7kOe7AIDqU0RKhtYuo+W9p7Kl5OoUja7ZQI+8DSkBwEelpGR4ZCSSEiEfZs+Ijk+EkHCwlGzp26pKebASfB9usu5LYhrldUIjE5I4cXDr8CDb0bjARwmNnXTF5a02c3vUazG/Hm+j2Tad5WaiY7aFXxuVWPs13/V0e+U2G8O33tjFCXbn9JRoSUiPxucmhoXDem8976EjJdZycUwrKSX8uRCfl7ojBDHm50ZifH6zlnloHJfo+Lrbc6VEfpYzDqT3OC9kfxLSwcv0d4P5Oh/cPv/nL6VtReC2ZhwbADqFIlKif31rRd8Z9JQAME8qJSV7HhwWJ+7NhIxcE9vTQqKlZNOWPlXKQyI5SBIJgriIW0l248Kur8ny4h8nE1GSoS/YiTo8xOuI6BGiY7bLKm+12ZASnjITkGbJgrUfxjGQ8xuJj9muBa9ntV0k93yMVJnu1asr1FPSwuFbkihB7uoeTHw+9HsaFy8qJVJ0stu7uDQScm6zN1H2JL/xulnLPETHJdqmbx27bKNtfnyS0IL9SUiJfi/F+SOWsezo8yZtP7OIzlXz8yeQ52aj3rSwmq3aU7wFAFSLYlLC95Scoj5+TslXDtMF3z0ltWE6J9bHPSUA+KmUlOzes8eWEkNEXCnp3bxZlfJgJcmg7TjHW3/hyuFb4kuYv4z5S5m/nPlLmr+sSyElnCh6EjQzzGQtIQsZUsLJqLfXxILXV0OzHClx21E1KTET97QkXibR1vFrrJu1zAcvk8cqJZmOl+vITLrtPwow5rbT2pHZZiUH8WL12ZPT5mtGrlus58QrJC4pssFl7WYn9x+ATqS4lOCJ7gAshEpJSX33bikceeKB3k2qVBJ5gcZf+oLhHu8qSYnV8+HgSohPFpJhJHNSHHzr6DCkwpESK0k02slJrp1AlhBOso3PQ1oSL9dzdiZeN2uZB31c+H/fuZ8oy/WnJd5u8t6K/YkmGu+9qK9eU+Lh1M/4txH1rtifoYxwj0NuKfH1FAHQeUBKAAhLpaRksD4kn9TOD0bk55Dwz/7yr2zxTe18DwkP2eIeEhaSDRt7Vakkzf9CDVpCnGTZx7tTpYQTRSt5y+gp8ZGQDZOOkZKMxNlNiBPJuDGkKWuZh8ZxUdt3Vkwm+dwbkJZ4mz0FLdqfBMY2PLLgl5IUeLtpB8YkRUomtBzFoKcELA0gJQCEpVJSAjqDzpQSj3C0UUrcBDghJbx+qe8paWAl2JwYxzLgJO1WUp+1LElDShhOqsVxa8yw28BwfamJd5aweOqKyd9mu46onP8Y5YC3Y+xrKl4p4W0725Lbh5SAzgdSAkBYICUgOFWSEjf5d8NKMN0b1kP1lBhM1JSIdISU6Gl9vF3py1jmYEsJo8REJeG83Hxfi9fXILk/Rl2pbY7EQ28/KTWqvSpSPyc+5iEl1vFwy+atD4CKAykBICyQEhCcKklJ3p4Sb5KqRUIKgkrwtLjkEB4dst6E4BhYdWUn06BFGAl8JouYwJtikasJufbJ03MCQIcCKQEgLJASEJzKSAkAGcgfcGiS7SdvEq82Vi8QAB0OpASAsEBKQHAgJQAAAMoOpASAsFRKSn798t/Rr166g3714h30S44X7qCXv/v/0KZNm+SXAP//0rf/ij76z8/TL1/9R1UKlA1ICQAAgLIDKQEgLJWSEhYSunJMxFERY0SXD9OTj/wb/exnP5NfAm+88QY9+a0vE70/Qh8+/z9VKVA2ICUAAADKDqQEgLBUS0peZClpCAldPkhPnvlXmah+/vOfp1dffVVIyb8IKXmQPnwOUlJWICUAAADKDqQEgLBUSkp4yJYpJHT5ISElX5E9JCwkL7zwgpCSfyb6xW66kiUl8mc5K/YLMlabq/3wsgVJyeP30y1dt0BKAAAAtBVICQBhqZaUvCCkxBAS+mC/kJL/EwvJ888/T0+evk9IyRBdefZvVCkPkJJFBVICAACg7BSWkskR+vKKFXTX9rNSSh7ddQ+tXLmSVq1aRatXr6ba+tM0LdaHlADgp1JS8vHFv7WEhD7YJ+8h0ULy9NNPCyn5JyElg3T5mQwpaYrz5OV5sdA6ssqXVUry7fOCpATDtwAAAASgmJQco97ly6nvTKOnhKVk3cMvxz0lU8M1WjN6DlICQAoVlJKGkND7o/IeEhaSW2+9lZ544gkhJf9I9N4uSMmiACkBAADQGRSRkvuXLaP7Riat4VuulLx5ej2kBIAMqiUlF4SUGELCv7LF95BwDwkLyfe//30hJWuFlAzQ5XOfU6U8yKFQaUk9J/yNJyF3xU84tufrB4jJB6gZdcmnKNdqKXU4uO2Ipz1tsNa1pSRqg17fqC8Bl+uh+gTXFa0vBcJ4Irj1YDS5TV2vLRvJbeY/btEX7ls0KARm9dmzdC8v695JrxlS8tK22xp16VhxVA3fWgYpAQAA0FaKSMnaofHEPSW2lFyi0+trNHoOw7cASKNSUnL1/OctIeFf2frxfz5A+/btk7H87/47/fj5f6ffvbuVPnj6c/S7uf9SJR0ypYRx/+Kvkvk4X7eXx0855uQ+TsZz9BqkSomcsMunSUnTfTFRgqDbqGVEb8Tdfs2QKblus23mPG7jDSnp6lpN323WU/L1u6jrM5toKr6nBFICAACgvRSRknHPje64pwSAYlRPSgwh4V/Z4pvav/q/P0NHjhyRv3JB7+2gjy/cSR8+9/f08av/qko6JBJ89Zf4OIF2kmujJ8GMRq+CriNdXLzbcZN7VwrM8ok2u+03t8349ovnmes1m+bN+nph0raZ87gNvhVLyeqzTYZvXdxKn+26i05YN7pDSgAAALSXIlKybO0QTWb2lFyhq1PDtGbNKD0DKQHAS6WkhJ/U7goJ39R+4cIFGV9d8+dEP98me0lu/nSj/N9L6l/6NZ7kOm0IlsSXpLtS4qElUqKJ1k+KgkkzCTGm5fYM8fIeM3eb+Y5b9IWbR0q+SV/q+ixtOe/++hakBAAAQHspIiVDa5fR8t5T2VJydYpG12ygR96GlADgo1pSwk9pd4SEb2pnGYl7Sn7eT+9P/Y/G/z68CbaJKxSRdJiCMVFrlNfDt2SvQuHhWw0piHoldL1O+TQpEfPr8TaabbOAlDhCYbUtdZv5jtt4mpS8NkC3d91O219hKXmJ+m/roi+d8v0kMKQEAABAeykiJfrXt1b0nUFPCQDzpFJS8iFLiSMkfFO71VPybh+9/0MhI/p/H02lRCfhXY3EXJbhXoEodKItb2x3RETfo5Gow0O8jogekbCb7bLKp0kJT3EbVB3x/SFeCkiJ3peUtqVtM89xS+0pMaTk9D2NMnHgRncAAACBKCYlfE/JKerj55R85TBd8N1TUhumc2J93FMCgJ9qSQk/pd0REr6HxOopeXcL/eKHLCXqfx85pAS0D/2Fy1++/CUcS0li+BZ+EhgAAMDiUFxK8ER3ABZCpaTkipQSW0j4HhL+Ajh//jxNTk4KGdlEv3iKpUT970H+NT+j9wK0F0gJAACAsgMpASAs1ZKSZ/9GPhRRxrnPyRvZOfbu3Us7d+6kjRs3ShF576m/lv+/f+5/qZI2jfs2wGIAKQEAAFB2ICUAhKVSUgI6A0gJAACAsgMpASAskBIQHEgJAACAsgMpASAskBIQnCpIydjYGAKBQCAqHAsFUgJAWCAlIDhVkBIAAABLG0gJAGGBlIDgQEoAAACUHUgJAGGplJScOHGCjh0/TkePHpXPJTl8eIwOHTpEDx08SAcOHKB9+/fLLls++UF5gZQAAAAoO5ASAMJSKSlhIeETVsdNmdQ24uTJk3Tp0iUpKhCT8gIpAQAAUHYgJQCEpVJSwj0kfMLekEnsHM2KE3l2ViSzKlhKLl++LL8UWExAOYGUAAAAKDuQEgDCUikp4SFbUkq0kFhSMiulZGBgQEZ9925VarGZoJp+WON0nXq6eqie61Hy01Tv6aLaYj7lcaK2sCffW/vbOA6WlLyxi7q7umnn65ASAAAA5QFSAkBYKiUlfA8Jn7BJIYmk5Pr1WZoRMTd3kwbrQ6pUGpwkd1GXioUn/3Z9XXGFnSIlvB+etvM+pYkLpAQAAEBFKSwlkyP05RUr6K7tZ6WUPLrrHlq5ciWtWrWKVq9eTbX1p2larA8pAcBPpaSEh2TxfSRJIeGENhISLSU7BwdVKR+RQDQSfhYAJQ7zgZN3V2zEvB6ZjRtSUogqSklWm1OkBMO3AAAAlJBiUnKMepcvp74zjZ4SlpJ1D78c95RMDddozeg5SAkAKVRKSvhXtviG9oSQzDaEZEac4CwlAzt3qVIesv66XxhXcFwgJRGQEgAAANWhiJTcv2wZ3TcyaQ3fcqXkzdPrISUAZFApKeGf/WUpcYWk0UsiktqZSEp2DOxUpXykiUSUVEc9HAojMZ+u9zSGZ2nRsBJ3H4aUyOFMWlB0Ah+1RdfbaFOz5Yy9LG6TRm7PV9ap2xKPxvoyckuJU5bnWfvLy6PXlpTI4Vv30ne0lLy6g2436vnSKS0lz9IDf95FdwoxXSbmQ0oAAAC0kyJSsnZoPHFPiS0ll+j0+hqNnsPwLQDSqJSU8HNIIikRImLJiAohJFpKtm3foUqlwDIhE18nkXckY6KmknkrwTZYoJRY25dtyrs8koCEQJnla0a7mtWt6jOlh/c9v5TICSU7ciJaZrU3ep0uJa/RjpU76BXdU/LNu0Ubv0RfN6Skq+tO2oueEgAAAG2miJSMe250xz0lABSjUlKyd+8+edImZESc1FpIIimZo/5t21WpbOLejziTNpPvRiIdveak2EnMFyglpgTY85os9243Wcbbu+Or21efNc88LgYtlRLx/okv6Ve232602ZaSOw9i+BYAAID2U0RKlq0dosnMnpIrdHVqmNasGaVnICUAeKmUlIyMjtKcOGldIdEyIuPajHyOSV9/vyqVh0g4dDLNiTz3QMiE3srcmSjxbshJSrIeE1pKVFvktoyelGbbbiolvvYIstYpKiWvDcihW7dvfyXqKXmxnz4LKQEAALAIFJGSobXLaHnvqWwpuTpFo2s20CNvQ0oA8FEpKRkeGYmkRMiH2TOi4xMhJBwsJVv6tqpSHjhZtjNyWyx4eU+NajrBV/PqcRE7+Y56IxwxEcl64te3PGJgSk9UT97lXG/6/S+uZPjqtg6Bqq8xT20/tQ7GbYNTb5qUvDUo5vfQ4JuOlHx7FXXd3hi+9WL/bWJ7kBIAAADhKSIl+te3VvSdQU8JAPOkUlKy58FhceLeTMjINbE9LSRaSjZt6VOl/EQJNvd4RGEn6JzT2wk5I+fpMskCVn32cDCVmHukpFYzy5kJf7PlTCQFWeX1sh5RT2ZPCWPtg5Csui02jHUMuF7LxHgX1XHlckWlhO8pub1R9213342eEgAAAItCMSnhe0pOUR8/p+Qrh+mC756S2jCdE+vjnhIA/FRKSnbv2WNLiSEirpT0bt6sSs0PTr7dhLu1pIjBEkB/4SaGb/FQPPElzV/WcviW+PLGTwIDAABYDIpLCZ7oDsBCqJSU1HfvlsKRJx7o3aRKzQPrL/ztAlLCX75v7Oqmru5d9DqkBAAAQImAlAAQlkpJyWB9SD6pnR+MyM8h4Z/95V/Z4pva+R4SHrLFPSQsJBs29qpSxdDDk9ovC0tcSsb1ULHV9F0WSUgJAACAEgEpASAslZIS0BnoL1w5fEt8CfOXcedKyQTVuget+3IAAACUH0gJAGGBlIDgVE1KZO+ZVyymabA7GuZn/QCAWHdisLsxbUT3YF494bq7yVx9WtSpy/NrX/0cS7H3LRf8Qw4tOTj2j0gko0VDP+UwUl/9Oto9xBSApQ2kBICwQEpAcColJZzIKsmIhSJObhtSojHFIcLoKRHlrDrMBDORLCelhEnWb8NyVAkpsfbf+TltPmapy5hoeeKHKJwk3j4OzUQiCi7j/jKfuSyC6/K1i+FlriyY+5O1zKmT9yf1zfRtZz4kj2Xz/Tdp9l4xKe9XTPrxSbQl9XgA0HogJQCEBVICglMdKRHJUtxDYkhCmpTwfLm+mWR5gtdxBaVWSy/D608PUrdKyHy9JLquakiJOD7mT01LQdHHMZKHOIH1LOPpmthPO8mNjnm871Y5gZi2188SC4fED19klXVlwZ6WPWpxI6P98e+roK1SEm3bfywdEvuvadJ+hRYL/zayjk80ndk2ANoIpASAsEBKQHCqISWc5DoJFosBz+PkSyZOppR41peI+Sk9JbaUuCWdnhJHSqzVjboq01NiwcdOJfleAUjuUzJZdY+/UWdiGcP15pOS5DHVCX1a+D4HCn6vtZA129e2SkmDZol/6mcqz3vF64j9rTfZRox5fORkyrYBCACkBICwQEpAcKogJRM1kfiLcBPObiEK8oGWMlMypISTKb2ekJCm95SY63NwfYZcRHUvQEqkQCWHf5USeSyM42jtXLRPbkLrm8d/kY/nGfXw/NpEM5Hg8EgK12P26ki4rrw9JTZWu5vtq0z6fe3UEUBK3P2XbVL73vS9akhKcr/8x89XvtX7C0BeICUAhAVSAoJTBSlh3OQ/no6TMWf4lsToGZG40wpRh6+nhGUomp0tJXZy6hm+VRUpUYm32jUpENmJboRvnnv/gb3clYUssdA0kmqbrLLudgSGXJh1Nd1XLpfcuMKznXniO5YRnv03hKJZ+9Nem3U0ppPHx0VuLyGIALQPSAkAYYGUgOBUVUo4sZLTHimJ11XywOuaCXIcKUO54uQulo8F9pRUgEginOTePBYKK6FVJOa5iS7LoDjejarcJD5LLBSyTl/iHyXr3vdXRrosyM+FTqyb7StvP/XNDCAlqfuvyGo/L3OGYXm34WAdnwTmkDwA2g+kBICwQEpAcKolJSwHTrIZJ2NGTwlLgxq2ZedpxXpKGnS2lMjk09dQJ5nl4+DrrXCT3PS/2k82EQgnciXSnBynJevNZMFIrJvt6yJLSfr+K1LbH/3f7Pj6yRIPSAkIC6QEgLBASkBwqiUlakLiiIKcbiSGnMRF4sLJk5OMGSHr5ITOnJ9IPrOlxCorolLDtzL/Au8k5onENyKRMMs6zYQ1eg8ShzWGt5OV4GYkwNym1IodWXDEwh6C1GRf5yElTUXCg79Myv5bxznfe8VY2zDraHJ8RG4Xw3Wk1Q9AO4CUABAWSAkITnWlRCRqVq+HT0pEWOu4ZRQigWtZT4lBfE9KmaWE99cQKh3xPsmkVc/3y4s3kXbqTTtGEU2kRLbBt+0MWZHwcrtcNEwtZX+y9tVa5gu3fU32KQXvsUzbfznf2EZW+w1SpUROph2fSHriZRASEBhICQBhgZSA4FRFSnzJsxQJmfCreUo4OOnSkuHrybAiI1u2ypoyY0hJAqud6YkhMJlfAs/HOtmrIGozE+tsG8oPJ++pdXH73fdaCBESdwBaBqQEgLBASkBwKiMlAAAAliyQEgDCAikBwYGUAAAAKDuQEgDCAikBwYGUAAAAKDuQEgDCAikBwYGUAAAAKDuQEgDCAikBwYGUAAAAKDuQEgDCAikBwYGUAAAAKDuQEgDCAikBwYGUAAAAKDuQEgDCAikBwYGUAAAAKDuQEgDCAikBwYGUAAAAKDuQEgDCAikBwYGUAAAAKDuQEgDCAikBwYGUAAAAKDuQEgDCAikBwYGUAAAAKDuQEgDCAikBwYGUAAAAKDuQEgDCAikBwYGUAAAAKDuQEgDCAikBwYGUAAAAKDuQEgDCAikBwYGUAAAAKDuQEgBCQvT/Aw4YHrxBl7FxAAAAAElFTkSuQmCC" alt="图片描述"></p><p>可见该文件总共有<code>1345</code>个字节。</p><p>3、查看通过三种方法获取的结果：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">文件CodeFormat.jar的大小是：<span class="number">1345</span>(Byte)=<span class="number">1</span>(KB)</span><br><span class="line">文件CodeFormat.jar的大小是：<span class="number">1345</span>(Byte)=<span class="number">1</span>(KB)</span><br><span class="line">最大的<span class="keyword">int</span>值=<span class="number">2147483647</span></span><br><span class="line">文件CodeFormat.jar的大小是：<span class="number">1345</span>(Byte)=<span class="number">1</span>KB</span><br></pre></td></tr></table></figure><p></p><h2 id="java获取文件大小总结"><a href="#java获取文件大小总结" class="headerlink" title="java获取文件大小总结"></a>java获取文件大小总结</h2><p>1、三种方法获取小文件(小于int能表示的最大范围:2147483647(Byte)=2097151(KB))时结果一样。<br>2、获取大文件时，为避免文件长度大于方法返回值类型的最大值，<strong>尽量使用File.length()或FileChannel.size()方法获取；</strong><br>最大的long值=9223372036854775807，9223372036854775807(Byte)转换为<code>TB</code>大小如下图，我想没有这么大的文件吧。使用long表示绝对是够了。<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAxQAAAEaCAYAAACIFhHIAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAEEASURBVHhe7Z3NchxZep55B5qr0NJyRN8JI3AL3iAQYS69Q4QDW2rjwA5aekFE2CHLUNiWZcmW4BlOc0iCI7IpcWbYIKenSTbAHg67zWE3yPT5zk/m+flOZlVWFlGoep7ot4nKPHn+MivzfSuzgGvff/99gxBCCCGEEEJjRKBACCGEEEIIjRaBAiGEEEIIITRaBAqEEEIIIYTQaBEoEEIIIYQQQqNFoEAIIYQQQgiN1pULFLdufNZ8dv1mc1tZhxBCG6FbN5rPPrve3LytrPv+dnPzujlP3rilrEMIIYSmVz1Q3L7ZXP/ss+b6zdv6+l7dam6o26YXOhsOPrvR3ErK9Ol2c/vWuH7dvnm9py3Xr1Fj7b2wz6PanCGERsuex/ren+69f+OWts6rr4553v9T1TMUGAbHjBBCCE2ra9pCkTPg4y5KdfOuXAjthXTggp6pPxxoKtu1dbR3Oq5uoEj3k6tj1js4btv55j6WC4TrYFz88aEeU35Oo3kK81ZopnkPbc1Y3gd7KZ/sp2h5qhH7Q61LqWd0m9GY+xTmw58TSmX7x5frfc9Imb55nsV8V8uU55VeTVVPdX6MTB3V49NqnvMmQgghNJuuyf9mutj3Kr5IOgNWM6nWhPZdOKumZR5lF21fZ9en/ALuXl+5QOGNRTeuKQLF7OZmOYFiTnM1iXybhdkKy9M50uctBI8hw+brvH49OyZ1xeYwKRveJ9k8uX0yXK9TGF/d5CbH4yRtisIcVI5TNSjofXXzUz8GpW+DgWNon9WCwICxT8qKJqknOr/KdsUcynrfhq23PjcIIYTQVLqmLRy6SPfJmotwkZMLaHbBs+tv3PTmIFNx8VRMjaKkTUV2PMn66KJsX8/WjqrJLtquT7P3wRusZM68qe2Zi0FVTKMmZyQnNixztD+dgllNjaUbX7lP9EBh5I1hv7Hu2roxcNy2x+kNpd7qPPljYHD+fD/mOVYWbjNooG0/j8V7wbefLlfeB6GfFd245fvbo3Ku8+Nc6lCO/b5jYIJ63PkzjLWcd3tsRq+X8h5FCCGEMl0rF9bMgVvea5ayC6ZczK4bM6Re3Iv6dZVhIJczFHUjrqz3F+tBzWK2bF3zX7BrIaftp2o+InnTlO4Pv+/mMYm5fL2z7J91DhQhNGjH1VCgqB+LoqitgWPHtRPKZe1V52m2Y8DVPee+W7DNTn4OauVr81hrvzaPsry3T64f1XNaaC+RHCPKOcUqew8HTVpPd4xamTFeN/MRxnjrRj4Ppg1zDr415XsUIYQQynQtX1A3Gu4iVw8U2cVRu/gZ2frnMbyVetL1PcaoMCfaRbx2YRd5s7SQ8v5rhiFbFkxIxVi3ZjNZ7vtq5zfvdzlHro6wT90cdOWD6nMfBwr3c6dkbDWDKGrH+eeztR/Kt9L3fRhbUP24FYWx+7Z8f/vnvqzTLe85Fq3itvzPajvRMen7k7RXOz78cnWuW/ljozK+qhZqM5Yf97yBQpsHK+395D/QMMvsflHbku2G9peRHV9XTq+vb196TVVP8d6eQbW5RgghhCbQtXSBfmGO19WNWXmR08rWL+41RcZKWW+NbLU+f3E2fWm3zy7qcblaG31yJrJvXhRZY5T3oZz7et010xHvg7j+MA9pm2r9NdOoKA4RWr+7Zb5fyn5yZaN+9bWvGM041KTL0iBySz6ljV6nCvNjyoT2e45Rdd5qJrhQ1JZ57epS+hYfI5qRVuepPs+JZu5rpkXaTOTnoLaN1r/e41J7P0i/3PzZOdbasu30HRdetu1wjMXvsQHlbU5Vj9921nNOdfwIIYTQRLoWv9CMWKfZL2L2AqZe+I28WdCVGsOgquka6lPUVjAnegBxhmRug2UUTPXs22rmR+TGktbjTUfFUJRt+vJG5ZyUdbl5ncWo6gpj18q6dd3+VNvSjGW1fd//2vJQxxz97+T7IdtZ9ZvMMJZCxX7SFNrybfj+pvsymxd/HKv7qZD+Hoql74sZtECbqZT9Hqt6jqjvl+J9LXX413a87bp8X9cUtWXHHY/R1RHvM2k/fp226TVVPdH7fGYVdSCEEELT6Vr7IlzE44twflFSlZsJudjFF/7KxW+E4UtNl2IiErl2r9+8FW0rjz/cUIyUXv+wInMy6wW7MBVBob9pH1Tz541dOQ4/15W+OJPf7Zu+umfZP66+ipnMTbBWrzaOSvuur1pbYR+kBn0+AxXquN5c9/uz71hQ5y06Fsr9Eivrr1FxHOfz0hco1Hkql8fS+y9S3qvK/hrTZio/B7V95Mervt+V5SLXhzCnrv5Qzq4r2nJl+veVlx339ebGjVBPWr9I+ha/Vtucqh6/n2bqu5FeB0IIITSdrrkfIiNRvfDMdhGTC2J/mfkuhq0yU5UaCEVy8a5ctEvNUkaR7ZMxufaP7VWMdabCPLZy81L2we+beBtv7Mo5VMpGcoas66ebw6yeimnUlNeXqDCFbo7LQJPtw0r7rq0+pWYyLJ9tn8Z983NoVDtG1Xmz6p9/p3Ie8mPbjbW+3qpnP/XuF5FWXyE/lrj+RdpM5OegNk/FsROkzJ1Xeix1+1CTHbcdyyz97erKj+W4fzL++LXtTzK+qeoR9Y9PVe8xiRBCCC2ma/I/awbMBeeWevEKchexPhMSjFaiwnyUF9HUDNTlyhkTcFMMx3zmxbU3/4W4b7xh3kJo0YxWIm/I9Dpd3+J5CQrz2m5XrcePr7IPc9NX1CvqMY258voSaaYwMbKVOau039tWoXI/a/PayfclHIOhD5X21Hnzcv3sO5aztqzi/aYcB3MGisHAMNM+9n2KyyzSZiI/B7VzjXbseLXngGy/uOX6vNt1eVvSRq39INsPU6cdd9ym63/Xv/x11uZU9bRy+2a2ua7VgRBCCE2na/K/8FuU+i88wxcxZ6Z0IxDLlrPteGMxrxEx5We/QJYX6VKzlMmUGyj7us/w+r5XTZxiJLN13ZhrZfNyscLcdabL7u94DKKZzKZTn8lX6w79k7pr81VpX69vSL49r/q25dyE/auZ1L6+jAsUoU7/OEw+L/mxJlrI3Ot9SBXtq7BsoTZj+fZr72Ffl/ZeCPOUHzfdOSVdLrLbyLqo3rAPdWX1R0GgfztNUV1T1ZMd1zOpNtcIIYTQBLoWv2gvvNGyTu4iNpthGJC/sM93oYtMUDA2+YVflduuPyzMUiaSbz8v32dq3Pz19dfNb60Prm4Zu7z2c1EYu2A0lHYUMxhMTbpPfR2aaczkzLPW52hfJcs7w13/o26V9pX+zyp9nLH0/ramL+tnvT7f995jujI37TGtbK+Z9Z75cHM88N4YnE9lPyzaZis/B7V5qgaK2nHll+f9is8zlX6n6jv2esYW2hmqf6p6YtltyveZqP98jhBCCE2na/GL/guQu9jOEihaI2bVY5ziC6dfXtYfTETFwGttJHLb14y60yxlgiqmw8r3ddRF3NU7Wx86Y56O2/etmJOwPC2vG+Mw3/p+i/vXzX9aR1iuHivR/tePpUr7RqFe7Tho65L6s32Tz5Ubd2zshtuM93f/vKWGcfa2wnJlXrzRTJaHeczGGvqWzJG2fbRcG7dqbudpUzleOvmxzhko6sdV9t7J+m77l7Xl+hyNu6+/dl0tCHRtJ8ehpkXrCfO/kGrtI4QQQuN1LX6hXXg7uQte/YIZTKt+UW6NWVifmZnaBV7K9F6kjeK6y7LOvKhGodUsZYw0k1UozINi0vrUZ2g0+b6k4/Vtyz5s59dL2a/BCBZzlhgXPw5bX2pG3LzLsm7fO/WZlpqhjqS1H5SPyyjvfxhXq2zstt/Jsr4+hXXdNkX9Qcocz9WWHVtteTbOqrks5754b2WK3z+x+o+LWMr+Vo6XTn4OlPmyUvaxU2UMvW358Wdt3TbHbLtfvYrxBtlxa/X74749H7hxLb2eSNrYZlmHEEIITalr8YtwAbJfzo4utMMaMA5SRjXhqRG1Zro1LXUDVFVrROL+uD4sFii6ccxykRe1Jq0aPnITbjTXxd/3qTfcTKfSGI+VG/fMwWlyfcr2L3usok97nARNd7wMaXh8/ca6e29XzzlFEOg7H/h1WntT1ePlzjG1cy+BAiGE0KfTtfjFel6A3IV5dKAIAWfUvITQUL/oLyTtk+ulaJY5nE32GFvWfMyi6qfES9CnbKsqdwwu/xiJNd3xMqiBuxOi2c5rioGP75TY5b7MLPMZzhsSUqaqxy8LH1YMzS+BAiGE0KfSNW0hujoa+pRyGk1lSlfgE3tr7kbc/RqjT9lWTZcSaj5RiPFG/VKPJ4QQQggRKNAnUPspK+YPIYQQQmjdRKBACCGEEEIIjRaBAiGEEEIIITRaBAqEEEIIIYTQaBEoEEIIIYQQQqNFoEAIIYQQQgiNFoECIYQQQgghNFoECoQQQgghhNBoKYHC/RXX2f4olfwBq/QPd9m/znrjVve3B3r/Uuvsf1FX/oBb0SdpY8a/BKtuPyT5w1mD9Zdz0L9c64vMw2X/RWW0TpL3ofa+qi1X30ty/Mt7OV6GEEIIIZSpDBQ2CMz2133FnBQmfW4TIsZ7yEzH5jwy36sQKGrj7ZmHoi9S1v/ht6BqyBrcPzJXs4+1DYDKusuRFjLdmMK+kPlL56vn+AlzWx1jWrcsm6v+ILtf4m3SfTRznUU9kWwffX+L5XE9tYDaE1yL95LbD0k7M54XEEIIIbRZuib/KwzKgKxZFQPiTdqtG5FJsUb6ZmpGxKgopnlIrSmOzXlsfAoTVNfkgaJi/G7c1JfberJtnGk2BjExu2IYewysrWOOQGHL1+tbLFBkbU2iPFB4Yxv10Zrz6LUdQ21O2uOuMgdm/XVjsuP9PFf9Rm59Xr/MTbfNvHVaqcdfPufp/JTBxcjUcVNbbiT1pNu4Pt2+eSMZz2LHCUIIIYTWWdfSBQNmNtKtG94MiWHNA4Q3Ktp2vZ+SSvuFgUoNpjNiaVud6gZNTNOw8XVtteUiQyfbl3cNpLzWZm25U9eXvJy8Hpj/wUCR6YoHCmt2s2PCLov73DcnNlDcMKGttv/M3Bjz3BcoeusfmN+gueoMmilQKPtQQlIx1p7lIulPaCsvJ/0YfYwghBBCaN11LX5RmsuKMbZmSAy8KFsfG5OKpB3VhGqGR8yMacctzwKP2pYzXGnQ6FPU/7w+aTu8tmPOjKPvr4zH9c+ZYb2dzgS2gcKPrSZ1jmw/TJ/tv6Fs3K/IcOb1K/sl7HP7b17Ot5H2w9f/53H7omgek3bTOYvbKfa1VRcoXNny+MvNeWHWY9m+hPnK6pJ1Mtbwr18+T/29bUeaq89BWb+c8kCRvw7vWVnux5vsj0zxvrY/9x/DZX8QQgghtOm61r7QDFctUAQZo1KYXmtMzPLElGRGvDUv0TLbVlbOmiITPm54w27aS0yoWo8uMXBFXzMVZXqNZtffLlC4cvK6ry1bj5kXKROXrf2cyO4ns33ULynbGe/MYNry+bx2ctvG5t4bSj/Owvgmc5KbWb8+bs++jo1tdzzdvnlTObZc+/YxpOJ4dArz16n/GHXrfb3RfpJ6wnFV7OeZ6nd1qvsp01x9Dsr65eTmPKkr3z/2dRQownZFXZGS4youW/sZIYQQQsjpmvshMpHBWFSUGM+bwcj47aNyQyarNXP+tTW2sTESmb7cMGVkXVw2Xj9boBBzZfqV1x9Lq6swdFJPMMu+zkSyTuaiYuCjuQ3zEwcHmRNteSJbR16/64srH/9spJbvZOddG3cwo/HPRul+y9pSTHsyZ7auel+c/LFk5lDmStvv1pznJrpWbz6WMFY7L8pyo9nrd31N9pMt6/ZxvM1cfQ7K+uWUz7mv25ez+7Nt30valboqx7/dXsq1bZk24nnSliOEEEIIeV2T/7WGojAcYpjiTzk7tdtYxWVSQy3l1DCQG80eoxIChWqWMiXmLts++fJ4Julnsa3SL82Ah/rda2f4ir5Fcxu3JduGn2vLE8VGuFVsbDPDOUugyPd70kZUd9F21pYvW4w9KmPby5alcnXY+bSmuyxnj72sz9XjzNYR+tz1Nxl3tp/nqb/abnx8+3Iz9zlIfV/kcx6W5ftYlnX7Kp73TtE2teBQW44QQggh5HVN/mcNg5iX3Fhac5eb17C8NEhBzijd6i3j5MxRGkhKiRlSjVdidiqKTXCtvCzX+lk1dKl56zfJZXmZHylnTWZr7nQV447H0ypuw81p2w9bPjebnRJjHZSNO5Qpy2ZtxWGgLVORtKH2K63DzW05f2k/etq17WTG+saNdJ9k412k/k7pfp+rzqCsX075nBup+9iVs8eRcswX+zK8N2xdfruq+t+vCCGEENosXWtfiHlJDI9ITM+AefAGJDE41mR1y4KBbtdbOUP1Wft9i3o7Yn5U4xVMUL48SDFa1kj1bRNLNXRemfHq+hcbxdRUBqnzYcdy3T7ilSzPFdqN9pU1q20/M8OpzEEsZ9jj/rjt0/l245D+aaY1HourL96XpozvW/qrSF2dZb9Ko23HF9VZmHN7vFXGaNdF/QnzF+/XbD/PVb9R3j+ndHzz1mmV9cupnHNbty/n+hIU9SmahyJMiOzxl7fl6pPl6dgQQgghhDpda1+I4chNRl+gqBkzu8yHBLsuM45hu9xM1ZYbjQkUuslzKk20LtV4KUr7d7u5fduZPjsXyvbSt8IQxmYvG1PSDztPpmyYa6t4nBXDKeV8vdYk+v6Gutsyokqf836J7PZZH7pl6fLQt7CunbMwJlumDBRhWTg2kr5apcdMPL7YSMfrk30vZaKxzVW/Vzpmr2gex9SZ98spnUMrZb+4ctE+uR0/Mli+x4r3kn8/uj6VxxRCCCGEUNC19oWYF+XvSWhyvzI0MmnB3CZGNJhAvzyUUc1PrG67YGDECBVmS6QFisQIRcsLhXZSsxm2t32N+tCnav9CG2Fe2rqlzc4YFm205cT4uTqmM3PSrmIoe+X6MDyn42SNrhJixmnM+ObRMupfVp3ZsR1k34tdeyHsyP5tQ4fyPm1D0WT7CiGEEELroGvaQrRK6jGGY6SFsCFZAzphHzKJUZ0sMI0Z3zxaRv3L7jNCCCGE0BJFoEA9kjAT7pRo6xFCCCGE0KaLQIEQQgghhBAaLQIFQgghhBBCaLQIFAghhBBCCKHRIlAghBBCCCGERotAgRBCCCGEEBotAgVCCCGEEEJotAgUCCGEEEIIodEiUCCEEEIIIYRGi0CBEEIIIYQQGi0CBUIIIYQQQmi0CBQIIYQQQgih0br261//ukEIIYQQQgihMbrWAAAAAAAAjIRAAQAAAAAAoyFQAAAAAADAaAgUAAAAAAAwGgIFAAAAAACMhkABAAAAAACjIVAAAAAAAMBoCBQAAAAAADAaAgUAAAAAAIyGQAEAAAAAAKMhUAAAAAAAwGgIFAAAAAAAMBoCBQAAAAAAjIZAAQAAAAAAoyFQAAAAAADAaAgUAACwdC4uLppnz541jx49au7cuYMQQugSdf/+/ebJkyfNu3fv/Fl6MQgUAACwVCRMPHjwoHn+/Hnz8uXL5uzsDCGE1l5i3F+/fr2SevXqVfP06dPm7t27k4QKAgUAACwVuWidnp7ai9aHDx/8UgCA9eXjx48rHSiC5PwsdyoWhUABAABLRe5OvHnzxr8CANgMrkKgkDspcpdiUQgUAACwVOSiKo89AQBsElchUIikn4tCoAAAgKUyxcUKAOCqQaAAAACYCAIFAGwiBAoAAICJIFAAwCZCoAAAAJgIAgUAbCIECgAAgIkgUADAJkKgAAAAmAgCBQBsIgQKAACAiSBQAMAmQqAAAACYiPkvVkfN3tZWs6Vqz6z1nBw0O9G6vXaFrNqJtkm1c3DiS+XldppoVUtvmawPcd1He93yXHFfTSXNwU60fufALAnkcxGNP3C0F63P605xfcrr6GvfkYxFWT/Uh3wu6n2U8SpjNKT7YWgelH3Zc7w4snnom0iAGRgVKI73m+3oOLXa3m+OozLH+9tm+W5zGC1bRAQKAABYeaa4WAWz1xl283ovMrbWTOqBoMWWiYxoto0zrKlRtcs0A21xZr/1nd6w9vnQsr58XClixOP6ikBg24zG3TcPraFOx2jrbPvkTXXaaNQHZX0+7rwP8jqrT0xSvEjoAkMZFvJ9k/bZkLVZ7MuhPhbjcvu2tl8AZmF8oNhu9o/DsuNmf9scm7uHbZkiUBzupq/nFIECAABWnkkChTWApdHsyMx9QWncrSlNNtACQr1NLWzYZdVOlH3sL6+R1lGOwS0rjbAf/05mtJU+Dc11Pu5yHsq5zsn73fZZbVvpYxKktPaG5inbRmlX278A8zBNoDAaCgwECgAAWHcWv1gNG1TVdMbUDGOygdSRfcpdrVAzqYYeM14z3j1NKMTj1OdFM8LtsqJ/Sh+kTI+RLuovyg+PS507QZu/JDwE4rHr+75rY3ietDnT2wWYnakChb0jET32FL8+3DXHuTn+a49HzSICBQAArDwLX6x6THpANYQtuqF0y9MAEZdxn5of2W3bi3XkWtU2q33VTK8PMEfucZzQhuazA7bNqH7NmBf9io1xzbC35dM5Kamb93aZtNE/CDtetYjWP3VOo31aMf7d3Oh9judJm8davQCzMk2gOGx2zfG7e9iVyQMGdygAAGDtWexiVQsDBms0vRHvM7CqIRWc0WzrSOpx7SbP2Xsj3PalMMahvrItNXz47ePlLjBUTKwfbzIXdlnZx65O16d2G20u4nn0SqczzIVI61u83isfa4ufo9r6av8IFHD1GB8o/PsoSPtSNoECAAA2iYUuVrOaOm+Kc08oqGYxmODY2CZ1RIY1oggGiRk3/bR3G3rMb4w6Nr2sHYNpo6jD4EJI6INpW/pUM8q5OfcBJK7XtZWPIVDOW1FeqdMS5iqev5y8f4K2LJ6nyjHSjZ1AAZfD+EChPPIUBQYCBQAAbByLXKwKA9+DXlY3k8MmdMZAkROZ+ZaaMVWX5+16Az+HsbV9lDHY+mXbikyZueasJV4/bNbb16ZcETJytPBgx6EHiq4P+r507cVlO9p5yn5uUdsFmJ2pAkX4TU/hsScCBQAAbBzjL1a6qa+hmkL1021DxeTHn1Rr9dllPYGiM7Ed9W00o5uO2fZnLlOrm+eWbD70vs0SKMLczRAobJt99UWo+0tpI9l/2nGSbhPvV0e2jdLu0L4GGGK6QJF+j4JAAQAAG8foi1XF9FuMAUwMpC1bmtbSSHbYdbFhzOuY4fVe1AfdgGpmt8Nukxv89vWQsTeYeYjX943XUhhn10bcv7QP0v/UaOfzlo8hr3OwTzFqoPBtRG0WdWbb5eXNgvRYKtrJ99MMcw8wwFSBYrZHnvIQMrsIFAAAsPKMvlhVzGXAmkpj+oJK89dv5oXBOnyIqK13ZtqvV93nsDFN6lCMebcuUlRhPIa+sVrUOc3bydZnc1CGpnwMaT/yOe6k7NuefZ7Uo0xo0gelj67uUIfWRjoPffsMYBbGB4ruOHRK7z4UgSL88TspmyyfTQQKAABYeaa4WAEAXDVGBYpLEIECAABWHrlYffzYIITQRunzz+805+evrTQjvyoiUAAAwEoTLqr2Aiuv+2T+hxBCV07a+czoc2PUz41hD6FiVYMFgQIAAFaS+EIrF9X4ovvB/C/WhfkfQghdZZn/Wpn/3Lkv3KEwpj0OFpqpv0wRKAAAYGVoQ0S4oPp/P7/zi+7Caxb8aP7tJK8RQuiqqzuvyXlOzndy7vvm7Lw580EiDhaasb8sESgAAGAlSIKEf22up/ai+vPP7/gLbdP8YK60ovdef/zRKbxGCKGrpvg8Zs9xPmTcNue+EChsqDDmfRXvVBAoAABgJcjvSsR3I27fuWsvtu+8vjdXW9F37z80b42+e//R/osQQldNcv4K57Dvf5DzW3eu++nPf9G8Ontt9Y0JEBIu2lAhWpFQQaAAAICVIL47Ye9MyOs/+9fmKmMuMwitqS7+1Z81r//fBdpYffC6aH7/7oPVmz9+aP5gJAHj2ASKr7953byMQsWq3ak4Oztr7t69a8/ji2DeEQAAAOOJ706EOxNy218M17sfPjaPnjxtfv38RfOtudjKxffs+w/NN99dNC/f/ti8eHth9TVCV1ByjGvL0YboD905TM5nr8x5Tc5vcp6T890/3L7b/PbluQ0VL4ySUBGCxSUHiqdPnzaPHz92J/MFIFAAAMBC2EBhFO5MSJiQR5zEbMmndOff/dD83c/uNV+cvrQX4a/eXDTP3/zYnH77Y/Pl6x+ap5F+c47Q1ZEc49pytBmy5y05jxnJ+ezZ73+05zc5z0m4+Pvb95rTF+cmVLxO7lQk36m4pEAhdyZOT0+b+/fvN2/fvvVn8/EQKAAAYDTxo05yd0K+MyFfTJQ7E2K25FM6+cTuq9+/b37+xWnzP24/bP76//6yOTL6q+N/av6L0V/+4y+bv5R/g/4RoashOca15WhDFM5fRnI++6vjB82R0X/76YPmb4z+9mcn9sOUfzDB4vjnd5uffn63uf35L5qf3zH6/I79tbIi+Q7Dp5Y85vTw4cPm3bt39ly+KAQKAAAYTQgU9u6E+Z/8dhP5MqJ84VrMloQJ+bTuy29/aP7jyR+af/+/zpt/859fIrQWkmNcW45Q0N/+7H7zv2/ft48/yXcq5Iva8tuf5FfKhkBxWaFiCskdjidPnhAoAABgHOFRJ1G4OyGPOslvcJIvJYrZkmeL5bGAf/ffz5q/fvRt8+i339pb7Qitg2xoVpYjJJJA8cXz182Tr86b0xev2+9T2O9SxL/x6ZK/R7GIXr16Zb+HQaAAAIBRlI87dXcn5FEnMVu/ffNj8xd33jT/6Zff2lvrHz6Y5QDrgjnGATQ+mhOkBIpfPjtv/vm3581vvj5vnr3wgeL82/Q3Pl3hQBHEOwEAAEaRBArzP/kytgSKt+8/2t9yImZLvqwodyd+e/6d3QZgrSBQQA8SKE5Oz5svnp83v/qdCRQvXzdfvXJ3KF6Fv6BtzDiBAgAANpYQKOT7E/K4kwQKedxJfg+7fHdCzNZvXv9oL6oXFxduI4B1gkABPci57+7T8+afnp03/+Ife5JA4X7b07l77ElCBYECAAA2lTxQyG93kkDx+3cX9u9MiNn61fkP9qIKsJYQKKAHOffd+c1588tTFyi+9N+jIFAAAAB4tEARvj8hf+RJzNY/f0OggDWGQAE9yLnvcxMoHnx5ZgLFaxsonptA4f7IHYECAACgDRThC9nyG57kD9lJoJDf7iRm6zGBAtYZAgX0IOe+n//6rHlw6r6Y/fRr90fu2r+aTaAAAIBNxwYKozhQfGe/kH3RBoovXr0nUMD6QqCAHmygkDsUEii+em0ChbtDEf5iNoECAAA2njxQyCNPcodCfsPT139wjzw9IlDAOkOggB5CoDj58rx5bO9QECgAAAASCBSw8RAooAcCBQAAwAD1QHHRfO0feSJQwFpDoIAeCBQAAAADzBQoXi4QKI72mq2trVZ7R3655+RgJ1m/c3Di13hODpqdaP3WzkGTlTBN9K9P29hrui6cNAc70baJdpq2K9kYtvJBGOptOIb6aOmdq6NmL1qX9yGfR1ExlwE/p+36fI5j2b5mbSfKxzpPP8t5Sucg2geBrK/KrpgfAgX0MCpQHO8329FxarW93xxH5n0VxTsBAABGsdRAYc1fbsyj17I+Nte50bWGPzaVPgDE25g6O1Pp18cu09S5F7lSa+xrht5jy7R1iEGOja83zFEbziR3ZYo2hvoo2LlRDLYl38b1IQ4Mtg95nRVCuKkGDotro16l61NaR/82s8xTfHzk5WVfyvHRTUN2PI2FQAE9jA8U283+cVh23Oxvm+N997ArM6DD3fnKTyHeCQAAMIplBorUmDtkWZ+RtSayz/DnISVjcPte424YqN+S1KGY6Ln7KHX0tKnUl9dhX9fdf4c34TtFGEgZM4/9+3ZonoYDSnk8aduMgEABPUwTKIwOd817Zrc5DK8HRKAAAIArw/IChW72hozqoJFdcqDQQlBBXIfan36jW/RR6uvrszXWSqCI+jlTv1uDPmTEFfOfUDP/9f0yPE96m924xh1PM0GggB6mChTH+9vdY082XGSBw9/F2N7/D82ueS/Ej0tt7x+n9bTrsoBi6/XrRjxixTsBAABG8anvUPQbQGcq60bX1zmw/XxGOGIgrDhcHe241IDS107ZxxAO7NiCGcjHKO20G0kd89wdcAyZ88CgSdfGbOfOLLPrwjiiuRyap8rcd33W9y2BApbNNIHi0IaE3cP0dRwU8m20OxR2WRQUkpCSt2le77ftzSbeCQAAMIplBgpnIiOTaE2juSCqBtAb9cJ0dljzWJjKsJ1IDwOxUc8NaUxnXuu4uuYwytHrWh9D/7qmnXmO+xLG3imuJ67fKxuH2z70M+9fzMhQFoJEtKEbl2+TQAFXlPGBwr8Xg7I7BkkYCK+jAFEEiiKkiCSY+GVzPlKliXcCAACMYqmBwpAaYWMoxVjmBjAEjcJwBjrDXDe6gi/XYzATk5swZKS9yc9N70yBIqbsY2eaI+J6vVnvigyNMwskhVnv6Z86noiK8de3i+Z0aJ4IFLCiTHOHIjyqFBn+pIx73Km7g6EEivhxpkxuO3fXQ14ndz7mEO8EAAAYxbIDRY41gLEr9Ga5MNQtwcj3mNwE3Xh2VMx0n5EOgUczrnadbpTrfUj7OBQo1PU1Yx/It7dzqCmtQ20romrg1fmLxjk4T1JWDxRuX+lzWhxPYyBQQA9TBYoyNITvTBjzr9xd0APFDHcgouARB5RZxDsBAABG8WkDRWYKvVHXP8kXXPn5PoHWjWmHbkzrRtqZ4rppTcOBZcjs530UM56PccJAUeLmoJx3ZSwJte0Ebd7j+obmSas73aach77+zAGBAnqYLlDk36MwEvO/vd/sm/CQ31XQH3maPSQU288g3gkAADCKpQYKY2pj/5cbwsHHVQaNuRjK1DTbNqI6j/bS7W2bfZ+k5/Qac0c+jnScw30M7XfGOHvtg1cxl20dJ81JV5khry+nYsSHxjqwP8q5T1/3z5Mha784PvL2Z9g3M0GggB6mChTFI09W4TGlPHz4QJB978IuS+ow24cyJpyodz/assPinQAAAKOYKVC8Gn+HwppGe8EsDawz9936Tt40eiOtlcnNdrsuNqAWZ667bRUD2meUrWmNt+9UGPywLk8mg30U0n4WZn+gjqR9o3qYEPRAURj4nBkMfNIPpa7eeTIkx4TWl2R/TBAmBAIF9DA+UITjNEh/XKl6JyGqowsGLijodWbr5rw7IeKdAAAAo+gNFH/4ceFAAbDyECigh1GBYmYpj0FdongnAADAKOqB4gOBAjYDAgX0sMxAkf/q2MsW7wQAABhFHij++OPH5rv3H+0dihf+kacvCBSwzhAooIcQKB6cnjf//NXraQJF+5uYZvitTZ9QvBMAAGAUaaD42N6h+PbdhzZQPP7mBwIFrC8ECujBBopfn7lAYe9QnDe/ffm6efHNFI88rZZ4JwAAwChsoDD/mizRBorvTKD4vQkUL9+6R54ef8MdClhjCBTQg5z7Ppc7FF+eNf/y1evmyxevo0BxTqAAAADQAsX3P0iguGhefefuUDw54w4FrDEECuhBzn2/eHre/PL03ASKcx8owiNPBAoAAIAiUPzgA8WbP35ozr7/YM3Wb17/SKCA9YVAAT3Iue+uCRQPn583T0ygOH1x3nz16jWBAgAAIBAChchkCRso3v0o36OQL2Z/aD78yU+c4UJoXfUTc4wDVJBAcXJ63nxhAsWvfnfePHv5ugwUxowTKAAAYGOJA0W4S+F+05P7YrY89vT89z82f3HnTfM3T7632wAAbAoSKH75LHwh+3Xz7MV58zsTKF6df9t8Y0LEmdydMGacQAEAABuLDRRe8pue5C5F+B7FH+xjT+4P3H35rfsexf/8FaECADYHOe998fy1f9zJ/crYr+Pf8GSM+FUPFGdnZ83p6SmBAgAAxhEHCrlDIaHCZAn72FP4bU/yXYrfSajwdyr+7X99ZS+yCCG0Cfrbn500f3/7XvMPt+82xz//RfNTo9uf32k+v/OL5nP51+vOnaupu3fvNg8fPiRQAADAeGygkH+N4r9H4b5L4R59klDx9R/eN7/+8rT5J3Ph0S5KCCG0jvq7n91r/o8NE3ebn35+14SJXzQ/zwKFtt2ydf/+/ebJkyfNu3fv7Ll8UQgUAAAwGvUuhQkU8l0KefTJhorvfmgePHjQPH/+vHn58qW9RY4QQusuMe7ym53kb0/Io07JX8h+fbmPO7169ap5+vSpvcMwRaggUAAAwEK0dyl8oJDvUkioCHcqfvObp/YZW7loffjwwW0EALDGfDQnRAkU8ncnJEy0fx07fBlbZIz9ZX9/QkKF3KlYFAIFAAAsTBsqjPJQIXcn3rx5Y8sBAGwKEiiSOxMmPLR/e8KYefvvJQcKuZMidykWhUABAAALYwNFkHltQ4WRfKdCLqoXFxeuIADAhiDnPgkSyZ0JY+JXJUwEST8XhUABAAALE4cJK/+zhIopLlYAAFcNOffJHQkJEvHfnFilMCEiUAAAwMrQhgofJsK/BAoA2ETk3FfclfD/asb+skSgAACAlSQOFgQKANhE5NzXhoigFQsTIgIFAACsNBIqCBQAsIm0gSKSZugvWwQKAABYeQgUALCJyLlPM/CrJgIFAACsPAQKANhECBQAAAATQaAAgE2EQAEAADARoy9WR3vN1tZWq70jv7zlpDnY6dZvlQWak4OdqI69pi2R1Z2oUs/OwYl/FXFy0OxE25Zljpq9aH1Rd7b91s6BGVVEvl4r0+Lno12fzU+inUYfjsyXsi6Zr3J9Os9D2yv7Mt8fyj4AuGqMChTH+8321nazfxwvP2x25X2xvd8cy+vD3fT9Ito9jMrPJwIFAACsPKMuVtZIR8bUGs7YqHqz3BpPZ9xjQ+9MbhcijvZM+aoZN+RtWrpAUAsLbRe8+e+8sOtjt13eR1mvjCnuo60zCkJ9BFPeN0aDnQfVsIexZnOQzX0+r25997pYP7gvpd14jL4fhAq44kwTKI6b/W3zfghhQmQDxW5zGF77wLG9f+xfzycCBQAArDxjLlaa6ZVlrRnPTKxgjWxrpjOzL6iBoaNoszXzeTBwpO057LJQh9JHu2yeUDNzoPBhxQSUueqPcIFrJ1uvjT2eW229W9ZNw8C+1NDmDuCKMUWgONw1758kPBgVgeJ1c7y/nYaOOUSgAACAlWf+i9WwgdfMfGKWVeOs12vpMdq17TSjHBvhwT5q5OtnNNahL2qbEWqfhdBO0T8lmBm6eobWD+9LFQIFrAGLBgobEorHn4yUQGGDx8jHnggUAACw8oy5WGnGNzahqjGOzbBqSOuBomq0LXOY4rhdrQ8DgcL2I65T6ugz3kLUTq9Rr7YdhYK8TGWbocAQz6c2t/2BwtVZ3x8AV4OFAsW++57E7qFSJg8U6vcuZheBAgAAVp5RFytrknNj25ltNQDE5lcz8xXzWzPNHX3bxZ/OO2Peteted9t5o1xpy5rspL5uWSctoHTb9Bl1dc5Cn7oK0rmozE1cl+tj1C8791GdA/syx9bduz8ArgbjA4W8B4xqjzDxpWwAANg0xl6sUjNtDKsY0yUEij4T7qgECiGYZyvT9pH0IWo3mGevvSMJGblZDkEjDRMazmyH+st+1ceiP5pUlB8RKATXLy9T35HUG63v25cdIZCV7QFcRcYHiu1m/9AHCy0o1B554jsUAACwrkxxsRKsKfUmNf65xZpfb7bjn1ucAU836wkLLbOU8ahGOaLoV35XY4goGCRhplTSXzVghbYrsuOQMnqg6JuPofXF/rPzEtoEWA8WChTy+JK/E1H89iYlULjf9DTusScCBQAArDzTBIosDCgGOf20PTLeAe3Tdm1ZweyBYj4j7eqdz0Qr44pI56Ajv6NQpZgPbez9fXDr++Y025e+vpn6B3CFWDhQmNfui9nZdym0QLHA9ygIFAAAsPKMuliZwBD7y9IQ50a3NLm5udZMdc2Ap1QChTHfe9Gysi7Tp3QQaQiaIcycnKQr7Rh6+quPZygARGh9yvqdt3FysNcfQIb2pRIOAdaBKQKFyP3q2GgZjzwBAMCmMfZiZY2nfHJtpH/q7z/Z9tIMc1yH9gm4FjJKKoHCYM11T/3OLPv1udG35t2vy9S2FW8v6gkTghooZgguLZWyyTiLPrj5CeuH9kMxj/kYIw3uGoAVZqpA0f5xu7DcPwqVaGSYEBEoAABg5ZniYgUAcNUYFSguQQQKAABYeQgUALCJECgAAAAmgkABAJsIgQIAAGAiCBQAsIkQKAAAACaCQAEAmwiBAgAAYCIIFACwiRAoAAAAJoJAAQCbCIECAABgIh48eNC8f//evwIA2AyuQqA4Oztr7t6963s8HgIFAAAsladPnzYvXrzwrwAANoOrECjk/Pz48WPf4/EQKAAAYKlcXFzYC+vLly/9EgCA9WeVA4XcmTg9PW3u37/fvH371vd4PAQKAABYOhIq5JOwe/fu2YssQgihy5M85vTw4cPm3bt3/iy9GAQKAABYOhIonj171jx69Ei9uCGEELpcyd2KJ0+ejAoZBAoAAFgqEibki9nPnz+3jz3JrXaEEFp3iUnXHjdaVb169creSZa7F/OGCgIFAAAsFblAybO6coH68OGDXwoAsL58/PjxygWKIDlny52KeSBQAADAUpG7E2/evPGvAAA2g6saKOTuyry/SpZAAQAAS0UuqvLYEwDAJnFVA4VI+j4PBAoAAFgq816YAADWAQIFAADARBAoAGATIVAAAABMBIECADYRAgUAAMBEECgAYBMhUAAAAEwEgQIANhECBQAAwEQQKABgEyFQAAAATASBAgA2EQIFAADARIwOFCcHzc7WVrPltXNwElY0Bzvd8lQ7TVssL7dzYJaUHO1FZbb2miO/3JL1YS9Zaaj2MXDU7PWulyp22vVF+9n25fq8/2Uf0/r1PiR1KPOU1hHPMQDUGBUojvebbfs+220OtfWiUGZ7vzn2y473t6P3qNP2/nG57YwiUAAAwEoxLlA4I92aX2/cC0MfYU1xVCB97cNFVkG+TULe5tGeuUjHZtr1sWui7OPRXhQAlPXOqHdlbH8iQy+v0/rM+jhUSJ/SAtZIJH2KA4LvQxwq0jaVecrGnfcZAHTGB4rtZnt7q9k9VNYbHe6asLBtAkQeKKLXIXTU6hgSgQIAAFaKUYHCmtjUtA6b/8js568Fuywz45W7FkLZnjPbwYxbY51tb5fV+phtb1pIA4mg9TtB2Sajd54MSb+19rK5L+sb7gMALBYo9vd304DQ6rDZ3do16wcChZEEj63dw/b1PCJQAADASjEqUOTm3yDGVntcRyhMrxJIciPcV19p/h2xGVeNu9puIKtTDQ96ux0TB4oZ5qkMSbK+L/QAgLBQoDiW4CD/puttcDAhIQ8QZaA4bva3xz/2RKAAAICVYlSgMIiRTcx37W6CZsxVsx4bZWfc947csvDMcWfkdeMem/HEmAf6AkW+Ti3bHyhsm9XAYrDj7gscblyhfnUMvkxXh/Spm8tkvwBAlcUChX+0KQkELiTIY0yDgeJw15wrer6HMSACBQAArBRjA4X9pN0Y2066kdY/kXfGPF4e6nOLQpDIDX66Pq82MeCFeVfq9GVs/2cKHz2BwvevbuZ9+0VACPg5idqcLVCEcUXKJwYAChYNFO7nKBRISPChQQ0U2fuUL2UDAMDaMCZQuE/i4zsM3tQWRjY3vzGpEd45OLKG2pXVt+vCib6+MODe5DuZ/h5JgNCDTwgXbSCYI1CEMFQNE6EftTDRBpu0veFA4UOIMuZ8bgAgZeFAEd2RkHXxHYvBOxR+W75DAQAAa8H8gaLyKb1mwFVTXkOMcggpQ4HC9UENFH1OWvpTM/VC3F9r8vVA0TXhDX3x+FaHC18zhA2t32p/o3myfSzb1u8KAUDM4oEiCgrZ3YrhQGGU3+GYQwQKAABYKZYZKOYytpl5lm3VOwG+vrLuSr8itDoTkj4ooSYz8LYPfYHJh4XqFOR3RXK0wBDPM4ECYDRTBAr3W522m91dExiiuw0zBYoFvkdBoAAAgJVi/kBhsKY2NrL+k/rExOp3GRym/F70yXvVOEfL8tf5NrHRFsz6vajC4vEh2V7pb2zu821So943PseQsdcfaUpJ6yhDk12fj2ugXwAwVaDwv/7VvOfivykxHCh45AkAANaIUYFCsAbeXUjVR3a0kBDjja/bvvIpf9KGUleyvqwjPG5kpTjsZL2RdqfAGna1Dhco4u3zcsm2iVxf8/Y7xWP1Yc2vG+yjEWECYJipAkX8ZeywTA0U0XvUamSYEBEoAABgpRgdKAAArjCjAsWKiEABAAArBYECADYRAgUAAMBEECgAYBMhUAAAAEwEgQIANhECBQAAwEQQKABgEyFQAAAATASBAgA2EQIFAADARBAoAGATIVAAAABMxIMHD5r379/7VwAAm8FVDRRnZ2fN3bt3/Shmg0ABAABL5enTp82LFy/8KwCAzeCqBgo5Zz9+/NiPYjYIFAAAsFQuLi7shfXly5d+CQDA+nPVAoXcmTg9PW3u37/fvH371o9iNggUAACwdCRUyKde9+7dsxdZhBBCqyV5zOnhw4fNu3fv/Jl7dggUAACwdCRQPHv2rHn06JF6IUMIIfTpJXcjnjx5MipExBAoAABgqUiYkC9mP3/+3D72JLfVEUJo3SWGXXu0aJX06tUre/dY7k4sEioIFAAAsFTkYiXP5crF6sOHD34pAMD68vHjxysRKILkPC13KsZCoAAAgKUidyfevHnjXwEAbAZXKVDIHZV5f1VsDIECAACWilxU5bEnAIBN4ioFCpH0dywECgAAWCqLXKQAAK4qBAoAAICJIFAAwCZCoAAAAJgIAgUAbCIECgAAgIkgUADAJkKgAAAAmAgCBQBsIgQKAACAiSBQAMAmQqAAAACYCAIFAGwiBAoAAICJGH2ROjlodra2mi2vnYMTv8JxtNetC9o78is9aZm9Jls9uP7kYCdav9NkXSj6mLcf4+rK6jjaa7dtlVUy3xj6+wAAn47FAsVxs7+dvre3dg+TMoe72Xqj3cO4jvlEoAAAgJVl3EXqqNkzF8c2RHjjHptlMdJ5yIhxBr4z4NZ47xw0YQu7PnqdrzcLku3z+syS5mAvL6+EDosbjxoo4jYzZupjOimmDUIFwCowOlAc7zfb5n28vX+cLD/e306W2UARh4zDXfP+3272j7tt5hGBAgAAVpZRF6nMzAvWTEdOuT9QGLO/k623oSQYemfwU+Mty8J6ZXu/rG7WtTodLgjsRO17egPFUB918nkCgMthXKA4bHaVMKGpCBT+rsYs22oiUAAAwMoy6iJlzX8ZKDqDrxn+lCJwxHUm4SIQ16mHg36zXgkUIRwpbeZ3IBIG+6hDoABYDcYECrkLsbW93xwr63KVgcKFkbGPPREoAABgZRl7kRKz3RpnMdeJ8R66WyCIwe9CiRjtrrxm/mOzrhv3PrOuh4OonVqgqA5iqI8Kto2heQGAT8GYQCEhYdY7DHmgmCeMaCJQAADAyjL2ImXNuzHHneI7Fs5sx+sLk+3Nda2MrT8KANbcR2Xc66hN//2EJACEZflyizP/7XIlUBRjzALJUB9T/JwUoQYALoP5A4X2yFL25ewoMNhAEZZ78aVsAABYS8ZcpJxxjs23N8u1j959eOiMdlm+rNMbfn8hlrJi4IvQEdYbo34kddT64MNFlx9M2djcK4EixfcnCQTDfbSEYEOYAFgZpgkUnfI7ELVHnvgOBQAArB3zX6Qqj/WE7yL4lzmJgVfLVuptcetreUFQzXxE14fyDkqimvGfMXTEfXRBqb9fAPDpmT9Q9D+2NBwojOQ3PY187IlAAQAAK8uVCRTWzNfrN5WakNBn9n0faolkMCwYhsrkffR3JvpCEABcDmMCRfiVsdqjS7MEikW+R0GgAACAlWXURcoa5dhYuzDQmfWT5iQ23dZox8Y6L2/I6jzai8ODu6MQFz852CvaT8KIqS95XfQhQwkLJ+kgij4P9dE+klVtEAAuk1GBwsiGAiVU2ADRGyh45AkAANaU0Rcp/+l7q8Q4e/MdrS99dV4m/+Q/fixJuyuQbq/59uQ7FpUyLVqg8I8rtSoq6O9j3n6nvjstAPApGBsorPydivR9vdscRmVsoMjKjA0TIgIFAACsLItcpAAArioLBYpLEIECAABWFgIFAGwiBAoAAICJIFAAwCZCoAAAAJgIAgUAbCIECgAAgIkgUADAJkKgAAAAmAgCBQBsIgQKAACAiSBQAMAmQqAAAACYiAcPHjTv37/3rwAANoOrFCjOzs6au3fv+p7PD4ECAACWytOnT5sXL174VwAAm8FVChRynn78+LHv+fwQKAAAYKlcXFzYC+vLly/9EgCA9ecqBAq5M3F6etrcv3+/efv2re/5/BAoAABg6UiokE/A7t27Zy+yCCGELl/ymNPDhw+bd+/e+bP1OAgUAACwdCRQPHv2rHn06JF6Ufv+T//UXJHMJQkhhNDkknNsON/K3YgnT54sHCJiTCsAAADLQ8KEfDH7+fPn9rEnucWeSy542nKEELqqEvOuPWZ0GZJzbPj51atX9o6x3J2YKlQQKAAAYKnIhUue0ZUL14cPH/zSDPkUDQBgTfj48ePKBoogOTfLnYop4AwOAABLRe5OvHnzxr+qQKAAgDVj1QOF3EVZ5FfFxnAGBwCApSIXVXnsqRcCBQCsGaseKETSxyngDA4AAEtlpgsWgQIA1gwCBQAAwEQQKABgEyFQAAAATASBAgA2EQIFAADARBAoAGATIVAAAABMBIECADYRAgUAAMBEECgAYBMhUAAAAEwEgQIANhECBQAAwESMDhQnB83O1laz5bVzcOJXeLL1e0d+ecTRXrd+a2uvyYucHOxE63eavAmhv8xJc7AT1hkVncjW7xyYJQCwCcwdKI73m+1wrlC0e1gps73fHGv1RSJQAADAlWZcoDhq9syFsg0RPjx0ft0Y9b3InB/tmQtravZdEOhChA0XsaHPtsnLC3ZZNQT4sNB2KuuzIW0zLw8A68zcgSKWDQ7bzf7x0PLjZn/bnFd2D9NymQgUAABwpRkVKKzZT829NedVM+7MfBI4jHlP7mrYUNIFiLK+rA5bvryr0aL0MQ0geZ8MyjYAsJ58mkBhdLhrziu7zWFcLhOBAgAArjSjAoVi5iUAFI89tZTmvSif1WnNfxEosjsWyfoU9e5FElpcqCkCRfWOBwCsE58qUBzvbw8+9kSgAACAK82oQGEQw5488tRjxFVzbwNCFyAkYKT5QAx/GiDyx5V2Do7cY0omrFhFFZR3OAxJoPCv236l7QHAevNpAsVhs2vOTfb7FXG5TAQKAAC40owNFNawByNvlT0qZB8f8uu0OwnW3Mfb53c43F2NeH1Xj/++Qx4OojpmChRxH720rgLA+rG8QJGeU/hSNgAArD1jAoW94xAb82D+a27cG/dudVk+rdMHhviuRlKHW58GEF+H32YwUGQBRHAhie9QAGwCywsUyiNPfIcCAADWmfkDhW7mneGvm/HksSe1bFRvfifB04WE4UBhf1YDhWs36U+LCzr5ZgCwfnyqQBF+01PfY08ECgAAuNJ80kARnPrCgSKrz5OEBKWNeD2BAmCz+XSBYvh7FAQKAAC40swfKAzWrMeG34WBODAkgcM/XtQZ9ay8kNVpw0Ns+PM6hl77Nrp+5GHBvY77aUNGTygCgPXhUwUKHnkCAIC1Z1SgEGwAMKY/KA4HBvd9hE7ZaoMPFW2Zyh2Jvjp8iKiu96Fh1vWECYDNYXmBIj6niPrDhIhAAQAAV5rRgQIA4AqzUKCYWAQKAAC40hAoAGATIVAAAABMBIECADYRAgUAAMBEECgAYBMhUAAAAEwEgQIANhECBQAAwEQQKABgEyFQAAAATMRMF6yf/MSFCoQQQpPr45/8CYECAACuLg8ePGjev3/vXwEAbAardIdC09nZWXP37l3f28UgUAAAwFJ5+vRp8+LFC/8KAGAzWPVAIefmx48f+94uBoECAACWysXFhb2wvnz50i8BAFh/VjVQyJ2J09PT5v79+83bt299bxeDQAEAAEtHQoV8Gnbv3j17kUUIIXQ5ksecHj582Lx7986foReHQAEAAAAAAKMhUAAAAAAAwGgIFAAAAAAAMBoCBQAAAAAAjKRp/j8pi4RTymXSEwAAAABJRU5ErkJggg==" alt="图片描述"></p><h2 id="完整的代码"><a href="#完整的代码" class="headerlink" title="完整的代码"></a>完整的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lan.base;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetFileLength</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getFileSize1</span><span class="params">(File file)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (file.exists() &amp;&amp; file.isFile()) </span><br><span class="line">    &#123;</span><br><span class="line">      </span><br><span class="line">        System.out.println(<span class="string">"文件"</span>+file.getName()+<span class="string">"的大小是："</span>+file.length()+<span class="string">"(Byte)="</span>+file.length()/<span class="number">1024</span>+<span class="string">"(KB)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据java.io.*的流获取文件大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getFileSize2</span><span class="params">(File file)</span></span>&#123;</span><br><span class="line">        FileInputStream fis  = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(file.exists() &amp;&amp; file.isFile())&#123;</span><br><span class="line">                String fileName = file.getName();</span><br><span class="line">                fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">                System.out.println(<span class="string">"文件"</span>+fileName+<span class="string">"的大小是："</span>+fis.available()+<span class="string">"(Byte)="</span>+fis.available()/<span class="number">1024</span>+<span class="string">"(KB)"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span>!=fis)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据java.nio.*的流获取文件大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getFileSize3</span><span class="params">(File file)</span></span>&#123;</span><br><span class="line">        FileChannel fc = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(file.exists() &amp;&amp; file.isFile())&#123;</span><br><span class="line">                String fileName = file.getName();</span><br><span class="line">                FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">                fc = fis.getChannel();</span><br><span class="line">                System.out.println(<span class="string">"文件"</span>+fileName+<span class="string">"的大小是："</span>+fc.size()+<span class="string">"(Byte)="</span>+fc.size()/<span class="number">1024</span>+<span class="string">"KB"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span>!=fc)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fc.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">File bigFile=<span class="keyword">new</span> File(<span class="string">"F:\\软件\\安装包_office2016\\Office2016.iso"</span>);</span><br><span class="line"><span class="comment">//File smallFile=new File("D:\\dev\\java\\my\\tools\\CodeFormat.jar");</span></span><br><span class="line">getFileSize1(bigFile);</span><br><span class="line">getFileSize2(bigFile);</span><br><span class="line">System.out.println(<span class="string">"最大的int值="</span>+Integer.MAX_VALUE);</span><br><span class="line">getFileSize3(bigFile);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文链接: <a href="https://www.lansheng.net.cn/blog/aa316c45/">java获取文件大小的方法</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java IO流之三 使用缓冲流来读写文件</title>
      <link href="/blog/8d787bfe/"/>
      <url>/blog/8d787bfe/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:16 GMT+0800 (中国标准时间) --><p>java IO流之三 使用缓冲流来读写文件</p><p><a href="http://blog.csdn.net/a107494639/article/details/7586689" target="_blank" rel="noopener">http://blog.csdn.net/a107494639/article/details/7586689</a></p><p>一、通过BufferedReader和BufferedWriter来读写文件</p><p>使用缓冲流的好处是，能够更高效的读写信息，原理是将数据先缓冲起来，然后一起写入或者读取出来。经常使用的是readLine()方法，表示一次读取一行数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.io;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;  </span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;  </span><br><span class="line"><span class="keyword">import</span> java.io.File;  </span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;  </span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;  </span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;  </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBufferedWriter</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        write();  </span><br><span class="line">        read();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * DOC 读取信息. </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> FileNotFoundException </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException, IOException </span>&#123;  </span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"E:\\a.txt"</span>);<span class="comment">// 指定要读取的文件  </span></span><br><span class="line">        <span class="comment">// 获得该文件的缓冲输入流  </span></span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(file));  </span><br><span class="line">        String line = <span class="string">""</span>;<span class="comment">// 用来保存每次读取一行的内容  </span></span><br><span class="line">        <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            System.out.println(line);  </span><br><span class="line">        &#125;  </span><br><span class="line">        bufferedReader.close();<span class="comment">// 关闭输入流  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * DOC 写入信息. </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"E:\\a.txt"</span>);<span class="comment">// 指定要写入的文件  </span></span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;<span class="comment">// 如果文件不存在则创建  </span></span><br><span class="line">            file.createNewFile();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 获取该文件的缓冲输出流  </span></span><br><span class="line">        BufferedWriter bufferedWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(file));  </span><br><span class="line">        <span class="comment">// 写入信息  </span></span><br><span class="line">        bufferedWriter.write(<span class="string">"你好世界"</span>);  </span><br><span class="line">        bufferedWriter.newLine();<span class="comment">// 表示换行  </span></span><br><span class="line">        bufferedWriter.write(<span class="string">"hello world"</span>);  </span><br><span class="line">        <span class="comment">//上面的都是写到缓冲区中的，刷新才会真正写入磁盘中的文件里</span></span><br><span class="line">        bufferedWriter.flush();<span class="comment">// 清空缓冲区  </span></span><br><span class="line">        bufferedWriter.close();<span class="comment">// 关闭输出流  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、使用BufferedInputStream和BufferedOuputStream读写图片</p><p>使用方式和FileInputStrem和FileOutputStream基本一致：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.example.io;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;  </span><br><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;  </span><br><span class="line"><span class="keyword">import</span> java.io.File;  </span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;  </span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBufferedString</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        <span class="comment">// 指定要读取文件的缓冲输入字节流  </span></span><br><span class="line">        BufferedInputStream in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"F:\\test.jpg"</span>));  </span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"E:\\test.jpg"</span>);  </span><br><span class="line">        <span class="keyword">if</span> (file != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            file.createNewFile();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 指定要写入文件的缓冲输出字节流  </span></span><br><span class="line">        BufferedOutputStream out = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(file));  </span><br><span class="line">        <span class="keyword">byte</span>[] bb = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];<span class="comment">// 用来存储每次读取到的字节数组  </span></span><br><span class="line">        <span class="keyword">int</span> n;<span class="comment">// 每次读取到的字节数组的长度  </span></span><br><span class="line">        <span class="keyword">while</span> ((n = in.read(bb)) != -<span class="number">1</span>) &#123;  </span><br><span class="line">            out.write(bb, <span class="number">0</span>, n);<span class="comment">// 写入到输出流  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        out.close();<span class="comment">// 关闭流  </span></span><br><span class="line">        in.close();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文链接: <a href="https://www.lansheng.net.cn/blog/8d787bfe/">java IO流之三 使用缓冲流来读写文件</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JAVA优化建议</title>
      <link href="/blog/3bbde7b0/"/>
      <url>/blog/3bbde7b0/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:16 GMT+0800 (中国标准时间) --><p><strong>代码优化的目标是：</strong><br>1、减小代码的体积<br>2、提高代码运行的效率<br><a id="more"></a></p><h2 id="代码优化细节"><a href="#代码优化细节" class="headerlink" title="代码优化细节"></a>代码优化细节</h2><p>###1、尽量指定类、方法的final修饰符###</p><p><strong>带有final修饰符的类是不可派生的</strong>。在Java核心API中，有许多应用final的例子，例如<code>java.lang.String</code>，整个类都是final的。<strong>为类指定final修饰符可以让类不可以被继承，为方法指定final修饰符可以让方法不可以被重写。如果指定了一个类为final，则该类所有的方法都是final的。</strong><br><strong>Java编译器会寻找机会内联所有的final方法，内联对于提升Java运行效率作用重大</strong>，具体参见Java运行期优化。此举能够使性能平均提高50%。</p><p>###2、尽量重用对象###</p><p><strong>特别是String对象的使用，出现大量字符串连接时应该使用StringBuilder/StringBuffer代替</strong>。由于Java虚拟机不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理，因此，生成过多的对象将会给程序的性能带来很大的影响。</p><p>###3、尽可能使用局部变量###</p><p>调用方法时<strong>传递的参数</strong>以及在调用中创建的<strong>临时变量都保存在栈中</strong>,<strong>栈中创建的变量，随着方法的运行结束，这些内容就没了，不需要额外的垃圾回收</strong>，所以创建速度较快。<br>其他变量，<strong>如静态变量、实例变量等，都在堆中创建</strong>，速度较慢。</p><p>###4、及时关闭流###</p><p>Java编程过程中，进行<code>数据库连接、I/O流操作</code>时务必小心，在使用完毕后，及时关闭以释放资源。<strong>因为对这些大对象的操作会造成系统大的开销</strong>，稍有不慎，将会导致严重的后果。</p><p>###5、尽量减少对变量的重复计算###</p><p>明确一个概念，<strong>对方法的调用，即使方法中只有一句语句，也是有消耗的，包括创建栈帧、调用方法时保护现场、调用方法完毕时恢复现场等</strong>。所以例如下面的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure><p>建议替换为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, <span class="keyword">int</span> length = list.size(); i &lt; length; i++)</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure><p>这样，在list.size()很大的时候，就减少了很多的消耗</p><p>###6、尽量采用懒加载的策略，即在需要的时候才创建###</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"aaa"</span>;<span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    list.add(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议替换为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    String str = <span class="string">"aaa"</span>;</span><br><span class="line">    list.add(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###7、慎用异常###</p><p>异常对性能不利。抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名为fillInStackTrace()的本地同步方法，fillInStackTrace()方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。<strong>异常只能用于错误处理，不应该用来控制程序流程。</strong></p><p>###8、不要在循环中使用try…catch…，应该把其放在最外层###</p><p>除非不得已。如果毫无理由地这么写了，只要你的领导资深一点、有强迫症一点，八成就要骂你为什么写出这种垃圾代码来了</p><p>###9、如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度###</p><p>比如<code>ArrayList</code>、<code>LinkedLlist</code>、<code>StringBuilder</code>、<code>StringBuffer</code>、<code>HashMap</code>、<code>HashSet</code>等等，以<code>StringBuilder</code>为例：</p><p>（1）<code>StringBuilder()</code>　　　　　　// 默认分配16个字符的空间</p><p>（2）<code>StringBuilder(int size)</code>　　// 默认分配size个字符的空间</p><p>（3）<code>StringBuilder(String str)</code>　// 默认分配16个字符+str.length()个字符空间</p><p>可以通过类（这里指的不仅仅是上面的StringBuilder）的来设定它的初始化容量，这样可以明显地提升性能。比如StringBuilder吧，length表示当前的StringBuilder能保持的字符数量<strong>。因为当StringBuilder达到最大容量的时候，它会将自身容量增加到当前的2倍再加2</strong>，<br><strong>无论何时只要StringBuilder达到它的最大容量，它就不得不创建一个新的字符数组然后将旧的字符数组内容拷贝到新字符数组中</strong>—-这是十分耗费性能的一个操作。试想，如果能预估到字符数组中大概要存放5000个字符而不指定长度，最接近5000的2次幂是4096，每次扩容加的2不管，那么：</p><p>（1）在4096 的基础上，再申请8194个大小的字符数组，加起来相当于一次申请了12290个大小的字符数组，如果一开始能指定5000个大小的字符数组，就节省了一倍以上的空间</p><p>（2）把原来的4096个字符拷贝到新的的字符数组中去</p><p>这样，既浪费内存空间又降低代码运行效率。所以，<strong>给底层以数组实现的集合、工具类设置一个合理的初始化容量是错不了的，这会带来立竿见影的效果。</strong>但是，注意，像<strong>HashMap这种是以数组+链表实现的集合</strong>，别把初始大小和你估计的大小设置得一样，因为一个table上只连接一个对象的可能性几乎为0。<strong>初始大小建议设置为2的N次幂</strong>，如果能估计到有2000个元素，设置成<code>new HashMap(128)、new HashMap(256)</code>都可以。</p><p>###10、当复制大量数据时，使用System.arraycopy()命令###</p><p>###11、乘法和除法使用移位操作###</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (val = <span class="number">0</span>; val &lt; <span class="number">100000</span>; val += <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">    a = val * <span class="number">8</span>;</span><br><span class="line">    b = val / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用移位操作可以极大地提高性能，因为在计算机底层，对位的操作是最方便、最快的，因此建议修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (val = <span class="number">0</span>; val &lt; <span class="number">100000</span>; val += <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">    a = val &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    b = val &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移位操作虽然快，但是可能会使代码不太好理解，因此最好加上相应的注释。</p><p>###12、循环内不要不断创建对象引用###</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法会导致内存中有count份Object对象引用存在，count很大的话，就耗费内存了，建议为改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= count; i++)</span><br><span class="line">&#123;</span><br><span class="line">    obj = <span class="keyword">new</span> Object(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，内存中只有一份Object对象引用，每次new Object()的时候，Object对象引用指向不同的Object罢了。内存中只有一份引用，这样就大大节省了内存空间了。</p><p>###13、基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList###</p><p>###14、尽量使用HashMap、ArrayList、StringBuilder###<br>除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销</p><p>###15、不要将数组声明为public static final###</p><p>因为这毫无意义，这样只是定义了引用为static final，数组的内容还是可以随意改变的，将数组声明为public更是一个安全漏洞，这意味着这个数组可以被外部类所改变</p><p>###16、尽量在合适的场合使用单例###</p><p>使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，简单来说，<strong>单例主要适用于以下三个方面：</strong></p><p><strong>（1）控制资源的使用，通过线程同步来控制资源的并发访问</strong></p><p><strong>（2）控制实例的产生，以达到节约资源的目的</strong></p><p><strong>（3）控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信</strong></p><p>###17、尽量避免随意使用静态变量###</p><p>要知道，当某个对象被定义为static的变量所引用，那么gc通常是不会回收这个对象所占有的堆内存的，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> B b = <span class="keyword">new</span> B();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时静态变量b的生命周期与A类相同，如果A类不被卸载，那么引用B指向的B对象会常驻内存，直到程序终止</p><p>###18、及时清除不再需要的会话###</p><p>为了清除不再活动的会话，许多应用服务器都有默认的会话超时时间，一般为30分钟。当应用服务器需要保存更多的会话时，如果内存不足，那么操作系统会把部分数据转移到磁盘，应用服务器也可能根据MRU（最近最频繁使用）算法把部分不活跃的会话转储到磁盘，甚至可能抛出内存不足的异常。如果会话要被转储到磁盘，那么必须要先被序列化，<strong>在大规模集群中，对对象进行序列化的代价是很昂贵的</strong>。因此，当会话不再需要时，应当及时调用<code>HttpSession</code>的<code>invalidate()</code>方法清除会话。</p><p>###19、实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历###</p><p>这是JDK推荐给用户的。JDK API对于RandomAccess接口的解释是：实现RandomAccess接口用来表明其支持快速随机访问，此接口的主要目的是允许一般的算法更改其行为，从而将其应用到随机或连续访问列表时能提供良好的性能。实际经验表明，<strong>实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。</strong>可以使用类似如下的代码作判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)&#123;&#125;</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Iterator&lt;?&gt; iterator = list.iterable(); </span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())</span><br><span class="line">    &#123;</span><br><span class="line">        iterator.next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>foreach循环的底层实现原理就是迭代器Iterator，参见Java语法糖1：可变长度参数以及foreach循环原理。所以后半句”反过来，如果是顺序访问的，则使用Iterator会效率更高”的意思就是顺序访问的那些类实例，使用foreach循环去遍历。</p><p>###20、使用同步代码块替代同步方法###</p><p>这点在多线程模块中的synchronized锁方法块一文中已经讲得很清楚了，<strong>除非能确定一整个方法都是需要进行同步的，否则尽量使用同步代码块，避免对那些不需要进行同步的代码也进行了同步，影响了代码执行效率。</strong></p><p>###21、将常量声明为static final，并以大写命名###</p><p>这样在编译期间就可以把这些内容放入常量池中，避免运行期间计算生成常量的值。另外，将常量的名字以大写命名也可以方便区分出常量与变量</p><p>###22、不要创建一些不使用的对象，不要导入一些不使用的类###</p><p>这毫无意义，如果代码中出现”<code>The value of the local variable i is not used</code>”、”<code>The import java.util is never used</code>”，那么请删除这些无用的内容</p><p>###23、程序运行过程中避免使用反射###</p><p>关于，请参见反射。反射是Java提供给用户一个很强大的功能，功能强大往往意味着效率不高。<strong>不建议在程序运行过程中使用尤其是频繁使用反射机制，特别是Method的invoke方法</strong>，如果确实有必要，一种建议性的做法是将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入内存—-<strong>用户只关心和对端交互的时候获取最快的响应速度，并不关心对端的项目启动花多久时间</strong>。</p><p>###24、使用数据库连接池和线程池###</p><p>这两个池都是用于重用对象的，前者可以避免频繁地打开和关闭连接，后者可以避免频繁地创建和销毁线程</p><p>###25、使用带缓冲的输入输出流进行IO操作###</p><p>带缓冲的输入输出流，<code>即BufferedReader</code>、<code>BufferedWriter</code>、<code>BufferedInputStream</code>、<code>BufferedOutputStream</code>，这可以极大地提升IO效率。</p><p>###26、顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList###</p><p>这个，理解ArrayList和LinkedList的原理就知道了</p><p>###27、不要让public方法中有太多的形参###</p><p>public方法即对外提供的方法，如果给这些方法太多形参的话主要有两点坏处：</p><p>1、违反了面向对象的编程思想，Java讲求一切都是对象，太多的形参，和面向对象的编程思想并不契合</p><p>2、参数太多势必导致方法调用的出错概率增加</p><p>至于这个”太多”指的是多少个，3、4个吧。比如我们用JDBC写一个insertStudentInfo方法，有10个学生信息字段要插如Student表中，可以把这10个参数封装在一个实体类中，作为insert方法的形参</p><p>###28、字符串变量和字符串常量equals的时候将字符串常量写在前面###</p><p>这是一个比较常见的小技巧了，如果有以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">if</span> (str.equals(<span class="string">"123"</span>)) </span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">"123"</span>.equals(str))</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这么做主要是可以避免空指针异常</strong></p><p>29、请知道，<strong>在java中<code>if (i == 1)</code>和<code>if (1 == i)</code>是没有区别的</strong>，但从阅读习惯上讲，建议使用前者</p><p>平时有人问，”if (i == 1)”和”if (1== i)”有没有区别，这就要从C/C++讲起。</p><p>在C/C++中，”if (i == 1)”判断条件成立，是以0与非0为基准的，0表示false，非0表示true，如果有这么一段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C/C++判断”i==1″不成立，所以以0表示，即false。但是如果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;<span class="keyword">if</span> (i = <span class="number">1</span>) &#123; ... &#125;<span class="keyword">else</span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>万一程序员一个不小心，把”if (i == 1)”写成”if (i = 1)”，这样就有问题了。<strong>在if之内将i赋值为1，if判断里面的内容非0，返回的就是true了，但是明明i为2，比较的值是1，应该返回的false。这种情况在C/C++的开发中是很可能发生的并且会导致一些难以理解的错误产生</strong>，所以，为了避免开发者在if语句中不正确的赋值操作，建议将if语句写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;<span class="keyword">if</span> (<span class="number">1</span> == i) &#123; ... &#125;<span class="keyword">else</span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>这样，即<strong>使开发者不小心写成了”1 = i”，C/C++编译器也可以第一时间检查出来，因为我们可以对一个变量赋值i为1，但是不能对一个常量赋值1为i。</strong></p><p>但是，在Java中，C/C++这种”if (i = 1)”的语法是不可能出现的，因为一旦写了这种语法，Java就会编译报错”Type mismatch: cannot convert from int to boolean”。但是，<strong>尽管Java的”if (i == 1)”和”if (1 == i)”在语义上没有任何区别，但是从阅读习惯上讲，建议使用前者会更好些</strong>。</p><p>###30、不要对数组使用toString()方法###</p><p>看一下对数组使用toString()打印出来的是什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span>[] is = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    System.out.println(is.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[I@<span class="number">18</span>a992f</span><br></pre></td></tr></table></figure><p>本意是想打印出数组内容，却有可能因为数组引用is为空而导致空指针异常。不过虽然<strong>对数组toString()没有意义，但是对集合toString()是可以打印出集合里面的内容的</strong>，因为集合的父类AbstractCollections重写了Object的toString()方法。</p><p>###31、不要对超出范围的基本数据类型做向下强制转型###</p><p>这绝不会得到想要的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> l = <span class="number">12345678901234L</span>;</span><br><span class="line">    <span class="keyword">int</span> i = (<span class="keyword">int</span>)l;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可能期望得到其中的某几位，但是结果却是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1942892530</span></span><br></pre></td></tr></table></figure><p>解释一下。Java中long是8个字节64位的，所以12345678901234在计算机中的表示应该是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 1011 0011 1010       0111 0011 1100 1110 0010 1111 1111 0010</span><br></pre></td></tr></table></figure><p>一个int型数据是4个字节32位的，从低位取出上面这串二进制数据的前32位是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0111 0011 1100 1110 0010 1111 1111 0010</span><br></pre></td></tr></table></figure><p>这串二进制表示为十进制1942892530，所以就是我们上面的控制台上输出的内容。从这个例子上还能顺便得到两个结论：</p><p>1、<strong>整型默认的数据类型是int</strong>，long l = 12345678901234L，这个数字已经超出了int的范围了，所以最后有一个L，表示这是一个long型数。顺便，<strong>浮点型的默认类型是double</strong>，所以定义float的时候要写成””float f = 3.5f”</p><p>2、接下来再写一句”int i i = l + i;”会报错，<strong>因为long + int是一个long，不能赋值给int</strong></p><p>###32、公用的集合类中不使用的数据一定要及时remove掉###</p><p><strong>如果一个集合类是公用的（也就是说不是方法里面的属性），那么这个集合里面的元素是不会自动释放的，因为始终有引用指向它们</strong>。所以，如果公用集合里面的某些数据不使用而不去remove掉它们，那么将会造成这个公用集合不断增大，使得系统有<strong>内存泄露</strong>的隐患。</p><p>###33、把一个基本数据类型转为字符串，基本数据类型的<code>包装类.toString()</code>是最快的方式、String.valueOf(数据)次之、数据+””最慢###</p><p><strong>把一个基本数据类型转为字符串一般有三种方式</strong>，我有一个Integer型数据i，可以使用<code>i.toString()</code>、<code>String.valueOf(i)</code>、<code>i+””</code>三种方式，三种方式的效率如何，看一个测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> loopTime = <span class="number">50000</span>;</span><br><span class="line">    Integer i = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; loopTime; j++)</span><br><span class="line">    &#123;</span><br><span class="line">     String str = String.valueOf(i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"String.valueOf()："</span> + (System.currentTimeMillis() - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">    startTime = System.currentTimeMillis(); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; loopTime; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        String str = i.toString();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    System.out.println(<span class="string">"Integer.toString()："</span> + (System.currentTimeMillis() - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">    startTime = System.currentTimeMillis(); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; loopTime; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        String str = i + <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"i + \"\"："</span> + (System.currentTimeMillis() - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String.valueOf()：<span class="number">11</span>ms Integer.toString()：<span class="number">5</span>ms i + <span class="string">""</span>：<span class="number">25</span>ms</span><br></pre></td></tr></table></figure><p><strong>所以以后遇到把一个基本数据类型转为String的时候，优先考虑使用<code>包装类.toString()</code>方法</strong>。至于为什么，很简单：</p><p>1、<strong>String.valueOf()方法底层调用了Integer.toString()方法</strong>，但是会在调用前做空判断,存在多余的操作。</p><p>2、Integer.toString()方法就不说了，直接调用了</p><p>3、<code>i + “”</code>底层使用了StringBuilder实现，先用append方法拼接，再用toString()方法获取字符串</p><p>三者对比下来，明显是2最快、1次之、3最慢</p><p>###34、使用最有效率的方式去遍历Map###</p><p>遍历Map的方式有很多，通常场景下我们需要的是遍历Map中的Key和Value，那么推荐使用的、效率最高的方式是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HashMap&lt;String, String&gt; hm = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    hm.put(<span class="string">"111"</span>, <span class="string">"222"</span>);</span><br><span class="line">    Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = hm.entrySet();</span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iter = entrySet.iterator(); </span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext())</span><br><span class="line">    &#123;</span><br><span class="line">        Map.Entry&lt;String, String&gt; entry = iter.next();</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">"\t"</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你只是想遍历一下这个Map的key值，那用”<code>Set keySet = hm.keySet();</code>”会比较合适一些</p><p>###35、对资源的close()建议分开操作###</p><p>意思是，比如我有这么一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    XXX.close();</span><br><span class="line">    YYY.close();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议修改为：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123; XXX.close(); &#125;<span class="keyword">catch</span> (Exception e) &#123; ... &#125;</span><br><span class="line"><span class="keyword">try</span>&#123; YYY.close(); &#125;<span class="keyword">catch</span> (Exception e) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p></p><p>虽然有些麻烦，却能避免资源泄露。我们想，如果没有修改过的代码，万一XXX.close()抛异常了，那么就进入了cath块中了，YYY.close()不会执行，YYY这块资源就不会回收了，一直占用着，这样的代码一多，是可能引起资源句柄泄露的。而改为下面的写法之后，就保证了无论如何XXX和YYY都会被close掉。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>本文转自：<a href="https://www.cnblogs.com/penglei-it/p/java_majorization.html" target="_blank" rel="noopener">java优化建议</a></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/3bbde7b0/">JAVA优化建议</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用java给Hexo博客内文章生成HexoFrontMatter</title>
      <link href="/blog/c91be9a9/"/>
      <url>/blog/c91be9a9/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:18 GMT+0800 (中国标准时间) --><p>文章正文……<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 需求 ##</span><br><span class="line">使用java为Hexo博客所有文章添加font-matter,要求如下：</span><br><span class="line">- 使用文件名作为标题即，`title: 文件名`</span><br><span class="line">- 使用多级子目录作为多级分类，例如`&quot;D:\Blog\bolg5\source\_posts\MyApplications\HexoTools\java自动生成HexoFontMatter.md&quot;`文章根目录为`D:\Blog\bolg5\source\_posts`，则多级分类为：</span><br></pre></td></tr></table></figure><p></p><p>categories:</p><ul><li>MyApplications</li><li>HexoTools<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br></pre></td><td class="code"><pre><span class="line">- 使用文章最后修改的时间做我时间标记Date,即`Date: 文章最后修改的时间`</span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line">## 实现 ##</span><br><span class="line">之前我代码已经写好了一部分，当时好像没有写文档。代码如下：</span><br><span class="line">```java</span><br><span class="line">package front.matter.tools;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.BufferedWriter;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.FilenameFilter;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.OutputStreamWriter;</span><br><span class="line">import java.io.UnsupportedEncodingException;</span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.regex.Matcher;</span><br><span class="line">import java.util.regex.Pattern;</span><br><span class="line">import clipboard.util.SysClipboardUtil;</span><br><span class="line"></span><br><span class="line">public class HexoAddFrontMatterAllInDir</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">String dirPath=SysClipboardUtil.getSysClipboardText();</span><br><span class="line">dealDir(dirPath);</span><br><span class="line">System.out.println(&quot;遍历结束&quot;);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 对该目录下的所有markdown文档加Front-matter首部</span><br><span class="line"> * </span><br><span class="line"> * @param dirpath</span><br><span class="line"> */</span><br><span class="line">public static void dealDir(String dirpath)</span><br><span class="line">&#123;</span><br><span class="line">File dirFile = new File(dirpath);</span><br><span class="line">// 如果是文件夹的话</span><br><span class="line">if (dirFile.isDirectory())</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">// 获取md文件，或者是目录的列表</span><br><span class="line">File[] fileList = dirFile.listFiles(new FilenameFilter()</span><br><span class="line">&#123;</span><br><span class="line">@Override</span><br><span class="line">public boolean accept(File dir, String name)</span><br><span class="line">&#123;</span><br><span class="line">// 如果是markdown文件的话</span><br><span class="line">if (name.endsWith(&quot;.md&quot;))</span><br><span class="line">return true;</span><br><span class="line">// 如果是一个目录的话</span><br><span class="line">else if (new File(dir, name).isDirectory())</span><br><span class="line">return true;</span><br><span class="line">// 其他不相关的文件不返回</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">for (File file : fileList)</span><br><span class="line">&#123;</span><br><span class="line">// 输出正在处理的文件名</span><br><span class="line">// System.out.println(file.getAbsolutePath());</span><br><span class="line">// 如果是文件的话</span><br><span class="line">if (file.isFile())</span><br><span class="line">&#123;</span><br><span class="line">// 在文章首部添加文件首部</span><br><span class="line">addIfHasNotFrontMatter(file);</span><br><span class="line">//更新文章首部，使用最近修改的时间作为文章的创建时间</span><br><span class="line">//updateIfHasFrontMatter(file);</span><br><span class="line">&#125; else</span><br><span class="line">// 递归调用下层目录</span><br><span class="line">dealDir(file.getAbsolutePath());</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (UnsupportedEncodingException e)</span><br><span class="line">&#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (FileNotFoundException e)</span><br><span class="line">&#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (IOException e)</span><br><span class="line">&#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 如果是markdown文件的话也可以直接使用进行首部追加</span><br><span class="line">else if (dirFile.isFile() &amp;&amp; dirFile.getAbsolutePath().endsWith(&quot;.md&quot;))</span><br><span class="line">&#123;</span><br><span class="line">// 在文章首部添加文件首部</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">addIfHasNotFrontMatter(dirFile);</span><br><span class="line">&#125; catch (UnsupportedEncodingException e)</span><br><span class="line">&#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (FileNotFoundException e)</span><br><span class="line">&#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (IOException e)</span><br><span class="line">&#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @param file</span><br><span class="line"> * @throws IOException</span><br><span class="line"> * @throws FileNotFoundException</span><br><span class="line"> * @throws UnsupportedEncodingException</span><br><span class="line"> */</span><br><span class="line">private static void addIfHasNotFrontMatter(File file)</span><br><span class="line">throws UnsupportedEncodingException, FileNotFoundException,</span><br><span class="line">IOException</span><br><span class="line">&#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">addIfHasNotFrontMatter(file.getAbsolutePath());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @param path</span><br><span class="line"> * @throws UnsupportedEncodingException</span><br><span class="line"> * @throws FileNotFoundException</span><br><span class="line"> * @throws IOException</span><br><span class="line"> */</span><br><span class="line">public static void addIfHasNotFrontMatter(String path)</span><br><span class="line">throws UnsupportedEncodingException, FileNotFoundException,</span><br><span class="line">IOException</span><br><span class="line">&#123;</span><br><span class="line">File file = new File(path);</span><br><span class="line">// 如果是markdown文档</span><br><span class="line">if (file.isFile() &amp;&amp; path.endsWith(&quot;.md&quot;))</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">// 读取文件到文章缓冲article中</span><br><span class="line">StringBuilder article = readFile(file);</span><br><span class="line">// 如果在文章中没有发现首部存在</span><br><span class="line">if (!hasFrontMatter(article))</span><br><span class="line">&#123;</span><br><span class="line">// 就添加首部</span><br><span class="line">StringBuilder frontmatter = createFrontMatter(file);</span><br><span class="line">// 然后在正文前面首部</span><br><span class="line">article.insert(0, frontmatter);</span><br><span class="line">// 处理结果写回该文件</span><br><span class="line">writeFile(file, article);</span><br><span class="line">System.out.println(&quot;处理完成:&quot;+path);</span><br><span class="line">&#125; else</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;已经存在首部了，不再重复加入&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**   </span><br><span class="line"> * @param file  </span><br><span class="line"> * @throws IOException </span><br><span class="line"> * @throws FileNotFoundException </span><br><span class="line"> * @throws UnsupportedEncodingException </span><br><span class="line"> */  </span><br><span class="line">private static void updateIfHasFrontMatter(File file) throws UnsupportedEncodingException, FileNotFoundException, IOException</span><br><span class="line">&#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">updateIfHasFrontMatter(file.getAbsolutePath());</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @param path</span><br><span class="line"> * @throws UnsupportedEncodingException</span><br><span class="line"> * @throws FileNotFoundException</span><br><span class="line"> * @throws IOException</span><br><span class="line"> */</span><br><span class="line">public static void updateIfHasFrontMatter(String path)</span><br><span class="line">throws UnsupportedEncodingException, FileNotFoundException,</span><br><span class="line">IOException</span><br><span class="line">&#123;</span><br><span class="line">File file = new File(path);</span><br><span class="line">// 如果是markdown文档</span><br><span class="line">if (file.isFile() &amp;&amp; path.endsWith(&quot;.md&quot;))</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">// 读取文件到文章缓冲article中</span><br><span class="line">StringBuilder article = readFile(file);</span><br><span class="line">// 从文章中移除原来的首部</span><br><span class="line">removeOldFrontMatter(article);</span><br><span class="line">// 根据文件名生成新的首部</span><br><span class="line">StringBuilder frontmatter = createFrontMatter(file);</span><br><span class="line">// 然后在正文前面首部</span><br><span class="line">article.insert(0, frontmatter);</span><br><span class="line">// 处理结果写回该文件</span><br><span class="line">writeFile(file, article);</span><br><span class="line">System.out.println(&quot;更新首部：&quot;+path);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @param file</span><br><span class="line"> * @param article</span><br><span class="line"> * @throws UnsupportedEncodingException</span><br><span class="line"> * @throws FileNotFoundException</span><br><span class="line"> * @throws IOException</span><br><span class="line"> */</span><br><span class="line">public static void writeFile(File file, StringBuilder article)</span><br><span class="line">throws UnsupportedEncodingException, FileNotFoundException,</span><br><span class="line">IOException</span><br><span class="line">&#123;</span><br><span class="line">BufferedWriter writer = new BufferedWriter(</span><br><span class="line">new OutputStreamWriter(new FileOutputStream(file), &quot;utf-8&quot;));</span><br><span class="line">writer.write(article.toString());</span><br><span class="line">writer.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @param path</span><br><span class="line"> * @param file</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static StringBuilder createFrontMatter(File file)</span><br><span class="line">&#123;</span><br><span class="line">String path = file.getAbsolutePath();</span><br><span class="line">// 生成首部</span><br><span class="line">StringBuilder frontmatter = new StringBuilder();</span><br><span class="line">String filename = file.getName();</span><br><span class="line">// 获取不含后缀的文件名,作为未标题</span><br><span class="line">String title = filename.substring(0, filename.length() - 3);</span><br><span class="line">frontmatter.append(&quot;title: &quot; + title);</span><br><span class="line">// 获取子目录列表</span><br><span class="line">int categoriesStart = path.indexOf(&quot;\\source\\_posts&quot;)</span><br><span class="line">+ &quot;\\source\\_posts&quot;.length();</span><br><span class="line">int categoriesEnd = path.indexOf(filename) - 1;</span><br><span class="line">String categoriesStr = path.substring(categoriesStart, categoriesEnd);</span><br><span class="line">categoriesStr = categoriesStr.replaceAll(&quot;\\\\&quot;, &quot;\n- &quot;);</span><br><span class="line">frontmatter.append(&quot;\ncategories: &quot; + categoriesStr);</span><br><span class="line">// 生成时间项</span><br><span class="line">SimpleDateFormat dateFormat = new SimpleDateFormat(</span><br><span class="line">&quot;yyyy-MM-dd HH:mm:ss&quot;);// 使用24小时制</span><br><span class="line">Date date = new Date(file.lastModified());</span><br><span class="line">frontmatter.append(&quot;\ndate: &quot; + dateFormat.format(date));</span><br><span class="line">frontmatter.append(&quot;\n---\n&quot;);// 加入frontmatter首部</span><br><span class="line">return frontmatter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @param builder</span><br><span class="line"> */</span><br><span class="line">public static void removeOldFrontMatter(StringBuilder builder)</span><br><span class="line">&#123;</span><br><span class="line">// 检查文章中是否有首部</span><br><span class="line">Pattern hasFrontMatter = Pattern.compile(&quot;(?:---\\n)?(?:.*\\n)+---\\n&quot;);</span><br><span class="line">// System.out.println(&quot;使用的正则表达式:&quot; + hasFrontMatter);</span><br><span class="line">Matcher matcherFrontMatter = hasFrontMatter.matcher(builder);</span><br><span class="line">int start = 0, end = 0;</span><br><span class="line">// 从文章首部开始匹配，匹配到了就不再匹配</span><br><span class="line">if (matcherFrontMatter.lookingAt())</span><br><span class="line">&#123;</span><br><span class="line">start = matcherFrontMatter.start();</span><br><span class="line">end = matcherFrontMatter.end();</span><br><span class="line">// 移除首部</span><br><span class="line">builder.delete(start, end);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @param builder</span><br><span class="line"> */</span><br><span class="line">public static boolean hasFrontMatter(StringBuilder builder)</span><br><span class="line">&#123;</span><br><span class="line">// 检查文章中是否有首部</span><br><span class="line">Pattern hasFrontMatter = Pattern.compile(&quot;(?:---\\n)?(?:.*\\n)+---\\n&quot;);</span><br><span class="line">Matcher matcherFrontMatter = hasFrontMatter.matcher(builder);</span><br><span class="line">return matcherFrontMatter.lookingAt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @param file</span><br><span class="line"> * @param builder</span><br><span class="line"> * @throws UnsupportedEncodingException</span><br><span class="line"> * @throws FileNotFoundException</span><br><span class="line"> * @throws IOException</span><br><span class="line"> */</span><br><span class="line">public static StringBuilder readFile(File file)</span><br><span class="line">throws UnsupportedEncodingException, FileNotFoundException,</span><br><span class="line">IOException</span><br><span class="line">&#123;</span><br><span class="line">StringBuilder builder = new StringBuilder(5000);</span><br><span class="line">// 先把文章读入缓冲中</span><br><span class="line">BufferedReader reader = new BufferedReader(</span><br><span class="line">new InputStreamReader(new FileInputStream(file), &quot;utf-8&quot;));</span><br><span class="line">String line = null;</span><br><span class="line">// 一行一行的读取</span><br><span class="line">while ((line = reader.readLine()) != null)</span><br><span class="line">&#123;</span><br><span class="line">builder.append(line + &quot;\n&quot;);// 添加到缓冲中</span><br><span class="line">&#125;</span><br><span class="line">reader.close();// 关闭文件</span><br><span class="line">return builder;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>上面的代码已经完成了功能，但是在使用的过程中还是有一些问题的，先来看主函数：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">String dirPath=SysClipboardUtil.getSysClipboardText();</span><br><span class="line">dealDir(dirPath);</span><br><span class="line">System.out.println(<span class="string">"遍历结束"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这里的需要从剪贴板获取需要处理文章的绝对路径，或者是所在的目录。</p><ul><li>如果是文章，就直接对该文章中添加front-matter,添加的算法是，生成front-matter到一个字符缓冲中，然后把文章也读入，追加到缓冲中，然后把文章缓冲覆盖写入到文件中。</li><li>如果是目录则递归遍历整个目录，检查文章是否已经有了front-matter,如果没有就添加，如果有了就不做处理。</li></ul><p>我现在要做的就是修改主方法，因为我不想每次传递路径到程序中，我的博客路径搭建之后就固定为<code>D:\Blog\bolg5\source\_posts</code>，我只需要递归遍历这个目录即可。虽然这样需要处理博客中的所有文章，空间和时间消耗可能大点。但是无所谓，我就是懒得传递路径到程序，因为我需要先要复制文章的路径到剪贴板，然后在调用程序。而修改后我可以直接调用就行。少了一个步骤。<br>修改后的主函数为：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">String dirPath = SysClipboardUtil.getSysClipboardText();</span><br><span class="line"><span class="comment">// 如果剪贴板中有东西</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="string">""</span>.equals(dirPath))</span><br><span class="line">&#123;</span><br><span class="line">dealDir(dirPath);</span><br><span class="line">System.out.println(<span class="string">"遍历结束"</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//如果剪贴板没有东西就默认对所有的文章进行处理</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 默认的博客文章地址</span></span><br><span class="line">String defaultPath = <span class="string">"D:\\Blog\\bolg5\\source\\_posts"</span>;</span><br><span class="line">dealDir(dirPath);</span><br><span class="line">System.out.println(<span class="string">"处理所有文章结束"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行后我发现问题了，剪贴板中可能随时有东西。这些信息不一定是路径，这样就会进入第一个分支，从而运行错误。解决方法：</p><ul><li>方案1：不再使用剪贴板传递参数，而是使用命令行参数，Windows运行框是可以传入命令行参数的，到时候修改一下bat文件把命令行参数传入java程序。</li><li>方案2：继续修改主代码，先检查参数是不是路径，如果是，dealDir()方法就使用该路径，如果不是dealDir()方法就使用默认路径。</li></ul><h2 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h2><p>修改代码为：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">String dirPath = SysClipboardUtil.getSysClipboardText();</span><br><span class="line">File file=<span class="keyword">new</span> File(dirPath);</span><br><span class="line"><span class="keyword">if</span>(file.isDirectory()||file.isFile())</span><br><span class="line">&#123;</span><br><span class="line">dealDir(dirPath);</span><br><span class="line">System.out.println(<span class="string">"遍历结束"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果剪贴板没有东西就默认对所有的文章进行处理</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 默认的博客文章地址</span></span><br><span class="line">String defaultPath = <span class="string">"D:\\Blog\\bolg5\\source\\_posts"</span>;</span><br><span class="line">dealDir(defaultPath);</span><br><span class="line">System.out.println(<span class="string">"处理所有文章结束"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这样就可以了，程序输出：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">已经存在首部了，不再重复加入</span><br><span class="line">处理完成:D:\Blog\bolg5\source\_posts\MyApplications\HexoTools\java自动生成HexoFontMatter.md</span><br><span class="line">已经存在首部了，不再重复加入</span><br><span class="line">......</span><br><span class="line">处理所有文章结束</span><br></pre></td></tr></table></figure><p></p><p>可以看到我最新写的文章<code>D:\Blog\bolg5\source\_posts\MyApplications\HexoTools\java自动生成HexoFontMatter.md</code>已经处理完毕。其他文章已经有front-matter程序不在添加。</p><p>使用方案2的好处就是我只管复制路径，然后调用程序，或者调用程序(默认)即可。而使用命令行参数的话还需要粘贴一次。<br>本次优化到此结束。<br>整个程序的代码为：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> front.matter.tools;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FilenameFilter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="keyword">import</span> clipboard.util.SysClipboardUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HexoAddFrontMatterAllInDir</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">String dirPath = SysClipboardUtil.getSysClipboardText();</span><br><span class="line">File file=<span class="keyword">new</span> File(dirPath);</span><br><span class="line"><span class="keyword">if</span>(file.isDirectory()||file.isFile())</span><br><span class="line">&#123;</span><br><span class="line">dealDir(dirPath);</span><br><span class="line">System.out.println(<span class="string">"遍历结束"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果剪贴板没有东西就默认对所有的文章进行处理</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 默认的博客文章地址</span></span><br><span class="line">String defaultPath = <span class="string">"D:\\Blog\\bolg5\\source\\_posts"</span>;</span><br><span class="line">dealDir(defaultPath);</span><br><span class="line">System.out.println(<span class="string">"处理所有文章结束"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对该目录下的所有markdown文档加Front-matter首部</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dirpath</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dealDir</span><span class="params">(String dirpath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">File dirFile = <span class="keyword">new</span> File(dirpath);</span><br><span class="line"><span class="comment">// 如果是文件夹的话</span></span><br><span class="line"><span class="keyword">if</span> (dirFile.isDirectory())</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取md文件，或者是目录的列表</span></span><br><span class="line">File[] fileList = dirFile.listFiles(<span class="keyword">new</span> FilenameFilter()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 如果是markdown文件的话</span></span><br><span class="line"><span class="keyword">if</span> (name.endsWith(<span class="string">".md"</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 如果是一个目录的话</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">new</span> File(dir, name).isDirectory())</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 其他不相关的文件不返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (File file : fileList)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 输出正在处理的文件名</span></span><br><span class="line"><span class="comment">// System.out.println(file.getAbsolutePath());</span></span><br><span class="line"><span class="comment">// 如果是文件的话</span></span><br><span class="line"><span class="keyword">if</span> (file.isFile())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 在文章首部添加文件首部</span></span><br><span class="line">addIfHasNotFrontMatter(file);</span><br><span class="line"><span class="comment">// 更新文章首部，使用最近修改的时间作为文章的创建时间</span></span><br><span class="line"><span class="comment">// updateIfHasFrontMatter(file);</span></span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="comment">// 递归调用下层目录</span></span><br><span class="line">dealDir(file.getAbsolutePath());</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果是markdown文件的话也可以直接使用进行首部追加</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (dirFile.isFile() &amp;&amp; dirFile.getAbsolutePath().endsWith(<span class="string">".md"</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 在文章首部添加文件首部</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">addIfHasNotFrontMatter(dirFile);</span><br><span class="line">&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> FileNotFoundException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addIfHasNotFrontMatter</span><span class="params">(File file)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> UnsupportedEncodingException, FileNotFoundException,</span></span><br><span class="line"><span class="function">IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">addIfHasNotFrontMatter(file.getAbsolutePath());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> FileNotFoundException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addIfHasNotFrontMatter</span><span class="params">(String path)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> UnsupportedEncodingException, FileNotFoundException,</span></span><br><span class="line"><span class="function">IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">File file = <span class="keyword">new</span> File(path);</span><br><span class="line"><span class="comment">// 如果是markdown文档</span></span><br><span class="line"><span class="keyword">if</span> (file.isFile() &amp;&amp; path.endsWith(<span class="string">".md"</span>))</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件到文章缓冲article中</span></span><br><span class="line">StringBuilder article = readFile(file);</span><br><span class="line"><span class="comment">// 如果在文章中没有发现首部存在</span></span><br><span class="line"><span class="keyword">if</span> (!hasFrontMatter(article))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 就添加首部</span></span><br><span class="line">StringBuilder frontmatter = createFrontMatter(file);</span><br><span class="line"><span class="comment">// 然后在正文前面首部</span></span><br><span class="line">article.insert(<span class="number">0</span>, frontmatter);</span><br><span class="line"><span class="comment">// 处理结果写回该文件</span></span><br><span class="line">writeFile(file, article);</span><br><span class="line">System.out.println(<span class="string">"处理完成:"</span> + path);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"已经存在首部了，不再重复加入"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> FileNotFoundException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">updateIfHasFrontMatter</span><span class="params">(File file)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> UnsupportedEncodingException, FileNotFoundException,</span></span><br><span class="line"><span class="function">IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">updateIfHasFrontMatter(file.getAbsolutePath());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> FileNotFoundException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">updateIfHasFrontMatter</span><span class="params">(String path)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> UnsupportedEncodingException, FileNotFoundException,</span></span><br><span class="line"><span class="function">IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">File file = <span class="keyword">new</span> File(path);</span><br><span class="line"><span class="comment">// 如果是markdown文档</span></span><br><span class="line"><span class="keyword">if</span> (file.isFile() &amp;&amp; path.endsWith(<span class="string">".md"</span>))</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件到文章缓冲article中</span></span><br><span class="line">StringBuilder article = readFile(file);</span><br><span class="line"><span class="comment">// 从文章中移除原来的首部</span></span><br><span class="line">removeOldFrontMatter(article);</span><br><span class="line"><span class="comment">// 根据文件名生成新的首部</span></span><br><span class="line">StringBuilder frontmatter = createFrontMatter(file);</span><br><span class="line"><span class="comment">// 然后在正文前面首部</span></span><br><span class="line">article.insert(<span class="number">0</span>, frontmatter);</span><br><span class="line"><span class="comment">// 处理结果写回该文件</span></span><br><span class="line">writeFile(file, article);</span><br><span class="line">System.out.println(<span class="string">"更新首部："</span> + path);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> article</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> FileNotFoundException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeFile</span><span class="params">(File file, StringBuilder article)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> UnsupportedEncodingException, FileNotFoundException,</span></span><br><span class="line"><span class="function">IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BufferedWriter writer = <span class="keyword">new</span> BufferedWriter(</span><br><span class="line"><span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(file), <span class="string">"utf-8"</span>));</span><br><span class="line">writer.write(article.toString());</span><br><span class="line">writer.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title">createFrontMatter</span><span class="params">(File file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">String path = file.getAbsolutePath();</span><br><span class="line"><span class="comment">// 生成首部</span></span><br><span class="line">StringBuilder frontmatter = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">String filename = file.getName();</span><br><span class="line"><span class="comment">// 获取不含后缀的文件名,作为未标题</span></span><br><span class="line">String title = filename.substring(<span class="number">0</span>, filename.length() - <span class="number">3</span>);</span><br><span class="line">frontmatter.append(<span class="string">"title: "</span> + title);</span><br><span class="line"><span class="comment">// 获取子目录列表</span></span><br><span class="line"><span class="keyword">int</span> categoriesStart = path.indexOf(<span class="string">"\\source\\_posts"</span>)</span><br><span class="line">+ <span class="string">"\\source\\_posts"</span>.length();</span><br><span class="line"><span class="keyword">int</span> categoriesEnd = path.indexOf(filename) - <span class="number">1</span>;</span><br><span class="line">String categoriesStr = path.substring(categoriesStart, categoriesEnd);</span><br><span class="line">categoriesStr = categoriesStr.replaceAll(<span class="string">"\\\\"</span>, <span class="string">"\n- "</span>);</span><br><span class="line">frontmatter.append(<span class="string">"\ncategories: "</span> + categoriesStr);</span><br><span class="line"><span class="comment">// 生成时间项</span></span><br><span class="line">SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(</span><br><span class="line"><span class="string">"yyyy-MM-dd HH:mm:ss"</span>);<span class="comment">// 使用24小时制</span></span><br><span class="line">Date date = <span class="keyword">new</span> Date(file.lastModified());</span><br><span class="line">frontmatter.append(<span class="string">"\ndate: "</span> + dateFormat.format(date));</span><br><span class="line">frontmatter.append(<span class="string">"\n---\n"</span>);<span class="comment">// 加入frontmatter首部</span></span><br><span class="line"><span class="keyword">return</span> frontmatter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> builder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeOldFrontMatter</span><span class="params">(StringBuilder builder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 检查文章中是否有首部</span></span><br><span class="line">Pattern hasFrontMatter = Pattern.compile(<span class="string">"(?:---\\n)?(?:.*\\n)+---\\n"</span>);</span><br><span class="line"><span class="comment">// System.out.println("使用的正则表达式:" + hasFrontMatter);</span></span><br><span class="line">Matcher matcherFrontMatter = hasFrontMatter.matcher(builder);</span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 从文章首部开始匹配，匹配到了就不再匹配</span></span><br><span class="line"><span class="keyword">if</span> (matcherFrontMatter.lookingAt())</span><br><span class="line">&#123;</span><br><span class="line">start = matcherFrontMatter.start();</span><br><span class="line">end = matcherFrontMatter.end();</span><br><span class="line"><span class="comment">// 移除首部</span></span><br><span class="line">builder.delete(start, end);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> builder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasFrontMatter</span><span class="params">(StringBuilder builder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 检查文章中是否有首部</span></span><br><span class="line">Pattern hasFrontMatter = Pattern.compile(<span class="string">"(?:---\\n)?(?:.*\\n)+---\\n"</span>);</span><br><span class="line">Matcher matcherFrontMatter = hasFrontMatter.matcher(builder);</span><br><span class="line"><span class="keyword">return</span> matcherFrontMatter.lookingAt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> builder</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> FileNotFoundException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title">readFile</span><span class="params">(File file)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> UnsupportedEncodingException, FileNotFoundException,</span></span><br><span class="line"><span class="function">IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="number">5000</span>);</span><br><span class="line"><span class="comment">// 先把文章读入缓冲中</span></span><br><span class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(</span><br><span class="line"><span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(file), <span class="string">"utf-8"</span>));</span><br><span class="line">String line = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 一行一行的读取</span></span><br><span class="line"><span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">builder.append(line + <span class="string">"\n"</span>);<span class="comment">// 添加到缓冲中</span></span><br><span class="line">&#125;</span><br><span class="line">reader.close();<span class="comment">// 关闭文件</span></span><br><span class="line"><span class="keyword">return</span> builder;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>依赖代码：</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/c91be9a9/">使用java给Hexo博客内文章生成HexoFrontMatter</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 我的软件 </category>
          
          <category> Hexo博客工具程序 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>30个要点帮你完成java代码优化</title>
      <link href="/blog/5ab73df2/"/>
      <url>/blog/5ab73df2/</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Nov 11 2018 22:42:16 GMT+0800 (中国标准时间) --><p>本文转载自：<a href="https://www.cnblogs.com/zhaoyan001/p/6078196.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhaoyan001/p/6078196.html</a></p><p>通过java代码规范来优化程序，优化内存使用情况，防止内存泄露</p><p><strong>可供程序利用的资源（内存、CPU时间、网络带宽等）是有限的，优化的目的就是让程序用尽可能少的资源完成预定的任务。</strong><br><strong>优化通常包含两方面的内容：</strong></p><ul><li>减小代码的体积</li><li>提高代码的运行效率。</li></ul><p><strong>本文讨论的主要是如何提高代码的效率。</strong></p><p>在Java程序中，性能问题的大部分原因并不在于Java语言，而是在于程序本身。养成好的代码编写习惯非常重要，比如正确地、巧妙地运用java.lang.String类和java.util.Vector类，它能够显著地提高程序的性能。下面我们就来具体地分析一下这方面的问题。</p><p><strong>1、 尽量指定类的final修饰符 带有final修饰符的类是不可派生的</strong></p><p>在Java核心API中，有许多应用final的例子，例如java.lang.String。为String类指定final防止了人们覆盖length()方法。另外，<strong>如果指定一个类为final，则该类所有的方法都是final。Java编译器会寻找机会内联（inline）所有的final方法（这和具体的编译器实现有关）。此举能够使性能平均提高50% 。</strong></p><p><strong>2、 尽量重用对象</strong></p><p>特别是String 对象的使用中，<strong>频繁出现字符串连接情况时应用StringBuffer 代替</strong>。由于系统不仅要花时间生成对象，以后可能还需花时间对这些对象进行垃圾回收和处理。因此，生成过多的对象将会给程序的性能带来很大的影响。</p><p><strong>3、 尽量使用局部变量</strong></p><p>调用方法时传递的参数以及在调用中创建的临时变量都保存在栈（Stack）中，速度较快。<br>其他变量，如静态变量、实例变量等，都在堆（Heap）中创建，速度较慢。另外，依赖于具体的编译器/JVM，局部变量还可能得到进一步优化。请参见《尽可能使用堆栈变量》。</p><p><strong>4、 不要重复初始化变量</strong><br>默认情况下，调用类的构造函数时， Java会把变量初始化成确定的值：所有的对象被设置成null，整数变量（byte、short、int、long）设置成0，float和double变量设置成0.0，逻辑值设置成false。当一个类从另一个类派生时，这一点尤其应该注意，因为用new关键词创建一个对象时，构造函数链中的所有构造函数都会被自动调用。</p><p>5、 在JAVA + ORACLE 的应用系统开发中，java中内嵌的SQL语句尽量使用大写的形式，以减轻ORACLE解析器的解析负担。</p><p>6、 Java 编程过程中，进行数据库连接、I/O流操作时务必小心，在使用完毕后，及时关闭以释放资源。<br>因为对这些大对象的操作会造成系统大的开销，稍有不慎，会导致严重的后果。</p><p>7、 由于JVM的有其自身的GC机制，不需要程序开发者的过多考虑，从一定程度上减轻了开发者负担，但同时也遗漏了隐患，过分的创建对象会消耗系统的大量内存，严重时会导致内存泄露，因此，保证过期对象的及时回收具有重要意义。</p><p><strong>JVM回收垃圾的条件是：对象不在被引用；</strong>然而，JVM的GC并非十分的机智，即使对象满足了垃圾回收的条件也不一定会被立即回收。<strong>所以，建议我们在对象使用完毕，应手动置成null。</strong></p><p><strong>8、 在使用同步机制时，应尽量使用方法同步代替代码块同步。</strong><br>这里就有问题了，为什么我看有的文章说尽量使用同步代码块？</p><p><strong>9、 尽量减少对变量的重复计算</strong><br>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; list.size; i ++) &#123;</span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应替换为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,<span class="keyword">int</span> len = list.size();i &lt; len; i ++)</span><br><span class="line">&#123;</span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>10、尽量采用懒加载的策略，即在需要的时候才开始创建。</strong></p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = “aaa”;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">1</span>) &#123;</span><br><span class="line">list.add(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应替换为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i == <span class="number">1</span>) </span><br><span class="line">&#123;</span><br><span class="line">    String str = “aaa”;</span><br><span class="line">    list.add(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>11、慎用异常</strong></p><p>异常对性能不利。抛出异常首先要创建一个新的对象。<code>Throwable</code>接口的构造函数调用名为<code>fillInStackTrace()</code>的本地（<code>Native</code>）方法，<code>fillInStackTrace()</code>方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，<code>VM</code>就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。<strong> 异常只能用于错误处理，不应该用来控制程序流程。</strong></p><p><strong>12、不要在循环中使用：Try {} catch() {}应把其放置在最外层。</strong></p><p>13、<code>StringBuffer</code> 的使用：</p><p><code>StringBuffer</code>表示了可变的、可写的字符串。<br>有三个构造方法 :<br><code>StringBuffer();</code> //默认分配16个字符的空间<br><code>StringBuffer (int size);</code> //分配size个字符的空间<br><code>StringBuffer (String str);</code> //分配16个字符+str.length()个字符空间<br>你可以通过<code>StringBuffer</code>的构造函数来设定它的初始化容量，这样可以明显地提升性能。</p><p>这里提到的构造函数是<code>StringBuffer(int length)</code>，<code>length</code>参数表示当前的<code>StringBuffer</code>能保持的字符数量。你也可以使用<code>ensureCapacity(int minimumcapacity)</code>方法在<code>StringBuffer</code>对象创建之后设置它的容量。首先我们看看<code>StringBuffer</code>的缺省行为，然后再找出一条更好的提升性能的途径。</p><p><code>StringBuffer</code>在内部维护一个字符数组，当你使用缺省的构造函数来创建<code>StringBuffer</code>对象的时候，<strong>因为没有设置初始化字符长度，<code>StringBuffer</code>的容量被初始化为16个字符</strong>，也就是说缺省容量就是<code>16</code>个字符。<strong>当<code>StringBuffer</code>达到最大容量的时候，它会将自身容量增加到当前的2倍再加2，也就是（2*旧值+2）</strong>。如果你使用缺省值，初始化之后接着往里面追加字符，在你追加到第16个字符的时候它会将容量增加到34（2<em>16+2），当追加到34个字符的时候就会将容量增加到70（2</em>34+2）。无论何时只要<code>StringBuffer</code>到达它的最大容量它就不得不创建一个新的字符数组然后重新将旧字符和新字符都拷贝一遍――这也太昂贵了点。所以总是给<code>StringBuffer</code>设置一个合理的初始化容量值是错不了的，这样会带来立竿见影的性能增益。<code>StringBuffer</code>初始化过程的调整的作用由此可见一斑。所以，</p><p><strong>使用一个合适的容量值来初始化StringBuffer永远都是一个最佳的建议。</strong></p><p>14、合理的使用Java类 java.util.Vector。</p><p>简单地说，一个Vector就是一个java.lang.Object实例的数组。Vector与数组相似，它的元素可以通过整数形式的索引访问。但是，Vector类型的对象在创建之后，对象的大小能够根据元素的增加或者删除而扩展、缩小。请考虑下面这个向Vector加入元素的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object bj = <span class="keyword">new</span> Object();</span><br><span class="line">Vector v = <span class="keyword">new</span> Vector(<span class="number">100000</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> I=<span class="number">0</span>;I&lt;<span class="number">100000</span>; I++)</span><br><span class="line">&#123; </span><br><span class="line">    v.add(<span class="number">0</span>,obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除非有绝对充足的理由要求每次都把新元素插入到Vector的前面，否则上面的代码对性能不利。在默认构造函数中，Vector的初始存储能力是10个元素，如果新元素加入时存储能力不足，则以后存储能力每次加倍。Vector类就对象StringBuffer类一样，每次扩展存储能力时，所有现有的元素都要复制到新的存储空间之中。下面的代码片段要比前面的例子快几个数量级：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object bj = <span class="keyword">new</span> Object();</span><br><span class="line">Vector v = <span class="keyword">new</span> Vector(<span class="number">100000</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> I=<span class="number">0</span>; I&lt;<span class="number">100000</span>; I++) </span><br><span class="line">&#123; </span><br><span class="line">    v.add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的规则也适用于Vector类的remove()方法。<strong>由于Vector中各个元素之间不能含有“空隙”，删除除最后一个元素之外的任意其他元素都导致被删除元素之后的元素向前移动，也就是说，从Vector删除最后一个元素要比删除第一个元素“开销”低好几倍。</strong></p><p>假设要从前面的Vector删除所有元素，我们可以使用这种代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> I=<span class="number">0</span>; I&lt;<span class="number">100000</span>; I++)</span><br><span class="line">&#123;</span><br><span class="line">v.remove(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，与下面的代码相比，前面的代码要慢几个数量级：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> I=<span class="number">0</span>; I&lt;<span class="number">100000</span>; I++)</span><br><span class="line">&#123;</span><br><span class="line">v.remove(v.size()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>Vector</code>类型的对象<code>v</code>删除所有元素的最好方法是：<br><code>v.removeAllElements();</code></p><p>假设<code>Vector</code>类型的对象<code>v</code>包含字符串“<code>Hello</code>”。考虑下面的代码，它要从这个<code>Vector</code>中删除“<code>Hello</code>”字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">int</span> i = v.indexOf(s);</span><br><span class="line"><span class="keyword">if</span>(I != -<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    v.remove(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些代码看起来没什么错误，但它同样对性能不利。在这段代码中，<code>indexOf()</code>方法对<code>v</code>进行顺序搜索寻找字符串“<code>Hello</code>”，<code>remove(s)</code>方法也要进行同样的顺序搜索。改进之后的版本是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">int</span> index = v.indexOf(s);</span><br><span class="line"><span class="keyword">if</span>(index != -<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    v.remove(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个版本中我们直接在<code>remove()</code>方法中给出待删除元素的精确索引位置，从而避免了第二次搜索。一个更好的版本是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"Hello"</span>; v.remove(s);</span><br></pre></td></tr></table></figure><p>最后，我们再来看一个有关<code>Vector</code>类的代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> I=<span class="number">0</span>; I++;I &lt; v.length)</span><br></pre></td></tr></table></figure><p>如果<code>v</code>包含100,000个元素，这个代码片段将调用<code>v.size()</code>方法100,000次。虽然<code>size</code>方法是一个简单的方法，但它仍旧需要一次方法调用的开销，至少<code>JVM</code>需要为它配置以及清除堆栈环境。在这里，<code>for</code>循环内部的代码不会以任何方式修改<code>Vector</code>类型对象<code>v</code>的大小，因此上面的代码最好改写成下面这种形式：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> size = v.size(),<span class="keyword">int</span> I=<span class="number">0</span>; I++;I&lt;size)</span><br></pre></td></tr></table></figure><p></p><p>虽然这是一个简单的改动，但它仍旧赢得了性能。毕竟，每一个<code>CPU</code>周期都是宝贵的。</p><p><strong>15、当复制大量数据时，使用<code>System.arraycopy()</code>命令。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] src=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] dest = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>];</span><br><span class="line">System.arraycopy(src, <span class="number">0</span>, dest, <span class="number">0</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>src:源数组; srcPos:源数组要复制的起始位置;<br>dest:目的数组; destPos:目的数组放置的起始位置;<br>length:复制的长度.</p><p>注意：src and dest都必须是同类型或者可以进行转换类型的数组．</p><p><strong>16、代码重构：增强代码的可读性。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShopCart</span> </span></span><br><span class="line"><span class="class">   </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> List carts ;</span><br><span class="line">        …</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span> <span class="params">(Object item)</span> </span></span><br><span class="line"><span class="function">       </span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(carts == <span class="keyword">null</span>) </span><br><span class="line">           &#123;</span><br><span class="line">               carts = <span class="keyword">new</span> ArrayList();</span><br><span class="line">           &#125;</span><br><span class="line">           crts.add(item);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object item)</span> </span></span><br><span class="line"><span class="function">       </span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(carts. contains(item)) </span><br><span class="line">           &#123;</span><br><span class="line">               carts.remove(item);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> List <span class="title">getCarts</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">       </span>&#123;</span><br><span class="line">           <span class="comment">//返回只读列表</span></span><br><span class="line">           <span class="keyword">return</span> Collections.unmodifiableList(carts);</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       <span class="comment">//不推荐这种方式</span></span><br><span class="line">       <span class="comment">//this.getCarts().add(item);</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>17、不用new关键词创建类的实例</strong></p><p>用<code>new</code>关键词创建类的实例时，构造函数链中的所有构造函数都会被自动调用。但如果一个对象实现了<code>Cloneable</code>接口，我们可以调用它的<code>clone()</code>方法。<code>clone()</code>方法不会调用任何类构造函数。</p><p>在使用设计模式（<code>Design Pattern</code>）的场合，如果用<code>Factory</code>模式创建对象，则改用<code>clone()</code>方法创建新的对象实例非常简单。例如，下面是<code>Factory</code>模式的一个典型实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Credit <span class="title">getNewCredit</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Credit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改进后的代码使用<code>clone()</code>方法，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Credit BaseCredit = <span class="keyword">new</span> Credit();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Credit <span class="title">getNewCredit</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Credit) BaseCredit.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的思路对于数组处理同样很有用。</p><p><strong>18、对于2的整数倍的乘法和除法用移位操作替代</strong></p><p>考虑下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (val = <span class="number">0</span>; val &lt; <span class="number">100000</span>; val +=<span class="number">5</span>) </span><br><span class="line">&#123;</span><br><span class="line">    alterX = val * <span class="number">8</span>; myResult = val * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用移位操作替代乘法操作可以极大地提高性能。下面是修改后的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (val = <span class="number">0</span>; val &lt; <span class="number">100000</span>; val += <span class="number">5</span>) </span><br><span class="line">&#123;</span><br><span class="line">    alterX = val &lt;&lt; <span class="number">3</span>; myResult = val &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的代码不再做乘以8的操作，而是改用等价的左移3位操作<strong>，每左移1位相当于乘以2。相应地，右移1位操作相当于除以2。</strong>值得一提的是，虽然移位操作速度快，但可能使代码比较难于理解，所以最好加上一些注释。</p><p><strong>19、在JSP页面中关闭无用的会话。</strong></p><p><strong>一个常见的误解是以为session在有客户端访问时就被创建，然而事实是直到某server端程序调用HttpServletRequest.getSession(true)这样的语句时才被创建</strong>，注意如果JSP没有显示的使用 &lt;&gt; 关闭session，则JSP文件在编译成Servlet时将会自动加上这样一条语句<code>HttpSession session = HttpServletRequest.getSession(true);</code>这也是JSP中隐含的session对象的来历。<strong>由于session会消耗内存资源，因此，如果不打算使用session，应该在所有的JSP中关闭它。</strong><br>对于那些无需跟踪会话状态的页面，关闭自动创建的会话可以节省一些资源。使用如下page指令：<code>&lt;%@ page session=&quot;false&quot;%&gt;</code></p><p><strong>20、JDBC与I/O</strong></p><p>如果应用程序需要访问一个规模很大的数据集，则应当考虑使用块提取方式。<strong>默认情况下，JDBC每次提取32行数据</strong>。举例来说，假设我们要遍历一个5000行的记录集，JDBC必须调用数据库157次才能提取到全部数据。如果把块大小改成512，则调用数据库的次数将减少到10次。</p><p><strong>21、Servlet与内存使用</strong><br>许多开发者随意地把大量信息保存到用户会话之中。<strong>一些时候，保存在会话中的对象没有及时地被垃圾回收机制回收</strong>。从性能上看，典型的症状是用户感到系统周期性地变慢，却又不能把原因归于任何一个具体的组件。如果监视JVM的堆空间，它的表现是内存占用不正常地大起大落。<br>解决这类内存问题主要有二种办法。<strong>第一种办法是，在所有作用范围为会话的Bean中实现<code>HttpSessionBindingListener</code>接口。这样，只要实现valueUnbound()方法，就可以显式地释放Bean使用的资源</strong>。</p><p><strong>另外一种办法就是尽快地把会话作废</strong>。大多数应用服务器都有设置会话作废间隔时间的选项。另外，也可以用编程的方式调用会话的setMaxInactiveInterval()方法，该方法用来设定在作废会话之前，Servlet容器允许的客户请求的最大间隔时间，以秒计。</p><p><strong>22、使用缓冲标记</strong></p><p>一些应用服务器加入了面向JSP的缓冲标记功能。例如，BEA的WebLogic Server从6.0版本开始支持这个功能，Open Symphony工程也同样支持这个功能。JSP缓冲标记既能够缓冲页面片断，也能够缓冲整个页面。当JSP页面执行时，如果目标片断已经在缓冲之中，则生成该片断的代码就不用再执行。页面级缓冲捕获对指定URL的请求，并缓冲整个结果页面。对于购物篮、目录以及门户网站的主页来说，这个功能极其有用。对于这类应用，页面级缓冲能够保存页面执行的结果，供后继请求使用。</p><p>23、选择合适的引用机制</p><p>在典型的JSP应用系统中，页头、页脚部分往往被抽取出来，然后根据需要引入页头、页脚。当前，在JSP页面中引入外部资源的方法主要有两种：include指令，以及include动作。<br>include指令：例如&lt;%@ include file=”copyright.html” %&gt;。该指令在编译时引入指定的资源。在编译之前，带有include指令的页面和指定的资源被合并成一个文件。被引用的外部资源在编译时就确定，比运行时才确定资源更高效。<br>include动作：例如&lt;jsp:include page=”copyright.jsp” /&gt;。该动作引入指定页面执行后生成的结果。由于它在运行时完成，因此对输出结果的控制更加灵活。但时，只有当被引用的内容频繁地改变时，或者在对主页面的请求没有出现之前，被引用的页面无法确定时，使用include动作才合算。</p><p>24、及时清除不再需要的会话</p><p>为了清除不再活动的会话，许多应用服务器都有默认的会话超时时间，一般为30分钟。当应用服务器需要保存更多会话时，如果内存容量不足，操作系统会把部分内存数据转移到磁盘，应用服务器也可能根据“最近最频繁使用”（Most Recently Used）算法把部分不活跃的会话转储到磁盘，甚至可能抛出“内存不足”异常。在大规模系统中，串行化会话的代价是很昂贵的。当会话不再需要时，应当及时调用HttpSession.invalidate()方法清除会话。HttpSession.invalidate()方法通常可以在应用的退出页面调用。</p><p>25、不要将数组声明为：public static final 。</p><p>26、HashMap的遍历效率讨论</p><p>经常遇到对HashMap中的key和value值对的遍历操作，有如下两种方法：<br>Map&lt;String, String[]&gt; paraMap = new HashMap&lt;String, String[]&gt;();<br>//第一个循环<br>Set<string>appFieldDefIds = paraMap.keySet();<br>for (String appFieldDefId : appFieldDefIds) {<br>String[] values = paraMap.get(appFieldDefId);<br>……<br>}</string></p><p>//第二个循环<br>for(Entry&lt;String, String[]&gt; entry : paraMap.entrySet()){<br>String appFieldDefId = entry.getKey();<br>String[] values = entry.getValue();<br>…….<br>}<br>第一种实现明显的效率不如第二种实现。<br>分析如下 Set<string>appFieldDefIds = paraMap.keySet(); 是先从HashMap中取得keySet<br>代码如下：<br>public Set<k>keySet() {<br>Set<k>ks = keySet;<br>return (ks != null ? ks : (keySet = new KeySet()));<br>}</k></k></string></p><p>private class KeySet extends AbstractSet<k>{<br>public Iterator<k>iterator() {<br>return newKeyIterator();<br>}<br>public int size() {<br>return size;<br>}<br>public boolean contains(Object o) {<br>return containsKey(o);<br>}<br>public boolean remove(Object o) {<br>return HashMap.this.removeEntryForKey(o) != null;<br>}<br>public void clear() {<br>HashMap.this.clear();<br>}<br>}</k></k></p><p>其实就是返回一个私有类KeySet, 它是从AbstractSet继承而来，实现了Set接口。</p><p>再来看看for/in循环的语法<br>for(declaration : expression)<br>statement</p><p>在执行阶段被翻译成如下各式<br>for(Iterator<e>#i = (expression).iterator(); #i.hashNext();){<br>declaration = #i.next();<br>statement<br>}</e></p><p>因此在第一个for语句for (String appFieldDefId : appFieldDefIds) 中调用了HashMap.keySet().iterator()</p><p>而这个方法调用了newKeyIterator()</p><p>Iterator<k>newKeyIterator() {<br>return new KeyIterator();<br>}<br>private class KeyIterator extends HashIterator<k>{<br>public K next() {<br>return nextEntry().getKey();<br>}<br>}</k></k></p><p>所以在for中还是调用了<br>在第二个循环for(Entry&lt;String, String[]&gt; entry : paraMap.entrySet())中使用的Iterator是如下的一个内部</p><p>类</p><p>private class EntryIterator extends HashIterator&lt;Map.Entry&lt;K,V&gt;&gt; {<br>public Map.Entry&lt;K,V&gt; next() {<br>return nextEntry();<br>}<br>}</p><p>此时第一个循环得到key，第二个循环得到HashMap的Entry效率就是从循环里面体现出来的第二个循环此致可以直接取key和value值而第一个循环还是得再利用HashMap的get(Object key)来取value值现在看看HashMap的get(Object key)方法<br>public V get(Object key) {<br>Object k = maskNull(key);<br>int hash = hash(k);<br>int i = indexFor(hash, table.length); //Entry[] table<br>Entry&lt;K,V&gt; e = table;<br>while (true) {<br>if (e == null)<br>return null;<br>if (e.hash == hash &amp;&amp; eq(k, e.key))<br>return e.value;<br>e = e.next;<br>}<br>}<br>其实就是再次利用Hash值取出相应的Entry做比较得到结果，所以使用第一中循环相当于两次进入HashMap的Entry</p><p>中而第二个循环取得Entry的值之后直接取key和value，效率比第一个循环高。其实按照Map的概念来看也应该是用第二个循环好一点，它本来就是key和value的值对，将key和value分开操作在这里不是个好选择。</p><p>27、array(数组) 和 ArryList的使用</p><p>array（[]）：最高效；但是其容量固定且无法动态改变；<br>ArrayList：容量可动态增长；但牺牲效率；<br>基于效率和类型检验，应尽可能使用array，无法确定数组大小时才使用ArrayList！<br>ArrayList是Array的复杂版本<br>ArrayList内部封装了一个Object类型的数组，从一般的意义来说，它和数组没有本质的差别，甚至于ArrayList的许多方法，如Index、IndexOf、Contains、Sort等都是在内部数组的基础上直接调用Array的对应方法。<br>ArrayList存入对象时，抛弃类型信息，所有对象屏蔽为Object，编译时不检查类型，但是运行时会报错。<br>注：jdk5中加入了对泛型的支持，已经可以在使用ArrayList时进行类型检查。<br>从这一点上看来，ArrayList与数组的区别主要就是由于动态增容的效率问题了</p><p>28、尽量使用HashMap 和ArrayList ,除非必要，否则不推荐使用HashTable和Vector ，后者由于使用同步机制，而导致了性能的开销。</p><p>29、StringBuffer 和StringBuilder的区别：</p><p>java.lang.StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。</p><p>StringBuilder。与该类相比，通常应该优先使用 java.lang.StringBuilder类，因为它支持所有相同的操作，但由于它不执行同步，所以速度更快。为了获得更好的性能，在构造 StirngBuffer 或 StirngBuilder 时应尽可能指定它的容量。当然，如果你操作的字符串长度不超过 16 个字符就不用了。 相同情况下使用 StirngBuilder 相比使用 StringBuffer 仅能获得 10%-15% 左右的性能提升，但却要冒多线程不安全的风险。而在现实的模块化编程中，负责某一模块的程序员不一定能清晰地判断该模块是否会放入多线程的环境中运行，因此：除非你能确定你的系统的瓶颈是在 StringBuffer 上，并且确定你的模块不会运行在多线程模式下，否则还是用 StringBuffer 吧。</p><p>30、尽量避免使用split</p><p>除非是必须的，否则应该避免使用split，split由于支持正则表达式，所以效率比较低，如果是频繁的几十，几百万的调用将会耗费大量资源，如果确实需要频繁的调用split，可以考虑使用apache的 StringUtils.split(string,char)，频繁split的可以缓存结果。</p><p>其他补充:</p><p>1、及时清除不再使用的对象，设为null<br>2、尽可能使用final,static等关键字<br>3、尽可能使用buffered对象</p><p>如何优化代码使JAVA源文件及编译后CLASS文件更小<br>1 尽量使用继承，继承的方法越多，你要写的代码量也就越少<br>2 打开JAVA编译器的优化选项： javac -O 这个选项将删除掉CLASS文件中的行号，并能把<br>一些private, static,final的小段方法申明为inline方法调用<br>3 把公用的代码提取出来<br>4 不要初始化很大的数组，尽管初始化一个数组在JAVA代码中只是一行的代码量，但<br>编译后的代码是一行代码插入一个数组的元素，所以如果你有大量的数据需要存在数组<br>中的话，可以先把这些数据放在String中，然后在运行期把字符串解析到数组中<br>5 日期类型的对象会占用很大的空间，如果你要存储大量的日期对象，可以考虑把它存储为<br>long型，然后在使用的时候转换为Date类型<br>6 类名，方法名和变量名尽量使用简短的名字，可以考虑使用Hashjava, Jobe, Obfuscate and Jshrink等工具自动完成这个工作<br>7 将static final类型的变量定义到Interface中去<br>8 算术运算 能用左移/右移的运算就不要用*和/运算，相同的运算不要运算多次</p><ol start="2"><li>不要两次初始化变量<br>Java通过调用独特的类构造器默认地初始化变量为一个已知的值。所有的对象被设置成null，integers (byte, short, int, long)被设置成0，float和double设置成0.0，Boolean变量设置成false。这对那些扩展自其它类的类尤其重要，这跟使用一个新的关键词创建一个对象时所有一连串的构造器被自动调用一样。</li><li><p>在任何可能的地方让类为Final<br>标记为final的类不能被扩展。在《核心Java API》中有大量这个技术的例子，诸如java.lang.String。将String类标记为final阻止了开发者创建他们自己实现的长度方法。<br>更深入点说，如果类是final的，所有类的方法也是final的。Java编译器可能会内联所有的方法（这依赖于编译器的实现）。在我的测试里，我已经看到性能平均增加了50%。</p></li><li><p>异常在需要抛出的地方抛出，try catch能整合就整合<br>try {<br>some.method1(); // Difficult for javac<br>} catch( method1Exception e ) { // and the JVM runtime<br>// Handle exception 1 // to optimize this<br>} // code<br>try {<br>some.method2();<br>} catch( method2Exception e ) {<br>// Handle exception 2<br>}</p></li></ol><p>try {<br>some.method3();<br>} catch( method3Exception e ) {<br>// Handle exception 3<br>}<br>已下代码 更容易被编译器优化<br>try {<br>some.method1(); // Easier to optimize<br>some.method2();<br>some.method3();<br>} catch( method1Exception e ) {<br>// Handle exception 1<br>} catch( method2Exception e ) {<br>// Handle exception 2<br>} catch( method3Exception e ) {<br>// Handle exception 3<br>}</p><ol start="10"><li>For循环的优化<br>Replace…<br>for( int i = 0; i &lt; collection.size(); i++ ) {<br>…<br>}</li></ol><p>with…<br>for( int i = 0, n = collection.size(); i &lt; n; i++ ) {<br>…<br>}</p><p><strong>5、 在JAVA + ORACLE 的应用系统开发中，java中内嵌的SQL语句尽量使用大写的形式，以减轻ORACLE解析器的解析负担。</strong></p><p>10、尽量采用lazy loading 的策略，即在需要的时候才开始创建。<br>例如： String str = “aaa”;<br>if(i == 1) {<br>list.add(str);<br>}<br>应替换为：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">1</span>) &#123;</span><br><span class="line">String str = “aaa”;</span><br><span class="line">list.add(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>12、不要在循环中使用：<br>Try {<br>} catch() {<br>}<br>应把其放置在最外层</p><p>以上所述就是本文的全部内容了，希望能够对大家的java优化有所帮助。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/5ab73df2/">30个要点帮你完成java代码优化</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
