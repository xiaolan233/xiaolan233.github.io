<!-- build time:Tue Nov 13 2018 22:54:45 GMT+0800 (中国标准时间) --><!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="true"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=6.4.0" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple.png?v=6.4.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32.png?v=6.4.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16.png?v=6.4.0"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"6.4.0",sidebar:{position:"right",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="keywords" content="没有关键字"><meta property="og:type" content="website"><meta property="og:title" content="蓝生的博客"><meta property="og:url" content="https://www.lansheng.net.cn/page/19/index.html"><meta property="og:site_name" content="蓝生的博客"><meta property="og:locale" content="zh-CN"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="蓝生的博客"><link rel="alternate" href="/atom.xml" title="蓝生的博客" type="application/atom+xml"><link rel="canonical" href="https://www.lansheng.net.cn/page/19/"><script type="text/javascript" id="page.configurations">CONFIG.page={sidebar:""}</script><title>蓝生的博客</title><noscript><style type="text/css">.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-right page-home"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">蓝生的博客</span> <span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><section id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.lansheng.net.cn/blog/d10c0440/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="蓝生"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="蓝生的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/blog/d10c0440/" itemprop="url">linux下删除目录及其子目录下某种类型文件</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-08-22 11:31:37" itemprop="dateCreated datePublished" datetime="2018-08-22T11:31:37+08:00">2018-08-22</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2018-11-05 17:17:08" itemprop="dateModified" datetime="2018-11-05T17:17:08+08:00">2018-11-05</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/blog/d10c0440/#comments" itemprop="discussionUrl"><span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/blog/d10c0440/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><p>原文：<a href="https://www.cnblogs.com/wyb628/p/7374372.html" target="_blank" rel="noopener">https://www.cnblogs.com/wyb628/p/7374372.html</a></p><p>Linux下，如果想要删除目录及其子目录下某种类型文件，比如说所有的txt文件，则可以使用下面的命令：</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name "*.txt" -type f -print -exec rm -rf &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> find . -name "*.txt" -type f -print -exec rm -rf &#123;&#125; \;</span><br><span class="line">./a.txt</span><br><span class="line">./b.txt</span><br><span class="line">./Java/c.txt</span><br><span class="line">./其他/d.txt</span><br></pre></td></tr></table></figure><p>可以看到，当前目录下的<code>a.txt</code>,<code>b.txt</code>,子目录<code>./Java/</code>下的<code>c.txt</code>，子目录<code>./其他/</code>下的<code>d.txt</code>都被删除掉了。<br></p><div class="post-button text-center"><a class="btn" href="/blog/d10c0440/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.lansheng.net.cn/blog/5e9f32fb/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="蓝生"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="蓝生的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/blog/5e9f32fb/" itemprop="url">Git忽略eclipse中的Java工程</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-08-22 10:20:48" itemprop="dateCreated datePublished" datetime="2018-08-22T10:20:48+08:00">2018-08-22</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2018-11-05 17:17:05" itemprop="dateModified" datetime="2018-11-05T17:17:05+08:00">2018-11-05</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/git教程/" itemprop="url" rel="index"><span itemprop="name">git教程</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/blog/5e9f32fb/#comments" itemprop="discussionUrl"><span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/blog/5e9f32fb/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><p>如果已经添加过了的话，<code>.gitignore</code>是无法过滤的，<br>所以，先删掉版本库吧，好在不是什么重要的代码；<br></p><div class="post-button text-center"><a class="btn" href="/blog/5e9f32fb/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.lansheng.net.cn/blog/2e0f7472/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="蓝生"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="蓝生的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/blog/2e0f7472/" itemprop="url">Java IO流 节点流和处理流</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-08-21 22:26:21" itemprop="dateCreated datePublished" datetime="2018-08-21T22:26:21+08:00">2018-08-21</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2018-11-05 17:17:06" itemprop="dateModified" datetime="2018-11-05T17:17:06+08:00">2018-11-05</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/Java-IO流/" itemprop="url" rel="index"><span itemprop="name">Java IO流</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/blog/2e0f7472/#comments" itemprop="discussionUrl"><span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/blog/2e0f7472/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><ul><li>节点流：可以从或向一个特定的地方（节点）读写数据。如FileReader.</li><li>处理流：是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。如BufferedReader.处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。</li></ul><h2 id="JAVA常用的节点流："><a href="#JAVA常用的节点流：" class="headerlink" title="JAVA常用的节点流：  ##　"></a>JAVA常用的节点流： ##</h2><ul><li>文 件: FileInputStream FileOutputStrean FileReader FileWriter 文件进行处理的节点流。</li><li>字符串: StringReader StringWriter 对字符串进行处理的节点流。</li><li>数 组: ByteArrayInputStream ByteArrayOutputStream CharArrayReader CharArrayWriter 对数组进行处理的节点流（对应的不再是文件，而是内存中的一个数组）。</li><li><p>管 道: PipedInputStream PipedOutputStream PipedReaderPipedWriter对管道进行处理的节点流。</p><div class="post-button text-center"><a class="btn" href="/blog/2e0f7472/#more" rel="contents">阅读全文 &raquo;</a></div></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.lansheng.net.cn/blog/c52cb4ad/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="蓝生"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="蓝生的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/blog/c52cb4ad/" itemprop="url">Java IO流 过滤器流</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-08-21 22:19:08" itemprop="dateCreated datePublished" datetime="2018-08-21T22:19:08+08:00">2018-08-21</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2018-11-05 17:17:06" itemprop="dateModified" datetime="2018-11-05T17:17:06+08:00">2018-11-05</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/Java-IO流/" itemprop="url" rel="index"><span itemprop="name">Java IO流</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/blog/c52cb4ad/#comments" itemprop="discussionUrl"><span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/blog/c52cb4ad/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><p>文件流、字节数组流、管道流等等被称之为原始流，它们提供了对某类数据的输入输出功能。为了在流处理的过程中简化和标准化某一类功能，例如缓冲、压缩、加密、摘要等，Java提供了一系列过滤器类，每组类提供了一种典型的信息处理功能。根据操作对象是字节还是字符，过滤器又分为过滤器流和阅读器/书写器两类，举例如下：</p><ul><li>BufferedInputStream/BufferedOutputStream 提供了字节流的缓冲功能；</li><li>BufferedReader/BufferedWriter 提供了字符流的缓冲功能；</li><li>DataInputStream/DataOutputStream 用来将java的简单数据类型和字符串保存为二进制格式，并从二进制格式读取；</li><li>ZipInputStream/ZipOutputStream 提供了字节流的zip格式压缩功能；</li><li>GZIPInputStream/GZIPOutputStream 提供了字节流的gzip格式压缩功能；</li><li>DigestInputStream/DigestOutputStream 提供了字节流的信息摘要功能；</li><li>CipherInputStream/CipherOutputStream 提供了字节流的加密解密功能；</li></ul><div class="post-button text-center"><a class="btn" href="/blog/c52cb4ad/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.lansheng.net.cn/blog/40aaea03/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="蓝生"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="蓝生的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/blog/40aaea03/" itemprop="url">java网络编程第4版 第1章 基本网络概念</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-08-20 14:35:12" itemprop="dateCreated datePublished" datetime="2018-08-20T14:35:12+08:00">2018-08-20</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2018-11-05 17:17:10" itemprop="dateModified" datetime="2018-11-05T17:17:10+08:00">2018-11-05</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/读书笔记/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/读书笔记/java网络编程第四版/" itemprop="url" rel="index"><span itemprop="name">java网络编程第四版</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/blog/40aaea03/#comments" itemprop="discussionUrl"><span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/blog/40aaea03/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><p>网络是几乎可以实时相互发送和接收数据的计算机和其他设备的集合</p><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>网络中的每台机器称为一个节点(node),</p><h2 id="主机"><a href="#主机" class="headerlink" title="主机"></a>主机</h2><p>具有玩呗功能的计算机节点称为主机(host)<br>用节点指代网络的所有设备，主机指代通用的计算机节点</p><h2 id="分组交换网络"><a href="#分组交换网络" class="headerlink" title="分组交换网络"></a>分组交换网络</h2><p>所有的现代计算机网络都是分组交换网络，流经网络的数据被分割成一个个的小块数据，称为包(packet,也称为分组)</p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>协议(protocol)是定义计算机如何通信的一组明确的规则：包括</p><ul><li>地址格式，</li><li>数据如何分包等</li></ul><p>例如超文本传输协议(Hypertext Transfer Protocol,HTTP)定义了Web浏览器如何与服务器通信</p><h2 id="网络的分层"><a href="#网络的分层" class="headerlink" title="网络的分层"></a>网络的分层</h2><p>在理论生，每一层只与紧挨其上和其下的层对话。<br>将网络分层，这样就可以修改甚至替换某一层的软件，只要层与层之间的接口保持不变，就不会影响到其他层。<br><img src="https://i.imgur.com/nNoT9rR.png" alt=""></p><h2 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a>TCP/IP四层模型</h2><p><img src="https://i.imgur.com/sjwPvWI.png" alt=""></p><h3 id="Web浏览器发送请求过程"><a href="#Web浏览器发送请求过程" class="headerlink" title="Web浏览器发送请求过程"></a>Web浏览器发送请求过程</h3><p>例如，当Web浏览器向Web服务器发送获取网页的请求是，浏览器实际上只与本地客户机上的传输层对话。</p><ul><li>传输层将请求分解为TCP片，向数据添加序列号和校验和，让后将请求(处理后的TCP片)传递给本地网际层。</li><li>网际层根据本地网络所需的大小将各个TCP片分成IP数据报。并传递到主机物理网络层，以便通过线缆传输数据。</li><li>主机物理网络层将数字编码为合适特定物理介质的模拟信号，将请求发送到线缆，目的地址的远程系统的主机网络层可以由此读取请求。</li></ul><p>远程系统的主机物理网络层将模拟信号解码为数字数据，将生成的IP数据包传递给服务器的网际层。<br>网网际层简单的检查IP数据报是否被破坏，如果已经分片则重组数据，然后传递给服务器的传输层。<br>服务器的传输层检查所有的数据是否都已经到达，对于丢失或破坏的部分，则要去重传(这个请求实际上将向下通过服务器的网际层，再通过服务器的主机网络层,回到客户端系统，然后再在客户端系统向上返回客户端的传输层，传输层在通过本地网际层和主机网络层重传前面丢失的数据。所有这些对于应用层是完全透明的)，一旦服务器的传输层接收到足够多的连续顺序数据报，就将这些连续的数据报重组写入一个流，由服务器应用层上运行的Web服务器读取。<br>服务器响应这个请求，再通过服务器系统的各个分层发回响应。通过Internet进行传输并分发给Web客户端。</p><p>可以猜到，实际的过程更为错综复杂。主机网络层是最为复杂的，特意地隐藏了很多细节。例如Internet发送的数据在最终目的地之前，完全有可能经过几个路由器以及相应的分层。可能需要从大气中的无线电波转换为铜线缆中的电子信号，在转换到光缆中的光脉冲，然后再反过来，从光脉冲转换到电子信号再到无线电波。不过，90%的情况下Java代码都将在应用层工作，只需要与传输层对话。其他10%的时间会在传输层处理，与应用层或网际层对话。</p><p><strong>主机网络层的复杂性对你是隐藏的，这是分层模型的关键。</strong></p><h2 id="主机网络层"><a href="#主机网络层" class="headerlink" title="主机网络层"></a>主机网络层</h2><p>在基于IP的Internet(Java唯一真正理解的网络)的标准参考模型中，网络中隐藏的部分数据主机网络层(host-to-work layer,也成链路层，数据链路层或网络接口层)<br>主机网络层，定义了一个特定的网络接口(如以太网卡或WiFi天线)如何通过物理连接想本地网络或世界其他地方发送IP数据报</p><p>Java从来都看不到物理层</p><p>需要考虑网络层和物理层的主要与原因是性能</p><h2 id="网际层"><a href="#网际层" class="headerlink" title="网际层"></a>网际层</h2><p>网际层(internet layer)这个是需要你考虑的第一层，在OSI模型中，网际层使用一个更一般的名字，称为网络层(network layer)。<br>网络层协议定义了数据为和字节如何组织为更大的分组，称为<code>包</code>,还定义了寻址机制，不同计算机要按照这个寻址机制查找对方。<br>忘记协议(IP)是世界上使用最广泛的网络层协议，也是java唯一理解的网络层协议。</p><p>数据按包在网际层上传输，这些包称为数据包(datagram)。每个IPv4数据报包含一个长度为20到60个字节的首部，以及一个包含多大65515字节的有效载荷(payload)。实际上，大多数IPv4数据包都小得多，从几十个字节到大约8K字节不等。<br>IPv6数据报包含一个更大的首部，数据可以多大4G字节。<br>下图展示了各个部分再IPv4数据报是如何排列的，所有为和字节都采用big-endian方式，从左至右为最高位到最低位。<br><img src="https://i.imgur.com/4WPEwkR.png" alt=""><br>除了路由和寻址，网际层的第二个作用是支持不同类型的主机网络层相互对话。Internet路由器会完成WiFi和Ethernet,Ethernet和DSL,DSL和光纤往返等协议之间的转换。如果没有网际层或类似的分层，则每个计算机只能与同一类网络上的其他计算进对话。</p><p>网际层负责使用同构协议将异构网络相互连接。</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>原始数据报有一些特点。最显著的缺点是不能保证发送可靠，即使能传送也可能在传输中遭到破坏。首部校验和只能检测首部中的破坏情况，而不能检测数据部分。最后即使数据包能到达目的地儿为被破坏，也不一定会以发送时的顺讯到达。各个数据报可能经过不同路由从源到达目的地。如果数据报A在数据报B之前发送，这并不意味着数据报A会在数据报B之前到达。<br>传输层(transport layer)负责确保各包以发送的顺序接收，并保证没有数据丢失或被破坏，如果丢包，传输层会要求发送方重传这个包。为了实现这个目标IP网络会给每个数据报添加一个附加首部，其中包含有更多信息。<br>传输层上主要有两个协议，一个是传输控制协议(Transmission Control Protocol，TCP)，这是一个开销很高的协议，支持对丢失或破坏的数据进行重传，并按照发送时的顺序进行传送。<br>第二个协议是用户数据报协议(User Dategram Protocol,UDP),它允许接收方法检测被破坏的包，但不保证这些包以正确的顺序传输(或者包有可能根本未传送)。但是UDP通常比TCP快。<br>TCP称为可靠的协议；UDP是不可靠的协议。</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>向用户传送数据的层称为应用层(application layer)。它下面的三层共同定义了数据如何从一台计算机传输到另一台计算机。应用层确定了数据传输后的操作。<br>例如应用层协议如HTTP(用于国际互联网)可以确保Web浏览器将图像显示为图片，而不是一长串数字。<br>你的程序中有关网络的部分大多是在应用层花费时间。<br>除了用于Web的HTTP，还有用于电子邮件的SMTP,POP和IMAP;<br>用于文件传输的FTP,FSP,和TFTP<br>用于文件访问的NFS,<br>用于文件共享的Guntella和BitTorrent;<br>用于语言通话的会话启动协议(Session Initiation Protocol，SIP)和Skype等。<br>此外，你的程序可以在必要时，定义自己的应用层协议</p><p>IP,TCP和UDP<br>IP(网际协议)</p><p>IP设计为允许任意两点之间有多个路由，可以绕过被破坏的路由器实现数据包的路由<br>IP必须是开放的，与平台无关</p><p>TCP置于IP之上，使得连接的两端能够确认接收到的IP包，以及请求重传丢失或被破坏的包。此外TCP允许接收端的包按发送时的顺序重新组合在一起。<br>不过TCP会有很大开销，因此，如果数据的顺序不是特别重要，而且单个包的丢失不会完全破坏数据流，那么有时候可以使用UDP发送数据包，而不需要TCP提供的保证。</p><p>UDP是不可靠的协议，它不能保证包一定到达目的地，也不保证包会以发送时相同的顺序到达。虽然这对于文件传输等用途来说存在问题，但是有些应用程序中，即使丢失部分数据最终用户也不会注意到，对于这种应用程序而言，UDP则完全可以接收。<br>例如，丢失视屏或银屏中的一些数据为不会造成太大的质量下降。如果要等待类似TCP等协议请求重传丢失的数据，那才会是更严重的问题。<br><strong>此外，可以在应用层的UDP数据流中建立纠错码，来解决数据丢失问题</strong></p><p>可以在IP之上运行很多其他协议。最常使用的是ICMP，即网际控制消息协议(Internet Control Message Protocol),它使用原始IP数据报在主机之间传递错误消息。使用这个协议最著名的应用是ping程序。Java不支持ICMP,也不允许发送原始IP数据报(而值运行发送TCP片或UDP数据报)</p><p>Java支持的协议只有TCP和UDP,如ICMP,IGMP，ARP,RARP,RSVP和其他协议在Java程序中都只能通过链接到原生代码来实现。</p><h2 id="IP地址和域名"><a href="#IP地址和域名" class="headerlink" title="IP地址和域名"></a>IP地址和域名</h2><p>作为Java程序员，你不需要担心IP的内部工作原理，但你必须了解寻址。IPv4网络中的每台计算机都由有一个4字节的数字来标识。一般写为点分四段格式，如<code>199.1.32.90</code>,这4个数中，每个数都是一个无符号字节，范围从0到255。IPv4网络中的每台计算机都有唯一的4字节地址。当数据通过网络传输时，包的首部会包括发往的机器地址(目的地址)和发送这个包的机器地址(源地址)。</p><p>沿途的路由器通过检查目的地址来发送数据包的最佳路由。IP包中包括源地址是为了让接收方知道要向谁回复。</p><p>IP地址不够用，现在正在想IPv6慢慢的过渡<br>IPv6使用16个字节的地址，这样就能有足够的地址来表示每个人，每天计算机，甚至是地球上的每一个设备。</p><h3 id="IPv6地址格式"><a href="#IPv6地址格式" class="headerlink" title="IPv6地址格式:"></a>IPv6地址格式:</h3><p><strong>IPv6地址通常为冒号分割的8个区块</strong>，每个区块是<code>4</code>个<code>16</code>进制数字，如<code>FEDC:BA98:7654:3210:FEDC:BA98:7654:3210</code>。前导的0不需要写，两个冒号表示多个0区块。例如<code>FEDC:0000:0000:0000:00DC:0000:7076:0010</code>可以写为更紧凑的形式，如：<code>FEDC::DC:0:7076:10</code></p><p>在IPv6和IPv4的混合网络中，IPv6地址的最后4个字节有时候写为IPv4的点分四段地址。例如,<code>FEDC:BA98:7654:3210:FEDC:BA98:7654:3210</code>可以写为：<code>FEDC:BA98:7654:3210:118.84.50.16</code></p><p>IPv6只在Java1.4以及以后版本中支持。Java1.3及以前版本只支持4字节地址。</p><h3 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h3><p>虽然计算机可以轻松的处理数字，但是人来对记忆数字不在行。所以开发了域名系统(Domain Name System,DNS)，用来将人类易于记忆的主机名(例如：<code>github.com</code>)转换为数字Internert地址(例如<code>52.74.223.119</code>)。当Java程序访问网络时，它们需要同时处理数字地址和响应的主机名。这些方法由<code>java.net.InetAddress</code>类提供。</p><p>有些计算机(尤其是服务器)有固定的地址。也有些其他计算机(特别是局域网和无线连接上的客户端)可能每次启动时会分配到不同的地址，这通常有DHCP服务器提供。</p><p><strong>你只需要记住IP地址可能会随着时间而改变，写代码时不要假定系统有相同的IP地址。</strong></p><h3 id="不可路由的地址"><a href="#不可路由的地址" class="headerlink" title="不可路由的地址"></a>不可路由的地址</h3><p>有一些地址区块和模式很特殊，以<code>10.</code>，<code>172.16.</code>，<code>172.31.</code>，和<code>192.168.</code>开头的所有IPv4地址都未分配。这些地址可以在内部网络使用，但是使用这些地址的主机不允许加入全球<code>Internet</code>。不过这些不可路由的地址对于建立Internet上看不到的专用网会很有用。</p><h3 id="本地回送地址"><a href="#本地回送地址" class="headerlink" title="本地回送地址"></a>本地回送地址</h3><p>以127开头的IPv4地址(最常见的是<code>127.0.0.1</code>)总是表示本地回送地址(<code>local loopback address</code>)。这就是说，这些地址总是指向本地计算机，而不论你在哪个计算机上运行。这个地址的主机名通常是<code>localhost</code>。</p><h3 id="广播地址"><a href="#广播地址" class="headerlink" title="广播地址"></a>广播地址</h3><p><code>4</code>个字节都使用相同数字的IPv4地址(如<code>255.255.255.255</code>)是一个广播地址。发送到这个地址的包将由本地网络多行的所有节点接收，但不能超越这个本地网络。例如,一个临时使用的客户端(如笔记本电脑)启动时，他会想<code>255.255.255.255</code>发送一个特定的消息，查找本地<code>DHCP</code>服务器。这个网络上的所有节点都接收到这个包，不过只有<code>DHCP</code>服务器做出相应。具体地，它会想这个笔记本电脑发送本地网络配置的有关信息，包括这个笔记本电脑在余下的会话中要使用的<code>IP</code>地址以及用来解析主机名的<code>DNS</code>服务器的地址。</p><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>如果每台计算机每次只做一件事情，那么地址可能就足够了。但是，现代计算机同时要做很多不同的事情。电子邮件需要与FTP请求分开，而FTP又要与Web业务流分开。<br>这是通过端口(port)来实现的。每台有IP地址的计算机都有几千个逻辑端口，确切的讲，每个传输层洗衣有65535个端口。这些知识计算机内存中的抽象，不表示任何物理实体，与USB端口不同。每个端口都是由1到65535之间的一个数字标识。每个端口可以分配给一个特定的服务。<br>例如，Web层协议HTTP一般使用80端口，我们说Web服务器在端口80监听(listen)入站连接(incomming connection)。<br>当数据发送到特定IP地址的某个机器上的Web服务器时,它还会发送到该机器的特定端口(通常是80端口)。<br>接收方检查接口收到的每个包，将数据发送给监听这个端口的程序。各种通信业务流就是这样区分的。<br>1到1023的端口号保留给已知的服务，如finger,FTP，HTTP和IMAP.在UNIX系统上包括Linux,这有root用户运行的程序来可以接收这些端口的数据。但是所有的程序都可以想这些端口发送数据。<br>在Windows上，所有的程序都可以使用这些端口，不需要专门的特权。</p><table><thead><tr><th style="text-align:left">协议名</th><th style="text-align:left">端口</th><th style="text-align:left">使用的传输协议</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left"><code>echo</code></td><td style="text-align:left">7</td><td style="text-align:left">TCP/UDP</td><td style="text-align:left">echo是一个测试协议，通过回显另一台机器的输入来验证两台机器是否连接成功</td></tr><tr><td style="text-align:left"><code>discard</code></td><td style="text-align:left">9</td><td style="text-align:left">TCP/UDP</td><td style="text-align:left">discard是一种用处不太大的协议，它将忽略服务器收到的所有数据</td></tr><tr><td style="text-align:left"><code>daytime</code></td><td style="text-align:left">13</td><td style="text-align:left">TCP/UDP</td><td style="text-align:left">提供服务器当前时间的ASCII表示</td></tr><tr><td style="text-align:left"><code>FTP数据</code></td><td style="text-align:left">20</td><td style="text-align:left">TCP</td><td style="text-align:left">FTP使用两个已知端口，这个20端口用来传输文件</td></tr><tr><td style="text-align:left"><code>FTP</code></td><td style="text-align:left">21</td><td style="text-align:left">TCP</td><td style="text-align:left">这个端口用来发送FTP命令，如put和get</td></tr><tr><td style="text-align:left"><code>SSH</code></td><td style="text-align:left">22</td><td style="text-align:left">TCP</td><td style="text-align:left">用于加密的远程登录</td></tr><tr><td style="text-align:left"><code>Telnet</code></td><td style="text-align:left">23</td><td style="text-align:left">TCP</td><td style="text-align:left">用于交互式远程命令行会话</td></tr><tr><td style="text-align:left"><code>smtp</code></td><td style="text-align:left">25</td><td style="text-align:left">TCP</td><td style="text-align:left">简单邮件传输协议(Simple Mail Transfer Protocol)用来在机器间发送邮件</td></tr><tr><td style="text-align:left"><code>time</code></td><td style="text-align:left">37</td><td style="text-align:left">TCP/UDP</td><td style="text-align:left">时间服务器返回服务器从1990年1月1日0:0:0之后过去的秒数，这是一个4字节有符号big-endain整数</td></tr><tr><td style="text-align:left"><code>whois</code></td><td style="text-align:left">43</td><td style="text-align:left">TCP</td><td style="text-align:left">用于Internet网络管理的简单目录服务</td></tr><tr><td style="text-align:left"><code>finger</code></td><td style="text-align:left">79</td><td style="text-align:left">TCP</td><td style="text-align:left">返回本地系统中用户(或多个用户)有关信息的服务</td></tr><tr><td style="text-align:left"><code>HTTP</code></td><td style="text-align:left">80</td><td style="text-align:left">TCP</td><td style="text-align:left">国际互联网的低层协议</td></tr><tr><td style="text-align:left"><code>POP3</code></td><td style="text-align:left">110</td><td style="text-align:left">TCP</td><td style="text-align:left">邮局协议版本3(Post Office Protocol Version 3)协议可以将积累的电子邮件从主机传输到偶然连接的客户端</td></tr><tr><td style="text-align:left"><code>NNTP</code></td><td style="text-align:left">119</td><td style="text-align:left">TCP</td><td style="text-align:left">Usenet新闻传输，正式的说无法为”网络新闻传输协议”(Network News Transfer Protocol)</td></tr><tr><td style="text-align:left"><code>IMAP</code></td><td style="text-align:left">143</td><td style="text-align:left">TCP</td><td style="text-align:left">Internet消息访问协议(Internet Message Access Protocol)是访问存储在服务器上的邮件的协议</td></tr><tr><td style="text-align:left"><code>dict</code></td><td style="text-align:left">2628</td><td style="text-align:left">TCP</td><td style="text-align:left">提供单词定义的UTF-8编码的字典服务</td></tr></tbody></table><h2 id="Internet"><a href="#Internet" class="headerlink" title="Internet"></a>Internet</h2><p>Internet是世界上最大的基于IP的网络。Internet不属于任何人(不过它的各个部分有响应的所有者)。它只是约定以只用标准方式相互对话的一个非常大的计算机集合。<br><code>Internet</code>不是唯一的基于IP的网络，但却是最大的一个。其他的IP网络成为<code>internet</code>(首字母<code>i</code>小写)</p><p>为确保Internet上不同网络的主机可以相互通信，就需要遵守一些对纯粹内部<code>internet</code>不适用的规则。更重要的规则是要处理不同组织，公司和个人地址的分配。<br>如果每个人都随意地挑选Internet地址，那么有相同地址的不同计算机出现在Internet上立即就会引起冲突。</p><h2 id="Internet地址分块"><a href="#Internet地址分块" class="headerlink" title="Internet地址分块"></a>Internet地址分块</h2><p>为了避免这个问题，区域Internet注册机构为Internet服务提供商(ISP)分配IPv4地址块。当公式或组织要建立一个基于IP的网络连接到Internet时，它们的ISP会给她们分配一个地址块。每个地址块有固定的前缀。例如如果前缀是<code>216.254.85</code>，那么本地网络可以使用从216.254.85.0到216.254.85.255的地址。由于这个块固定了前24位，所以称为<code>/24</code>。<br>同理：<br><code>/23</code>指定了前<code>23</code>位,而留出9位表示总共<code>2^9=512</code>个本机IP地址。<br>“/30”子网(最小的子网)指定了子网中IP地址的前30位，留出2位表示2^2=4个本地IP地址。</p><p>不过，所有块中最低地址用于表示网络本身，最高地址是这个网络的一个广播地址。所以可用地址比分到的地址要少两个。</p><p>那么”<code>/30</code>“中的四个本地IP地址中，除去一个表示网络本身的最低地址，除去一个用于广播的最高地址，就只剩下两个可用自由分配的地址了。</p><h2 id="网络地址转换"><a href="#网络地址转换" class="headerlink" title="网络地址转换"></a>网络地址转换</h2><p>由于IP地址越来越稀缺，而对原始IP地址的需求越来越大，如今大多数网络都使用了网络地址转换(Network Address Translation,NAT)。<br>基于NAT的网络中，大多数阶段只有不可路由的本地地址，这些地址可能从<code>10.x.x.x</code>,<code>172.16.x.x</code>到<code>172.31.x.x</code>或<code>192.168.x.x</code>选择。<br>例如，我的公寓里大学有十来个IP节点，大家会公用一个外部可见的IP(<code>216.254.85.72</code>)地址。我现在用的这个计算机的IP地址是<code>192.168.1.5</code>，不过在你的网络中<code>192.168.1.5</code>这个地址可能指示的是一个完全不同的主机(如果存在这样一个主机)。<br>另外，你也无法使用<code>192.168.1.5</code>发送数据到我的计算机。</p><p>实际上你必须把数据发送到到<code>216.254.85.72</code>这个地址(即使如此，只有当为把NAT路由器配置为<code>将入站连接传递到`</code>192.168.1.5`时,数据才会真正送达我的计算机)。</p><p>路由器会监视出站和入站连接，调整IP包中地址。例如，我向外网发数据，对于这些出站的包，路由器将这个包的源地址该为路由器的外部地址(在我这个网络是:<code>2016.254.85.72</code>)。<br>而外网发来的这些入站的包，路由器将目的地址改为一个本地地址。如<code>192.168.1.12</code>。<br>那么路由器如何记录哪些连接来自或发往那台内部计算机,这对于Java程序员并不是特别重要。只要正确配置了你的机器，这个过程基本上<br>就是透明的。<strong>你只需要记住外部地址和内部地址有可能不同就行了。</strong><br>感觉作者这里没有说清楚，说了一半的感觉</p><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><p>位于Internet和本地网络之间的一些硬件和软件会检查所有进出的数据，以保证其合法性。这就称为防火墙(firewall)。</p><p><strong>防火墙要负责检查传入或传出其网络结构的各个包，根据一组规则接收或拒绝这些包。</strong></p><p><strong>过滤通常是基于地址和端口的。</strong>例如，多有来自C类网络<code>193.28.25.x</code>的通信会被拒绝，因为你过去遭受过这个网站中黑客的攻击。</p><p>出站的SSH连接可能是允许的，但入站的SSH连接不允许，端口<code>80</code>(Web)的入站连接时允许的，但只限于公司的Web服务器。</p><p><strong>更智能的防火墙会查看包的内容，确定是否接收或拒绝</strong>。防火墙具体的配置(哪些数据包允许通过而哪些不允许通过)取决于网站的安全需求。Java与防火墙没有太大关系，除非防火墙总是妨碍你的事。</p><h2 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h2><blockquote><p>代理服务器(proxy server)与防火墙有关。如果说防火墙会阻止一个网络上的主机与外界直接建立连接，那么代理服务器就起到中间人的作用。</p><p>如果防火墙阻止一个机器连接外部网络，这个机器可以请求本地代理服务器的Web页面，而不是直接请求远程Web服务器的Web页面。<br>然后代理服务器会请求远程Web服务器的页面，将远程Web服务器的响应转发给最初发出请求的机器。</p><p>代理还可以用于FTP服务器和其他连接。</p><p>使用代理服务器的安全优势之一是外部主机只能看到代理服务器，而不会知道内部机器的主机名和IP地址，这样就是的攻击内部网络更加困难。</p></blockquote><p>个人绝对代理服务器就好比黄牛，通过访问代理服务器来访问外网，就跟我们跟黄牛买票差不多。<br>防火墙一般工作与传输层或网际层，而代理服务器通常工作与应用层。代理服务器对一些应用层协议非常了解，如HTTP和FTP(一个值得注意的例外是SOCKS代理服务器，Socks服务器工作与传输层，可以代理所有的TCP和UDP连接，而不考虑应用层协议)</p><p>可以检查通过代理服务的包，确保其中包含适当类型的数据。<br>下图展示了代理服务器在分层模型中的位置：<br><img src="https://i.imgur.com/0lDn1pg.png" alt=""></p><p>只要所有对Internet的访问都通过代理服务器转发，那么访问就可以收到严格的控制。<br>例如，公司可能选择组织访问<a href="http://www.playboy.com,但允许访问www.microsoft.com。一些公式允许入站FTP，但不允许出站FTP。这样公司的机密数据就不会容易的被非法带出公司。" target="_blank" rel="noopener">www.playboy.com,但允许访问www.microsoft.com。一些公式允许入站FTP，但不允许出站FTP。这样公司的机密数据就不会容易的被非法带出公司。</a></p><p>其他公式已经开始使用代理服务器来跟踪员工的Web使用情况，这样可以看到是谁在利用Internet获取技术支持，是谁在利用它找私人朋友。</p><h3 id="实现本地缓存"><a href="#实现本地缓存" class="headerlink" title="实现本地缓存"></a>实现本地缓存</h3><p>代理服务器还可以用来实现本地缓存(local caching)。当请求Web服务器的文件时，代理服务器首先查看此文件是否已经在缓存中。如果文件在缓存中，那么代理服务器将提供缓存中的文件，而不是Internet上的文件。如果这个文件不在缓存中，那么代理服务器将从Internet中获取此文件，然后转发给请求方，并将该文件存储在缓存中，供下次请求使用。这种机制可以显著的降低Internet连接的负载，大大提高响应时间。</p><p>例如，美国在线(America Online)<code>aol.com</code>运行着世界上最大的代理服务器<code>场</code>之一，代理服务器可以加快向用户传输数据的速度。如果你查看Web服务器的日志文件，可能会发现<code>aol.com</code>域客户的一些点击记录，但不想你想象的那么多，要知道AOL用户已经超过300万。按理说，这么多人访问，点击记录应该很多才是。<br>这是因为当用户访问时，AOL代理服务器优先从其缓存中提供了许多页面，而不是为每位用户都重新请求页面。很多其他大的ISP也是这样做的。</p><h3 id="代理服务器的缺点"><a href="#代理服务器的缺点" class="headerlink" title="代理服务器的缺点"></a>代理服务器的缺点</h3><p>代理服务器最大的问题在于它无法应对所有协议。通常已有的协议如HTTP,FTP和SMTP允许通过，而新的协议如BitTorrent则可能不允许通过。在快速改变的Internet世界，这是一个很大的缺点，对于Java程序员而言这是一个缺点，因为他限制了定制协议的有效性。</p><p>使用Java可以很容易地创建为你的应用而优化的新协议，这么做通常也很有用。但是，没有代理服务器能够理解你这些独一无二的协议。<br>因此，有些开发人员开始通过HTTP来接入他们定制的协议，最著名的是SOAP。</p><h2 id="客户-服务器模型"><a href="#客户-服务器模型" class="headerlink" title="客户/服务器模型"></a>客户/服务器模型</h2><p>大多数现代网络编程都基于<code>客户/服务器模型</code>。</p><h3 id="客户端和服务器端功能分解"><a href="#客户端和服务器端功能分解" class="headerlink" title="客户端和服务器端功能分解"></a>客户端和服务器端功能分解</h3><ul><li>客户/服务器应用程序一般讲大量数据存储在昂贵的高性能服务器或服务器云上。</li><li>而大多数程序逻辑和用户界面有客户端软件处理，这些客户端软件运行在相对便宜的个人计算机上。</li></ul><p>在多数情况下，服务器主要发送数据，而客户端主要接收数据，但是很少有一个程序只发送或只接受数据。</p><p>更有可能的是客户端发起对话，而服务器等待客户端与它开始对话。在有些情况下，同一个程序会同时作为客户端和服务器，下图展示了这两种可能性。<br><img src="https://i.imgur.com/UaS3Rtg.png" alt=""></p><blockquote><p>Internet上最流行的客户/服务器系统是Web,Web服务器(如Apache)响应Web客户端(如Firefox)的请求。数据存储在Web服务器上，会发送给请求数据的客户端。除了最初的页面请求，几乎所有数据都从服务器想客户端传输，而不是从客户端传输到服务器。</p><p>FTP是符合客户端/服务器模型的更古老的服务。FTP使用不同的应用协议和不同的软件，但依然分为<strong>发送文件的FTP服务器和接收文件的FTP客户端。</strong>人们通常使用FTP从客户端向服务器上传文件，所以很难讲数据传输是一个方向传输的。但是要说FTP客户端发起连接而FTP服务器进行响应，这仍然是正确的。</p></blockquote><h3 id="对等连接"><a href="#对等连接" class="headerlink" title="对等连接"></a>对等连接</h3><p>不是所有应用程序都简单的符合客户端/服务器模型。例如，在网络游戏中，看起来两个玩家都能大致相同的来回发送数据(公平游戏中)。这种连接称为<code>对等</code>(peer-to-peer)连接。</p><h4 id="对等网路典型例子"><a href="#对等网路典型例子" class="headerlink" title="对等网路典型例子"></a>对等网路典型例子</h4><p>电话系统就是典型的对等网络例子,每部电话都可以呼叫另外的电话，或者被另外的电话呼叫。<br>Java在其核心网络API中没有显示的对等通信。不过，引用程序可以很容易的通过集中方式提供对等通信，最常见的是同时所谓服务器和客户端。另外，对等端可以通过中间服务器程序相互通信，这个程序将程序从一端转发到其他对等端。这样就很好的解决了两个对等端如何发现对方的问题。</p><h2 id="Internet标准"><a href="#Internet标准" class="headerlink" title="Internet标准"></a>Internet标准</h2><p>世界上有很多标准组织，但是关于应用层网络编程的协议大多数标准都是由下面两个组织制定的，它们分别是IETF(Internet Engineering Task Forse,Internet工程任务组)和W3C(World Wide Web Consortium,国际互联网协会)。</p><p>IETF是不太正式的民间团体,向所有感兴趣参与的团队开放。它的标准是根据”多数人的意见和正在运行的代码”做出决定,倾向于跟踪而不是引导实现。IETF(Internet工程任务组)标准包括TCP/IP,MIME和SMTP。</p><p>与IETF不同W3C是厂商组织，由缴纳会费的成员公司控制，明确拒绝个人参与。在极大程度上，W3C会尽力在实现之前定义标准，W3C标准包括HTTP，HTML和XML。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/40aaea03/">java网络编程第4版 第1章 基本网络概念</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.lansheng.net.cn/blog/9e1b6b70/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="蓝生"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="蓝生的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/blog/9e1b6b70/" itemprop="url">匹配IP地址</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-08-19 19:39:36" itemprop="dateCreated datePublished" datetime="2018-08-19T19:39:36+08:00">2018-08-19</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2018-11-05 17:17:07" itemprop="dateModified" datetime="2018-11-05T17:17:07+08:00">2018-11-05</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/Java-正则表达式/" itemprop="url" rel="index"><span itemprop="name">Java 正则表达式</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/blog/9e1b6b70/#comments" itemprop="discussionUrl"><span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/blog/9e1b6b70/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><p>正则表达式匹配IP地址</p><blockquote><p>正则表达式，又称规则表达式。接下来通过本文给大家介绍正则表达式匹配<code>IP</code>的表达式，非常不错，具有参考借鉴价值，需要的的朋友参考下吧</p></blockquote><p>这里给大家详细讲解一下一个匹配IP地址的正则表达式，<br>有关正则方面的知识，会在详细的讲解中提到。<br>在讲解之前，我先给大家介绍一下，ip地址的生成规则。<br>IP地址，是由32位数字二进制转为四个十进制的字符串组成。<br>怎么转化？下面讲解：</p><p>二进制：<code>11111111111111111111111111111111</code><br>分为四部分：<code>11111111.11111111.11111111.11111111</code><br>转化：<code>2^7+2^6+2^5+2^4+2^3+2^2+2^1+2^0=255</code><br>转为十进制范围：<code>0~255.0~255.0~255.0~255</code><br>这就是<code>IP</code>地址的范围。<br>根据这个生成<code>IP</code>的规则和范围，我们可以用正则表达式来匹配出<code>IP</code>地址，但怎么匹配呢？各人有各人的方法，这里我讲解一下我的思路。</p><p>根据IP地址的字符串规律，我把匹配IP地址的表达式分为两部分来考虑。<br>第一部分：匹配3个<code>0~255.</code>（注意后面的一个点）<br>第二部分：匹配最后的数字<code>0~255</code><br>也就是说，<strong>先匹配出<code>0~255.</code>（注意后面的一个点） 这个字符串，然后重复匹配3次，然后再匹配最后的数字部分0~255</strong>。这就是我匹配<code>IP</code>地址的思路。</p><p>首先，我要提一下<strong>，正则是没有办法做数字运算的</strong>，所以，我们无法用数字运算的方式筛选出IP的数字范围。既然没法用数字运算的方式筛选出IP的数字范围，那么我们应该用什么其他方式来筛选这个数字范围呢？我的思路是分组讨论，然后再把这些分组合并起来组成IP的数字范围。</p><h2 id="匹配一个合法的数字"><a href="#匹配一个合法的数字" class="headerlink" title="匹配一个合法的数字"></a>匹配一个合法的数字</h2><h3 id="三位数的情况："><a href="#三位数的情况：" class="headerlink" title="三位数的情况："></a>三位数的情况：</h3><ul><li>假设百位是<code>2</code>，那么根据<code>IP</code>数字的范围规则，这里又要分为两种情况，为什么？你想想，最大数字是<code>255</code>，当十位数为<code>5</code>时，个位数最大只能为<code>5</code>是吧？(<code>250-255</code>).而当十位数为<code>0到4</code>时，个位数可以是任意数字对吧？(<code>200-249</code>)<br>所以，这里的两种情况分别为：<ul><li><code>2[0-4][0-9]</code></li><li><code>25[0-5]</code></li></ul></li><li>假设百位数是<code>1</code>，那么这个数字的范围为<code>100-199</code>,对应正则表达式就为<code>1[0-9][0-9]</code>。这个应该不难理解，就不解释。</li></ul><h3 id="两位数的情况"><a href="#两位数的情况" class="headerlink" title="两位数的情况"></a>两位数的情况</h3><p>分析完了三位数数的情况，接下来就是两数的情况了，假如是两位数，那么十位数的前面第一个数不能为零是吧？也就是范围为<code>10-99</code>(<code>10,11...,19,20,...,99</code>),对应的正则表达式为<code>[1-9][0-9]</code></p><h3 id="一位数的情况"><a href="#一位数的情况" class="headerlink" title="一位数的情况"></a>一位数的情况</h3><p>剩下的就是个位数的情况了，个位数的情况，大家应该很容易得出结论，就是：<code>[0-9]</code>。</p><p>四种情况分析下来，我们得出了IP数字的范围分组为：</p><ul><li><code>25[0-5]</code></li><li><code>2[0-4][0-9]</code></li><li><code>1[0-9][0-9]</code></li><li><code>[1-9][0-9]</code></li><li><code>[0-9]</code></li></ul><h3 id="匹配一个合法的数字-1"><a href="#匹配一个合法的数字-1" class="headerlink" title="匹配一个合法的数字"></a>匹配一个合法的数字</h3><p>所以匹配IPv4中一个和法的数组的正则表达式为<code>(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])</code></p><h3 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h3><ul><li>可以把两位数<code>[1-9][0-9]</code>和一位数的情况<code>[0-9]</code>合并，写为<code>[1-9]?[0-9]</code>.</li><li>用简写<code>\d</code>替代<code>[0-9]</code></li></ul><p>所以优化后的一个合法的数字的正则表达式为：<code>(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)</code></p><h2 id="匹配一个合法的数字和点号三次-："><a href="#匹配一个合法的数字和点号三次-：" class="headerlink" title="匹配一个合法的数字和点号三次 ##："></a>匹配一个合法的数字和点号三次 ##：</h2><p>点号要转义为<code>\.</code>,<br><code>((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}</code></p><h2 id="最终的表达式："><a href="#最终的表达式：" class="headerlink" title="最终的表达式："></a>最终的表达式：</h2><p>三组数字和点号之后，后面还有一组数字。这样的话综合起来就是：<br><code>((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)</code></p><h3 id="优化：-1"><a href="#优化：-1" class="headerlink" title="优化："></a>优化：</h3><p>上面我们使用了括号<code>(...)</code>来限定量词和多选的作用范围。但是这样也会在匹配的时候进行捕获，捕获的话会造成不必要的开销，这里使用<code>(?:...)</code>来限定，这样省去捕获分组的开销。<br><code>(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)</code><br>测试：<br>合法的IP地址：</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/9e1b6b70/">匹配IP地址</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.lansheng.net.cn/blog/5b873e00/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="蓝生"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="蓝生的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/blog/5b873e00/" itemprop="url">通过FTP快速传输文件到手机</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-08-19 12:51:06" itemprop="dateCreated datePublished" datetime="2018-08-19T12:51:06+08:00">2018-08-19</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2018-11-05 17:17:08" itemprop="dateModified" datetime="2018-11-05T17:17:08+08:00">2018-11-05</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/其他/" itemprop="url" rel="index"><span itemprop="name">其他</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/其他/Windows相关/" itemprop="url" rel="index"><span itemprop="name">Windows相关</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/blog/5b873e00/#comments" itemprop="discussionUrl"><span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/blog/5b873e00/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="手机上安装了ES文件浏览器"><a href="#手机上安装了ES文件浏览器" class="headerlink" title="手机上安装了ES文件浏览器"></a>手机上安装了ES文件浏览器</h2><p>在手机下载安装APP“ES文件管理器“（其他文件管理器只要具有“远程管理器”功能的也可以)</p><h2 id="ES文件浏览器中的设置"><a href="#ES文件浏览器中的设置" class="headerlink" title="ES文件浏览器中的设置"></a>ES文件浏览器中的设置</h2><ul><li><p><strong>首先将手机连上wifi（和电脑在同一个局域网)，或者直接连接到电脑开的热点</strong></p></li><li><p><strong>打开APP后点左上角的菜单。</strong></p><center><img src="https://i.imgur.com/xRfQj57.jpg" width="50%"></center></li><li><strong>点“网络”项，</strong><center><img src="https://i.imgur.com/6J2YI8u.jpg" width="50%"></center></li><li><strong>然后点“<code>远程管理器</code>”</strong></li></ul><p>这里解释一下为什么不用 “局域网” 和 “FTP” ，这两种方法也可以实现无线传输文件的功能，但使用局域网可能会由于权限而导致拒绝访问的问题，对普通用户来说解决这个问题有点头疼。而”FTP”和”远程管理器”的其实都是使用的FTP协议，区别在于”FTP”是手机做为FTP客户端，电脑上需要安装一个FTP服务器软件。“远程管理器”则手机是FTP服务端，电脑上安装的是FTP客户端，本文使用远程管理器，相对来说在电脑安装FTP客户端软件更简单.</p><center><img src="https://i.imgur.com/lC3E8nU.jpg" width="50%"></center><ul><li><strong>点“<code>打开</code>“即可看到主机地址和端口号，</strong></li></ul><center><img src="https://i.imgur.com/nHUh2Zg.jpg" width="50%"></center><ul><li><strong>把这个记下来，在电脑上要使用，如图</strong></li></ul><center><img src="https://i.imgur.com/ZFBIfTs.jpg" width="50%"></center><ul><li><strong>按下Win+E快捷键，打开文件资源管理器输入这个地址</strong></li></ul><center><img src="https://i.imgur.com/NMcbvNi.png" width="80%"></center><ul><li><strong>按下回车，就可进入手机中的目录啦</strong><br><img src="https://i.imgur.com/BziPLyj.png" alt=""><h2 id="传输文件"><a href="#传输文件" class="headerlink" title="传输文件"></a>传输文件</h2></li></ul><p>进入手机目录，可以很方便的在手机和电脑之间互相传输(复制粘贴)文件,这种方式比蓝牙快的多了。</p><ul><li>从电脑中复制文件：</li></ul><p><img src="https://i.imgur.com/UnByZow.png" alt=""></p><ul><li>粘贴到手机中：</li></ul><p><img src="https://i.imgur.com/WnZDMj7.png" alt=""></p><ul><li>很快就传输好啦：</li></ul><p><img src="https://i.imgur.com/zsHwKNN.png" alt=""></p><ul><li>复制成功：</li></ul><p><img src="https://i.imgur.com/QdLVFRl.png" alt=""></p><h2 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h2><ul><li>最后再ES文件浏览器中关闭连接即可：</li></ul><center><img src="https://i.imgur.com/fmOTpnh.jpg" width="50%"></center><p>参考：<a href="http://baijiahao.baidu.com/s?id=1596833763494677229&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">http://baijiahao.baidu.com/s?id=1596833763494677229&amp;wfr=spider&amp;for=pc</a></p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/5b873e00/">通过FTP快速传输文件到手机</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.lansheng.net.cn/blog/c1fee13e/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="蓝生"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="蓝生的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/blog/c1fee13e/" itemprop="url">DatagramSocket类</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-08-18 21:47:34" itemprop="dateCreated datePublished" datetime="2018-08-18T21:47:34+08:00">2018-08-18</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2018-11-05 17:17:07" itemprop="dateModified" datetime="2018-11-05T17:17:07+08:00">2018-11-05</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/java-网络编程/" itemprop="url" rel="index"><span itemprop="name">java 网络编程</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/java-网络编程/API/" itemprop="url" rel="index"><span itemprop="name">API</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/blog/c1fee13e/#comments" itemprop="discussionUrl"><span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/blog/c1fee13e/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>DatagramSocket()</code></td><td style="text-align:left">构造数据报套接字并将其绑定到本地主机上任何可用的端口。</td></tr><tr><td style="text-align:left"><code>DatagramSocket(int port)</code></td><td style="text-align:left">创建数据报套接字并将其绑定到本地主机上的指定端口。</td></tr><tr><td style="text-align:left"><code>DatagramSocket(int port, InetAddress laddr)</code></td><td style="text-align:left">创建数据报套接字，将其绑定到指定的IP地址</td></tr><tr><td style="text-align:left"><code>DatagramSocket(SocketAddress bindaddr)</code></td><td style="text-align:left">创建数据报套接字，将其绑定到指定的本地套接字地址。</td></tr><tr><td style="text-align:left"><code>protected DatagramSocket(DatagramSocketImpl impl)</code></td><td style="text-align:left">创建带有指定 DatagramSocketImpl 的未绑定数据报套接字。</td></tr></tbody></table><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>void bind(SocketAddress addr)</code></td><td style="text-align:left">将此 DatagramSocket 绑定到特定的地址和端口。</td></tr><tr><td style="text-align:left"><code>void close()</code></td><td style="text-align:left">关闭此数据报套接字。</td></tr><tr><td style="text-align:left"><code>void connect(InetAddress address, int port)</code></td><td style="text-align:left">将套接字连接到此套接字的远程地址。</td></tr><tr><td style="text-align:left"><code>void connect(SocketAddress addr)</code></td><td style="text-align:left">将此套接字连接到远程套接字地址（IP 地址 + 端口号）。</td></tr><tr><td style="text-align:left"><code>void disconnect()</code></td><td style="text-align:left">断开套接字的连接。</td></tr><tr><td style="text-align:left"><code>boolean getBroadcast()</code></td><td style="text-align:left">检测是否启用了 SO_BROADCAST。</td></tr><tr><td style="text-align:left"><code>DatagramChannel getChannel()</code></td><td style="text-align:left">返回与此数据报套接字关联的唯一 DatagramChannel 对象（如果有）。</td></tr><tr><td style="text-align:left"><code>InetAddress getInetAddress()</code></td><td style="text-align:left">返回此套接字连接的地址。</td></tr><tr><td style="text-align:left"><code>InetAddress getLocalAddress()</code></td><td style="text-align:left">获取套接字绑定的本地地址。</td></tr><tr><td style="text-align:left"><code>int getLocalPort()</code></td><td style="text-align:left">返回此套接字绑定的本地主机上的端口号。</td></tr><tr><td style="text-align:left"><code>SocketAddress getLocalSocketAddress()</code></td><td style="text-align:left">返回此套接字绑定的端点的地址，如果尚未绑定则返回 null。</td></tr><tr><td style="text-align:left"><code>int getPort()</code></td><td style="text-align:left">返回此套接字的端口。</td></tr><tr><td style="text-align:left"><code>int getReceiveBufferSize()</code></td><td style="text-align:left">获取此 DatagramSocket 的 SO_RCVBUF 选项的值，该值是平台在 DatagramSocket 上输入时使用的缓冲区大小。</td></tr><tr><td style="text-align:left"><code>SocketAddress getRemoteSocketAddress()</code></td><td style="text-align:left">返回此套接字连接的端点的地址，如果未连接则返回 null。</td></tr><tr><td style="text-align:left"><code>boolean getReuseAddress()</code></td><td style="text-align:left">检测是否启用了 SO_REUSEADDR。</td></tr><tr><td style="text-align:left"><code>int getSendBufferSize()</code></td><td style="text-align:left">获取此 DatagramSocket 的 SO_SNDBUF 选项的值，该值是平台在 DatagramSocket 上输出时使用的缓冲区大小。</td></tr><tr><td style="text-align:left"><code>int getSoTimeout()</code></td><td style="text-align:left">获取 SO_TIMEOUT 的设置。</td></tr><tr><td style="text-align:left"><code>int getTrafficClass()</code></td><td style="text-align:left">为从此 DatagramSocket 上发送的包获取 IP 数据报头中的流量类别或服务类型。</td></tr><tr><td style="text-align:left"><code>boolean isBound()</code></td><td style="text-align:left">返回套接字的绑定状态。</td></tr><tr><td style="text-align:left"><code>boolean isClosed()</code></td><td style="text-align:left">返回是否关闭了套接字。</td></tr><tr><td style="text-align:left"><code>boolean isConnected()</code></td><td style="text-align:left">返回套接字的连接状态。</td></tr><tr><td style="text-align:left"><code>void receive(DatagramPacket p)</code></td><td style="text-align:left">从此套接字接收数据报包。</td></tr><tr><td style="text-align:left"><code>void send(DatagramPacket p)</code></td><td style="text-align:left">从此套接字发送数据报包。</td></tr><tr><td style="text-align:left"><code>void setBroadcast(boolean on)</code></td><td style="text-align:left">启用/禁用 SO_BROADCAST。</td></tr><tr><td style="text-align:left"><code>static void setDatagramSocketImplFactory(DatagramSocketImplFactory fac)</code></td><td style="text-align:left">为应用程序设置数据报套接字实现工厂。</td></tr><tr><td style="text-align:left"><code>void setReceiveBufferSize(int size)</code></td><td style="text-align:left">将此 DatagramSocket 的 SO_RCVBUF 选项设置为指定的值。</td></tr><tr><td style="text-align:left"><code>void setReuseAddress(boolean on)</code></td><td style="text-align:left">启用/禁用 SO_REUSEADDR 套接字选项。</td></tr><tr><td style="text-align:left"><code>void setSendBufferSize(int size)</code></td><td style="text-align:left">将此 DatagramSocket 的 SO_SNDBUF 选项设置为指定的值。</td></tr><tr><td style="text-align:left"><code>void setSoTimeout(int timeout)</code></td><td style="text-align:left">启用/禁用带有指定超时值的 SO_TIMEOUT，以毫秒为单位。</td></tr><tr><td style="text-align:left"><code>void setTrafficClass(int tc)</code></td><td style="text-align:left">为从此 DatagramSocket 上发送的数据报在 IP 数据报头中设置流量类别 (traffic class) 或服务类型八位组 (type-of-service octet)。</td></tr></tbody></table><p>本文链接: <a href="https://www.lansheng.net.cn/blog/c1fee13e/">DatagramSocket类</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.lansheng.net.cn/blog/12786bb5/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="蓝生"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="蓝生的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/blog/12786bb5/" itemprop="url">7网络协议</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-08-18 21:24:12" itemprop="dateCreated datePublished" datetime="2018-08-18T21:24:12+08:00">2018-08-18</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2018-11-05 17:17:07" itemprop="dateModified" datetime="2018-11-05T17:17:07+08:00">2018-11-05</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/java-网络编程/" itemprop="url" rel="index"><span itemprop="name">java 网络编程</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/blog/12786bb5/#comments" itemprop="discussionUrl"><span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/blog/12786bb5/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><p>参考：<a href="http://www.cnblogs.com/springcsc/archive/2009/12/03/1616413.html" target="_blank" rel="noopener">http://www.cnblogs.com/springcsc/archive/2009/12/03/1616413.html</a><br>对于需要从事网络编程的程序员来说，网络协议是一个需要深刻理解的概念。那么什么是网络协议呢？</p><p><strong>网络协议是指对于网络中传输的数据格式的规定。</strong>对于网络编程初学者来说，没有必要深入了解TCP/IP协议簇，所以对于初学者来说去读大部头的《TCP/IP协议》也不是一件很合适的事情，因为深入了解TCP/IP协议是网络编程提高阶段，也是深入网络编程底层时才需要做的事情。<br>对于一般的网络编程来说，更多的是关心网络上传输的逻辑数据内容，也就是更多的是应用层上的网络协议，所以后续的内容均以实际应用的数据为基础来介绍网络协议的概念。</p><p>那么什么是网络协议呢，下面看一个简单的例子。春节晚会上“小沈阳”和赵本山合作的小品《不差钱》中，小沈阳和赵本山之间就设计了一个协议，协议的内容为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果点的菜价钱比较贵是，就说没有。</span><br></pre></td></tr></table></figure><p></p><p>按照该协议的规定，就有了下面的对话：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">赵本山：<span class="number">4</span>斤的龙虾</span><br><span class="line">小沈阳：(经过判断，得出价格比较高)，没有</span><br><span class="line">赵本山：鲍鱼</span><br><span class="line">小沈阳：(经过判断，得出价格比较高)，没有</span><br></pre></td></tr></table></figure><p></p><p>这就是一种双方达成的一种协议约定，其实这种约定的实质和网络协议的实质是一样的。<strong>网络协议的实质也是客户端程序和服务器端程序对于数据的一种约定，只是由于以计算机为基础，所以更多的是使用数字来代表内容，这样就显得比较抽象一些。</strong></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>下 面再举一个简单的例子，介绍一些基础的网络协议设计的知识。例如需要设计一个简单的网络程序：网络计算器。也就是在客户端输入需要计算的数字和运算符，在 服务器端实现计算，并将计算的结果反馈给客户端。在这个例子中，就需要约定两个数据格式：<strong>客户端发送给服务器端的数据格式，以及服务器端反馈给客户端的数 据格式。</strong></p><h3 id="客户端发送给服务器的数据格式"><a href="#客户端发送给服务器的数据格式" class="headerlink" title="客户端发送给服务器的数据格式"></a>客户端发送给服务器的数据格式</h3><p>可能你觉得这个比较简单，例如客户端输入的数字依次是<code>12</code>和<code>432</code>，输入的运算符是加号，可能最容易想到的数据格式是形成字符串“<code>12+432</code>”，这样格式的确比较容易阅读，但是服务器端在进行计算时，逻辑就比较麻烦，因为需要首先拆分该字符串，然后才能进行计算，所以可用的数据格式就有了一下几种：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“<span class="number">12</span>，<span class="number">432</span>，+”     格式为：第一个数字，第二个数字，运算符</span><br><span class="line">“<span class="number">12</span>，+，<span class="number">432</span>”     格式为：第一个数字，运算符，第二个数字</span><br></pre></td></tr></table></figure><p></p><p>其实以上两种数据格式很接近，比较容易阅读，在服务器端收到该数据格式以后，使用“<code>，</code>”为分隔符分割字符串即可。</p><p>假设对于运算符再进行一次约定，例如约定数字<code>0</code>代表加法<code>+</code>，<code>1</code>代表减法<code>-</code>，2代表乘法<code>*</code>，3代表除法<code>/</code>，整体格式遵循以上第一种格式，则上面的数字生产的协议数据为：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“<span class="number">12</span>，<span class="number">432</span>，<span class="number">0</span>”</span><br></pre></td></tr></table></figure><p></p><p>这就是一种基本的发送的协议约定了。</p><h3 id="服务器反馈的数据格式"><a href="#服务器反馈的数据格式" class="headerlink" title="服务器反馈的数据格式"></a>服务器反馈的数据格式</h3><p>另 外一个需要设计的协议格式就是服务器端反馈的数据格式，其实服务器端主要反馈计算结果，但是在实际接受数据时，有可能存在格式错误的情况，这样就需要简单 的设计一下服务器端反馈的数据格式了。例如规定，如果发送的数据格式正确，则反馈结果，否则反馈字符串“错误”。这样就有了以下的数据格式：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">客户端：“<span class="number">1</span>,<span class="number">111</span>,<span class="number">1</span>”     服务器端：”-<span class="number">110</span>”</span><br><span class="line">客户端：“<span class="number">123</span>,<span class="number">23</span>,<span class="number">0</span>”    服务器端：“<span class="number">146</span>”</span><br><span class="line">客户端：“<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>”       服务器端：“错误”</span><br></pre></td></tr></table></figure><p></p><p>这样就设计出了一种最最基本的网络协议格式，从该示例中可以看出，<strong>网络协议就是一种格式上的约定，可以根据逻辑的需要约定出各种数据格式</strong>，在进行设计时一般遵循“简单、通用、容易解析”的原则进行。</p><p>而对于复杂的网络程序来说，需要传输的数据种类和数据量都比较大，这样只需要依次设计出每种情况下的数据格式即可，例如QQ程序，在该程序中需要进行传输的网络数据种类很多，那么在设计时就可以遵循：登录格式、注册格式、发送消息格式等等，一一进行设计即可。所以对于复杂的网络程序来说，只是增加了更多的命令格式，在实际设计时的工作量增加不是太大。</p><p>不管怎么说，在网络编程中，<strong>对于同一个网络程序来说，一般都会涉及到两个网络协议格式：客户端发送数据格式和服务器端反馈数据格式</strong>，在实际设计时，需要一一对应。这就是最基本的网络协议的知识。</p><p>网络协议设计完成以后，在进行网络编程时，就需要根据设计好的协议格式，在程序中进行对应的编码了，客户端程序和服务器端程序需要进行协议处理的代码分别如下。</p><p>客户端程序需要完成的处理为：</p><ul><li>客户端发送协议格式的生成</li><li>服务器端反馈数据格式的解析</li></ul><p>服务器端程序需要完成的处理为：</p><ul><li>服务器端反馈协议格式的生成</li><li>客户端发送协议格式的解析</li></ul><p>这里的<strong>生成是指将计算好的数据，转换成规定的数据格式</strong>，这里的<strong>解析指，从反馈的数据格式中拆分出需要的数据。</strong>在进行对应的代码编写时，严格遵循协议约定即可。</p><p>所以，对于程序员来说，在进行网络程序编写时，需要首先根据逻辑的需要设计网络协议格式，然后遵循协议格式约定进行协议生成和解析代码的编写，最后使用网络编程技术实现整个网络编程的功能。</p><p>由于各种网络程序使用不同的协议格式，所以不同网络程序的客户端之间无法通用。</p><h2 id="常见协议"><a href="#常见协议" class="headerlink" title="常见协议"></a>常见协议</h2><p>而对于常见协议的格式，例如</p><ul><li><code>HTTP(Hyper Text Transfer Protocol</code>，超文本传输协议)、</li><li><code>FTP(File Transfer Protocol</code>，文件传输协议)，</li><li><code>SMTP(Simple Mail Transfer Protocol</code>，简单邮件传输协议)等等，</li></ul><p>都有通用的规定，具体可以查阅相关的<code>RFC</code>文档。</p><p>最后，对于一种网络程序来说，网络协议格式是该程序最核心的技术秘密，因为一旦协议格式泄漏，则任何一个人都可以根据该格式进行客户端的编写，这样将影响服务器端的实现，也容易出现一些其它的影响。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>关于网络编程基本的技术就介绍这么多，该部分介绍了网络编程的基础知识，以及Java语言对于网络编程的支持，网络编程的步骤等，并详细介绍了TCP方式网络编程和UDP方式网络编程在Java语言中的实现。</p><p>网络协议也是网络程序的核心，所以在实际开始进行网络编程时，设计一个良好的协议格式也是必须进行的工作。</p><h2 id="网络编程示例"><a href="#网络编程示例" class="headerlink" title="网络编程示例"></a>网络编程示例</h2><p>“实践出真知”，所以在进行技术学习时，还是需要进行很多的练习，才可以体会技术的奥妙，下面通过两个简单的示例，演示网络编程的实际使用。</p><h2 id="质数判别示例"><a href="#质数判别示例" class="headerlink" title="质数判别示例"></a>质数判别示例</h2><p>该示例实现的功能是质数判断，<strong>程序实现的功能为客户端程序接收用户输入的数字，然后将用户输入的内容发送给服务器端，服务器端判断客户端发送的数字是否是质数，并将判断的结果反馈给客户端，客户端根据服务器端的反馈显示判断结果。</strong></p><p><strong>质数的规则是</strong>：<strong>最小的质数是2，只能被1和自身整除的<code>自然数</code>。当用户输入小于2的数字，以及输入的内容不是自然数时，都属于非法输入。</strong></p><p>网络程序的功能都分为客户端程序和服务器端程序实现，下面先描述一下每个程序分别实现的功能：</p><h3 id="客户端程序功能："><a href="#客户端程序功能：" class="headerlink" title="客户端程序功能："></a>客户端程序功能：</h3><ul><li>接收用户控制台输入</li><li>判断输入内容是否合法</li><li>按照协议格式生成发送数据</li><li>发送数据</li><li>接收服务器端反馈</li><li>解析服务器端反馈信息，并输出</li></ul><h3 id="服务器端程序功能："><a href="#服务器端程序功能：" class="headerlink" title="服务器端程序功能："></a>服务器端程序功能：</h3><ul><li>接收客户端发送数据</li><li>按照协议格式解析数据</li><li>判断数字是否是质数</li><li>根据判断结果，生成协议数据</li><li>将数据反馈给客户端</li></ul><p>分解好了网络程序的功能以后，就可以设计网络协议格式了，如果该程序的功能比较简单，所以设计出的协议格式也不复杂。</p><h3 id="客户端发送协议格式："><a href="#客户端发送协议格式：" class="headerlink" title="客户端发送协议格式："></a>客户端发送协议格式：</h3><ul><li>将用户输入的数字转换为字符串，再将字符串转换为byte数组即可。</li><li>例如用户输入16，则转换为字符串“16”，使用getBytes转换为byte数组。</li><li>客户端发送“quit”字符串代表结束连接<h3 id="服务器端发送协议格式："><a href="#服务器端发送协议格式：" class="headerlink" title="服务器端发送协议格式："></a>服务器端发送协议格式：</h3></li><li>反馈数据长度为1个字节。数字0代表是质数，1代表不是质数，2代表协议格式错误。</li><li>例如客户端发送数字12，则反馈1，发送13则反馈0，发送0则反馈2。</li></ul><p>功能设计完成以后，就可以分别进行客户端和服务器端程序的编写了，在编写完成以后联合起来进行调试即可。</p><p>下面分别以TCP方式和UDP方式实现该程序，注意其实现上的差异。不管使用哪种方式实现，客户端都可以多次输入数据进行判断。对于UDP方式来说，不需要向服务器端发送quit字符串。</p><h3 id="以TCP方式实现"><a href="#以TCP方式实现" class="headerlink" title="以TCP方式实现"></a>以TCP方式实现</h3><h4 id="客户端程序"><a href="#客户端程序" class="headerlink" title="客户端程序"></a>客户端程序</h4><p>以TCP方式实现的客户端程序代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> example1;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 以TCP方式实现的质数判断客户端程序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPPrimeClient</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> BufferedReader br;</span><br><span class="line">    <span class="keyword">static</span> Socket socket;</span><br><span class="line">    <span class="keyword">static</span> InputStream is;</span><br><span class="line">    <span class="keyword">static</span> OutputStream os;</span><br><span class="line">    <span class="comment">/**服务器IP*/</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> String HOST = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">    <span class="comment">/**服务器端端口*/</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> PORT = <span class="number">10005</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        init(); <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"请输入数字："</span>);</span><br><span class="line">            String input = readInput(); <span class="comment">//读取输入</span></span><br><span class="line">            <span class="keyword">if</span>(isQuit(input))</span><br><span class="line">            &#123; <span class="comment">//判读是否结束</span></span><br><span class="line">                <span class="keyword">byte</span>[] b = <span class="string">"quit"</span>.getBytes();</span><br><span class="line">                send(b);</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//结束程序</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(checkInput(input))</span><br><span class="line">            &#123; <span class="comment">//校验合法</span></span><br><span class="line">                <span class="comment">//发送数据</span></span><br><span class="line">                send(input.getBytes());</span><br><span class="line">                <span class="comment">//接收数据</span></span><br><span class="line">                <span class="keyword">byte</span>[] data = receive();</span><br><span class="line">                <span class="comment">//解析反馈数据</span></span><br><span class="line">                parse(data);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"输入不合法，请重新输入！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        close(); <span class="comment">//关闭流和连接</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 初始化</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            br = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">            <span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">            socket = <span class="keyword">new</span> Socket(HOST,PORT);</span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 读取客户端输入</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">readInput</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> br.readLine();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 判断是否输入quit</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> input 输入内容</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> true代表结束，false代表不结束</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isQuit</span><span class="params">(String input)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(input == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"quit"</span>.equalsIgnoreCase(input))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 校验输入</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> input 用户输入内容</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> true代表输入符合要求，false代表不符合</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkInput</span><span class="params">(String input)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(input == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> n = Integer.parseInt(input);</span><br><span class="line">            <span class="keyword">if</span>(n &gt;= <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//输入不是整数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 向服务器端发送数据</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> data 数据内容</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">byte</span>[] data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            os.write(data);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 接收服务器端反馈</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 反馈数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] receive()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> n = is.read(b);</span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[n];</span><br><span class="line">            <span class="comment">//复制有效数据</span></span><br><span class="line">            System.arraycopy(b, <span class="number">0</span>, data, <span class="number">0</span>, n);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 解析协议数据</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> data 协议数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(<span class="keyword">byte</span>[] data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"服务器端反馈数据不正确！"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span> value = data[<span class="number">0</span>]; <span class="comment">//取第一个byte</span></span><br><span class="line">        <span class="comment">//按照协议格式解析</span></span><br><span class="line">        <span class="keyword">switch</span>(value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            System.out.println(<span class="string">"质数"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">"不是质数"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            System.out.println(<span class="string">"协议格式错误"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 关闭流和连接</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            br.close();</span><br><span class="line">            is.close();</span><br><span class="line">            os.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该代码中，将程序的功能使用方法进行组织，使得结构比较清晰，核心的逻辑流程在main方法中实现。</p><h3 id="服务器端实现"><a href="#服务器端实现" class="headerlink" title="服务器端实现"></a>服务器端实现</h3><p>以TCP方式实现的服务器端的代码如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> example1;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 以TCP方式实现的质数判别服务器端</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPPrimeServer</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">10005</span>;</span><br><span class="line">        ServerSocket ss = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            ss = <span class="keyword">new</span> ServerSocket(PORT);</span><br><span class="line">            System.out.println(<span class="string">"服务器端已启动："</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Socket s = ss.accept();</span><br><span class="line">                <span class="keyword">new</span> PrimeLogicThread(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                ss.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e2) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="服务器逻辑线程"><a href="#服务器逻辑线程" class="headerlink" title="服务器逻辑线程"></a>服务器逻辑线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">package example1;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.net.*;</span><br><span class="line">/**</span><br><span class="line">* 实现质数判别逻辑的线程</span><br><span class="line">*/</span><br><span class="line">public class PrimeLogicThread extends Thread </span><br><span class="line">&#123;</span><br><span class="line">    Socket socket;</span><br><span class="line">    InputStream is;</span><br><span class="line">    OutputStream os;</span><br><span class="line">    public PrimeLogicThread(Socket socket)</span><br><span class="line">    &#123;</span><br><span class="line">        this.socket = socket;</span><br><span class="line">        init();</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">    * 初始化</span><br><span class="line">    */</span><br><span class="line">    private void init()</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">        &#125;catch(Exception e)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        while(true)</span><br><span class="line">        &#123;</span><br><span class="line">            //接收客户端反馈</span><br><span class="line">            byte[] data = receive();</span><br><span class="line">            //判断是否是退出</span><br><span class="line">            if(isQuit(data))</span><br><span class="line">            &#123;</span><br><span class="line">                break; //结束循环</span><br><span class="line">            &#125;</span><br><span class="line">            //逻辑处理</span><br><span class="line">            byte[] b = logic(data);</span><br><span class="line">            //反馈数据</span><br><span class="line">            send(b);</span><br><span class="line">        &#125;</span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">    * 接收客户端数据</span><br><span class="line">    * @return 客户端发送的数据</span><br><span class="line">    */</span><br><span class="line">    private byte[] receive()</span><br><span class="line">    &#123;</span><br><span class="line">        byte[] b = new byte[1024];</span><br><span class="line">        try </span><br><span class="line">        &#123;</span><br><span class="line">            int n = is.read(b);</span><br><span class="line">            byte[] data = new byte[n];</span><br><span class="line">            //复制有效数据</span><br><span class="line">            System.arraycopy(b, 0, data, 0, n);</span><br><span class="line">            return data;</span><br><span class="line">        &#125; catch (Exception e)&#123;&#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">    * 向客户端发送数据</span><br><span class="line">    * @param data 数据内容</span><br><span class="line">    */</span><br><span class="line">    private void send(byte[] data)</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            os.write(data);</span><br><span class="line">        &#125;catch(Exception e)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">    * 判断是否是quit</span><br><span class="line">    * @return 是返回true，否则返回false</span><br><span class="line">    */</span><br><span class="line">    private boolean isQuit(byte[] data)</span><br><span class="line">    &#123;</span><br><span class="line">        if(data == null)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            String s = new String(data);</span><br><span class="line">            if(s.equalsIgnoreCase(&quot;quit&quot;))</span><br><span class="line">            &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private byte[] logic(byte[] data)</span><br><span class="line">    &#123;</span><br><span class="line">        //反馈数组</span><br><span class="line">        byte[] b = new byte[1];</span><br><span class="line">        //校验参数</span><br><span class="line">        if(data == null)</span><br><span class="line">        &#123;</span><br><span class="line">            b[0] = 2;</span><br><span class="line">            return b;</span><br><span class="line">        &#125;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            //转换为数字</span><br><span class="line">            String s = new String(data);</span><br><span class="line">            int n = Integer.parseInt(s);</span><br><span class="line">            //判断是否是质数</span><br><span class="line">            if(n &gt;= 2)</span><br><span class="line">            &#123;</span><br><span class="line">                boolean flag = isPrime(n);</span><br><span class="line">                if(flag)</span><br><span class="line">                &#123;</span><br><span class="line">                    b[0] = 0;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    b[0] = 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                b[0] = 2; //格式错误</span><br><span class="line">                System.out.println(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            b[0] = 2;</span><br><span class="line">        &#125;</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">    *</span><br><span class="line">    * @param n</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">    private boolean isPrime(int n)</span><br><span class="line">    &#123;</span><br><span class="line">        boolean b = true;</span><br><span class="line">        for(int i = 2;i &lt;= Math.sqrt(n);i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(n % i == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                b = false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">    * 关闭连接</span><br><span class="line">    */</span><br><span class="line">    private void close()</span><br><span class="line">    &#123;</span><br><span class="line">        try </span><br><span class="line">        &#123;</span><br><span class="line">            is.close();</span><br><span class="line">            os.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; catch (Exception e)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本示例使用的服务器端的结构和前面示例中的结构一致，只是逻辑线程的实现相对来说要复杂一些，在线程类中的logic方法中实现了服务器端逻辑，根据客户端发送过来的数据，判断是否是质数，然后根据判断结果按照协议格式要求，生成客户端反馈数据，实现服务器端要求的功能。</p><h3 id="运行结果如下"><a href="#运行结果如下" class="headerlink" title="运行结果如下"></a>运行结果如下</h3><p><img src="https://i.imgur.com/FPsEGIo.png" alt="运行结果"></p><h2 id="猜数字小游戏"><a href="#猜数字小游戏" class="headerlink" title="猜数字小游戏"></a>猜数字小游戏</h2><p>下面这个示例是一个猜数字的控制台小游戏。该游戏的规则是：<strong>当客户端第一次连接到服务器端时，服务器端生产一个【0，50】之间的随机数字，然后客户端输入数字来猜该数字，每次客户端输入数字以后，发送给服务器端，服务器端判断该客户端发送的数字和随机数字的关系，并反馈比较结果，客户端总共有5次猜的机会，猜中时提示猜中，当输入”quit”时结束程序。</strong></p><p>和前面的示例类似，在进行网络程序开发时，首先需要分解一下功能的实现，觉得功能是在客户端程序中实现还是在服务器端程序中实现。区分的规则一般是：</p><ul><li>客户端 程序实现接收用户输入等界面功能，并实现一些基础的校验降低服务器端的压力，</li><li>而将程序核心的逻辑以及数据存储等功能放在服务器端进行实现。<br>遵循该原则划分 的客户端和服务器端功能如下所示。</li></ul><h3 id="客户端程序功能列表："><a href="#客户端程序功能列表：" class="headerlink" title="客户端程序功能列表："></a>客户端程序功能列表：</h3><ul><li>接收用户控制台输入</li><li>判断输入内容是否合法</li><li>按照协议格式发送数据</li><li>根据服务器端的反馈给出相应提示</li></ul><h3 id="服务器端程序功能列表："><a href="#服务器端程序功能列表：" class="headerlink" title="服务器端程序功能列表："></a>服务器端程序功能列表：</h3><ul><li>接收客户端发送数据</li><li>按照协议格式解析数据</li><li>判断发送过来的数字和随机数字的关系</li><li>根据判断结果生产协议数据</li><li>将生产的数据反馈给客户端</li></ul><p>在该示例中，实际使用的网络命令也只有两条，所以显得协议的格式比较简单。</p><h3 id="其中客户端程序协议格式如下："><a href="#其中客户端程序协议格式如下：" class="headerlink" title="其中客户端程序协议格式如下："></a>其中客户端程序协议格式如下：</h3><ul><li>将用户输入的数字转换为字符串，然后转换为byte数组</li><li>发送“quit”字符串代表退出<h3 id="其中服务器端程序协议格式如下："><a href="#其中服务器端程序协议格式如下：" class="headerlink" title="其中服务器端程序协议格式如下："></a>其中服务器端程序协议格式如下：</h3><code>反馈长度为1个字节，数字0代表相等(猜中)，1代表大了，2代表小了，其它数字代表错误。</code></li></ul><p>实现该程序的代码比较多，下面分为客户端程序实现和服务器端程序实现分别进行列举。</p><h3 id="客户端程序实现代码如下："><a href="#客户端程序实现代码如下：" class="headerlink" title="客户端程序实现代码如下："></a>客户端程序实现代码如下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">package guess;</span><br><span class="line"></span><br><span class="line">import java.net.*;</span><br><span class="line">import java.io.*;</span><br><span class="line">/**</span><br><span class="line"> * 猜数字客户端</span><br><span class="line"> */</span><br><span class="line">public class TCPClient</span><br><span class="line">&#123;</span><br><span class="line">	public static void main(String[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		Socket socket = null;</span><br><span class="line">		OutputStream os = null;</span><br><span class="line">		InputStream is = null;</span><br><span class="line">		BufferedReader br = null;</span><br><span class="line">		byte[] data = new byte[2];</span><br><span class="line">		try</span><br><span class="line">		&#123;</span><br><span class="line">			// 建立连接</span><br><span class="line">			socket = new Socket(&quot;127.0.0.1&quot;, 10001);</span><br><span class="line">			// 发送数据</span><br><span class="line">			os = socket.getOutputStream();</span><br><span class="line">			// 读取反馈数据</span><br><span class="line">			is = socket.getInputStream();</span><br><span class="line">			// 键盘输入流</span><br><span class="line">			br = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">			// 多次输入</span><br><span class="line">			while (true)</span><br><span class="line">			&#123;</span><br><span class="line">				System.out.println(&quot;请输入数字：&quot;);</span><br><span class="line">				// 接收输入</span><br><span class="line">				String s = br.readLine();</span><br><span class="line">				// 结束条件</span><br><span class="line">				if (s.equals(&quot;quit&quot;))</span><br><span class="line">				&#123;</span><br><span class="line">					os.write(&quot;quit&quot;.getBytes());</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">				// 校验输入是否合法</span><br><span class="line">				boolean b = true;</span><br><span class="line">				try</span><br><span class="line">				&#123;</span><br><span class="line">					Integer.parseInt(s);</span><br><span class="line">				&#125; catch (Exception e)</span><br><span class="line">				&#123;</span><br><span class="line">					b = false;</span><br><span class="line">				&#125;</span><br><span class="line">				if (b)</span><br><span class="line">				&#123; // 输入合法</span><br><span class="line">					// 发送数据</span><br><span class="line">					os.write(s.getBytes());</span><br><span class="line">					// 接收反馈</span><br><span class="line">					is.read(data);</span><br><span class="line">					// 判断</span><br><span class="line">					switch (data[0])</span><br><span class="line">					&#123;</span><br><span class="line">						case 0 :</span><br><span class="line">							System.out.println(&quot;相等！祝贺你！&quot;);</span><br><span class="line">							break;</span><br><span class="line">						case 1 :</span><br><span class="line">							System.out.println(&quot;大了！&quot;);</span><br><span class="line">							break;</span><br><span class="line">						case 2 :</span><br><span class="line">							System.out.println(&quot;小了！&quot;);</span><br><span class="line">							break;</span><br><span class="line">						default :</span><br><span class="line">							System.out.println(&quot;其它错误！&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">					// 提示猜的次数</span><br><span class="line">					System.out.println(&quot;你已经猜了&quot; + data[1] + &quot;次！&quot;);</span><br><span class="line">					// 判断次数是否达到5次</span><br><span class="line">					if (data[1] &gt;= 5)</span><br><span class="line">					&#123;</span><br><span class="line">						System.out.println(&quot;你挂了！&quot;);</span><br><span class="line">						// 给服务器端线程关闭的机会</span><br><span class="line">						os.write(&quot;quit&quot;.getBytes());</span><br><span class="line">						// 结束客户端程序</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; else</span><br><span class="line">				&#123; // 输入错误</span><br><span class="line">					System.out.println(&quot;输入错误！&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; catch (Exception e)</span><br><span class="line">		&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; finally</span><br><span class="line">		&#123;</span><br><span class="line">			try</span><br><span class="line">			&#123;</span><br><span class="line">				// 关闭连接</span><br><span class="line">				br.close();</span><br><span class="line">				is.close();</span><br><span class="line">				os.close();</span><br><span class="line">				socket.close();</span><br><span class="line">			&#125; catch (Exception e)</span><br><span class="line">			&#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该示例中，首先建立一个到<code>IP</code>地址为<code>127.0.0.1</code>的端口为<code>10001</code>的连接，然后进行各个流的初始化工作，将逻辑控制的代码放入在一个<code>while</code>循环中，这样可以在客户端多次进行输入。在循环内部，首先判断用户输入的是否为<code>quit</code>字符串，如果是则结束程序，如果输入不是<code>quit</code>，则首先校验输入的是否是数字，如果不是数字则直接输出“输入错误！”并继续接收用户输入，如果是数字则发送给服务器端，并根据服务器端的反馈显示相应的提示信息。最后关闭流和连接，结束客户端程序。</p><p>服务器端程序的实现还是分为服务器控制程序和逻辑线程，实现的代码分别如下：</p><h3 id="服务器控制程序"><a href="#服务器控制程序" class="headerlink" title="服务器控制程序"></a>服务器控制程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> guess;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* TCP连接方式的服务器端</span></span><br><span class="line"><span class="comment">* 实现功能：接收客户端的数据，判断数字关系</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//监听端口</span></span><br><span class="line">            ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">10001</span>);</span><br><span class="line">            System.out.println(<span class="string">"服务器已启动："</span>);</span><br><span class="line">            <span class="comment">//逻辑处理</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//获得连接</span></span><br><span class="line">                Socket s = ss.accept();</span><br><span class="line">                <span class="comment">//启动线程处理</span></span><br><span class="line">                <span class="keyword">new</span> LogicThread(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逻辑线程"><a href="#逻辑线程" class="headerlink" title="逻辑线程"></a>逻辑线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">package guess;</span><br><span class="line">import java.net.*;</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.util.*;</span><br><span class="line">/**</span><br><span class="line">* 逻辑处理线程</span><br><span class="line">*/</span><br><span class="line">public class LogicThread extends Thread </span><br><span class="line">&#123;</span><br><span class="line">    Socket s;</span><br><span class="line">    static Random r = new Random();</span><br><span class="line">    public LogicThread(Socket s)</span><br><span class="line">    &#123;</span><br><span class="line">        this.s = s;</span><br><span class="line">        start(); //启动线程</span><br><span class="line">    &#125;</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        //生成一个[0，50]的随机数</span><br><span class="line">        int randomNumber = Math.abs(r.nextInt() % 51);</span><br><span class="line">        //用户猜的次数</span><br><span class="line">        int guessNumber = 0;</span><br><span class="line">        InputStream is = null;</span><br><span class="line">        OutputStream os = null;</span><br><span class="line">        byte[] data = new byte[2];</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            //获得输入流</span><br><span class="line">            is = s.getInputStream();</span><br><span class="line">            //获得输出流</span><br><span class="line">            os = s.getOutputStream();</span><br><span class="line">            while(true)</span><br><span class="line">            &#123; //多次处理</span><br><span class="line">                //读取客户端发送的数据</span><br><span class="line">                byte[] b = new byte[1024];</span><br><span class="line">                int n = is.read(b);</span><br><span class="line">                String send = new String(b,0,n);</span><br><span class="line">                //结束判别</span><br><span class="line">                if(send.equals(&quot;quit&quot;))</span><br><span class="line">                &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                //解析、判断</span><br><span class="line">                try</span><br><span class="line">                &#123;</span><br><span class="line">                    int num = Integer.parseInt(send);</span><br><span class="line">                    //处理</span><br><span class="line">                    guessNumber++; //猜的次数增加1</span><br><span class="line">                    data[1] = (byte)guessNumber;</span><br><span class="line">                    //判断</span><br><span class="line">                    if(num &gt; randomNumber)</span><br><span class="line">                    &#123;</span><br><span class="line">                        data[0] = 1;</span><br><span class="line">                    &#125;else if(num &lt; randomNumber)&#123;</span><br><span class="line">                        data[0] = 2;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        data[0] = 0;</span><br><span class="line">                        //如果猜对</span><br><span class="line">                        guessNumber = 0; //清零</span><br><span class="line">                        randomNumber = Math.abs(r.nextInt() % 51);</span><br><span class="line">                    &#125;</span><br><span class="line">                    //反馈给客户端</span><br><span class="line">                    os.write(data);</span><br><span class="line">                &#125;catch(Exception e)&#123; //数据格式错误</span><br><span class="line">                    data[0] = 3;</span><br><span class="line">                    data[1] = (byte)guessNumber;</span><br><span class="line">                    os.write(data); //发送错误标识</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                os.flush();   //强制发送</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                is.close();</span><br><span class="line">                os.close();</span><br><span class="line">                s.close();</span><br><span class="line">            &#125;catch(Exception e)&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文链接: <a href="https://www.lansheng.net.cn/blog/12786bb5/">7网络协议</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://www.lansheng.net.cn/blog/b6cecc51/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="蓝生"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="蓝生的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/blog/b6cecc51/" itemprop="url">UDP网络编程</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-08-18 15:50:10" itemprop="dateCreated datePublished" datetime="2018-08-18T15:50:10+08:00">2018-08-18</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2018-11-05 17:17:07" itemprop="dateModified" datetime="2018-11-05T17:17:07+08:00">2018-11-05</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/java-网络编程/" itemprop="url" rel="index"><span itemprop="name">java 网络编程</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/blog/b6cecc51/#comments" itemprop="discussionUrl"><span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/blog/b6cecc51/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><p>参考：<a href="https://blog.csdn.net/sihai12345/article/details/79334299" target="_blank" rel="noopener">https://blog.csdn.net/sihai12345/article/details/79334299</a></p><p>网络通讯的方式除了<code>TCP</code>方式以外，还有一种实现的方式就是<code>UDP</code>方式。<code>UDP(User Datagram Protocol)</code>，中文意思是<strong>用户数据报协议</strong>，方式类似于发短信息，是一种物美价廉的通讯方式，使用<strong>该种方式无需建立专用的虚拟连接</strong>，由于无需建立专用的连接，所以<strong>对于服务器的压力要比<code>TCP</code>小很多</strong>，所以也是一种常见的网络编程方式。但是使用<strong>该种方式最大的不足是传输不可靠</strong>，当然也不是说经常丢失，就像大家发短信息一样，理论上存在收不到的可能，这种可能性可能是<code>1%</code>，反正比较小，但是由于这种可能的存在，所以平时我们都觉得重要的事情还是打个电话吧(类似<code>TCP</code>方式)，一般的事情才发短信息(类似<code>UDP</code>方式)。网络编程中也是这样，<strong>必须要求可靠传输的信息一般使用<code>TCP</code>方式实现，一般的数据才使用<code>UDP</code>方式实现。</strong></p><p><code>UDP</code>方式的网络编程也在<code>Java</code>语言中获得了良好的支持，由于其在传输数据的过程中不需要建立专用的连接等特点，所以在<code>Java API</code>中设计的实现结构和<code>TCP</code>方式不太一样。当然，需要使用的类还是包含在<code>java.net</code>包中。</p><h2 id="Java-UDP网络编程相关类"><a href="#Java-UDP网络编程相关类" class="headerlink" title="Java UDP网络编程相关类"></a>Java UDP网络编程相关类</h2><p>在<code>Java API</code>中，实现<code>UDP</code>方式的编程，包含<code>客户端网络编程</code>和<code>服务器端网络编程</code>，主要由两个类实现，分别是：</p><h3 id="DatagramSocket类"><a href="#DatagramSocket类" class="headerlink" title="DatagramSocket类"></a>DatagramSocket类</h3><p><code>DatagramSocket</code>类实现“<strong>网络连接</strong>”，包括客户端网络连接和服务器端网络连接。虽然UDP方式的网络通讯不需要建立专用的网络连接，但是毕竟还是需要发送和接收数据，<strong><code>DatagramSocket</code>实现的就是发送数据时的发射器，以及接收数据时的监听器的角色。</strong>类比于TCP中的网络连接，该类既可以用于实现客户端连接，也可以用于实现服务器端连接。</p><h3 id="DatagramPacket类"><a href="#DatagramPacket类" class="headerlink" title="DatagramPacket类"></a><code>DatagramPacket</code>类</h3><p><strong><code>DatagramPacket</code>类实现对于网络中传输的数据封装</strong>，也就是说，<strong>该类的对象代表网络中交换的<code>数据</code></strong>。<br><strong>在<code>UDP</code>方式的网络编程中，无论是需要发送的数据还是需要接收的数据，都必须被处理成<code>DatagramPacket</code>类型的对象</strong>，该对象中包含<code>发送到的地址</code>、<code>发送到的端口号</code>以及<code>发送的内容</code>等。其实<code>DatagramPacket</code>类的作用类似于现实中的信件，在信件中包含信件发送到的地址以及接收人，还有发送的内容等，邮局只需要按照地址传递即可。在接收数据时，接收到的数据也必须被处理成<code>DatagramPacket</code>类型的对象，在该对象中包含发送方的地址、端口号等信息，也包含数据的内容。和<code>TCP</code>方式的网络传输相比，<strong><code>IO</code>编程在<code>UDP</code>方式的网络编程中变得不是必须的内容</strong>，结构也要比<code>TCP</code>方式的网络编程简单一些。</p><p>下面介绍一下UDP方式的网络编程中，客户端和服务器端的实现步骤，以及通过基础的示例演示UDP方式的网络编程在Java语言中的实现方式。</p><p>UDP方式的网络编程，编程的步骤和TCP方式类似，只是使用的类和方法存在比较大的区别，下面首先介绍一下UDP方式的网络编程客户端实现过程。</p><h2 id="UDP客户端编程步骤"><a href="#UDP客户端编程步骤" class="headerlink" title="UDP客户端编程步骤"></a>UDP客户端编程步骤</h2><p>UDP客户端编程涉及的步骤也是4个部分：<strong>建立连接</strong>、<strong>发送数据</strong>、<strong>接收数据</strong>和<strong>关闭连接</strong>。</p><h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p>首先介绍UDP方式的网络编程中建立连接的实现。其中<strong>UDP方式的建立连接和TCP方式不同，只需要建立一个连接对象即可，不需要指定服务器的IP和端口号码</strong>。实现的代码为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DatagramSocket ds = new DatagramSocket();</span><br></pre></td></tr></table></figure><p></p><p>这样就建立了一个客户端连接，<strong>该客户端连接使用系统随机分配的一个本地计算机的未用端口号</strong>。在该连接中，不指定服务器端的IP和端口，所以UDP方式的网络连接更像一个发射器，而不是一个具体的连接。<br>当然，可以通过制定连接使用的端口号来创建客户端连接。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DatagramSocket ds = new DatagramSocket(5000);</span><br></pre></td></tr></table></figure><p></p><p>这样就是使用本地计算机的<code>5000</code>号端口建立了一个连接。<strong>一般在建立客户端连接时没有必要指定端口号码。</strong></p><h3 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h3><p>接着，介绍一下UDP客户端编程中发送数据的实现。<strong>在UDP方式的网络编程中，IO技术不是必须的</strong>，<strong>发送数据步骤：</strong></p><ul><li>需要将需要发送的数据内容首先转换为<code>byte</code>数组，</li><li>然后将<code>数据内容</code>、<code>服务器IP</code>和<code>服务器端口号</code>一起构造成一个<code>DatagramPacket</code>类型的对象，这样数据的准备就完成了，</li><li>发送时调用网络连接对象中的send方法发送该对象即可。</li></ul><p>例如将字符串“<code>Hello</code>”发送到IP是<code>127.0.0.1</code>，端口号是<code>10001</code>的服务器，则实现发送数据的代码如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String s = “Hello”;</span><br><span class="line">String host = “<span class="number">127.0</span>.0.1”;</span><br><span class="line"><span class="keyword">int</span> port = <span class="number">10001</span>;</span><br><span class="line"><span class="comment">//将发送的内容转换为byte数组</span></span><br><span class="line"><span class="keyword">byte</span>[] byteToSend = s.getBytes();</span><br><span class="line"><span class="comment">//将服务器IP转换为InetAddress对象</span></span><br><span class="line">InetAddress serverIP = InetAddress.getByName(host);</span><br><span class="line"><span class="comment">//构造发送的数据包对象,数据包中放入数据，目的地址，目的端口号</span></span><br><span class="line">DatagramPacket sendDp = <span class="keyword">new</span> DatagramPacket(byteToSend,byteToSend.length,serverIP,port);</span><br><span class="line"><span class="comment">//发送数据</span></span><br><span class="line">ds.send(sendDp);</span><br></pre></td></tr></table></figure><p></p><p>在该示例代码中，不管发送的数据内容是什么，都需要转换为byte数组，然后将服务器端的IP地址构造成InetAddress类型的对象，在准备完成以后，将这些信息构造成一个DatagramPacket类型的对象，发送的数据内容、服务器端的IP和端口号，都包含在DatagramPacket对象中。在准备完成以后，调用连接对象ds的send方法把DatagramPacket对象发送出去即可。</p><p>按照UDP协议的约定，在进行数据传输时，系统只是尽全力传输数据，但是并不保证数据一定被正确传输，<strong>如果数据在传输过程中丢失，那就丢失了。</strong></p><p>UDP方式在进行网络通讯时，也遵循“<strong>请求-响应</strong>”模型，<strong>在发送数据完成以后，就可以接收服务器端的反馈数据了。</strong></p><h3 id="客户端接收数据"><a href="#客户端接收数据" class="headerlink" title="客户端接收数据"></a>客户端接收数据</h3><p>下面介绍一下UDP客户端编程中接收数据的实现。当数据发送出去以后，就可以接收服务器端的反馈信息了。<strong>接收数据在Java语言中的实现是这样的：</strong></p><ul><li>首先构造一个数据缓冲数组，该数组用于存储接收的服务器端反馈数据，该数组的长度必须大于或等于服务器端反馈的实际有效数据的长度。</li><li>然后以该缓冲数组为基础构造一个DatagramPacket数据包对象，</li><li>最后调用连接对象的receive方法接收数据即可。</li></ul><p>接收到的服务器端反馈数据存储在DatagramPacket类型的对象内部。实现接收数据以及显示服务器端反馈内容的示例代码如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步,构造缓冲数组用于接收数据</span></span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">//第二步,构造数据包对象</span></span><br><span class="line">DatagramPacket received = <span class="keyword">new</span> DatagramPacket(data,data.length);</span><br><span class="line"><span class="comment">//接收数据</span></span><br><span class="line">ds.receive(receiveDp);</span><br><span class="line"><span class="comment">//输出数据内容</span></span><br><span class="line"><span class="keyword">byte</span>[] b = receiveDp.getData(); <span class="comment">//获得缓冲数组</span></span><br><span class="line"><span class="keyword">int</span> len = receiveDp.getLength(); <span class="comment">//获得有效数据长度</span></span><br><span class="line">String s = <span class="keyword">new</span> String(b,<span class="number">0</span>,len);</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure><p></p><p>在该代码中，首先构造缓冲数组<code>data</code>，这里设置的长度<code>1024</code>是预估的接收到的数据长度，要求该长度必须大于或等于接收到的数据长度，然后以该缓冲数组为基础，构造数据包对象，使用连接对象<code>ds</code>的<code>receive</code>方法接收反馈数据，由于在<code>Java</code>语言中，除<code>String</code>以外的其它对象都是按照地址传递，所以在<code>receive</code>方法内部可以改变数据包对象<code>receiveDp</code>的内容，这里的<code>receiveDp</code>的功能和返回值类似。数据接收到以后，只需要从数据包对象中读取出来就可以了，使用<code>DatagramPacket</code>对象中的<code>getData</code>方法可以获得数据包对象的缓冲区数组，但是缓冲区数组的长度一般大于有效数据的长度，换句话说，也就是缓冲区数组中只有一部分数据是反馈数据，所以需要使用<code>DatagramPacket</code>对象中的<code>getLength</code>方法获得有效数据的长度，则有效数据就是缓冲数组中的前有效数据长度个内容，这些才是真正的服务器端反馈的数据的内容。</p><h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><p>UDP方式客户端网络编程的最后一个步骤就是关闭连接。虽然UDP方式不建立专用的虚拟连接，但是连接对象还是需要占用系统资源，所以在使用完成以后必须关闭连接。关闭连接使用连接对象中的close方法即可，实现的代码如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ds.close();</span><br></pre></td></tr></table></figure><p></p><p>需要说明的是，和TCP建立连接的方式不同，UDP方式的同一个网络连接对象，可以发送到达不同服务器端IP或端口的数据包，这点是TCP方式无法做到的。</p><h2 id="UDP服务端网络编程"><a href="#UDP服务端网络编程" class="headerlink" title="UDP服务端网络编程"></a>UDP服务端网络编程</h2><p>介绍完了<code>UDP</code>方式客户端网络编程的基础知识以后，下面再来介绍一下<code>UDP</code>方式服务器端网络编程的基础知识。</p><p><code>UDP</code>方式网络编程的服务器端实现和<code>TCP</code>方式的服务器端实现类似，也是服务器端监听某个端口，然后获得数据包，进行逻辑处理以后将处理以后的结果反馈给客户端，最后关闭网络连接，下面依次进行介绍。</p><h3 id="第一步监听窗口，建立连接"><a href="#第一步监听窗口，建立连接" class="headerlink" title="第一步监听窗口，建立连接"></a>第一步监听窗口，建立连接</h3><p>首先<code>UDP</code>方式服务器端网络编程需要建立一个连接，该连接监听某个端口，实现的代码为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DatagramSocket ds = new DatagramSocket(10010);</span><br></pre></td></tr></table></figure><p></p><p>由于<strong>服务器端的端口需要固定，所以一般在建立服务器端连接时，都指定端口号。</strong>例如该示例代码中指定10010端口为服务器端使用的端口号，客户端端在连接服务器端时连接该端口号即可。</p><h3 id="第二步：接收客户端的数据"><a href="#第二步：接收客户端的数据" class="headerlink" title="第二步：接收客户端的数据"></a>第二步：接收客户端的数据</h3><p>接着服务器端就开始接收客户端发送过来的数据，其接收的方法和客户端接收的方法一直，其中<code>receive</code>方法的作用类似于<code>TCP</code>方式中<code>accept</code>方法的作用，该方法也是一个阻塞方法，其作用是接收数据。</p><h3 id="第三步：处理接收的数据，给出响应"><a href="#第三步：处理接收的数据，给出响应" class="headerlink" title="第三步：处理接收的数据，给出响应"></a>第三步：处理接收的数据，给出响应</h3><p>接收到客户端发送过来的数据以后，服务器端对该数据进行逻辑处理，然后将处理以后的结果再发送给客户端，<strong>在这里发送时就比客户端要麻烦一些，因为服务器端需要获得客户端的IP和客户端使用的端口号</strong>，这个都可以<code>从接收到的数据包中获得</code>。示例代码如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得客户端的IP</span></span><br><span class="line">InetAddress clientIP = receiveDp.getAddress();</span><br><span class="line"><span class="comment">//获得客户端的端口号</span></span><br><span class="line">Int clientPort = receiveDp.getPort();</span><br></pre></td></tr></table></figure><p></p><p>使用以上代码，就可以从接收到的数据包对象<code>receiveDp</code>中获得客户端的<code>IP</code>地址和客户端的端口号，这样就可以在服务器端中将处理以后的数据构造成数据包对象，然后将处理以后的数据内容反馈给客户端了。</p><p>最后，当服务器端实现完成以后，关闭服务器端连接，实现的方式为调用连接对象的<code>close</code>方法，示例代码如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ds.close();</span><br></pre></td></tr></table></figure><p></p><p>介绍完了<code>UDP</code>方式下的客户端编程和服务器端编程的基础知识以后，下面通过一个简单的示例演示<code>UDP</code>网络编程的基本使用。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>该实例的功能是实现<strong>将客户端程序的系统时间发送给服务器端，服务器端接收到时间以后，向客户端反馈字符串“<code>OK</code>”。</strong>实现该功能的客户端代码如下所示：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> udp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单的UDP客户端，实现向服务器端发生系统时间功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleUDPClient</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		DatagramSocket ds = <span class="keyword">null</span>; <span class="comment">// 连接对象</span></span><br><span class="line">		DatagramPacket sendDp; <span class="comment">// 发送数据包对象</span></span><br><span class="line">		DatagramPacket receiveDp; <span class="comment">// 接收数据包对象</span></span><br><span class="line">		String serverHost = <span class="string">"127.0.0.1"</span>; <span class="comment">// 服务器IP</span></span><br><span class="line">		<span class="keyword">int</span> serverPort = <span class="number">10010</span>; <span class="comment">// 服务器端口号</span></span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 建立连接,自动分配一个空闲端口</span></span><br><span class="line">			ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">			<span class="comment">// 初始化发送数据</span></span><br><span class="line">			Date d = <span class="keyword">new</span> Date(); <span class="comment">// 当前时间</span></span><br><span class="line">			String content = d.toString(); <span class="comment">// 转换为字符串</span></span><br><span class="line">			<span class="keyword">byte</span>[] data = content.getBytes();</span><br><span class="line">			<span class="comment">// 初始化IP地址</span></span><br><span class="line">			InetAddress address = InetAddress.getByName(serverHost);</span><br><span class="line">			<span class="comment">// 初始化发送包对象 数据,数据的长度,IP地址,端口号</span></span><br><span class="line">			sendDp = <span class="keyword">new</span> DatagramPacket(data, data.length, address, serverPort);</span><br><span class="line">			<span class="comment">// 发送这个数据包</span></span><br><span class="line">			ds.send(sendDp);</span><br><span class="line">			<span class="comment">// 初始化接收数据</span></span><br><span class="line">			<span class="keyword">byte</span>[] receive = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">			receiveDp = <span class="keyword">new</span> DatagramPacket(receive, receive.length);</span><br><span class="line">			<span class="comment">// 从服务器接收数据包,</span></span><br><span class="line">			ds.receive(receiveDp);</span><br><span class="line">			<span class="comment">// 读取反馈内容，并输出</span></span><br><span class="line">			<span class="keyword">byte</span>[] response = receiveDp.getData();</span><br><span class="line">			<span class="keyword">int</span> len = receiveDp.getLength();</span><br><span class="line">			String s = <span class="keyword">new</span> String(response, <span class="number">0</span>, len);</span><br><span class="line">			System.out.println(<span class="string">"服务器端反馈为："</span> + s);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e)</span><br><span class="line">		&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">try</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 关闭连接</span></span><br><span class="line">				ds.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e)</span><br><span class="line">			&#123;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在该示例代码中，首先建立<code>UDP</code>方式的网络连接，然后获得当前系统时间，这里获得的系统时间是客户端程序运行的本地计算机的时间，然后将时间字符串以及服务器端的<code>IP</code>和端口，构造成发送数据包对象，调用连接对象<code>ds</code>的<code>send</code>方法发送出去。在数据发送出去以后，构造接收数据的数据包对象，调用连接对象<code>ds</code>的<code>receive</code>方法接收服务器端的反馈，并输出在控制台。最后在<code>finally</code>语句块中关闭客户端网络连接。</p><p>和下面将要介绍的服务器端一起运行时，客户端程序的输出结果为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">服务器端反馈为：OK</span><br></pre></td></tr></table></figure><p></p><p>下面是该示例程序的服务器端代码实现：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> udp;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 简单UDP服务器端，实现功能是输出客户端发送数据，</span></span><br><span class="line"><span class="comment">并反馈字符串“OK"给客户端</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleUDPServer</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DatagramSocket ds = <span class="keyword">null</span>; <span class="comment">//连接对象</span></span><br><span class="line">        DatagramPacket sendDp; <span class="comment">//发送数据包对象</span></span><br><span class="line">        DatagramPacket receiveDp; <span class="comment">//接收数据包对象</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">10010</span>; <span class="comment">//端口</span></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//建立连接，监听端口</span></span><br><span class="line">            ds = <span class="keyword">new</span> DatagramSocket(PORT);</span><br><span class="line">            System.out.println(<span class="string">"服务器端已启动："</span>);</span><br><span class="line">            <span class="comment">//初始化接收数据</span></span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            receiveDp = <span class="keyword">new</span> DatagramPacket(b,b.length);</span><br><span class="line">            <span class="comment">//接收</span></span><br><span class="line">            ds.receive(receiveDp);</span><br><span class="line">            <span class="comment">//读取反馈内容，并输出</span></span><br><span class="line">            InetAddress clientIP = receiveDp.getAddress();</span><br><span class="line">            <span class="keyword">int</span> clientPort = receiveDp.getPort();</span><br><span class="line">            <span class="keyword">byte</span>[] data = receiveDp.getData();</span><br><span class="line">            <span class="keyword">int</span> len = receiveDp.getLength();</span><br><span class="line">            System.out.println(<span class="string">"客户端IP："</span> + clientIP.getHostAddress());</span><br><span class="line">            System.out.println(<span class="string">"客户端端口："</span> + clientPort);</span><br><span class="line">            System.out.println(<span class="string">"客户端发送内容："</span> + <span class="keyword">new</span> String(data,<span class="number">0</span>,len));</span><br><span class="line">            <span class="comment">//发送反馈</span></span><br><span class="line">            String response = <span class="string">"OK"</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] bData = response.getBytes();</span><br><span class="line">            sendDp = <span class="keyword">new</span> DatagramPacket(bData,bData.length,clientIP,clientPort);</span><br><span class="line">            <span class="comment">//发送</span></span><br><span class="line">            ds.send(sendDp);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//关闭连接,释放占用的端口</span></span><br><span class="line">                ds.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在该服务器端实现中，首先监听<code>10010</code>号端口，和<code>TCP</code>方式的网络编程类似，服务器端的<code>receive</code>方法是阻塞方法，如果客户端不发送数据，则程序会在该方法处阻塞。</p><p>当客户端发送数据到达服务器端时，则接收客户端发送过来的数据，然后将客户端发送的数据内容读取出来，并在服务器端程序中打印客户端的相关信息，<strong>从客户端发送过来的数据包中可以读取出客户端的<code>IP</code>以及客户端端口号</strong>，将反馈数据字符串“<code>OK</code>”发送给客户端，最后关闭服务器端连接，释放占用的系统资源，完成程序功能示例。</p><p>运行结果：<br><img src="https://i.imgur.com/fzgDZkV.png" alt=""></p><p>和前面<code>TCP</code>方式中的网络编程类似，这个示例也仅仅是网络编程的功能示例，也存在前面介绍的客户端无法进行多次数据交换，以及服务器端不支持多个客户端的问题，这两个问题也需要对于代码进行处理才可以很方便的进行解决。</p><p>在解决该问题以前，需要特别指出的是<code>UDP</code>方式的网络编程由于不建立虚拟的连接，所以在实际使用时和<code>TCP</code>方式存在很多的不同，最大的一个不同就是“<code>无状态</code>”。该特点指每次服务器端都收到信息，但是这些信息和连接无关，换句话说，也就是服务器端只是从信息是无法识别出是谁发送的，这样就要求发送信息时的内容需要多一些，这个在后续的示例中可以看到。</p><h2 id="多次发送多次接收"><a href="#多次发送多次接收" class="headerlink" title="多次发送多次接收"></a>多次发送多次接收</h2><p>下面是实现客户端多次发送以及服务器端支持多个数据包同时处理的程序结构，实现的原理和<code>TCP</code>方式类似，在<strong>客户端将数据的发送和接收放入循环中，而服务器端则将接收到的每个数据包启动一个专门的线程进行处理。</strong>实现的代码如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> udp;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 简单的UDP客户端，实现向服务器端发生系统时间功能</span></span><br><span class="line"><span class="comment">* 该程序发送3次数据到服务器端</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MulUDPClient</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DatagramSocket ds = <span class="keyword">null</span>; <span class="comment">//连接对象</span></span><br><span class="line">        DatagramPacket sendDp; <span class="comment">//发送数据包对象</span></span><br><span class="line">        DatagramPacket receiveDp; <span class="comment">//接收数据包对象</span></span><br><span class="line">        String serverHost = <span class="string">"127.0.0.1"</span>; <span class="comment">//服务器IP</span></span><br><span class="line">        <span class="keyword">int</span> serverPort = <span class="number">10012</span>; <span class="comment">//服务器端口号</span></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//建立连接</span></span><br><span class="line">            ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">            <span class="comment">//初始化</span></span><br><span class="line">            InetAddress address = InetAddress.getByName(serverHost);</span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            receiveDp = <span class="keyword">new</span> DatagramPacket(b,b.length);</span><br><span class="line">            System.out.println(<span class="string">"客户端准备完成"</span>);</span><br><span class="line">            <span class="comment">//循环10次，每次间隔0.01秒</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//初始化发送数据</span></span><br><span class="line">                Date d = <span class="keyword">new</span> Date(); <span class="comment">//当前时间</span></span><br><span class="line">                String content = d.toString(); <span class="comment">//转换为字符串</span></span><br><span class="line">                <span class="keyword">byte</span>[] data = content.getBytes();</span><br><span class="line">                <span class="comment">//初始化发送包对象</span></span><br><span class="line">                sendDp = <span class="keyword">new</span> DatagramPacket(data,data.length,address, serverPort);</span><br><span class="line">                <span class="comment">//发送</span></span><br><span class="line">                ds.send(sendDp);</span><br><span class="line">                <span class="comment">//延迟</span></span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                <span class="comment">//接收</span></span><br><span class="line">                ds.receive(receiveDp);</span><br><span class="line">                <span class="comment">//读取反馈内容，并输出</span></span><br><span class="line">                <span class="keyword">byte</span>[] response = receiveDp.getData();</span><br><span class="line">                <span class="keyword">int</span> len = receiveDp.getLength();</span><br><span class="line">                String s = <span class="keyword">new</span> String(response,<span class="number">0</span>,len);</span><br><span class="line">                System.out.println(<span class="string">"服务器端反馈为："</span> + s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//关闭连接</span></span><br><span class="line">                ds.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在该示例中，将和服务器端进行数<strong>据交换的逻辑写在一个for循环的内部，这样就可以实现和服务器端的多次交换了</strong>，考虑到服务器端的响应速度，在每次发送之间加入0.01秒的时间间隔。最后当数据交换完成以后关闭连接，结束程序。</p><p>实现该逻辑的服务器端程序代码如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> udp;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 可以并发处理数据包的服务器端</span></span><br><span class="line"><span class="comment">* 功能为：显示客户端发送的内容，并向客户端反馈字符串“OK”</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MulUDPServer</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DatagramSocket ds = <span class="keyword">null</span>; <span class="comment">//连接对象</span></span><br><span class="line">        DatagramPacket receiveDp; <span class="comment">//接收数据包对象</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">10012</span>; <span class="comment">//端口</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        receiveDp = <span class="keyword">new</span> DatagramPacket(b,b.length);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//建立连接，监听端口</span></span><br><span class="line">            ds = <span class="keyword">new</span> DatagramSocket(PORT);</span><br><span class="line">            System.out.println(<span class="string">"服务器端已启动："</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//接收</span></span><br><span class="line">                ds.receive(receiveDp);</span><br><span class="line">                <span class="comment">//启动线程处理数据包</span></span><br><span class="line">                <span class="keyword">new</span> LogicThread(ds,receiveDp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//关闭连接</span></span><br><span class="line">                ds.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>该代码实现了服务器端的接收逻辑，使用一个循环来接收客户端发送过来的数据包，当接收到数据包以后启动一个LogicThread线程处理该数据包。这样服务器端就可以实现同时处理多个数据包了。</p><p>实现逻辑处理的线程代码如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> udp;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 逻辑处理线程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogicThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**连接对象*/</span></span><br><span class="line">    DatagramSocket ds;</span><br><span class="line">    <span class="comment">/**接收到的数据包*/</span></span><br><span class="line">    DatagramPacket dp;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogicThread</span><span class="params">(DatagramSocket ds,DatagramPacket dp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ds = ds;</span><br><span class="line">        <span class="keyword">this</span>.dp = dp;</span><br><span class="line">        start(); <span class="comment">//启动线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//获得缓冲数组</span></span><br><span class="line">            <span class="keyword">byte</span>[] data = dp.getData();</span><br><span class="line">            <span class="comment">//获得有效数据长度</span></span><br><span class="line">            <span class="keyword">int</span> len = dp.getLength();</span><br><span class="line">            <span class="comment">//客户端IP</span></span><br><span class="line">            InetAddress clientAddress = dp.getAddress();</span><br><span class="line">            <span class="comment">//客户端端口</span></span><br><span class="line">            <span class="keyword">int</span> clientPort = dp.getPort();</span><br><span class="line">            <span class="comment">//输出</span></span><br><span class="line">            System.out.println(<span class="string">"客户端IP："</span> + clientAddress.getHostAddress());</span><br><span class="line">            System.out.println(<span class="string">"客户端端口号："</span> + clientPort);</span><br><span class="line">            System.out.println(<span class="string">"客户端发送内容："</span> + <span class="keyword">new</span> String(data,<span class="number">0</span>,len));</span><br><span class="line">            <span class="comment">//反馈到客户端</span></span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="string">"OK"</span>.getBytes();</span><br><span class="line">            DatagramPacket sendDp = <span class="keyword">new</span> DatagramPacket(b,b.length,clientAddress,clientPort);</span><br><span class="line">            <span class="comment">//发送</span></span><br><span class="line">            ds.send(sendDp);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在该线程中，只处理一次UDP通讯，当通讯结束以后线程死亡，在线程内部，每次获得客户端发送过来的信息，将获得的信息输出到服务器端程序的控制台，然后向客户端反馈字符串“OK”。</p><p><strong>由于UDP数据传输过程中可能存在丢失，所以在运行该程序时可能会出现程序阻塞的情况。</strong>如果需要避免该问题，可以<strong>将客户端的网络发送部分也修改成线程实现</strong>。</p><h3 id="情况：得不到服务器的响应，一直阻塞"><a href="#情况：得不到服务器的响应，一直阻塞" class="headerlink" title="情况：得不到服务器的响应，一直阻塞"></a>情况：得不到服务器的响应，一直阻塞</h3><p><img src="https://i.imgur.com/ONgEpnm.png" alt=""><br>正常运行的情况：<br><img src="https://i.imgur.com/gPAL9qU.png" alt=""><br>客户端接收响应的时候，设置超时时间，超时的时候停止等待接收。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0;i &lt; 10;i++)</span><br><span class="line">&#123;</span><br><span class="line">    //初始化发送数据</span><br><span class="line">    Date d = new Date(); //当前时间</span><br><span class="line">    String content = d.toString(); //转换为字符串</span><br><span class="line">    byte[] data = content.getBytes();</span><br><span class="line">    //初始化发送包对象</span><br><span class="line">    sendDp = new DatagramPacket(data,data.length,address, serverPort);</span><br><span class="line">    //发送</span><br><span class="line">    ds.send(sendDp);</span><br><span class="line">    //设置接收的延时如果超过这个时间就不在等待接收</span><br><span class="line">    ds.setSoTimeout(3000);</span><br><span class="line">    //接收</span><br><span class="line">    ds.receive(receiveDp);</span><br><span class="line">    //读取反馈内容，并输出</span><br><span class="line">    byte[] response = receiveDp.getData();</span><br><span class="line">    int len = receiveDp.getLength();</span><br><span class="line">    String s = new String(response,0,len);</span><br><span class="line">    System.out.println(&quot;服务器端反馈为：&quot; + s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这样当客户端长时间接收不到服务器的响应的时候，就会抛出<code>java.net.SocketTimeoutException</code>异常，客户端被终止运行。<br>超时的运行效果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">客户端准备完成</span><br><span class="line">服务器端反馈为：OK</span><br><span class="line">java.net.SocketTimeoutException: Receive timed out</span><br><span class="line">        at java.net.DualStackPlainDatagramSocketImpl.socketReceiveOrPeekData(Native Method)</span><br><span class="line">        at java.net.DualStackPlainDatagramSocketImpl.receive0(DualStackPlainDatagramSocketImpl.java:124)</span><br><span class="line">        at java.net.AbstractPlainDatagramSocketImpl.receive(AbstractPlainDatagramSocketImpl.java:143)</span><br><span class="line">        at java.net.DatagramSocket.receive(DatagramSocket.java:812)</span><br><span class="line">        at udp.MulUDPClient.main(MulUDPClient.java:40)</span><br></pre></td></tr></table></figure><p></p><p>关于基础的UDP网络编程就介绍这么多了，下面将介绍一下网络协议的概念。</p><p>本文链接: <a href="https://www.lansheng.net.cn/blog/b6cecc51/">UDP网络编程</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article></section><nav class="pagination"><a class="extend prev" rel="prev" href="/page/18/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><span class="page-number current">19</span><a class="page-number" href="/page/20/">20</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/20/"><i class="fa fa-angle-right" aria-label="下一页"></i></a></nav></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="蓝生"><p class="site-author-name" itemprop="name">蓝生</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">241</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">78</span> <span class="site-state-item-name">分类</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://blog.csdn.net/qq_21808961" target="_blank" title="CSDN"><i class="fa fa-fw fa-arrow-right"></i>CSDN</a> </span><span class="links-of-author-item"><a href="https://www.shixiseng.com/" target="_blank" title="实习僧"><i class="fa fa-fw fa-arrow-right"></i>实习僧</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://ziyuan.baidu.com/xzh/home/index" title="百度熊掌号" target="_blank">百度熊掌号</a></li><li class="links-of-blogroll-item"><a href="https://ziyuan.baidu.com/linksubmit/index" title="百度链接提交" target="_blank">百度链接提交</a></li><li class="links-of-blogroll-item"><a href="https://reuixiy.github.io/" title="超好看的Hexo+NexT博客" target="_blank">超好看的Hexo+NexT博客</a></li><li class="links-of-blogroll-item"><a href="https://www.face2ai.com/" title="谭升" target="_blank">谭升</a></li></ul></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">蓝生</span></div><div class="theme-info"><div class="powered-by"></div><span class="post-count">博客全站共341.9k字</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv" title="总访客量"><i class="fa fa-user"></i> 总访客量:<span class="busuanzi-value" id="busuanzi_value_site_uv"></span> </span><span class="site-pv" title="总访问量"><i class="fa fa-eye"></i> 总访问量:<span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/js/src/utils.js?v=6.4.0"></script><script type="text/javascript" src="/js/src/motion.js?v=6.4.0"></script><script type="text/javascript" src="/js/src/affix.js?v=6.4.0"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.0"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.0"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script type="text/javascript">var GUEST=["nick","mail","link"],guest="nick,mail,link";guest=guest.split(",").filter(function(e){return GUEST.indexOf(e)>-1}),new Valine({el:"#comments",verify:!0,notify:!1,appId:"8uEACQMqUrxjo1Hqof21pkCV-gzGzoHsz",appKey:"DgRm99ypfVS7Mm9YLchO1RGG",placeholder:"填写昵称,邮箱,网址即可评论.昵称可随意写,邮箱用于接收回复提醒,网址也设置为你个人网站或者博客的地址.",avatar:"mm",meta:guest,pageSize:"10",visitor:!1})</script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(t,e,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,r=document.getElementById(e),s=document.getElementById(o),a=function(){var t=r.value.trim().toLowerCase(),e=t.split(/[\s\-]+/);e.length>1&&e.push(t);var o=[];if(t.length>0&&n.forEach(function(n){function r(e,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===t&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(t,e){var o="",n=e.start;return e.hits.forEach(function(e){o+=t.substring(n,e.position);var r=e.position+e.length;o+='<b class="search-keyword">'+t.substring(e.position,r)+"</b>",n=r}),o+=t.substring(n,e.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url),d=[],g=[];if(""!=l&&(e.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());(s=e.indexOf(t,r))>-1;)a.push({position:s,word:t}),r=s+n;return a}d=d.concat(e(t,h,!1)),g=g.concat(e(t,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(t){b+="<a href='"+f+'\'><p class="search-result">'+s(p,t)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===e.length&&""===e[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>';else{o.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id});var a='<ul class="search-result-list">';o.forEach(function(t){a+=t.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){var e=27===t.which&&$(".search-popup").is(":visible");e&&onPopupClose()})</script><script>!function(){var t=document.createElement("script"),s=window.location.protocol.split(":")[0];"https"===s?t.src="https://zz.bdstatic.com/linksubmit/push.js":t.src="http://push.zhanzhang.baidu.com/push.js";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script></body></html><script type="text/javascript" src="/js/src/love.js"></script><!-- rebuild by neat -->